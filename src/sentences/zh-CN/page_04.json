[
    {
        "source": "The thinking is that we can globally cache it and use it between calls to the API, avoiding expensive loads/unloads.",
        "suggest": "这种想法是，我们可以全局缓存它，并在调用 API 之间使用它，避免昂贵的加载/卸载。",
        "translate": ""
    },
    {
        "source": "If this is a problem for leak detectors or something like that we can cross the bridge when we get there.",
        "suggest": "如果这是泄漏检测器之类的问题，我们可以在到达那里时桥接。",
        "translate": ""
    },
    {
        "source": "Work around `SymGetOptions` and `SymSetOptions` not being present in winapi itself.",
        "suggest": "解决 Winapi 本身中不存在的 `SymGetOptions` 和 `SymSetOptions` 的问题。",
        "translate": ""
    },
    {
        "source": "Otherwise this is only used when we're double-checking types against winapi.",
        "suggest": "否则，仅在我们针对 winapi 再次检查类型时使用。",
        "translate": ""
    },
    {
        "source": "Not defined in winapi yet",
        "suggest": "尚未在 winapi 中定义",
        "translate": ""
    },
    {
        "source": "This is defined in winapi, but it's incorrect (FIXME winapi-rs#768)",
        "suggest": "这是在 winapi 中定义的，但不正确 (FIXME winapi-rs#768)",
        "translate": ""
    },
    {
        "source": "This macro is used to define a `Dbghelp` structure which internally contains all the function pointers that we might load.",
        "suggest": "此宏用于定义 `Dbghelp` 结构体，该结构内部包含我们可能加载的所有函数指针。",
        "translate": ""
    },
    {
        "source": "The loaded DLL for `dbghelp.dll`",
        "suggest": "`dbghelp.dll` 的已加载 DLL",
        "translate": ""
    },
    {
        "source": "Each function pointer for each function we might use",
        "suggest": "我们可能使用的每个函数的每个函数指针",
        "translate": ""
    },
    {
        "source": "Initially we haven't loaded the DLL",
        "suggest": "最初我们还没有加载 DLL",
        "translate": ""
    },
    {
        "source": "Initiall all functions are set to zero to say they need to be dynamically loaded.",
        "suggest": "将所有函数的 Initiall 设置为零，以表示需要动态加载它们。",
        "translate": ""
    },
    {
        "source": "Convenience typedef for each function type.",
        "suggest": "每个函数类型的便利 typedef。",
        "translate": ""
    },
    {
        "source": "Attempts to open `dbghelp.dll`.",
        "suggest": "尝试打开 `dbghelp.dll`。",
        "translate": ""
    },
    {
        "source": "Returns success if it works or error if `LoadLibraryW` fails.",
        "suggest": "如果成功，则返回成功; 如果 `LoadLibraryW` 失败，则返回错误。",
        "translate": ""
    },
    {
        "source": "Panics if library is already loaded.",
        "suggest": "Panics (如果已加载库)。",
        "translate": ""
    },
    {
        "source": "Function for each method we'd like to use.",
        "suggest": "我们要使用的每种方法的函数。",
        "translate": ""
    },
    {
        "source": "When called it will either read the cached function pointer or load it and return the loaded value.",
        "suggest": "调用时，它将读取缓存的函数指针或将其加载并返回已加载的值。",
        "translate": ""
    },
    {
        "source": "Loads are asserted to succeed.",
        "suggest": "断言负载成功。",
        "translate": ""
    },
    {
        "source": "Convenience proxy to use the cleanup locks to reference dbghelp functions.",
        "suggest": "方便代理使用清理锁来引用 dbghelp 函数。",
        "translate": ""
    },
    {
        "source": "Initialize all support necessary to access `dbghelp` API functions from this crate.",
        "suggest": "初始化从 crate 访问 `dbghelp` API 函数所需的所有支持。",
        "translate": ""
    },
    {
        "source": "Note that this function is **safe**, it internally has its own synchronization.",
        "suggest": "请注意，此函数是安全的，它在内部具有自己的同步。",
        "translate": ""
    },
    {
        "source": "Also note that it is safe to call this function multiple times recursively.",
        "suggest": "另请注意，以递归方式多次调用此函数是安全的。",
        "translate": ""
    },
    {
        "source": "First thing we need to do is to synchronize this function.",
        "suggest": "我们需要做的第一件事就是同步这个函数。",
        "translate": ""
    },
    {
        "source": "This can be called concurrently from other threads or recursively within one thread.",
        "suggest": "可以从其他线程并发调用，也可以在一个线程内递归调用。",
        "translate": ""
    },
    {
        "source": "Note that it's trickier than that though because what we're using here, `dbghelp`, *also* needs to be synchronized with all other callers to `dbghelp` in this process.",
        "suggest": "请注意，这比这要复杂得多，因为在此过程中，我们在此使用的 `dbghelp` 还必须与所有其他调用方同步到 `dbghelp`。",
        "translate": ""
    },
    {
        "source": "Typically there aren't really that many calls to `dbghelp` within the same process and we can probably safely assume that we're the only ones accessing it.",
        "suggest": "通常，在同一进程中实际上没有太多对 `dbghelp` 的调用，我们可以放心地假设我们是唯一访问它的人。",
        "translate": ""
    },
    {
        "source": "There is, however, one primary other user we have to worry about which is ironically ourselves, but in the standard library.",
        "suggest": "但是，还有一个主要的其他用户，我们不得不担心的是讽刺的是我们自己，但是在标准库中。",
        "translate": ""
    },
    {
        "source": "The Rust standard library depends on this crate for backtrace support, and this crate also exists on crates.io.",
        "suggest": "Rust 标准库依赖于此 crate 来支持回溯，并且该 crate 也存在于 crates.io 上。",
        "translate": ""
    },
    {
        "source": "This means that if the standard library is printing a panic backtrace it may race with this crate coming from crates.io, causing segfaults.",
        "suggest": "这意味着，如果标准库正在打印 panic 回溯，则它可能与来自 crates.io 的 crate 竞争，从而导致段错误。",
        "translate": ""
    },
    {
        "source": "To help solve this synchronization problem we employ a Windows-specific trick here (it is, after all, a Windows-specific restriction about synchronization).",
        "suggest": "为了帮助解决此同步问题，我们在此处采用了 Windows 特有的技巧 (毕竟，这是 Windows 特有的关于同步的限制)。",
        "translate": ""
    },
    {
        "source": "We create a *session-local* named mutex to protect this call.",
        "suggest": "我们创建一个 *会话本地* 名为互斥锁来保护此调用。",
        "translate": ""
    },
    {
        "source": "The intention here is that the standard library and this crate don't have to share Rust-level APIs to synchronize here but can instead work behind the scenes to make sure they're synchronizing with one another.",
        "suggest": "这里的意图是，标准库和此 crate 不必共享 Rust 级别的 API 即可在此处进行同步，而是可以在后台进行操作以确保它们彼此同步。",
        "translate": ""
    },
    {
        "source": "That way when this function is called through the standard library or through crates.io we can be sure that the same mutex is being acquired.",
        "suggest": "这样，当通过标准库或 crates.io 调用此函数时，我们可以确保获取了相同的互斥锁。",
        "translate": ""
    },
    {
        "source": "So all of that is to say that the first thing we do here is we atomically create a `HANDLE` which is a named mutex on Windows.",
        "suggest": " 所以所有这一切都是说，我们要做的第一件事就是原子地创建一个 `HANDLE`，它是 Windows 上的一个命名互斥锁。",
        "translate": ""
    },
    {
        "source": "We synchronize a bit with other threads sharing this function specifically and ensure that only one handle is created per instance of this function.",
        "suggest": "我们与专门共享此函数的其他线程进行了一些同步，并确保每个此函数实例仅创建一个句柄。",
        "translate": ""
    },
    {
        "source": "Note that the handle is never closed once it's stored in the global.",
        "suggest": "请注意，一旦将句柄存储在长度中，它就永远不会关闭。",
        "translate": ""
    },
    {
        "source": "After we've actually go the lock we simply acquire it, and our `Init` handle we hand out will be responsible for dropping it eventually.",
        "suggest": "实际执行锁定后，我们只需获取它，然后我们递出的 `Init` 句柄将最终负责将其丢弃。",
        "translate": ""
    },
    {
        "source": "Ok, phew!",
        "suggest": "好，phew!",
        "translate": ""
    },
    {
        "source": "Now that we're all safely synchronized, let's actually start processing everything.",
        "suggest": "现在我们已经安全地同步了，让我们开始处理所有内容。",
        "translate": ""
    },
    {
        "source": "First up we need to ensure that `dbghelp.dll` is actually loaded in this process.",
        "suggest": "首先，我们需要确保在此过程中实际加载了 `dbghelp.dll`。",
        "translate": ""
    },
    {
        "source": "We do this dynamically to avoid a static dependency.",
        "suggest": "我们动态地执行此操作以避免静态依赖。",
        "translate": ""
    },
    {
        "source": "This has historically been done to work around weird linking issues and is intended at making binaries a bit more portable since this is largely just a debugging utility.",
        "suggest": "从历史上讲，这样做是为了解决怪异的链接问题，它的目的是使二进制文件具有更高的可移植性，因为这在很大程度上只是调试实用程序。",
        "translate": ""
    },
    {
        "source": "Once we've opened `dbghelp.dll` we need to call some initialization functions in it, and that's detailed more below.",
        "suggest": "打开 `dbghelp.dll` 之后，我们需要在其中调用一些初始化函数，下面将对其进行详细说明。",
        "translate": ""
    },
    {
        "source": "We only do this once, though, so we've got a global boolean indicating whether we're done yet or not.",
        "suggest": "不过，我们只执行一次，因此我们有一个布尔值布尔值指示我们是否已经完成。",
        "translate": ""
    },
    {
        "source": "Ensure that the `SYMOPT_DEFERRED_LOADS` flag is set, because according to MSVC's own docs about this: \"This is the fastest, most efficient way to use the symbol handler.\", so let's do that!",
        "suggest": "确保设置了 `SYMOPT_DEFERRED_LOADS` 标志，因为根据 MSVC 自己的文档: \"This is the fastest, most efficient way to use the symbol handler.\"，让我们开始吧!",
        "translate": ""
    },
    {
        "source": "Actually initialize symbols with MSVC.",
        "suggest": "实际上使用 MSVC 初始化符号。",
        "translate": ""
    },
    {
        "source": "Note that this can fail, but we ignore it.",
        "suggest": "请注意，这可能会失败，但是我们将其忽略。",
        "translate": ""
    },
    {
        "source": "There's not a ton of prior art for this per se, but LLVM internally seems to ignore the return value here and one of the sanitizer libraries in LLVM prints a scary warning if this fails but basically ignores it in the long run.",
        "suggest": "本身并没有很多现有技术，但是 LLVM 内部似乎忽略了这里的返回值，并且 LLVM 中的一个消毒剂库在失败时会发出可怕的警告，但从长远来看基本上会忽略它。",
        "translate": ""
    },
    {
        "source": "One case this comes up a lot for Rust is that the standard library and this crate on crates.io both want to compete for `SymInitializeW`.",
        "suggest": "Rust 出现了很多情况，就是标准库和 crates.io 上的 crate 都想竞争 `SymInitializeW`。",
        "translate": ""
    },
    {
        "source": "The standard library historically wanted to initialize then cleanup most of the time, but now that it's using this crate it means that someone will get to initialization first and the other will pick up that initialization.",
        "suggest": "历史上，标准库大多数时候都想初始化然后进行清理，但是现在它使用的是 crate，这意味着某个人将首先进行初始化，而另一个人将进行该初始化。",
        "translate": ""
    },
    {
        "source": "Unsafe here so test passes on no_std.",
        "suggest": "这里不安全，因此测试通过了 no_std。",
        "translate": ""
    },
    {
        "source": "A library for acquiring a backtrace at runtime",
        "suggest": "一个在运行时获取回溯的库",
        "translate": ""
    },
    {
        "source": "This library is meant to supplement the `RUST_BACKTRACE=1` support of the standard library by allowing an acquisition of a backtrace at runtime programmatically.",
        "suggest": "该库旨在通过允许在运行时以编程方式获取回溯来补充对标准库的 `RUST_BACKTRACE=1` 支持。",
        "translate": ""
    },
    {
        "source": "The backtraces generated by this library do not need to be parsed, for example, and expose the functionality of multiple backend implementations.",
        "suggest": "例如，不需要解析此库生成的回溯，并且可以公开多个后端实现的功能。",
        "translate": ""
    },
    {
        "source": "First, add this to your Cargo.toml",
        "suggest": "首先，将此添加到您的 Cargo.toml",
        "translate": ""
    },
    {
        "source": "When we're building as part of libstd, silence all warnings since they're irrelevant as this crate is developed out-of-tree.",
        "suggest": "当我们作为 libstd 的一部分进行构建时，请静默所有警告，因为它们无关紧要，因为此 crate 是在树外开发的。",
        "translate": ""
    },
    {
        "source": "This is only used for gimli right now, which is only used on some platforms, so don't worry if it's unused in other configurations.",
        "suggest": "目前仅用于 gimli，仅在某些平台上使用，因此不用担心它是否在其他配置中未使用。",
        "translate": ""
    },
    {
        "source": "dl_iterate_phdr takes a callback that will receive a dl_phdr_info pointer for every DSO that has been linked into the process.",
        "suggest": "dl_iterate_phdr 进行回调，该回调将为已链接到该进程的每个 DSO 接收 dl_phdr_info 指针。",
        "translate": ""
    },
    {
        "source": "dl_iterate_phdr also ensures that the dynamic linker is locked from start to finish of the iteration.",
        "suggest": "dl_iterate_phdr 还可以确保动态链接器从迭代的开始到结束都被锁定。",
        "translate": ""
    },
    {
        "source": "If the callback returns a non-zero value the iteration is terminated early.",
        "suggest": "如果回调返回非零值，则迭代会提前终止。",
        "translate": ""
    },
    {
        "source": "will be passed as the third argument to the callback on each call.",
        "suggest": "将作为第三个参数传递给每次调用的回调。",
        "translate": ""
    },
    {
        "source": "gives the size of the dl_phdr_info.",
        "suggest": "给出 dl_phdr_info 的大小。",
        "translate": ""
    },
    {
        "source": "We need to parse out the build ID and some basic program header data which means that we need a bit of stuff from the ELF spec as well.",
        "suggest": "我们需要解析出构建 ID 和一些基本程序头数据，这意味着我们也需要 ELF 规范中的一些内容。",
        "translate": ""
    },
    {
        "source": "Now we have to replicate, bit for bit, the structure of the dl_phdr_info type used by fuchsia's current dynamic linker.",
        "suggest": "现在，我们必须一点一点地复制 Fuchsia 的当前动态链接器使用的 dl_phdr_info 类型的结构体。",
        "translate": ""
    },
    {
        "source": "Chromium also has this ABI boundary as well as crashpad.",
        "suggest": "Chromium 也具有此 ABI 边界以及崩溃垫。",
        "translate": ""
    },
    {
        "source": "Eventully we'd like to move these cases to use elf-search but we'd need to provide that in the SDK and that has not yet been done.",
        "suggest": "最终，我们希望将这些案例移至使用 elf-search，但我们需要在 SDK 中提供它，但尚未完成。",
        "translate": ""
    },
    {
        "source": "Thus we (and they) are stuck having to use this method which incurs a tight coupling with the fuchsia libc.",
        "suggest": "因此，我们 (和他们) 不得不使用此方法，而该方法会导致与 Fuchsia  libc 紧密耦合。",
        "translate": ""
    },
    {
        "source": "We have no way of knowing of checking if e_phoff and e_phnum are valid.",
        "suggest": "我们无法知道检查 e_phoff 和 e_phnum 是否有效。",
        "translate": ""
    },
    {
        "source": "should ensure this for us however so it's safe to form a slice here.",
        "suggest": "应该为我们确保这一点，因此在此处形成切片是安全的。",
        "translate": ""
    },
    {
        "source": "Elf_Phdr represents a 64-bit ELF program header in the endianness of the target architecture.",
        "suggest": "Elf_Phdr 以目标体系结构的字节序表示一个 64 位的 ELF 程序头。",
        "translate": ""
    },
    {
        "source": "Phdr represents a valid ELF program header and its contents.",
        "suggest": "Phdr 表示有效的 ELF 程序标头及其内容。",
        "translate": ""
    },
    {
        "source": "We have no way of checking if p_addr or p_memsz are valid.",
        "suggest": "我们无法检查 p_addr 或 p_memsz 是否有效。",
        "translate": ""
    },
    {
        "source": "Fuchsia's libc parses the notes first however so by virtue of being here these headers must be valid.",
        "suggest": "Fuchsia 的 libc 首先解析了 note，因此这些 header 既然出现在这里，就一定是有效的。",
        "translate": ""
    },
    {
        "source": "NoteIter does not require the underlying data to be valid but it does require the bounds to be valid.",
        "suggest": "注意 Iter 不需要底层数据有效，但是它要求边界有效。",
        "translate": ""
    },
    {
        "source": "We trust that libc has ensured that this is the case for us here.",
        "suggest": "我们相信 libc 确保在这里对我们而言就是这种情况。",
        "translate": ""
    },
    {
        "source": "The note type for build IDs.",
        "suggest": "构建 ID 的 note 类型。",
        "translate": ""
    },
    {
        "source": "Elf_Nhdr represents an ELF note header in the endianness of the target.",
        "suggest": "Elf_Nhdr 表示目标字节序中的 ELF note 头。",
        "translate": ""
    },
    {
        "source": "Note represents an ELF note (header + contents).",
        "suggest": "Note 表示 ELF note (标题 + 内容)。",
        "translate": ""
    },
    {
        "source": "The name is left as a u8 slice because it is not always null terminated and rust makes it easy enough to check that the bytes match eitherway.",
        "suggest": "该名称保留为 u8 切片，因为它并不总是以 null 结尾，并且 rust 使得检查字节是否匹配仍然足够容易。",
        "translate": ""
    },
    {
        "source": "NoteIter lets you safely iterate over a note segment.",
        "suggest": "NoteIter 使您可以安全地遍历笔记段。",
        "translate": ""
    },
    {
        "source": "It terminates as soon as an error occurs or there are no more notes.",
        "suggest": "一旦发生错误或没有更多 note，它将终止。",
        "translate": ""
    },
    {
        "source": "If you iterate over invalid data it will function as though no notes were found.",
        "suggest": "如果您遍历无效数据，它将像没有找到 note 的情况一样起作用。",
        "translate": ""
    },
    {
        "source": "It is an invariant of function that the pointer and size given denote a valid range of bytes that can all be read.",
        "suggest": "函数的不变式是，给定的指针和大小表示可以读取的有效字节范围。",
        "translate": ""
    },
    {
        "source": "The contents of these bytes can be anything but the range must be valid for this to be safe.",
        "suggest": "这些字节的内容可以是任何东西，但范围必须是有效的，以确保安全。",
        "translate": ""
    },
    {
        "source": "align_to aligns 'x' to 'to'-byte alignment assuming 'to' is a power of 2.",
        "suggest": "假设 '`to` 为 2 的幂，align_to 将 'x' 对齐为 `to` 字节对齐。",
        "translate": ""
    },
    {
        "source": "This follows a standard pattern in C/C++ ELF parsing code where (x + to - 1) & -to is used.",
        "suggest": "这遵循 C/C++ ELF 解析代码中的标准模式，其中使用 (x + 到 - 1) &-to。",
        "translate": ""
    },
    {
        "source": "Rust does not let you negate usize so I use",
        "suggest": "Rust 不允许您否定 usize，所以我用",
        "translate": ""
    },
    {
        "source": "2's-complement conversion to recreate that.",
        "suggest": "2 的补码转换以重新创建它。",
        "translate": ""
    },
    {
        "source": "take_bytes_align4 consumes num bytes from the slice (if present) and additionally ensures that the final slice is properlly aligned.",
        "suggest": "take_bytes_align4 从切片 (如果存在) 中消耗 num 个字节，并另外确保最终切片正确对齐。",
        "translate": ""
    },
    {
        "source": "If an either the number of bytes requested is too large or the slice can't be realigned afterwards due to not enough remaining bytes existing, None is returned and the slice is not modified.",
        "suggest": "如果请求的字节数太大或由于剩余字节数不足而无法在之后重新对齐切片，则将返回 None 且不对切片进行修改。",
        "translate": ""
    },
    {
        "source": "This function has no real invariants the caller must uphold other than perhaps that 'bytes' should be aligned for performance (and on some architectures correctness).",
        "suggest": "该函数没有调用者必须坚持的任何实际不变性，除了 'bytes' 应该针对性能 (以及某些体系结构的正确性) 进行对齐之外。",
        "translate": ""
    },
    {
        "source": "The values in the Elf_Nhdr fields might be nonsense but this function ensures no such thing.",
        "suggest": "Elf_Nhdr 字段中的值可能是无意义的，但此函数可确保不会出现这种情况。",
        "translate": ""
    },
    {
        "source": "This is safe as long as there is enough space and we just confirmed that in the if statement above so this should not be unsafe.",
        "suggest": "只要有足够的空间，这是安全的，并且我们只是在上面的 if 语句中确认了这一点，所以这应该不是不安全的。",
        "translate": ""
    },
    {
        "source": "Note that sice_of::<Elf_Nhdr>() is always 4-byte aligned.",
        "suggest": "请注意 sice_of::<Elf_Nhdr> () 始终 4 字节对齐。",
        "translate": ""
    },
    {
        "source": "Check if we've reached the end.",
        "suggest": "检查我们是否到达终点。",
        "translate": ""
    },
    {
        "source": "We transmute out an nhdr but we carefully consider the resulting struct.",
        "suggest": "我们转换了 nhdr，但我们仔细考虑了生成的结构体。",
        "translate": ""
    },
    {
        "source": "We don't trust the namesz or descsz and we make no unsafe decisions based on the type.",
        "suggest": "我们不信任 namez 或 descsz，也不会根据类型做出不安全的决定。",
        "translate": ""
    },
    {
        "source": "So even if we get out complete garbage we should still be safe.",
        "suggest": "因此，即使我们丢掉了完整的垃圾，我们仍然应该是安全的。",
        "translate": ""
    },
    {
        "source": "Indicates that a segment is executable.",
        "suggest": "指示段是可执行的。",
        "translate": ""
    },
    {
        "source": "Indicates that a segment is writable.",
        "suggest": "指示段是可写的。",
        "translate": ""
    },
    {
        "source": "Indicates that a segment is readable.",
        "suggest": "指示段是可读的。",
        "translate": ""
    },
    {
        "source": "Represents an ELF segment at runtime.",
        "suggest": "表示运行时的 ELF 段。",
        "translate": ""
    },
    {
        "source": "Gives the runtime virtual address of this segment's contents.",
        "suggest": "提供此段内容的运行时虚拟地址。",
        "translate": ""
    },
    {
        "source": "Gives the memory size of this segment's contents.",
        "suggest": "给出此段内容的内存大小。",
        "translate": ""
    },
    {
        "source": "Gives the module virtual address of this segment with the ELF file.",
        "suggest": "使用 ELF 文件为该段提供模块的虚拟地址。",
        "translate": ""
    },
    {
        "source": "Gives the permissions found in the ELF file.",
        "suggest": "提供在 ELF 文件中找到的权限。",
        "translate": ""
    },
    {
        "source": "These permissions are not necessarily the permissions present at runtime however.",
        "suggest": "但是，这些权限不一定是运行时存在的权限。",
        "translate": ""
    },
    {
        "source": "Lets one iterate over Segments from a DSO.",
        "suggest": "让一个 DSO 遍历细分。",
        "translate": ""
    },
    {
        "source": "Represents an ELF DSO (Dynamic Shared Object).",
        "suggest": "表示 ELF DSO (动态共享 Object)。",
        "translate": ""
    },
    {
        "source": "This type references the data stored in the actual DSO rather than making its own copy.",
        "suggest": "此类型引用存储在实际 DSO 中的数据，而不是制作其自己的副本。",
        "translate": ""
    },
    {
        "source": "The dynamic linker always gives us a name, even if the name is empty.",
        "suggest": "即使名称为空，动态链接器也始终为我们提供一个名称。",
        "translate": ""
    },
    {
        "source": "In the case of the main executable this name will be empty.",
        "suggest": "对于主可执行文件，此名称将为空。",
        "translate": ""
    },
    {
        "source": "In the case of a shared object it will be the soname (see DT_SONAME).",
        "suggest": "如果是共享的 object，则为 soname (请参见 DT_SONAME)。",
        "translate": ""
    },
    {
        "source": "On Fuchsia virtually all binaries have build IDs but this is not a strict requierment.",
        "suggest": "在 Fuchsia 上，几乎所有二进制文件都有构建 ID，但这不是严格的要求。",
        "translate": ""
    },
    {
        "source": "There's no way to match up DSO information with a real ELF file afterwards if there is no build_id so we require that every DSO have one here.",
        "suggest": "如果没有 build_id，那么以后就无法将 DSO 信息与真实的 ELF 文件进行匹配，因此我们要求每个 DSO 在此处都具有一个。",
        "translate": ""
    },
    {
        "source": "DSO's without a build_id are ignored.",
        "suggest": "没有 build_id 的 DSO 将被忽略。",
        "translate": ""
    },
    {
        "source": "Returns an iterator over Segments in this DSO.",
        "suggest": "返回此 DSO 中的细分上的迭代器。",
        "translate": ""
    },
    {
        "source": "These errors encode issues that arise while parsing information about each DSO.",
        "suggest": "这些错误编码了在解析有关每个 DSO 的信息时出现的问题。",
        "translate": ""
    },
    {
        "source": "NameError means that an error occurred while converting a C style string into a rust string.",
        "suggest": "NameError 表示将 C 样式字符串转换为 rust 字符串时发生错误。",
        "translate": ""
    },
    {
        "source": "BuildIDError means that we didn't find a build ID.",
        "suggest": "BuildIDError 表示我们找不到构建 ID。",
        "translate": ""
    },
    {
        "source": "This could either be because the DSO had no build ID or because the segment containing the build ID was malformed.",
        "suggest": "这可能是因为 DSO 没有构建 ID，或者是因为包含构建 ID 的段格式错误。",
        "translate": ""
    },
    {
        "source": "Calls either 'dso' or 'error' for each DSO linked into the process by the dynamic linker.",
        "suggest": "对于由动态链接器链接到进程的每个 DSO，调用 'dso' 或 'error'。",
        "translate": ""
    },
    {
        "source": "A DsoPrinter that will have one of eats methods called foreach DSO.",
        "suggest": "DsoPrinter 将具有一种称为 foreach DSO 的 eats 方法。",
        "translate": ""
    },
    {
        "source": "dl_iterate_phdr ensures that info.name will point to a valid location.",
        "suggest": "dl_iterate_phdr 确保 info.name 指向有效位置。",
        "translate": ""
    },
    {
        "source": "This function prints the Fuchsia symbolizer markup for all information contained in a DSO.",
        "suggest": "此函数为 DSO 中包含的所有信息打印 Fuchsia 符号器标记。",
        "translate": ""
    },
    {
        "source": "A formatter for backtraces.",
        "suggest": "回溯的格式化程序。",
        "translate": ""
    },
    {
        "source": "This type can be used to print a backtrace regardless of where the backtrace itself comes from.",
        "suggest": "不管回溯本身来自何处，都可以使用此类型来打印回溯。",
        "translate": ""
    },
    {
        "source": "If you have a `Backtrace` type then its `Debug` implementation already uses this printing format.",
        "suggest": "如果您使用的是 `Backtrace` 类型，则其 `Debug` 实现已使用此打印格式。",
        "translate": ""
    },
    {
        "source": "The styles of printing that we can print",
        "suggest": "我们可以打印的打印样式",
        "translate": ""
    },
    {
        "source": "Prints a terser backtrace which ideally only contains relevant information",
        "suggest": "打印一个简短的回溯，理想情况下仅包含相关信息",
        "translate": ""
    },
    {
        "source": "Prints a backtrace that contains all possible information",
        "suggest": "打印包含所有可能信息的回溯",
        "translate": ""
    },
    {
        "source": "Create a new `BacktraceFmt` which will write output to the provided `fmt`.",
        "suggest": "创建一个新的 `BacktraceFmt`，它将输出写入到提供的 `fmt` 中。",
        "translate": ""
    },
    {
        "source": "The `format` argument will control the style in which the backtrace is printed, and the `print_path` argument will be used to print the `BytesOrWideString` instances of filenames.",
        "suggest": "`format` 参数将控制打印回溯记录的样式，而 `print_path` 参数将用于打印文件名的 `BytesOrWideString` 实例。",
        "translate": ""
    },
    {
        "source": "This type itself doesn't do any printing of filenames, but this callback is required to do so.",
        "suggest": "此类型本身不执行任何文件名打印，但是需要执行此回调。",
        "translate": ""
    },
    {
        "source": "Prints a preamble for the backtrace about to be printed.",
        "suggest": "打印将要打印的回溯的前导。",
        "translate": ""
    },
    {
        "source": "This is required on some platforms for backtraces to be fully symbolicated later, and otherwise this should just be the first method you call after creating a `BacktraceFmt`.",
        "suggest": "在某些平台上，这是必需的，以便在以后完全符号化回溯，否则，这应该只是在创建 `BacktraceFmt` 之后调用的第一个方法。",
        "translate": ""
    },
    {
        "source": "Adds a frame to the backtrace output.",
        "suggest": "将框架添加到回溯输出。",
        "translate": ""
    },
    {
        "source": "This commit returns an RAII instance of a `BacktraceFrameFmt` which can be used to actually print a frame, and on destruction it will increment the frame counter.",
        "suggest": "该提交返回 `BacktraceFrameFmt` 的 RAII 实例，该实例可用于实际打印帧，并且在销毁时它将增加帧计数器。",
        "translate": ""
    },
    {
        "source": "Completes the backtrace output.",
        "suggest": "完成回溯输出。",
        "translate": ""
    },
    {
        "source": "This is currently a no-op but is added for future compatibility with backtrace formats.",
        "suggest": "目前这是一个空操作，但为实现 future 与 backtrace 格式的兼容性而添加。",
        "translate": ""
    },
    {
        "source": "Currently a no-op-- including this hook to allow for future additions.",
        "suggest": "当前不操作 - 包括此 hook 以允许添加 future。",
        "translate": ""
    },
    {
        "source": "A formatter for just one frame of a backtrace.",
        "suggest": "仅用于回溯的一帧的格式化程序。",
        "translate": ""
    },
    {
        "source": "This type is created by the `BacktraceFmt::frame` function.",
        "suggest": "此类型由 `BacktraceFmt::frame` 函数创建。",
        "translate": ""
    },
    {
        "source": "Prints a `BacktraceFrame` with this frame formatter.",
        "suggest": "使用此帧格式化程序打印 `BacktraceFrame`。",
        "translate": ""
    },
    {
        "source": "This will recursively print all `BacktraceSymbol` instances within the `BacktraceFrame`.",
        "suggest": "这将递归打印 `BacktraceFrame` 中的所有 `BacktraceSymbol` 实例。",
        "translate": ""
    },
    {
        "source": "Prints a `BacktraceSymbol` within a `BacktraceFrame`.",
        "suggest": "在 `BacktraceFrame` 中打印 `BacktraceSymbol`。",
        "translate": ""
    },
    {
        "source": "this isn't great that we don't end up printing anything with non-utf8 filenames.",
        "suggest": "这不是很好，因为我们最终不会输出任何非 utf8 文件名的文件。",
        "translate": ""
    },
    {
        "source": "Thankfully almost everything is utf8 so this shouldn't be too too bad.",
        "suggest": "幸运的是，几乎所有东西都是 utf8，所以这应该不太糟。",
        "translate": ""
    },
    {
        "source": "Prints a raw traced `Frame` and `Symbol`, typically from within the raw callbacks of this crate.",
        "suggest": "通常从此 crate 的原始回调中打印原始跟踪的 `Frame` 和 `Symbol`。",
        "translate": ""
    },
    {
        "source": "Adds a raw frame to the backtrace output.",
        "suggest": "将原始帧添加到回溯输出中。",
        "translate": ""
    },
    {
        "source": "This method, unlike the previous, takes the raw arguments in case they're being source from different locations.",
        "suggest": "与以前的方法不同，此方法采用原始参数，以防它们来自不同位置。",
        "translate": ""
    },
    {
        "source": "Note that this may be called multiple times for one frame.",
        "suggest": "注意，对于一帧可以多次调用。",
        "translate": ""
    },
    {
        "source": "Adds a raw frame to the backtrace output, including column information.",
        "suggest": "将原始帧添加到 backtrace 输出中，包括列信息。",
        "translate": ""
    },
    {
        "source": "This method, like the previous, takes the raw arguments in case they're being source from different locations.",
        "suggest": "与前面的方法一样，此方法采用原始参数，以防它们来自不同位置。",
        "translate": ""
    },
    {
        "source": "Fuchsia is unable to symbolize within a process so it has a special format which can be used to symbolize later.",
        "suggest": "Fuchsia 无法在进程中进行符号化，因此它具有一种特殊的格式，可用于以后进行符号化。",
        "translate": ""
    },
    {
        "source": "Print that instead of printing addresses in our own format here.",
        "suggest": "在此处打印，而不用我们自己的格式打印地址。",
        "translate": ""
    },
    {
        "source": "No need to print \"null\" frames, it basically just means that the system backtrace was a bit eager to trace back super far.",
        "suggest": "无需打印 \"null\" 帧，这基本上意味着系统回溯有点渴望超远地回溯。",
        "translate": ""
    },
    {
        "source": "To reduce TCB size in Sgx enclave, we do not want to implement symbol resolution functionality.",
        "suggest": "为了减小 Sgx 飞地中的 TCB 大小，我们不想实现符号解析功能。",
        "translate": ""
    },
    {
        "source": "Rather, we can print the offset of the address here, which could be later mapped to correct function.",
        "suggest": "相反，我们可以在此处打印地址的偏移量，以后可以将其映射为正确的函数。",
        "translate": ""
    },
    {
        "source": "Print the index of the frame as well as the optional instruction pointer of the frame.",
        "suggest": "打印框架的索引以及框架的可选指令指针。",
        "translate": ""
    },
    {
        "source": "If we're beyond the first symbol of this frame though we just print appropriate whitespace.",
        "suggest": "如果我们超出该帧的第一个符号，尽管我们只打印适当的空格。",
        "translate": ""
    },
    {
        "source": "Next up write out the symbol name, using the alternate formatting for more information if we're a full backtrace.",
        "suggest": "接下来，写出符号名称，如果我们有完整的回溯，请使用其他格式来获取更多信息。",
        "translate": ""
    },
    {
        "source": "Here we also handle symbols which don't have a name,",
        "suggest": "在这里，我们还处理没有名称的符号，",
        "translate": ""
    },
    {
        "source": "And last up, print out the filename/line number if they're available.",
        "suggest": "最后，打印出 filename/line 编号 (如果有)。",
        "translate": ""
    },
    {
        "source": "are printed on lines under the symbol name, so print some appropriate whitespace to sort of right-align ourselves.",
        "suggest": "是在符号名称下的行上打印的，因此请打印一些适当的空格以使自己右对齐。",
        "translate": ""
    },
    {
        "source": "Delegate to our internal callback to print the filename and then print out the line number.",
        "suggest": "委托给我们的内部回调以打印文件名，然后打印出行号。",
        "translate": ""
    },
    {
        "source": "Add column number, if available.",
        "suggest": "添加列号 (如果有)。",
        "translate": ""
    },
    {
        "source": "We only care about the first symbol of a frame",
        "suggest": "我们只关心框架的第一个符号",
        "translate": ""
    },
    {
        "source": "Symbolication strategy using `dbghelp.dll` on Windows, only used for MSVC",
        "suggest": "在 Windows 上使用 `dbghelp.dll` 的符号化策略，仅用于 MSVC",
        "translate": ""
    },
    {
        "source": "This symbolication strategy, like with backtraces, uses dynamically loaded information from `dbghelp.dll`.",
        "suggest": "这种符号化策略与回溯一样，都使用从 `dbghelp.dll` 动态加载的信息。",
        "translate": ""
    },
    {
        "source": "(see `src/dbghelp.rs` for info about why it's dynamically loaded).",
        "suggest": "(有关动态加载原因的信息，请参见 `src/dbghelp.rs`)。",
        "translate": ""
    },
    {
        "source": "This API selects its resolution strategy based on the frame provided or the information we have at hand.",
        "suggest": "该 API 根据提供的框架或我们掌握的信息来选择其解析策略。",
        "translate": ""
    },
    {
        "source": "If a frame from `StackWalkEx` is given to us then we use similar APIs to generate correct information about inlined functions.",
        "suggest": "如果给了我们 `StackWalkEx` 的框架，那么我们将使用类似的 API 来生成有关内联函数的正确信息。",
        "translate": ""
    },
    {
        "source": "Otherwise if all we have is an address or an older stack frame from `StackWalk64` we use the older APIs for symbolication.",
        "suggest": "否则，如果我们所拥有的只是地址或 `StackWalk64` 的较旧栈帧，则可以使用较旧的 API 进行符号化。",
        "translate": ""
    },
    {
        "source": "There's a good deal of support in this module, but a good chunk of it is converting back and forth between Windows types and Rust types.",
        "suggest": "这个模块有很多支持，但是其中很大一部分是在 Windows 类型和 Rust 类型之间来回转换。",
        "translate": ""
    },
    {
        "source": "For example symbols come to us as wide strings which we then convert to utf-8 strings if we can.",
        "suggest": "例如，符号以宽字符串的形式出现在我们面前，如果可以的话，我们将其转换为 utf-8 字符串。",
        "translate": ""
    },
    {
        "source": "Store an OsString on std so we can provide the symbol name and filename.",
        "suggest": "在 std 上存储一个 OsString，以便我们提供符号名称和文件名。",
        "translate": ""
    },
    {
        "source": "the struct size in C.",
        "suggest": " C 中的结构体大小。",
        "translate": ""
    },
    {
        "source": "the value is different to `size_of::<SYMBOL_INFOW>() - MAX_SYM_NAME + 1` (== 81) due to struct alignment.",
        "suggest": "由于结构体对齐，该值不同于 `size_of::<SYMBOL_INFOW>() - MAX_SYM_NAME + 1` ( == 81)。",
        "translate": ""
    },
    {
        "source": "If the symbol name is greater than MaxNameLen, SymFromAddrW will give a buffer of (MaxNameLen - 1) characters and set NameLen to the real value.",
        "suggest": "如果符号名称大于 MaxNameLen，则 SymFromAddrW 将提供一个 (MaxNameLen-1) 个字符的缓冲区，并将 NameLen 设置为实际值。",
        "translate": ""
    },
    {
        "source": "Reencode the utf-16 symbol to utf-8 so we can use `SymbolName::new` like all other platforms",
        "suggest": "将 utf-16 符号重新编码为 utf-8，因此我们可以像其他所有平台一样使用 `SymbolName::new`",
        "translate": ""
    },
    {
        "source": "Collect all the symbols into a local vector which is sorted by address and contains enough data to learn about the symbol name.",
        "suggest": "将所有符号收集到本地 vector 中，该 vector 按地址排序，并包含足够的数据以了解符号名称。",
        "translate": ""
    },
    {
        "source": "Note that we only look at function symbols and also note that the sections are 1-indexed because the zero section is special (apparently).",
        "suggest": "请注意，我们仅查看函数符号，还注意到这些节是 1 索引的，因为零节是特殊的 (apparently)。",
        "translate": ""
    },
    {
        "source": "Note that unlike other formats COFF doesn't embed the size of each symbol.",
        "suggest": "请注意，与其他格式不同，COFF 不会嵌入每个符号的大小。",
        "translate": ""
    },
    {
        "source": "As a last ditch effort search for the *closest* symbol to a particular address and return that one.",
        "suggest": "作为最后的努力，将 *close* 符号搜索到特定地址并返回该地址。",
        "translate": ""
    },
    {
        "source": "This gets really wonky once symbols start getting removed because the symbols returned here can be totally incorrect, but we have no idea of knowing how to detect that.",
        "suggest": "一旦开始删除符号，此操作将变得非常不稳定，因为此处返回的符号可能完全不正确，但是我们不知道如何检测到该错误。",
        "translate": ""
    },
    {
        "source": "typically `addr` isn't in the array, but `i` is where we'd insert it, so the previous position must be the greatest less than `addr`",
        "suggest": "通常 `addr` 不在数组中，但是 `i` 是我们要插入它的位置，因此前一个位置必须小于 `addr`",
        "translate": ""
    },
    {
        "source": "Zero-sized type representing the native endianness.",
        "suggest": "零大小类型，表示本地字节序。",
        "translate": ""
    },
    {
        "source": "We could use a literal instead, but this helps ensure correctness.",
        "suggest": "我们可以改用字面量，但这有助于确保正确性。",
        "translate": ""
    },
    {
        "source": "The entire file data.",
        "suggest": "整个文件数据。",
        "translate": ""
    },
    {
        "source": "List of pre-parsed and sorted symbols by base address.",
        "suggest": "按基地址预先解析和排序的符号列表。",
        "translate": ""
    },
    {
        "source": "Only look at function/object symbols.",
        "suggest": "只看 function/object 符号。",
        "translate": ""
    },
    {
        "source": "This mirrors what libbacktrace does and in general we're only symbolicating function addresses in theory.",
        "suggest": "这反映了 libbacktrace 的功能，并且一般而言，我们只是在理论上象征着函数地址。",
        "translate": ""
    },
    {
        "source": "symbols correspond to data, and maybe someone's crazy enough to have a function go into static data?",
        "suggest": "符号与数据相对应，也许有人疯了以至于有一个函数进入静态数据?",
        "translate": ""
    },
    {
        "source": "skip anything that's in an undefined section header, since it means it's an imported function and we're only symbolicating with locally defined functions.",
        "suggest": "跳过未定义节标题中的所有内容，因为这意味着它是导入的函数，并且我们仅使用本地定义的函数进行符号化。",
        "translate": ""
    },
    {
        "source": "Check for DWARF-standard (gABI) compression, i.e., as generated by ld's `--compress-debug-sections=zlib-gabi` flag.",
        "suggest": "检查 DWARF 标准的 (gABI) 压缩，即由 ld 的 `--compress-debug-sections=zlib-gabi` 标志生成。",
        "translate": ""
    },
    {
        "source": "Not compressed.",
        "suggest": "未压缩。",
        "translate": ""
    },
    {
        "source": "Zlib compression is the only known type.",
        "suggest": "Zlib 压缩是唯一已知的类型。",
        "translate": ""
    },
    {
        "source": "Check for the nonstandard GNU compression format, i.e., as generated by ld's `--compress-debug-sections=zlib-gnu` flag.",
        "suggest": "检查非标准的 GNU 压缩格式，即由 ld 的 `--compress-debug-sections=zlib-gnu` 标志生成的压缩格式。",
        "translate": ""
    },
    {
        "source": "This means that if we're actually asking for `.debug_info` then we need to look up a section named `.zdebug_info`.",
        "suggest": "这意味着，如果我们实际上要的是 `.debug_info`，那么我们需要查找一个名为 `.zdebug_info` 的部分。",
        "translate": ""
    },
    {
        "source": "Same sort of binary search as Windows above",
        "suggest": "与上述 Windows 相同的二进制搜索",
        "translate": ""
    },
    {
        "source": "The loading path for OSX is is so different we just have a completely different implementation of the function here.",
        "suggest": "OSX 的加载路径是如此不同，我们在这里只是对函数进行了完全不同的实现。",
        "translate": ""
    },
    {
        "source": "On OSX we need to go probing the filesystem for a bunch of files.",
        "suggest": "在 OSX 上，我们需要探查文件系统中的一堆文件。",
        "translate": ""
    },
    {
        "source": "First up we need to load the unique UUID which is stored in the macho header of the file we're reading, specified at `path`.",
        "suggest": "首先，我们需要加载唯一的 UUID，该 UUID 存储在我们正在读取的文件的男子气概的标头中，该标头指定为 `path`。",
        "translate": ""
    },
    {
        "source": "Next we need to look for a `*.dSYM` file.",
        "suggest": "接下来，我们需要查找 `*.dSYM` 文件。",
        "translate": ""
    },
    {
        "source": "For now we just probe the containing directory and look around for something that matches `*.dSYM`.",
        "suggest": "现在，我们仅探测包含目录，并查找与 `*.dSYM` 匹配的内容。",
        "translate": ""
    },
    {
        "source": "Once it's found we root through the dwarf resources that it contains and try to find a macho file which has a matching UUID as the one of our own file.",
        "suggest": "一旦找到它，我们便会遍历它包含的矮人资源，并尝试查找一个具有匹配的 UUID 的男子气概的文件作为我们自己的文件之一。",
        "translate": ""
    },
    {
        "source": "If we find a match that's the dwarf file we want to return.",
        "suggest": "如果找到匹配的文件，则要返回该文件。",
        "translate": ""
    },
    {
        "source": "Looks like nothing matched our UUID, so let's at least return our own file.",
        "suggest": "看起来没有任何东西与我们的 UUID 相匹配，所以至少让我们返回自己的文件。",
        "translate": ""
    },
    {
        "source": "This should have the symbol table for at least some symbolication purposes.",
        "suggest": "它至少应具有符号表，以用于某些符号化目的。",
        "translate": ""
    },
    {
        "source": "Look for files in the `DWARF` directory which have a matching uuid to the original object file.",
        "suggest": "在 `DWARF` 目录中查找具有与原始 object 文件匹配的 uuid 的文件。",
        "translate": ""
    },
    {
        "source": "If we find one then we found the debug information.",
        "suggest": "如果找到一个，则找到调试信息。",
        "translate": ""
    },
    {
        "source": "This is used both for executables/libraries and source object files.",
        "suggest": "executables/libraries 和 object 源文件都使用此文件。",
        "translate": ""
    },
    {
        "source": "Only set for executables/libraries, and not the source object files.",
        "suggest": "仅为 executables/libraries 设置，而不为源 object 文件设置。",
        "translate": ""
    },
    {
        "source": "The outer Option is for lazy loading, and the inner Option allows load errors to be cached.",
        "suggest": "外部选项用于延迟加载，内部选项允许缓存加载错误。",
        "translate": ""
    },
    {
        "source": "files should have all sections in a single unnamed segment load command.",
        "suggest": "文件应在单个未命名段装入命令中包含所有节。",
        "translate": ""
    },
    {
        "source": "We never search object file symbols by address.",
        "suggest": "我们从不按地址搜索 object 文件符号。",
        "translate": ""
    },
    {
        "source": "Instead, we already know the symbol name from the executable, and we need to search by name to find the matching symbol in the object file.",
        "suggest": "相反，我们已经从可执行文件中知道了符号名称，我们需要按名称搜索以在 object 文件中找到匹配的符号。",
        "translate": ""
    },
    {
        "source": "Try to load a context for an object file.",
        "suggest": "尝试加载 object 文件的上下文。",
        "translate": ""
    },
    {
        "source": "If dsymutil was not run, then the DWARF may be found in the source object files.",
        "suggest": "如果没有运行 dsymutil，则可能在源 object 文件中找到 DWARF。",
        "translate": ""
    },
    {
        "source": "contains a map from addresses to symbols and object paths.",
        "suggest": "包含从地址到符号和 object 路径的 map。",
        "translate": ""
    },
    {
        "source": "Look up the address and get a mapping for the object.",
        "suggest": "查找地址并获取 object 的映射。",
        "translate": ""
    },
    {
        "source": "No cached mapping, so create it.",
        "suggest": "没有缓存的映射，请创建它。",
        "translate": ""
    },
    {
        "source": "Don't leak the `'static` lifetime, make sure it's scoped to just ourselves.",
        "suggest": "请勿泄漏 `'static` 的生命周期，请确保它仅适用于我们自己。",
        "translate": ""
    },
    {
        "source": "We must translate the address in order to be able to look it up in the DWARF in the object file.",
        "suggest": "我们必须转换该地址，以便能够在 object 文件的 DWARF 中查找该地址。",
        "translate": ""
    },
    {
        "source": "symbol names can be either `/path/to/object.o` or `/path/to/archive.a(object.o)`.",
        "suggest": "符号名称可以是 `/path/to/object.o` 或 `/path/to/archive.a(object.o)`。",
        "translate": ""
    },
    {
        "source": "keep the file alive to prevent it from ebeing deleted which would cause us to read bad data.",
        "suggest": "使文件保持活动状态，以防止其被删除，这将导致我们读取错误的数据。",
        "translate": ""
    },
    {
        "source": "only used on Linux right now, so allow dead code elsewhere",
        "suggest": "目前仅在 Linux 上使用，因此允许在其他地方使用无效代码",
        "translate": ""
    },
    {
        "source": "A simple arena allocator for byte buffers.",
        "suggest": "一个简单的舞台分配器，用于字节缓冲区。",
        "translate": ""
    },
    {
        "source": "Allocates a buffer of the specified size and returns a mutable reference to it.",
        "suggest": "分配指定大小的缓冲区，并向其返回可变引用。",
        "translate": ""
    },
    {
        "source": "this is the only function that ever constructs a mutable reference to `self.buffers`.",
        "suggest": "这是创建 `self.buffers` 的可变引用的唯一函数。",
        "translate": ""
    },
    {
        "source": "we never remove elements from `self.buffers`, so a reference to the data inside any buffer will live as long as `self` does.",
        "suggest": "我们从不从 `self.buffers` 中删除元素，因此只要 `self` 起作用，对任何缓冲区中的数据的引用都将有效。",
        "translate": ""
    },
    {
        "source": "Support for symbolication using the `gimli` crate on crates.io",
        "suggest": "在 crates.io 上使用 `gimli` crate 支持符号化",
        "translate": ""
    },
    {
        "source": "This is the default symbolication implementation for Rust.",
        "suggest": "这是 Rust 的默认符号实现。",
        "translate": ""
    },
    {
        "source": "'static lifetime is a lie to hack around lack of support for self-referential structs.",
        "suggest": "静态生命周期是在缺乏对自我指称结构体的支持的情况下撒谎的谎言。",
        "translate": ""
    },
    {
        "source": "Convert to 'static lifetimes since the symbols should only borrow `map` and `stash` and we're preserving them below.",
        "suggest": "转换为静态生命周期，因为这些符号仅应借用 `map` 和 `stash`，我们将其保留在下面。",
        "translate": ""
    },
    {
        "source": "For loading native libraries on Windows, see some discussion on rust-lang/rust#71060 for the various strategies here.",
        "suggest": "要在 Windows 上加载原生库，请参见 rust-lang/rust#71060 上有关各种策略的一些讨论。",
        "translate": ""
    },
    {
        "source": "MinGW libraries currently don't support ASLR (rust-lang/rust#16514), but DLLs can still be relocated around in the address space.",
        "suggest": "MinGW 库当前不支持 ASLR (rust-lang/rust#16514)，但是 DLL 仍可以在地址空间中重新定位。",
        "translate": ""
    },
    {
        "source": "It appears that addresses in debug info are all as-if this library was loaded at its \"image base\", which is a field in its COFF file headers.",
        "suggest": "如果该库是在其 \"image base\" 处加载的，则调试信息中的地址似乎全部都作为该库的 COFF 文件头中的一个字段。",
        "translate": ""
    },
    {
        "source": "Since this is what debuginfo seems to list we parse the symbol table and store addresses as if the library was loaded at \"image base\" as well.",
        "suggest": "由于这是 debuginfo 似乎列出的内容，因此我们解析符号表并存储地址，就像该库也已在 \"image base\" 上加载一样。",
        "translate": ""
    },
    {
        "source": "The library may not be loaded at \"image base\", however.",
        "suggest": "但是，该库可能未在 \"image base\" 上加载。",
        "translate": ""
    },
    {
        "source": "(presumably something else may be loaded there?) This is where the `bias` field comes into play, and we need to figure out the value of `bias` here.",
        "suggest": "(大概在那里可能还有其他内容吗? ) 这是 `bias` 字段起作用的地方，我们需要在这里计算 `bias` 的值。",
        "translate": ""
    },
    {
        "source": "Unfortunately though it's not clear how to acquire this from a loaded module.",
        "suggest": "不幸的是，尽管目前尚不清楚如何从已加载的模块中获取此信息。",
        "translate": ""
    },
    {
        "source": "What we do have, however, is the actual load address (`modBaseAddr`).",
        "suggest": "但是，我们要做的是实际的加载地址 (`modBaseAddr`)。",
        "translate": ""
    },
    {
        "source": "As a bit of a cop-out for now we mmap the file, read the file header information, then drop the mmap.",
        "suggest": "现在，作为一点补偿，我们对文件进行 mmap，读取文件头信息，然后丢弃 mmap。",
        "translate": ""
    },
    {
        "source": "This is wasteful because we'll probably reopen the mmap later, but this should work well enough for now.",
        "suggest": "这很浪费，因为我们稍后可能会重新打开 mmap，但这现在应该可以正常工作了。",
        "translate": ""
    },
    {
        "source": "Once we have the `image_base` (desired load location) and the `base_addr` (actual load location) we can fill in the `bias` (difference between the actual and desired) and then the stated address of each segment is the `image_base` since that's what the file says.",
        "suggest": "一旦有了 `image_base` (所需的加载位置) 和 `base_addr` (实际的加载位置)，我们就可以填写 `bias` (实际值与期望值之差)，然后每个段的指定地址就是 `image_base`，因为这就是文件所说的。",
        "translate": ""
    },
    {
        "source": "For now it appears that unlike ELF/MachO we can make do with one segment per library, using `modBaseSize` as the whole size.",
        "suggest": "现在看来，与 ELF/MachO 不同，我们可以使用 `modBaseSize` 作为整个大小来处理每个库一个段。",
        "translate": ""
    },
    {
        "source": "uses the Mach-O file format and uses DYLD-specific APIs to load a list of native libraries that are part of the application.",
        "suggest": "使用 Mach-O 文件格式，并使用 DYLD 特定的 API 加载作为应用程序一部分的原生库的列表。",
        "translate": ""
    },
    {
        "source": "Fetch the name of this library which corresponds to the path of where to load it as well.",
        "suggest": "获取该库的名称，该名称也与加载该库的路径相对应。",
        "translate": ""
    },
    {
        "source": "Load the image header of this library and delegate to `object` to parse all the load commands so we can figure out all the segments involved here.",
        "suggest": "加载该库的图像头并将其委托给 `object` 来解析所有加载命令，因此我们可以找出此处涉及的所有段。",
        "translate": ""
    },
    {
        "source": "Iterate over the segments and register known regions for segments that we find.",
        "suggest": "遍历这些段，并为找到的段注册已知区域。",
        "translate": ""
    },
    {
        "source": "Additionally record information bout text segments for processing later, see comments below.",
        "suggest": "另外，记录有关文本段的信息以供以后处理，请参见下面的注释。",
        "translate": ""
    },
    {
        "source": "Determine the \"slide\" for this library which ends up being the bias we use to figure out where in memory objects are loaded.",
        "suggest": "确定该库的 \"slide\"，这最终是我们用来确定内存对象加载位置的偏差。",
        "translate": ""
    },
    {
        "source": "This is a bit of a weird computation though and is the result of trying a few things in the wild and seeing what sticks.",
        "suggest": "但是，不过，这是一个有点奇怪的计算，并且是在野外尝试一些东西并看到什么是坚持的结果。",
        "translate": ""
    },
    {
        "source": "The general idea is that the `bias` plus a segment's `stated_virtual_memory_address` is going to be where in the actual address space the segment resides.",
        "suggest": "通常的想法是，`bias` 加上段的 `stated_virtual_memory_address` 将成为该段在实际地址空间中的位置。",
        "translate": ""
    },
    {
        "source": "The other thing we rely on though is that a real address minus the `bias` is the index to look up in the symbol table and debuginfo.",
        "suggest": "但是，我们所依赖的另一件事是，实际地址减去 `bias` 是要在符号表和 debuginfo 中查找的索引。",
        "translate": ""
    },
    {
        "source": "It turns out, though, that for system loaded libraries these calculations are incorrect.",
        "suggest": "但是事实证明，对于系统加载的库，这些计算是不正确的。",
        "translate": ""
    },
    {
        "source": "For native executables, however, it appears correct.",
        "suggest": "但是，对于原生可执行文件，它似乎是正确的。",
        "translate": ""
    },
    {
        "source": "Lifting some logic from LLDB's source it has some special-casing for the first `__TEXT` section loaded from file offset 0 with a nonzero size.",
        "suggest": "从 LLDB 的源代码中提取了一些逻辑，它对从文件偏移量 0 (非零大小) 加载的第一个 `__TEXT` 节有一些特殊的框。",
        "translate": ""
    },
    {
        "source": "For whatever reason when this is present it appears to mean that the symbol table is relative to just the vmaddr slide for the library.",
        "suggest": "无论出于何种原因，出现这种情况似乎都意味着符号表仅相对于库的 vmaddr 幻灯片。",
        "translate": ""
    },
    {
        "source": "If it's *not* present then the symbol table is relative to the the vmaddr slide plus the segment's stated address.",
        "suggest": "如果 *不存在*，则符号表是相对于 vmaddr 幻灯片加上段的声明地址的。",
        "translate": ""
    },
    {
        "source": "To handle this situation if we *don't* find a text section at file offset zero then we increase the bias by the first text sections's stated address and decrease all stated addresses by that amount as well.",
        "suggest": "为了处理这种情况，如果我们 *找不到* 文件偏移量为零的文本部分，那么我们将增加第一个文本部分的声明地址的偏见，并将所有声明地址也减少该数量。",
        "translate": ""
    },
    {
        "source": "That way the symbol table is always appears relative to the library's bias amount.",
        "suggest": "这样，符号表总是相对于库的偏差量出现。",
        "translate": ""
    },
    {
        "source": "This appears to have the right results for symbolizing via the symbol table.",
        "suggest": "这似乎对于通过符号表进行符号化具有正确的结果。",
        "translate": ""
    },
    {
        "source": "Honestly I'm not entirely sure whether this is right or if there's something else that should indicate how to do this.",
        "suggest": "老实说，我不确定这是正确的还是还有其他方法可以指示如何做到这一点。",
        "translate": ""
    },
    {
        "source": "For now though this seems to work well enough (?) and we should always be able to tweak this over time if necessary.",
        "suggest": "目前，尽管 (?) 看起来已经足够好了，但如果有必要，我们应该可以随时对其进行调整。",
        "translate": ""
    },
    {
        "source": "For some more information see #318",
        "suggest": "有关更多信息，请参见 #318。",
        "translate": ""
    },
    {
        "source": "Other Unix (e.g.",
        "suggest": "其他 Unix (例如",
        "translate": ""
    },
    {
        "source": "Linux) platforms use ELF as an object file format and typically implement an API called `dl_iterate_phdr` to load native libraries.",
        "suggest": "Linux) 平台使用 ELF 作为 object 文件格式，并且通常实现称为 `dl_iterate_phdr` 的 API 来加载原生库。",
        "translate": ""
    },
    {
        "source": "should be a valid pointers.",
        "suggest": "应该是一个有效的指针。",
        "translate": ""
    },
    {
        "source": "should be a valid pointer to a `std::Vec`.",
        "suggest": "应该是指向 `std::Vec` 的有效指针。",
        "translate": ""
    },
    {
        "source": "doesn't natively support debug info, but the build system will place debug info at the path `romfs:/debug_info.elf`.",
        "suggest": "本身不支持调试信息，但是构建系统会将调试信息放置在路径 `romfs:/debug_info.elf` 处。",
        "translate": ""
    },
    {
        "source": "Everything else should use ELF, but doesn't know how to load native libraries.",
        "suggest": "其他所有内容都应使用 ELF，但不知道如何加载原生库。",
        "translate": ""
    },
    {
        "source": "All known shared libraries that have been loaded.",
        "suggest": "已加载的所有已知共享库。",
        "translate": ""
    },
    {
        "source": "Mappings cache where we retain parsed dwarf information.",
        "suggest": "映射缓存，其中保留了解析的矮人信息。",
        "translate": ""
    },
    {
        "source": "This list has a fixed capacity for its entire liftime which never increases.",
        "suggest": "此列表在整个提升期间具有固定的容量，永远不会增加。",
        "translate": ""
    },
    {
        "source": "The `usize` element of each pair is an index into `libraries` above where `usize::max_value()` represents the current executable.",
        "suggest": "每对中的 `usize` 元素是 `libraries` 的索引，以上 `usize::max_value()` 表示当前可执行文件。",
        "translate": ""
    },
    {
        "source": "The `Mapping` is corresponding parsed dwarf information.",
        "suggest": "`Mapping` 是相应的解析后的矮人信息。",
        "translate": ""
    },
    {
        "source": "Note that this is basically an LRU cache and we'll be shifting things around in here as we symbolize addresses.",
        "suggest": "请注意，这基本上是一个 LRU 缓存，我们将在这里对地址进行符号化，以表示地址。",
        "translate": ""
    },
    {
        "source": "Segments of this library loaded into memory, and where they're loaded.",
        "suggest": "该库的各段已加载到内存中以及它们的加载位置。",
        "translate": ""
    },
    {
        "source": "The \"bias\" of this library, typically where it's loaded into memory.",
        "suggest": "该库的 \"bias\"，通常是它被加载到内存中的位置。",
        "translate": ""
    },
    {
        "source": "This value is added to each segment's stated address to get the actual virtual memory address that the segment is loaded into.",
        "suggest": "将此值添加到每个段的声明地址中，以获取该段加载到的实际虚拟内存地址。",
        "translate": ""
    },
    {
        "source": "Additionally this bias is subtracted from real virtual memory addresses to index into debuginfo and the symbol table.",
        "suggest": "另外，从实际虚拟内存地址中减去此偏差以将其索引到 debuginfo 和符号表中。",
        "translate": ""
    },
    {
        "source": "The stated address of this segment in the object file.",
        "suggest": "object 文件中此段的指定地址。",
        "translate": ""
    },
    {
        "source": "This is not actually where the segment is loaded, but rather this address plus the containing library's `bias` is where to find it.",
        "suggest": "实际上，这不是加载该段的位置，而是在该地址加上包含库的 `bias` 所在的位置。",
        "translate": ""
    },
    {
        "source": "The size of ths segment in memory.",
        "suggest": "内存中 ths 段的大小。",
        "translate": ""
    },
    {
        "source": "unsafe because this is required to be externally synchronized",
        "suggest": "不安全，因为需要从外部进行同步",
        "translate": ""
    },
    {
        "source": "A very small, very simple LRU cache for debug info mappings.",
        "suggest": "一个非常小，非常简单的 LRU 缓存，用于调试信息映射。",
        "translate": ""
    },
    {
        "source": "The hit rate should be very high, since the typical stack doesn't cross between many shared libraries.",
        "suggest": "命中率应该很高，因为典型的栈不会在许多共享库之间交叉。",
        "translate": ""
    },
    {
        "source": "The `addr2line::Context` structures are pretty expensive to create.",
        "suggest": "`addr2line::Context` 结构的创建成本非常高。",
        "translate": ""
    },
    {
        "source": "Its cost is expected to be amortized by subsequent `locate` queries, which leverage the structures built when constructing `addr2line::Context`s to get nice speedups.",
        "suggest": "预期其成本将由后续的 `locate` 查询摊销，这些查询将利用在构建 `addr2line::Context`s 时构建的结构来获得良好的加速效果。",
        "translate": ""
    },
    {
        "source": "If we didn't have this cache, that amortization would never happen, and symbolicating backtraces would be ssssllllooooowwww.",
        "suggest": "如果我们没有此缓存，则摊销将永远不会发生，而象征性回溯将是 ssssllllooooowwww。",
        "translate": ""
    },
    {
        "source": "First up, test if this `lib` has any segment containing the `addr` (handling relocation).",
        "suggest": "首先，测试此 `lib` 是否具有包含 `addr` 的任何段 (处理重定位)。",
        "translate": ""
    },
    {
        "source": "If this check passes then we can continue below and actually translate the address.",
        "suggest": "如果此检查通过，那么我们可以继续下面的内容并实际翻译地址。",
        "translate": ""
    },
    {
        "source": "Note that we're using `wrapping_add` here to avoid overflow checks.",
        "suggest": "请注意，我们在这里使用 `wrapping_add` 以避免溢出检查。",
        "translate": ""
    },
    {
        "source": "It's been seen in the wild that the SVMA + bias computation overflows.",
        "suggest": "疯狂地看到 SVMA + 偏差计算会溢出。",
        "translate": ""
    },
    {
        "source": "It seems a bit odd that would happen but there's not a huge amount we can do about it other than probably just ignore those segments since they're likely pointing off into space.",
        "suggest": "这似乎有点奇怪，但除了可能忽略这些片段，因为它们可能指向太空之外，我们对此无能为力。",
        "translate": ""
    },
    {
        "source": "This originally came up in rust-lang/backtrace-rs#329.",
        "suggest": "这最初是在 rust-lang/backtrace-rs#329 中出现的。",
        "translate": ""
    },
    {
        "source": "Now that we know `lib` contains `addr`, we can offset with the bias to find the stated virutal memory address.",
        "suggest": "既然我们知道 `lib` 包含 `addr`，我们就可以通过偏置进行偏移以找到规定的虚拟内存地址。",
        "translate": ""
    },
    {
        "source": "Invariant: after this conditional completes without early returning from an error, the cache entry for this path is at index 0.",
        "suggest": "不变式: 此条件完成后又没有从错误中尽早返回，此路径的缓存条目位于索引 0。",
        "translate": ""
    },
    {
        "source": "When the mapping is already in the cache, move it to the front.",
        "suggest": "当映射已经在缓存中时，将其移到最前面。",
        "translate": ""
    },
    {
        "source": "When the mapping is not in the cache, create a new mapping, insert it into the front of the cache, and evict the oldest cache entry if necessary.",
        "suggest": "当映射不在高速缓存中时，请创建一个新的映射，将其插入高速缓存的前面，并在必要时逐出最旧的高速缓存条目。",
        "translate": ""
    },
    {
        "source": "don't leak the `'static` lifetime, make sure it's scoped to just ourselves",
        "suggest": "不要泄漏 `'static` 的生命周期，请确保它仅限于我们自己",
        "translate": ""
    },
    {
        "source": "Extend the lifetime of `sym` to `'static` since we are unfortunately required to here, but it's ony ever going out as a reference so no reference to it should be persisted beyond this frame anyway.",
        "suggest": "将 `sym` 的生命周期扩展到 `'static`，这是很不幸的，因为我们必须这样做，但是它永远只是引用而已，因此无论如何都不应将引用保留在此框架之外。",
        "translate": ""
    },
    {
        "source": "Finally, get a cached mapping or create a new mapping for this file, and evaluate the DWARF info to find the file/line/name for this address.",
        "suggest": "最后，获取缓存的映射或为此文件创建新的映射，并评估 DWARF 信息以查找该地址的 file/line/name。",
        "translate": ""
    },
    {
        "source": "We were able to locate frame information for this symbol, and `addr2line`'s frame internally has all the nitty gritty details.",
        "suggest": "我们能够找到该符号的框架信息，并且 `addr2line` 的框架内部具有所有细腻的细节。",
        "translate": ""
    },
    {
        "source": "Couldn't find debug information, but we found it in the symbol table of the elf executable.",
        "suggest": "找不到调试信息，但是我们在 elf 可执行文件的符号表中找到了它。",
        "translate": ""
    },
    {
        "source": "Symbolication strategy using the DWARF-parsing code in libbacktrace.",
        "suggest": "在 libbacktrace 中使用 DWARF 解析代码的符号化策略。",
        "translate": ""
    },
    {
        "source": "The libbacktrace C library, typically distributed with gcc, supports not only generating a backtrace (which we don't actually use) but also symbolicating the backtrace and handling dwarf debug information about things like inlined frames and whatnot.",
        "suggest": "通常与 gcc 一起分发的 libbacktrace C 库不仅支持生成回溯 (我们实际上没有使用过)，而且还支持回溯的符号化和处理有关内联帧之类的东西的矮小的调试信息。",
        "translate": ""
    },
    {
        "source": "This is relatively complicated due to lots of various concerns here, but the basic idea is:",
        "suggest": "由于这里存在许多各种各样的问题，所以这相对复杂，但是基本思想是:",
        "translate": ""
    },
    {
        "source": "First we call `backtrace_syminfo`.",
        "suggest": "首先我们调用 `backtrace_syminfo`。",
        "translate": ""
    },
    {
        "source": "This gets symbol information from the dynamic symbol table if we can.",
        "suggest": "如果可以的话，这将从动态符号表中获取符号信息。",
        "translate": ""
    },
    {
        "source": "Next we call `backtrace_pcinfo`.",
        "suggest": "接下来，我们调用 `backtrace_pcinfo`。",
        "translate": ""
    },
    {
        "source": "This will parse debuginfo tables if they're available and allow us to recover information about inline frames, filenames, line numbers, etc.",
        "suggest": "这将解析 debuginfo 表 (如果有)，并允许我们恢复有关内联框架，文件名，行号等的信息。",
        "translate": ""
    },
    {
        "source": "There's lots of trickery about getting the dwarf tables into libbacktrace, but hopefully it's not the end of the world and is clear enough when reading below.",
        "suggest": "将侏儒表放入 libbacktrace 有很多技巧，但是希望它不是世界末日，并且在阅读下面的内容时已经足够清楚了。",
        "translate": ""
    },
    {
        "source": "This is the default symbolication strategy for non-MSVC and non-OSX platforms.",
        "suggest": "这是非 MSVC 和非 OSX 平台的默认符号策略。",
        "translate": ""
    },
    {
        "source": "In libstd though this is the default strategy for OSX.",
        "suggest": "尽管在 libstd 中，这是 OSX 的默认策略。",
        "translate": ""
    },
    {
        "source": "If possible prefer the `function` name which comes from debuginfo and can typically be more accurate for inline frames for example.",
        "suggest": "如果可能的话，最好使用来自 debuginfo 的 `function` 名称，例如，对于内联框架，它通常更准确。",
        "translate": ""
    },
    {
        "source": "If that's not present though fall back to the symbol table name specified in `symname`.",
        "suggest": "如果不存在，则回退到 `symname` 中指定的符号表名称。",
        "translate": ""
    },
    {
        "source": "Note that sometimes `function` can feel somewhat less accurate, for example being listed as `try<i32,closure>` isntead of `std::panicking::try::do_call`.",
        "suggest": "请注意，有时 `function` 的准确性可能会有所降低，例如，被列为 `std::panicking::try::do_call` 的 `try<i32,closure>` 代表。",
        "translate": ""
    },
    {
        "source": "It's not really clear why, but overall the `function` name seems more accurate.",
        "suggest": "尚不清楚原因，但总体而言 `function` 名称似乎更准确。",
        "translate": ""
    },
    {
        "source": "do nothing for now",
        "suggest": "现在什么也不做",
        "translate": ""
    },
    {
        "source": "Type of the `data` pointer passed into `syminfo_cb`",
        "suggest": "传递给 `syminfo_cb` 的 `data` 指针的类型",
        "translate": ""
    },
    {
        "source": "Once this callback is invoked from `backtrace_syminfo` when we start resolving we go further to call `backtrace_pcinfo`.",
        "suggest": "当我们开始解析时，一旦从 `backtrace_syminfo` 调用了此回调，我们将进一步调用 `backtrace_pcinfo`。",
        "translate": ""
    },
    {
        "source": "The `backtrace_pcinfo` function will consult debug information and attemp tto do things like recover file/line information as well as inlined frames.",
        "suggest": "`backtrace_pcinfo` 函数将查询调试信息，并尝试执行诸如恢复 file/line 信息以及内联框架之类的操作。",
        "translate": ""
    },
    {
        "source": "Note though that `backtrace_pcinfo` can fail or not do much if there's not debug info, so if that happens we're sure to call the callback with at least one symbol from the `syminfo_cb`.",
        "suggest": "请注意，尽管没有调试信息，但 `backtrace_pcinfo` 可能失败或失败很多，因此，如果发生这种情况，我们一定要使用 `syminfo_cb` 中的至少一个符号来调用回调。",
        "translate": ""
    },
    {
        "source": "Type of the `data` pointer passed into `pcinfo_cb`",
        "suggest": "传递给 `pcinfo_cb` 的 `data` 指针的类型",
        "translate": ""
    },
    {
        "source": "The libbacktrace API supports creating a state, but it does not support destroying a state.",
        "suggest": "libbacktrace API 支持创建状态，但不支持销毁状态。",
        "translate": ""
    },
    {
        "source": "I personally take this to mean that a state is meant to be created and then live forever.",
        "suggest": "我个人认为这意味着一个国家将被创造，然后永远存在。",
        "translate": ""
    },
    {
        "source": "I would love to register an at_exit() handler which cleans up this state, but libbacktrace provides no way to do so.",
        "suggest": "我很想注册一个 at_exit() 处理程序来清理此状态，但是 libbacktrace 没有提供这样做的方法。",
        "translate": ""
    },
    {
        "source": "With these constraints, this function has a statically cached state that is calculated the first time this is requested.",
        "suggest": "由于这些限制，此函数具有静态缓存的状态，该状态是在首次请求此状态时计算的。",
        "translate": ""
    },
    {
        "source": "Remember that backtracing all happens serially (one global lock).",
        "suggest": "请记住，所有回溯都是按顺序进行的 (一个锁)。",
        "translate": ""
    },
    {
        "source": "Note the lack of synchronization here is due to the requirement that `resolve` is externally synchronized.",
        "suggest": "请注意，此处缺少同步是由于需要对 `resolve` 进行外部同步。",
        "translate": ""
    },
    {
        "source": "Don't exercise threadsafe capabilities of libbacktrace since we're always calling it in a synchronized fashion.",
        "suggest": "不要使用 libbacktrace 的线程安全功能，因为我们总是以同步方式调用它。",
        "translate": ""
    },
    {
        "source": "no extra data",
        "suggest": "没有多余的数据",
        "translate": ""
    },
    {
        "source": "Note that for libbacktrace to operate at all it needs to find the DWARF debug info for the current executable.",
        "suggest": "请注意，要使 libbacktrace 完全起作用，它需要找到当前可执行文件的 DWARF 调试信息。",
        "translate": ""
    },
    {
        "source": "It typically does that via a number of mechanisms including, but not limited to:",
        "suggest": "它通常通过多种机制来做到这一点，包括但不限于:",
        "translate": ""
    },
    {
        "source": "on supported platforms",
        "suggest": "在支持的平台上",
        "translate": ""
    },
    {
        "source": "The filename passed in explicitly when creating state",
        "suggest": "创建状态时显式传递的文件名",
        "translate": ""
    },
    {
        "source": "The libbacktrace library is a big wad of C code.",
        "suggest": "libbacktrace 库是一大堆 C 代码。",
        "translate": ""
    },
    {
        "source": "This naturally means it's got memory safety vulnerabilities, especially when handling malformed debuginfo.",
        "suggest": "这自然意味着它具有内存安全漏洞，尤其是在处理格式错误的 debuginfo 时。",
        "translate": ""
    },
    {
        "source": "Libstd has run into plenty of these historically.",
        "suggest": "从历史上看，Libstd 已经遇到了很多此类情况。",
        "translate": ""
    },
    {
        "source": "If /proc/self/exe is used then we can typically ignore these as we assume that libbacktrace is \"mostly correct\" and otherwise doesn't do weird things with \"attempted to be correct\" dwarf debug info.",
        "suggest": "如果使用 /proc/self/exe，则通常可以忽略这些，因为我们假设 libbacktrace 是 \"mostly correct\"，否则对于 \"attempted to be correct\" 矮调试信息不会做奇怪的事情。",
        "translate": ""
    },
    {
        "source": "If we pass in a filename, however, then it's possible on some platforms (like BSDs) where a malicious actor can cause an arbitrary file to be placed at that location.",
        "suggest": "但是，如果我们传递文件名，则在某些平台 (例如 BSD) 上，恶意行为者可能会导致将任意文件放置在该位置，这是可能的。",
        "translate": ""
    },
    {
        "source": "This means that if we tell libbacktrace about a filename it may be using an arbitrary file, possibly causing segfaults.",
        "suggest": "这意味着，如果我们告诉 libbacktrace 有关文件名的信息，那么它可能正在使用任意文件，可能会导致段错误。",
        "translate": ""
    },
    {
        "source": "If we don't tell libbacktrace anything though then it won't do anything on platforms that don't support paths like /proc/self/exe!",
        "suggest": "如果我们不告诉 libbacktrace 任何东西，那么它将在不支持 /proc/self/exe 之类的平台上不做任何事情!",
        "translate": ""
    },
    {
        "source": "Given all that we try as hard as possible to *not* pass in a filename, but we must on platforms that don't support /proc/self/exe at all.",
        "suggest": "考虑到所有这些，我们尽可能不传递文件名，但是我们必须在完全不支持 /proc/self/exe 的平台上运行。",
        "translate": ""
    },
    {
        "source": "Note that ideally we'd use `std::env::current_exe`, but we can't require `std` here.",
        "suggest": "请注意，理想情况下，我们将使用 `std::env::current_exe`，但此处我们不需要 `std`。",
        "translate": ""
    },
    {
        "source": "Use `_NSGetExecutablePath` to load the current executable path into a static area (which if it's too small just give up).",
        "suggest": "使用 `_NSGetExecutablePath` 将当前的可执行路径加载到静态区域 (如果它太小，则放弃)。",
        "translate": ""
    },
    {
        "source": "Note that we're seriously trusting libbacktrace here to not die on corrupt executables, but it surely does...",
        "suggest": "请注意，我们非常信任这里的 libbacktrace 不会死于损坏的可执行文件，但是它确实可以...",
        "translate": ""
    },
    {
        "source": "has a mode of opening files where after it's opened it can't be deleted.",
        "suggest": "具有打开文件的模式，该文件在打开后无法删除。",
        "translate": ""
    },
    {
        "source": "That's in general what we want here because we want to ensure that our executable isn't changing out from under us after we hand it off to libbacktrace, hopefully mitigating the ability to pass in arbitrary data into libbacktrace (which may be mishandled).",
        "suggest": "总的来说，这就是我们想要的，因为我们希望确保在将可执行文件移交给 libbacktrace 之后，可执行文件不会从我们下面改变出来，希望减轻将任意数据传递到 libbacktrace 中的能力 (这可能会被错误处理)。",
        "translate": ""
    },
    {
        "source": "Given that we do a bit of a dance here to attempt to get a sort of lock on our own image:",
        "suggest": "鉴于我们在这里进行了一些跳舞，试图对自己的形象有所了解:",
        "translate": ""
    },
    {
        "source": "Get a handle to the current process, load its filename.",
        "suggest": "获取当前进程的句柄，加载其文件名。",
        "translate": ""
    },
    {
        "source": "Open a file to that filename with the right flags.",
        "suggest": "使用正确的标志打开一个具有该文件名的文件。",
        "translate": ""
    },
    {
        "source": "Reload the current process's filename, making sure it's the same",
        "suggest": "重新加载当前进程的文件名，确保它是相同的",
        "translate": ""
    },
    {
        "source": "If that all passes we in theory have indeed opened our process's file and we're guaranteed it won't change.",
        "suggest": "如果所有这些通过了，那么我们理论上确实已经打开了进程的文件，并且可以保证它不会改变。",
        "translate": ""
    },
    {
        "source": "FWIW a bunch of this is copied from libstd historically, so this is my best interpretation of what was happening.",
        "suggest": "FWIW 从历史上从 libstd 复制了一堆，所以这是我对正在发生的事情的最好解释。",
        "translate": ""
    },
    {
        "source": "This lives in static memory so we can return it..",
        "suggest": "这驻留在静态内存中，因此我们可以将其返回。",
        "translate": ""
    },
    {
        "source": "and this lives on the stack since it's temporary",
        "suggest": "由于它是临时的，因此存在于栈中",
        "translate": ""
    },
    {
        "source": "intentionally leak `handle` here because having that open should preserve our lock on this file name.",
        "suggest": "故意在这里泄漏 `handle`，因为打开该文件会保留我们对该文件名的锁定。",
        "translate": ""
    },
    {
        "source": "We want to return a slice that is nul-terminated, so if everything was filled in and it equals the total length then equate that to failure.",
        "suggest": "我们想返回一个 nul 终止的切片，因此，如果所有内容都已填写且等于总长度，则将其等同于失败。",
        "translate": ""
    },
    {
        "source": "Otherwise when returning success make sure the nul byte is included in the slice.",
        "suggest": "否则，返回成功时，请确保在切片中包含 nul 字节。",
        "translate": ""
    },
    {
        "source": "backtrace errors are currently swept under the rug",
        "suggest": "当前回溯错误已被清除",
        "translate": ""
    },
    {
        "source": "Call the `backtrace_syminfo` API which (from reading the code) should call `syminfo_cb` exactly once (or fail with an error presumably).",
        "suggest": "调用 `backtrace_syminfo` API，该 API (通过读取代码) 应该恰好调用一次 `syminfo_cb` (或者可能会因错误而失败)。",
        "translate": ""
    },
    {
        "source": "We then handle more within the `syminfo_cb`.",
        "suggest": "然后，我们在 `syminfo_cb` 中处理更多内容。",
        "translate": ""
    },
    {
        "source": "Note that we do this since `syminfo` will consult the symbol table, finding symbol names even if there's no debug information in the binary.",
        "suggest": "请注意，我们这样做是因为 `syminfo` 将查询符号表，即使二进制文件中没有调试信息，也会查找符号名称。",
        "translate": ""
    },
    {
        "source": "only look at the top frame",
        "suggest": "只看顶部框架",
        "translate": ""
    },
    {
        "source": "Resolve an address to a symbol, passing the symbol to the specified closure.",
        "suggest": "解析符号的地址，然后将符号传递给指定的闭包。",
        "translate": ""
    },
    {
        "source": "This function will look up the given address in areas such as the local symbol table, dynamic symbol table, or DWARF debug info (depending on the activated implementation) to find symbols to yield.",
        "suggest": "该函数将在局部符号表，动态符号表或 DWARF 调试信息 (取决于激活的实现) 等区域中查找给定地址，以查找要产生的符号。",
        "translate": ""
    },
    {
        "source": "The closure may not be called if resolution could not be performed, and it also may be called more than once in the case of inlined functions.",
        "suggest": "如果无法执行解析，则可能不会调用闭包，对于内联函数，也可能会多次调用。",
        "translate": ""
    },
    {
        "source": "Symbols yielded represent the execution at the specified `addr`, returning file/line pairs for that address (if available).",
        "suggest": "产生的符号表示在指定的 `addr` 处的执行，并返回该地址的 file/line 对 (如果有)。",
        "translate": ""
    },
    {
        "source": "Note that if you have a `Frame` then it's recommended to use the `resolve_frame` function instead of this one.",
        "suggest": "请注意，如果您有 `Frame`，则建议使用 `resolve_frame` 函数而不是 `Frame` 函数。",
        "translate": ""
    },
    {
        "source": "Resolve a previously capture frame to a symbol, passing the symbol to the specified closure.",
        "suggest": "将先前捕获的帧解析为符号，然后将符号传递给指定的闭包。",
        "translate": ""
    },
    {
        "source": "This functin performs the same function as `resolve` except that it takes a `Frame` as an argument instead of an address.",
        "suggest": "该函数的功能与 `resolve` 相同，不同之处在于它使用 `Frame` 作为参数而不是地址。",
        "translate": ""
    },
    {
        "source": "This can allow some platform implementations of backtracing to provide more accurate symbol information or information about inline frames for example.",
        "suggest": "例如，这可以允许回溯的某些平台实现提供更准确的符号信息或有关内联帧的信息。",
        "translate": ""
    },
    {
        "source": "It's recommended to use this if you can.",
        "suggest": "如果可以的话，建议使用此功能。",
        "translate": ""
    },
    {
        "source": "IP values from stack frames are typically (always?) the instruction *after* the call that's the actual stack trace.",
        "suggest": "来自栈帧的 IP 值通常是 (always?) 实际栈跟踪调用之后的指令。",
        "translate": ""
    },
    {
        "source": "Symbolizing this on causes the filename/line number to be one ahead and perhaps into the void if it's near the end of the function.",
        "suggest": "对此进行符号化表示，导致 filename/line 数字在该函数的结尾附近，如果它在函数的末尾提前一个，并且可能成为空白。",
        "translate": ""
    },
    {
        "source": "This appears to basically always be the case on all platforms, so we always subtract one from a resolved ip to resolve it to the previous call instruction instead of the instruction being returned to.",
        "suggest": "在所有平台上，似乎基本上都是这种情况，因此我们总是从已解析的 ip 中减去一个，以将其解析为上一个调用指令，而不是返回到该指令。",
        "translate": ""
    },
    {
        "source": "Ideally we would not do this.",
        "suggest": "理想情况下，我们不会这样做。",
        "translate": ""
    },
    {
        "source": "Ideally we would require callers of the `resolve` APIs here to manually do the -1 and account that they want location information for the *previous* instruction, not the current.",
        "suggest": "理想情况下，我们将要求 `resolve` API 的调用者在此处手动执行 -1，并说明他们需要 *previous* 指令 (而不是当前指令) 的位置信息。",
        "translate": ""
    },
    {
        "source": "Ideally we'd also expose on `Frame` if we are indeed the address of the next instruction or the current.",
        "suggest": "理想情况下，如果我们确实是下一条指令或当前指令的地址，则也应在 `Frame` 上公开。",
        "translate": ""
    },
    {
        "source": "For now though this is a pretty niche concern so we just internally always subtract one.",
        "suggest": "就目前而言，尽管这是一个非常特殊的问题，所以我们在内部始终总是减去一个。",
        "translate": ""
    },
    {
        "source": "Consumers should keep working and getting pretty good results, so we should be good enough.",
        "suggest": "消费者应该继续努力并取得不错的成绩，所以我们应该足够好。",
        "translate": ""
    },
    {
        "source": "Same as `resolve`, only unsafe as it's unsynchronized.",
        "suggest": "与 `resolve` 相同，只是不安全，因为它未同步。",
        "translate": ""
    },
    {
        "source": "See the `resolve` function for more documentation and examples.",
        "suggest": "有关更多文档和示例，请参见 `resolve` 函数。",
        "translate": ""
    },
    {
        "source": "See information on `resolve` for caveats on `cb` panicking.",
        "suggest": "有关 `cb` 恐慌的注意事项，请参见 `resolve` 上的信息。",
        "translate": ""
    },
    {
        "source": "Same as `resolve_frame`, only unsafe as it's unsynchronized.",
        "suggest": "与 `resolve_frame` 相同，只是不安全，因为它未同步。",
        "translate": ""
    },
    {
        "source": "See the `resolve_frame` function for more documentation and examples.",
        "suggest": "有关更多文档和示例，请参见 `resolve_frame` 函数。",
        "translate": ""
    },
    {
        "source": "See information on `resolve_frame` for caveats on `cb` panicking.",
        "suggest": "有关 `cb` 恐慌的注意事项，请参见 `resolve_frame` 上的信息。",
        "translate": ""
    },
    {
        "source": "A trait representing the resolution of a symbol in a file.",
        "suggest": "trait 表示文件中符号的分辨率。",
        "translate": ""
    },
    {
        "source": "This trait is yielded as a trait object to the closure given to the `backtrace::resolve` function, and it is virtually dispatched as it's unknown which implementation is behind it.",
        "suggest": "trait 作为给 `backtrace::resolve` 函数的闭包的 trait object 产生，并且实际上是分派的，因为未知其背后是哪种实现。",
        "translate": ""
    },
    {
        "source": "A symbol can give contextual information about a function, for example the name, filename, line number, precise address, etc.",
        "suggest": "符号可以提供有关函数的上下文信息，例如名称，文件名，行号，精确地址等。",
        "translate": ""
    },
    {
        "source": "Not all information is always available in a symbol, however, so all methods return an `Option`.",
        "suggest": "并非所有信息都始终在符号中可用，因此，所有方法都返回 `Option`。",
        "translate": ""
    },
    {
        "source": "this lifetime bound needs to be persisted eventually to `Symbol`, but that's currently a breaking change.",
        "suggest": "这个生命周期的界限最终需要坚持到 `Symbol`，但这是一个重大突破。",
        "translate": ""
    },
    {
        "source": "For now this is safe since `Symbol` is only ever handed out by reference and can't be cloned.",
        "suggest": "现在，这是安全的，因为 `Symbol` 仅由引用分发，并且不能被克隆。",
        "translate": ""
    },
    {
        "source": "Returns the name of this function.",
        "suggest": "返回此函数的名称。",
        "translate": ""
    },
    {
        "source": "The returned structure can be used to query various properties about the symbol name:",
        "suggest": "返回的结构体可用于查询有关符号名称的各种属性:",
        "translate": ""
    },
    {
        "source": "The `Display` implementation will print out the demangled symbol.",
        "suggest": "`Display` 的实现将打印出 demangled 符号。",
        "translate": ""
    },
    {
        "source": "The raw `str` value of the symbol can be accessed (if it's valid utf-8).",
        "suggest": "可以访问符号的原始 `str` 值 (如果它是有效的 utf-8)。",
        "translate": ""
    },
    {
        "source": "The raw bytes for the symbol name can be accessed.",
        "suggest": "可以访问符号名称的原始字节。",
        "translate": ""
    },
    {
        "source": "Returns the starting address of this function.",
        "suggest": "返回此函数的起始地址。",
        "translate": ""
    },
    {
        "source": "Returns the raw filename as a slice.",
        "suggest": "返回原始文件名作为切片。",
        "translate": ""
    },
    {
        "source": "This is mainly useful for `no_std` environments.",
        "suggest": "这主要对 `no_std` 环境有用。",
        "translate": ""
    },
    {
        "source": "Returns the column number for where this symbol is currently executing.",
        "suggest": "返回此符号当前正在执行的位置的列号。",
        "translate": ""
    },
    {
        "source": "Only gimli currently provides a value here and even then only if `filename` returns `Some`, and so it is then consequently subject to similar caveats.",
        "suggest": "当前只有 gimli 在此处提供一个值，即使 `filename` 返回 `Some` 也是如此，因此也要受到类似的警告。",
        "translate": ""
    },
    {
        "source": "Returns the line number for where this symbol is currently executing.",
        "suggest": "返回此符号当前正在执行的行号。",
        "translate": ""
    },
    {
        "source": "This return value is typically `Some` if `filename` returns `Some`, and is consequently subject to similar caveats.",
        "suggest": "如果 `filename` 返回 `Some`，则此返回值通常为 `Some`，因此也有类似的警告。",
        "translate": ""
    },
    {
        "source": "Returns the file name where this function was defined.",
        "suggest": "返回定义此函数的文件名。",
        "translate": ""
    },
    {
        "source": "This is currently only available when libbacktrace or gimli is being used (e.g.",
        "suggest": "当前仅在使用 libbacktrace 或 gimli 时才可用 (例如",
        "translate": ""
    },
    {
        "source": "platforms other) and when a binary is compiled with debuginfo.",
        "suggest": "其他平台) 以及使用 debuginfo 编译二进制文件时。",
        "translate": ""
    },
    {
        "source": "If neither of these conditions is met then this will likely return `None`.",
        "suggest": "如果这两个条件都不满足，则可能会返回 `None`。",
        "translate": ""
    },
    {
        "source": "Maybe a parsed C++ symbol, if parsing the mangled symbol as Rust failed.",
        "suggest": "如果将损坏的符号解析为 Rust 失败，则可能是解析的 C++ 符号。",
        "translate": ""
    },
    {
        "source": "Make sure to keep this zero-sized, so that the `cpp_demangle` feature has no cost when disabled.",
        "suggest": "确保保持这个零大小，这样 `cpp_demangle` 特性在禁用时没有成本。",
        "translate": ""
    },
    {
        "source": "A wrapper around a symbol name to provide ergonomic accessors to the demangled name, the raw bytes, the raw string, etc.",
        "suggest": "符号名称周围的包装器，以提供符合人体工程学的访问器来访问已分解的名称，原始字节，原始字符串等。",
        "translate": ""
    },
    {
        "source": "Allow dead code for when the `cpp_demangle` feature is not enabled.",
        "suggest": "未启用 `cpp_demangle` 功能时，请使用无效代码。",
        "translate": ""
    },
    {
        "source": "Creates a new symbol name from the raw underlying bytes.",
        "suggest": "从原始基础字节创建一个新的符号名称。",
        "translate": ""
    },
    {
        "source": "Returns the raw (mangled) symbol name as a `str` if the symbol is valid utf-8.",
        "suggest": "如果符号有效 utf-8，则将原始 (mangled) 符号名称返回为 `str`。",
        "translate": ""
    },
    {
        "source": "Use the `Display` implementation if you want the demangled version.",
        "suggest": "如果需要 demangled 版本，请使用 `Display` 实现。",
        "translate": ""
    },
    {
        "source": "Returns the raw symbol name as a list of bytes",
        "suggest": "以字节列表形式返回原始符号名称",
        "translate": ""
    },
    {
        "source": "This may to print if the demangled symbol isn't actually valid, so handle the error here gracefully by not propagating it outwards.",
        "suggest": "如果被检索的符号实际上不是有效的，这可能会打印出来，所以通过不向外传播错误来优雅地处理这里的错误。",
        "translate": ""
    },
    {
        "source": "Attempt to reclaim that cached memory used to symbolicate addresses.",
        "suggest": "尝试回收用于表示地址的缓存内存。",
        "translate": ""
    },
    {
        "source": "This method will attempt to release any global data structures that have otherwise been cached globally or in the thread which typically represent parsed DWARF information or similar.",
        "suggest": "此方法将尝试释放已全局缓存或在线程中缓存的任何数据结构，这些数据结构通常表示已解析的 DWARF 信息或类似信息。",
        "translate": ""
    },
    {
        "source": "While this function is always available it doesn't actually do anything on most implementations.",
        "suggest": "尽管此函数始终可用，但实际上在大多数实现中都没有任何作用。",
        "translate": ""
    },
    {
        "source": "Libraries like dbghelp or libbacktrace do not provide facilities to deallocate state and manage the allocated memory.",
        "suggest": "诸如 dbghelp 或 libbacktrace 之类的库不提供释放状态和管理分配的内存的功能。",
        "translate": ""
    },
    {
        "source": "For now the `gimli-symbolize` feature of this crate is the only feature where this function has any effect.",
        "suggest": "目前，此 crate 的 `gimli-symbolize` 功能是该函数起作用的唯一功能。",
        "translate": ""
    },
    {
        "source": "Empty symbolication strategy used to compile for platforms that have no support.",
        "suggest": "空的符号化策略，用于为不支持的平台进行编译。",
        "translate": ""
    },
    {
        "source": "Platform dependent types.",
        "suggest": "平台相关的类型。",
        "translate": ""
    },
    {
        "source": "A platform independent representation of a string.",
        "suggest": "字符串的平台无关表示。",
        "translate": ""
    },
    {
        "source": "When working with `std` enabled it is recommended to the convenience methods for providing conversions to `std` types.",
        "suggest": "在启用 `std` 的情况下，建议使用方便的方法来提供到 `std` 类型的转换。",
        "translate": ""
    },
    {
        "source": "A slice, typically provided on Unix platforms.",
        "suggest": "切片，通常在 Unix 平台上提供。",
        "translate": ""
    },
    {
        "source": "Wide strings typically from Windows.",
        "suggest": "宽字符串通常来自 Windows。",
        "translate": ""
    },
    {
        "source": "Lossy converts to a `Cow<str>`, will allocate if `Bytes` is not valid UTF-8 or if `BytesOrWideString` is `Wide`.",
        "suggest": "有损转换为 `Cow<str>`，将在 `Bytes` 无效 UTF-8 或 `BytesOrWideString` 为 `Wide` 时进行分配。",
        "translate": ""
    },
    {
        "source": "Provides a `Path` representation of `BytesOrWideString`.",
        "suggest": "提供 `BytesOrWideString` 的 `Path` 表示形式。",
        "translate": ""
    },
    {
        "source": "A module to define the FFI definitions we use on Windows for `dbghelp.dll`",
        "suggest": "用于定义我们在 Windows 上用于 `dbghelp.dll` 的 FFI 定义的模块",
        "translate": ""
    },
    {
        "source": "This module uses a custom macro, `ffi!`, to wrap all definitions to automatically generate tests to assert that our definitions here are the same as `winapi`.",
        "suggest": "此模块使用自定义宏 `ffi!` 来包装所有定义，以自动生成测试以断言此处的定义与 `winapi` 相同。",
        "translate": ""
    },
    {
        "source": "This module largely exists to integrate into libstd itself where winapi is not currently available.",
        "suggest": "存在该模块的主要目的是集成到当前无法使用 winapi 的 libstd 本身中。",
        "translate": ""
    },
    {
        "source": "Handling verification against unions in winapi requires some special care",
        "suggest": "在 Winapi 中处理对 union 的验证需要一些特别的注意",
        "translate": ""
    },
    {
        "source": "Skip this field on x86_64 `CONTEXT` since it's a union and a bit funny",
        "suggest": "跳过 x86_64 `CONTEXT`  上的的这个字段，因为它是一个 union，而且有点滑稽",
        "translate": ""
    },
    {
        "source": "Otherwise test all fields normally.",
        "suggest": "否则，请正常测试所有字段。",
        "translate": ""
    },
    {
        "source": "Skip musl which is by default statically linked and doesn't support dynamic libraries.",
        "suggest": "跳过 musl，默认情况下是静态链接的，并且不支持动态库。",
        "translate": ""
    },
    {
        "source": "Skip MinGW on libbacktrace which doesn't have support for DLLs.",
        "suggest": "在不支持 DLL 的 libbacktrace 上跳过 MinGW。",
        "translate": ""
    },
    {
        "source": "Skip Miri, since it doesn't support dynamic libraries.",
        "suggest": "跳过 Miri，因为它不支持动态库。",
        "translate": ""
    },
    {
        "source": "this shouldn't have to happen first in this function, but currently it does.",
        "suggest": "此功能不必首先在此函数中发生，但目前确实如此。",
        "translate": ""
    },
    {
        "source": "this tests a distinction between two independent calls to the inlined function.",
        "suggest": "这将测试对内联函数的两个独立调用之间的区别。",
        "translate": ""
    },
    {
        "source": "(un)fortunately, LLVM somehow merges two consecutive such calls into one node.",
        "suggest": "不幸的是，LLVM 以某种方式将两个连续的此类调用合并到一个节点中。",
        "translate": ""
    },
    {
        "source": "These run in docker containers on CI where they can't re-exec the test, so just skip these for CI.",
        "suggest": "它们在 CI 上的 docker 容器中运行，无法重新执行测试，因此对于 CI 只需跳过这些即可。",
        "translate": ""
    },
    {
        "source": "No other reason this can't run on those platforms though.",
        "suggest": "但是，没有其他原因不能在这些平台上运行。",
        "translate": ""
    },
    {
        "source": "Miri does not have support for re-execing a file",
        "suggest": "Miri 不支持重新执行文件",
        "translate": ""
    },
    {
        "source": "50-character module name",
        "suggest": "50 个字符的模块名称",
        "translate": ""
    },
    {
        "source": "50-character struct name",
        "suggest": "50 个字符的结构体名称",
        "translate": ""
    },
    {
        "source": "Long function names must be truncated to (MAX_SYM_NAME - 1) characters.",
        "suggest": "长函数名称必须截断为 (MAX_SYM_NAME-1) 个字符。",
        "translate": ""
    },
    {
        "source": "Only run this test for msvc, since gnu prints \"<no info>\" for all frames.",
        "suggest": "仅对 msvc 运行此测试，因为 gnu 将为所有帧打印 \"<no info>\"。",
        "translate": ""
    },
    {
        "source": "10 repetitions of struct name, so fully qualified function name is atleast 10 * (50 + 50) * 2 = 2000 characters long.",
        "suggest": "结构体名称的 10 个重复，因此完全合格的函数名称至少为 10 *(50 + 50)* 2=2000 个字符长。",
        "translate": ""
    },
    {
        "source": "It's actually longer since it also includes `::`, `<>` and the name of the current module",
        "suggest": "实际上它更长，因为它还包含 `::`，`<>` 和当前模块的名称",
        "translate": ""
    },
    {
        "source": "This test only works on platforms which have a working `symbol_address` function for frames which reports the starting address of a symbol.",
        "suggest": "该测试仅适用于具有适用于框架的 `symbol_address` 函数的平台，该框架报告符号的起始地址。",
        "translate": ""
    },
    {
        "source": "As a result it's only enabled on a few platforms.",
        "suggest": "结果，它仅在少数平台上启用。",
        "translate": ""
    },
    {
        "source": "hasn't really been tested, and OSX doesn't support actually finding an enclosing frame, so disable this",
        "suggest": "尚未经过实际测试，并且 OSX 实际上不支持查找封闭框架，因此请禁用此功能",
        "translate": ""
    },
    {
        "source": "On ARM finding the enclosing function is simply returning the ip itself.",
        "suggest": "在 ARM 上，找到封闭的函数只是返回 ip 本身。",
        "translate": ""
    },
    {
        "source": "Reflects the conditional compilation logic at end of src/symbolize/mod.rs",
        "suggest": "反映 src/symbolize/mod.rs 末尾的条件编译逻辑",
        "translate": ""
    },
    {
        "source": "shouldn't ignore this test on i686-msvc, unsure why it's failing",
        "suggest": "不应该在 i686-msvc 上忽略此测试，不确定为什么会失败",
        "translate": ""
    },
    {
        "source": "we care about line numbers here",
        "suggest": "我们在这里关心行号",
        "translate": ""
    },
    {
        "source": "Various platforms have various bits of weirdness about their backtraces.",
        "suggest": "各种平台在回溯上都有各种怪异之处。",
        "translate": ""
    },
    {
        "source": "To find a good starting spot let's search through the frames",
        "suggest": "为了找到一个好的起点，让我们搜索一下框架",
        "translate": ""
    },
    {
        "source": "dbghelp is *quite* liberal (and wrong) in many of its reports right now...",
        "suggest": "dbghelp 现在在其许多报告中都是 *相当* 自由的 (而且是错误的) ...",
        "translate": ""
    },
    {
        "source": "This assertion can also fail for release builds, so skip it there",
        "suggest": "对于断言版本，此断言也可能失败，因此请在此处跳过",
        "translate": ""
    },
    {
        "source": "dbghelp doesn't always resolve symbols right now",
        "suggest": "dbghelp 并不总是立即解析符号",
        "translate": ""
    },
    {
        "source": "in release mode names get weird as functions can get merged together with `mergefunc`, so only assert this in debug mode",
        "suggest": "在发布模式下，名称变得很奇怪，因为函数可以与 `mergefunc` 合并在一起，因此只能在调试模式下声明此名称",
        "translate": ""
    },
    {
        "source": "the following `make_*` functions are pulled out of line, rather than defining their results as inline closures at their call sites, so that the resulting closures don't have \"recursive_stack_references\" in their mangled names.",
        "suggest": "下面的 `make_*` 函数被取消了顺序，而不是将其结果定义为在其调用位置处的内联闭包，因此，生成的闭包的名称中不包含 \"recursive_stack_references\"。",
        "translate": ""
    },
    {
        "source": "If the SP is null, then we don't have an implementation for getting the SP on this target.",
        "suggest": "如果 SP 为空，那么我们没有实现在此目标上获取 SP 的实现。",
        "translate": ""
    },
    {
        "source": "Just keep walking the stack, but don't make our assertions about the on-stack pointers and SP values.",
        "suggest": "只需继续执行栈，但不要对栈指针和 SP 值进行断言。",
        "translate": ""
    },
    {
        "source": "The stack grows down.",
        "suggest": "栈向下增长。",
        "translate": ""
    },
    {
        "source": "Ensure we benchmark cases where the functions are called with strings that are not perfectly aligned or have a length which is not a multiple of size_of::<usize>() (or both)",
        "suggest": "确保我们对用不完全对齐或长度不是 size_of 的倍数的字符串调用函数的情况进行基准测试: <usize> () (或两者)",
        "translate": ""
    },
    {
        "source": "These are separate since it's easier to debug errors if they don't go through macro expansion first.",
        "suggest": "这些是分开的，因为如果不先进行宏展开，则更容易调试错误。",
        "translate": ""
    },
    {
        "source": "transmuting a sequence of `u8` to `usize` is always fine",
        "suggest": "将 `u8` 序列转换为 `usize` 总是很好",
        "translate": ""
    },
    {
        "source": "transmuting a sequence of `u8` to `[usize; 2]` is always fine",
        "suggest": "将 `u8` 序列转换为 `[usize; 2]` 总是很好",
        "translate": ""
    },
    {
        "source": "Lower-case ASCII 'a' is the first byte that has its highest bit set after wrap-adding 0x1F:",
        "suggest": "小写 ASCII 'a' 是包装 0x1F 后设置最高位的第一个字节:",
        "translate": ""
    },
    {
        "source": "Lower-case ASCII 'z' is the last byte that has its highest bit unset after wrap-adding 0x05:",
        "suggest": "小写 ASCII 'z' 是在包装 0x05 之后未设置其最高位的最后一个字节:",
        "translate": ""
    },
    {
        "source": "except for 0xFB to 0xFF, but those are in the range of bytes that have the highest bit unset again after adding 0x1F.",
        "suggest": "0xFB 到 0xFF 除外，但是这些字节在添加 0x1F 之后再次取消设置最高位的字节范围内。",
        "translate": ""
    },
    {
        "source": "So `(byte + 0x1f) & !(byte + 5)` has its highest bit set iff `byte` is a lower-case ASCII letter.",
        "suggest": "因此，如果 `byte` 是小写的 ASCII 字母，则 `(byte + 0x1f) & !(byte + 5)` 具有最高的位设置。",
        "translate": ""
    },
    {
        "source": "Lower-case ASCII letters all have the 0x20 bit set.",
        "suggest": "小写 ASCII 字母均已设置为 0x20。",
        "translate": ""
    },
    {
        "source": "(Two positions right of 0x80, the highest bit.) Unsetting that bit produces the same letter, in upper-case.",
        "suggest": "(0x80 的右两个位置是最高位。) 取消设置该位会产生相同的字母 (大写)。",
        "translate": ""
    },
    {
        "source": "transmuting a sequence of `u8` to `u32` is always fine",
        "suggest": "将 `u8` 序列转换为 `u32` 总是很好",
        "translate": ""
    },
    {
        "source": "this is incorrect for some byte values:",
        "suggest": "对于某些字节值，这是不正确的:",
        "translate": ""
    },
    {
        "source": "addition within a byte can carry/overflow into the next byte.",
        "suggest": "一个字节内的加法可以将 carry/overflow 放入下一个字节。",
        "translate": ""
    },
    {
        "source": "Test case: b\"\\xFFz  \"",
        "suggest": "测试用例: b`\\xFFz`",
        "translate": ""
    },
    {
        "source": "transmuting a sequence of `u8` to `u64` is always fine",
        "suggest": "将 `u8` 序列转换为 `u64` 总是很好",
        "translate": ""
    },
    {
        "source": "like above, this is incorrect for some byte values.",
        "suggest": "像上面一样，这对于某些字节值是不正确的。",
        "translate": ""
    },
    {
        "source": "control whitespace",
        "suggest": "控制空格",
        "translate": ""
    },
    {
        "source": "lowercase hex digit",
        "suggest": "小写十六进制数字",
        "translate": ""
    },
    {
        "source": "uppercase hex digit",
        "suggest": "大写十六进制数字",
        "translate": ""
    },
    {
        "source": "implemented as a plain loop.",
        "suggest": "实现为普通循环。",
        "translate": ""
    },
    {
        "source": "implemented with `fold` for internal iteration.",
        "suggest": "使用 `fold` 进行内部迭代。",
        "translate": ""
    },
    {
        "source": "(except when `by_ref()` effectively disables that optimization.)",
        "suggest": "(除非 `by_ref()` 有效地禁用了该优化。)",
        "translate": ""
    },
    {
        "source": "Helper to benchmark `sum` for iterators taken by value which can optimize `fold`, and by reference which cannot.",
        "suggest": "可以根据可以优化 `fold` 的值和不能使用引用的迭代器对 `sum` 进行基准测试的助手。",
        "translate": ""
    },
    {
        "source": "Checks whether Skip<Zip<A,B>> is as fast as Zip<Skip<A>, Skip<B>>, from",
        "suggest": "从以下位置检查 Skip<Zip<A,B>> 是否与 Zip<Skip<A>，Skip<B>> 一样快",
        "translate": ""
    },
    {
        "source": "does not support benches (no time).",
        "suggest": "不支持长凳 (无时间)。",
        "translate": ""
    },
    {
        "source": "Overhead of dtors",
        "suggest": "dtors 的开销",
        "translate": ""
    },
    {
        "source": "LCG constants from https://en.wikipedia.org/wiki/Numerical_Recipes.",
        "suggest": "https://en.wikipedia.org/wiki/Numerical_Recipes 的 LCG 常量。",
        "translate": ""
    },
    {
        "source": "Lookup the whole range to get 50% hits and 50% misses.",
        "suggest": "查找整个范围以获得 50% 的命中率和 50% 的未命中率。",
        "translate": ""
    },
    {
        "source": "Make panics and failed asserts immediately abort without formatting any message",
        "suggest": "使 panics 和失败的断言立即终止而不格式化任何消息",
        "translate": ""
    },
    {
        "source": "A memory allocator that can be registered as the standard library’s default through the `#[global_allocator]` attribute.",
        "suggest": "可以通过 `#[global_allocator]` 属性将其分配为标准库的默认内存分配器。",
        "translate": ""
    },
    {
        "source": "Some of the methods require that a memory block be *currently allocated* via an allocator.",
        "suggest": "某些方法要求通过分配器 *currently* 分配存储块。",
        "translate": ""
    },
    {
        "source": "This means that:",
        "suggest": "这意味着:",
        "translate": ""
    },
    {
        "source": "the starting address for that memory block was previously returned by a previous call to an allocation method such as `alloc`, and",
        "suggest": "该存储块的起始地址先前是由先前的调用返回到诸如 `alloc` 的分配方法的，并且",
        "translate": ""
    },
    {
        "source": "the memory block has not been subsequently deallocated, where blocks are deallocated either by being passed to a deallocation method such as `dealloc` or by being passed to a reallocation method that returns a non-null pointer.",
        "suggest": "内存块尚未随后被释放，而是通过传递给诸如 `dealloc` 的释放方法或传递给返回非空指针的重新分配方法来对块进行释放。",
        "translate": ""
    },
    {
        "source": "The `GlobalAlloc` trait is an `unsafe` trait for a number of reasons, and implementors must ensure that they adhere to these contracts:",
        "suggest": "由于多种原因，`GlobalAlloc` trait 是 `unsafe` trait，实现者必须确保遵守以下契约:",
        "translate": ""
    },
    {
        "source": "It's undefined behavior if global allocators unwind.",
        "suggest": "如果分配器解散，这是未定义的行为。",
        "translate": ""
    },
    {
        "source": "This restriction may be lifted in the future, but currently a panic from any of these functions may lead to memory unsafety.",
        "suggest": "可以在 future 中取消此限制，但是当前来自任何这些函数的 panic 都可能导致内存不安全。",
        "translate": ""
    },
    {
        "source": "queries and calculations in general must be correct.",
        "suggest": "查询和计算通常必须正确。",
        "translate": ""
    },
    {
        "source": "Callers of this trait are allowed to rely on the contracts defined on each method, and implementors must ensure such contracts remain true.",
        "suggest": "允许 trait 的调用者依赖于每种方法上定义的协定，实现者必须确保此类协定保持正确。",
        "translate": ""
    },
    {
        "source": "You may not rely on allocations actually happening, even if there are explicit heap allocations in the source.",
        "suggest": "即使源中存在显式堆分配，您也可能不依赖实际发生的分配。",
        "translate": ""
    },
    {
        "source": "The optimizer may detect unused allocations that it can either eliminate entirely or move to the stack and thus never invoke the allocator.",
        "suggest": "优化器可能会检测到未使用的分配，该分配器可以将其完全消除或移到栈，因此从不调用分配器。",
        "translate": ""
    },
    {
        "source": "The optimizer may further assume that allocation is infallible, so code that used to fail due to allocator failures may now suddenly work because the optimizer worked around the need for an allocation.",
        "suggest": "优化器可能进一步假设分配是无误的，因此由于分配器故障而导致分配器失败的代码现在可能突然起作用，因为优化器解决了分配需求。",
        "translate": ""
    },
    {
        "source": "More concretely, the following code example is unsound, irrespective of whether your custom allocator allows counting how many allocations have happened.",
        "suggest": "更具体地说，无论您的自定义分配器是否允许计算发生了多少分配，下面的代码示例都是不正确的。",
        "translate": ""
    },
    {
        "source": "Note that the optimizations mentioned above are not the only optimization that can be applied.",
        "suggest": "请注意，上面提到的优化并不是唯一可以应用的优化。",
        "translate": ""
    },
    {
        "source": "You may generally not rely on heap allocations happening if they can be removed without changing program behavior.",
        "suggest": "如果可以在不更改程序行为的情况下将其删除，则通常可能不依赖于发生的堆分配。",
        "translate": ""
    },
    {
        "source": "Whether allocations happen or not is not part of the program behavior, even if it could be detected via an allocator that tracks allocations by printing or otherwise having side effects.",
        "suggest": "分配的发生与否不是程序行为的一部分，即使可以通过分配器检测到分配，该分配器通过打印或其他方式跟踪分配也会产生副作用。",
        "translate": ""
    },
    {
        "source": "Allocate memory as described by the given `layout`.",
        "suggest": "按照给定的 `layout` 分配内存。",
        "translate": ""
    },
    {
        "source": "Returns a pointer to newly-allocated memory, or null to indicate allocation failure.",
        "suggest": "返回指向新分配的内存的指针，或者返回 null 以指示分配失败。",
        "translate": ""
    },
    {
        "source": "This function is unsafe because undefined behavior can result if the caller does not ensure that `layout` has non-zero size.",
        "suggest": "该函数是不安全的，因为如果调用者不确保 `layout` 的大小为非零，则可能导致未定义的行为。",
        "translate": ""
    },
    {
        "source": "(Extension subtraits might provide more specific bounds on behavior, e.g., guarantee a sentinel address or a null pointer in response to a zero-size allocation request.)",
        "suggest": "(扩展子特性可能提供行为的更具体限制，例如，保证响应零大小分配请求的前哨地址或空指针。)",
        "translate": ""
    },
    {
        "source": "The allocated block of memory may or may not be initialized.",
        "suggest": "分配的内存块可能会初始化也可能不会初始化。",
        "translate": ""
    },
    {
        "source": "Returning a null pointer indicates that either memory is exhausted or `layout` does not meet this allocator's size or alignment constraints.",
        "suggest": "返回空指针表示内存已耗尽，或者 `layout` 不满足此分配器的大小或对齐约束。",
        "translate": ""
    },
    {
        "source": "Implementations are encouraged to return null on memory exhaustion rather than aborting, but this is not a strict requirement.",
        "suggest": "鼓励实现在内存耗尽时返回 null 而不是终止，但这不是严格的要求。",
        "translate": ""
    },
    {
        "source": "(Specifically: it is *legal* to implement this trait atop an underlying native allocation library that aborts on memory exhaustion.)",
        "suggest": "(具体来说: 在一个底层的原生分配库上实现此 trait 是 *合法的*，该本地分配库在内存耗尽时中止。)",
        "translate": ""
    },
    {
        "source": "Clients wishing to abort computation in response to an allocation error are encouraged to call the [`handle_alloc_error`] function, rather than directly invoking `panic!` or similar.",
        "suggest": "鼓励希望因分配错误而终止计算的客户调用 [`handle_alloc_error`] 函数，而不是直接调用 `panic!` 或类似方法。",
        "translate": ""
    },
    {
        "source": "Deallocate the block of memory at the given `ptr` pointer with the given `layout`.",
        "suggest": "使用给定的 `layout` 在给定的 `ptr` 指针处释放内存块。",
        "translate": ""
    },
    {
        "source": "This function is unsafe because undefined behavior can result if the caller does not ensure all of the following:",
        "suggest": "该函数是不安全的，因为如果调用者不能确保满足以下所有条件，则可能导致未定义的行为:",
        "translate": ""
    },
    {
        "source": "must denote a block of memory currently allocated via this allocator,",
        "suggest": "必须表示当前通过此分配器分配的一块内存，",
        "translate": ""
    },
    {
        "source": "must be the same layout that was used to allocate that block of memory.",
        "suggest": "必须与用于分配该内存块的布局相同。",
        "translate": ""
    },
    {
        "source": "Behaves like `alloc`, but also ensures that the contents are set to zero before being returned.",
        "suggest": "行为类似于 `alloc`，但也确保在返回之前将内容设置为零。",
        "translate": ""
    },
    {
        "source": "This function is unsafe for the same reasons that `alloc` is.",
        "suggest": "出于与 `alloc` 相同的原因，此函数是不安全的。",
        "translate": ""
    },
    {
        "source": "However the allocated block of memory is guaranteed to be initialized.",
        "suggest": "但是，保证已分配的内存块将被初始化。",
        "translate": ""
    },
    {
        "source": "Returning a null pointer indicates that either memory is exhausted or `layout` does not meet allocator's size or alignment constraints, just as in `alloc`.",
        "suggest": "像 `alloc` 一样，返回空指针表示内存已耗尽或 `layout` 不满足分配器的大小或对齐约束。",
        "translate": ""
    },
    {
        "source": "the safety contract for `alloc` must be upheld by the caller.",
        "suggest": "调用者必须遵守 `alloc` 的安全保证。",
        "translate": ""
    },
    {
        "source": "as allocation succeeded, the region from `ptr` of size `size` is guaranteed to be valid for writes.",
        "suggest": "随着分配成功，从 `ptr` 开始的大小为 `size` 的区域将保证对写入有效。",
        "translate": ""
    },
    {
        "source": "Shrink or grow a block of memory to the given `new_size`.",
        "suggest": "将内存块缩小或增加到给定的 `new_size`。",
        "translate": ""
    },
    {
        "source": "The block is described by the given `ptr` pointer and `layout`.",
        "suggest": "该块由给定的 `ptr` 指针和 `layout` 描述。",
        "translate": ""
    },
    {
        "source": "If this returns a non-null pointer, then ownership of the memory block referenced by `ptr` has been transferred to this allocator.",
        "suggest": "如果返回非空指针，则 `ptr` 引用的内存块的所有权已转移到此分配器。",
        "translate": ""
    },
    {
        "source": "The memory may or may not have been deallocated, and should be considered unusable (unless of course it was transferred back to the caller again via the return value of this method).",
        "suggest": "内存可能已释放，也可能尚未释放，应将其视为不可用的 (除非当然已通过此方法的返回值再次将其转移回调用方)。",
        "translate": ""
    },
    {
        "source": "The new memory block is allocated with `layout`, but with the `size` updated to `new_size`.",
        "suggest": "`layout` 分配了新的存储块，但 `size` 更新为 `new_size`。",
        "translate": ""
    },
    {
        "source": "This new layout should be used when deallocating the new memory block with `dealloc`.",
        "suggest": "当用 `dealloc` 释放新的内存块时，应该使用这种新的布局。",
        "translate": ""
    },
    {
        "source": "The range `0..min(layout.size(), new_size)` of the new memory block is guaranteed to have the same values as the original block.",
        "suggest": "确保新存储块的范围 `0..min(layout.size(), new_size)` 与原始存储块具有相同的值。",
        "translate": ""
    },
    {
        "source": "If this method returns null, then ownership of the memory block has not been transferred to this allocator, and the contents of the memory block are unaltered.",
        "suggest": "如果此方法返回 null，则该存储块的所有权尚未转移到此分配器，并且该存储块的内容不会更改。",
        "translate": ""
    },
    {
        "source": "must be currently allocated via this allocator,",
        "suggest": "当前必须通过此分配器分配，",
        "translate": ""
    },
    {
        "source": "must be the same layout that was used to allocate that block of memory,",
        "suggest": "必须与用于分配该内存块的布局相同，",
        "translate": ""
    },
    {
        "source": "must be greater than zero.",
        "suggest": "必须大于零。",
        "translate": ""
    },
    {
        "source": "when rounded up to the nearest multiple of `layout.align()`, must not overflow (i.e., the rounded value must be less than `usize::MAX`).",
        "suggest": "当四舍五入到最接近的 `layout.align()` 倍数时，一定不能溢出 (即，四舍五入的值必须小于 `usize::MAX`)。",
        "translate": ""
    },
    {
        "source": "Returns null if the new layout does not meet the size and alignment constraints of the allocator, or if reallocation otherwise fails.",
        "suggest": "如果新布局不符合分配器的大小和对齐约束，或者重新分配失败，则返回 null。",
        "translate": ""
    },
    {
        "source": "Implementations are encouraged to return null on memory exhaustion rather than panicking or aborting, but this is not a strict requirement.",
        "suggest": "鼓励实现在内存耗尽时返回 null 而不是恐慌或终止，但是这不是严格的要求。",
        "translate": ""
    },
    {
        "source": "Clients wishing to abort computation in response to a reallocation error are encouraged to call the [`handle_alloc_error`] function, rather than directly invoking `panic!` or similar.",
        "suggest": "鼓励希望响应重新分配错误而终止计算的客户调用 [`handle_alloc_error`] 函数，而不是直接调用 `panic!` 或类似方法。",
        "translate": ""
    },
    {
        "source": "the caller must ensure that the `new_size` does not overflow.",
        "suggest": "调用者必须确保 `new_size` 不会溢出。",
        "translate": ""
    },
    {
        "source": "comes from a `Layout` and is thus guaranteed to be valid.",
        "suggest": "来自 `Layout`，因此可以保证是有效的。",
        "translate": ""
    },
    {
        "source": "the caller must ensure that `new_layout` is greater than zero.",
        "suggest": "调用者必须确保 `new_layout` 大于零。",
        "translate": ""
    },
    {
        "source": "the previously allocated block cannot overlap the newly allocated block.",
        "suggest": "先前分配的块不能与新分配的块重叠。",
        "translate": ""
    },
    {
        "source": "Remember to finalize with `pad_to_align`!",
        "suggest": "记得用 `pad_to_align` 来完成!",
        "translate": ""
    },
    {
        "source": "test that it works",
        "suggest": "测试它是否有效",
        "translate": ""
    },
    {
        "source": "While this function is used in one place and its implementation could be inlined, the previous attempts to do so made rustc slower:",
        "suggest": "虽然此函数在一个地方使用过，并且可以内联其实现，但是以前的尝试使 rustc 变慢了:",
        "translate": ""
    },
    {
        "source": "Layout of a block of memory.",
        "suggest": "一块内存的布局。",
        "translate": ""
    },
    {
        "source": "An instance of `Layout` describes a particular layout of memory.",
        "suggest": "`Layout` 的实例描述了特定的内存布局。",
        "translate": ""
    },
    {
        "source": "You build a `Layout` up as an input to give to an allocator.",
        "suggest": "您将 `Layout` 作为输入分配给分配器。",
        "translate": ""
    },
    {
        "source": "All layouts have an associated size and a power-of-two alignment.",
        "suggest": "所有布局都具有关联的大小和 2 的幂次对齐。",
        "translate": ""
    },
    {
        "source": "(Note that layouts are *not* required to have non-zero size, even though `GlobalAlloc` requires that all memory requests be non-zero in size.",
        "suggest": "(请注意，布局不要求具有非零大小，即使 `GlobalAlloc` 要求所有内存请求的大小为非零。",
        "translate": ""
    },
    {
        "source": "A caller must either ensure that conditions like this are met, use specific allocators with looser requirements, or use the more lenient `Allocator` interface.)",
        "suggest": "调用方必须确保满足这样的条件，使用要求较宽松的特定分配器，或者使用更宽松的 `Allocator` 接口。)",
        "translate": ""
    },
    {
        "source": "size of the requested block of memory, measured in bytes.",
        "suggest": "请求的内存块的大小，以字节为单位。",
        "translate": ""
    },
    {
        "source": "alignment of the requested block of memory, measured in bytes.",
        "suggest": "请求的内存块的对齐方式，以字节为单位。",
        "translate": ""
    },
    {
        "source": "we ensure that this is always a power-of-two, because API's like `posix_memalign` require it and it is a reasonable constraint to impose on Layout constructors.",
        "suggest": "我们确保这始终是 2 的幂，因为像 `posix_memalign` 这样的 API 都需要这样做，并且强加给 Layout 构造函数是一个合理的约束。",
        "translate": ""
    },
    {
        "source": "(However, we do not analogously require `align >= sizeof(void*)`, even though that is *also* a requirement of `posix_memalign`.)",
        "suggest": "(但是，我们类似地不要求 `align>= sizeof(void *)`, even though that is* also* a requirement of `posix_memalign`.)",
        "translate": ""
    },
    {
        "source": "Constructs a `Layout` from a given `size` and `align`, or returns `LayoutError` if any of the following conditions are not met:",
        "suggest": "从给定的 `size` 和 `align` 创建 `Layout`，或者如果不满足以下任何条件，则返回 `LayoutError`:",
        "translate": ""
    },
    {
        "source": "must not be zero,",
        "suggest": "不能为零，",
        "translate": ""
    },
    {
        "source": "must be a power of two,",
        "suggest": "必须是 2 的幂",
        "translate": ""
    },
    {
        "source": "when rounded up to the nearest multiple of `align`, must not overflow (i.e., the rounded value must be less than or equal to `usize::MAX`).",
        "suggest": "当四舍五入到最接近的 `align` 倍数时，一定不能溢出 (即，四舍五入的值必须小于或等于 `usize::MAX`)。",
        "translate": ""
    },
    {
        "source": "(power-of-two implies align != 0.)",
        "suggest": "(2 的幂表示 align=0。)",
        "translate": ""
    },
    {
        "source": "Rounded up size is:",
        "suggest": "舍入后的大小为:",
        "translate": ""
    },
    {
        "source": "We know from above that align != 0.",
        "suggest": "从上面我们知道 align! =0。",
        "translate": ""
    },
    {
        "source": "If adding (align - 1) does not overflow, then rounding up will be fine.",
        "suggest": "如果加法 (align-1) 没有溢出，则四舍五入是可以的。",
        "translate": ""
    },
    {
        "source": "Conversely, &-masking with !(align - 1) will subtract off only low-order-bits.",
        "suggest": "相反，&-masking with! (align-1) 将仅减去低位。",
        "translate": ""
    },
    {
        "source": "Thus if overflow occurs with the sum, the &-mask cannot subtract enough to undo that overflow.",
        "suggest": "因此，如果总和发生溢出，则 &-mask cannot 减去足以抵消该溢出。",
        "translate": ""
    },
    {
        "source": "Above implies that checking for summation overflow is both necessary and sufficient.",
        "suggest": "以上暗示检查总和溢出是否必要和充分。",
        "translate": ""
    },
    {
        "source": "the conditions for `from_size_align_unchecked` have been checked above.",
        "suggest": "`from_size_align_unchecked` 的条件已在上面进行了检查。",
        "translate": ""
    },
    {
        "source": "Creates a layout, bypassing all checks.",
        "suggest": "创建一个布局，绕过所有检查。",
        "translate": ""
    },
    {
        "source": "This function is unsafe as it does not verify the preconditions from [`Layout::from_size_align`].",
        "suggest": "此函数不安全，因为它无法验证 [`Layout::from_size_align`] 的前提条件。",
        "translate": ""
    },
    {
        "source": "the caller must ensure that `align` is greater than zero.",
        "suggest": "调用者必须确保 `align` 大于零。",
        "translate": ""
    },
    {
        "source": "The minimum size in bytes for a memory block of this layout.",
        "suggest": "此布局的存储块的最小大小 (以字节为单位)。",
        "translate": ""
    },
    {
        "source": "The minimum byte alignment for a memory block of this layout.",
        "suggest": "此布局的存储块的最小字节对齐。",
        "translate": ""
    },
    {
        "source": "Constructs a `Layout` suitable for holding a value of type `T`.",
        "suggest": "创建一个适合保存 `T` 类型值的 `Layout`。",
        "translate": ""
    },
    {
        "source": "the align is guaranteed by Rust to be a power of two and the size+align combo is guaranteed to fit in our address space.",
        "suggest": "Rust 保证 align 为 2 的幂，并且 size + align 组合保证适合我们的地址空间。",
        "translate": ""
    },
    {
        "source": "As a result use the unchecked constructor here to avoid inserting code that panics if it isn't optimized well enough.",
        "suggest": "结果，如果未对 panics 进行最佳优化，请在此处使用未经检查的构造函数，以免插入 panics 的代码。",
        "translate": ""
    },
    {
        "source": "Produces layout describing a record that could be used to allocate backing structure for `T` (which could be a trait or other unsized type like a slice).",
        "suggest": "产生描述记录的布局，该记录可用于为 `T` 分配支持结构 (可以是 trait 或其他未定义大小的类型，例如切片)。",
        "translate": ""
    },
    {
        "source": "see rationale in `new` for why this is using the unsafe variant",
        "suggest": "有关为什么使用不安全成员的信息，请参见 `new` 中的基本原理。",
        "translate": ""
    },
    {
        "source": "This function is only safe to call if the following conditions hold:",
        "suggest": "仅在满足以下条件时，此函数才可以安全调用:",
        "translate": ""
    },
    {
        "source": "If `T` is `Sized`, this function is always safe to call.",
        "suggest": "如果 `T` 是 `Sized`，则调用该函数始终是安全的。",
        "translate": ""
    },
    {
        "source": "If the unsized tail of `T` is:",
        "suggest": "如果 `T` 的未定义大小的尾部为:",
        "translate": ""
    },
    {
        "source": "a [slice], then the length of the slice tail must be an intialized integer, and the size of the *entire value* (dynamic tail length + statically sized prefix) must fit in `isize`.",
        "suggest": "[slice]，则切片尾部的长度必须是一个初始化整数，并且 *entire 值*(动态尾部长度 + 静态大小的前缀) 的大小必须适合 `isize`。",
        "translate": ""
    },
    {
        "source": "a [trait object], then the vtable part of the pointer must point to a valid vtable for the type `T` acquired by an unsizing coersion, and the size of the *entire value* (dynamic tail length + statically sized prefix) must fit in `isize`.",
        "suggest": "[trait object]，则指针的 vtable 部分必须指向通过未调整大小的强制性获得的 `T` 类型的有效 vtable，并且 *entire 值*(动态尾部长度 + 静态大小的前缀) 的大小必须适合 `isize`。",
        "translate": ""
    },
    {
        "source": "an (unstable) [extern type], then this function is always safe to call, but may panic or otherwise return the wrong value, as the extern type's layout is not known.",
        "suggest": "(unstable) [extern type]，则此函数始终可以安全调用，但可能会 panic 或以其他方式返回错误的值，因为外部类型的布局未知。",
        "translate": ""
    },
    {
        "source": "This is the same behavior as [`Layout::for_value`] on a reference to an extern type tail.",
        "suggest": "这与在外部类型尾巴上引用 [`Layout::for_value`] 时的行为相同。",
        "translate": ""
    },
    {
        "source": "otherwise, it is conservatively not allowed to call this function.",
        "suggest": "否则，保守地不允许调用此函数。",
        "translate": ""
    },
    {
        "source": "we pass along the prerequisites of these functions to the caller",
        "suggest": "我们将这些函数的先决条件传递给调用者",
        "translate": ""
    },
    {
        "source": "Creates a `NonNull` that is dangling, but well-aligned for this Layout.",
        "suggest": "创建一个悬空的 `NonNull`，但此 Layout 非常适合该 `NonNull`。",
        "translate": ""
    },
    {
        "source": "Note that the pointer value may potentially represent a valid pointer, which means this must not be used as a \"not yet initialized\" sentinel value.",
        "suggest": "请注意，该指针值可能表示一个有效的指针，这意味着不得将其用作 \"not yet initialized\" 标记值。",
        "translate": ""
    },
    {
        "source": "Types that lazily allocate must track initialization by some other means.",
        "suggest": "延迟分配的类型必须通过其他某种方式来跟踪初始化。",
        "translate": ""
    },
    {
        "source": "align is guaranteed to be non-zero",
        "suggest": "align 保证为非零",
        "translate": ""
    },
    {
        "source": "Creates a layout describing the record that can hold a value of the same layout as `self`, but that also is aligned to alignment `align` (measured in bytes).",
        "suggest": "创建一个描述记录的布局，该记录可以保留与 `self` 相同的布局值，但也与对齐方式 `align` 对齐 (以字节为单位)。",
        "translate": ""
    },
    {
        "source": "If `self` already meets the prescribed alignment, then returns `self`.",
        "suggest": "如果 `self` 已经满足规定的对齐方式，则返回 `self`。",
        "translate": ""
    },
    {
        "source": "Note that this method does not add any padding to the overall size, regardless of whether the returned layout has a different alignment.",
        "suggest": "请注意，无论返回的布局是否具有不同的对齐方式，此方法都不会在整体大小上添加任何填充。",
        "translate": ""
    },
    {
        "source": "In other words, if `K` has size 16, `K.align_to(32)` will *still* have size 16.",
        "suggest": "换句话说，如果 `K` 的大小为 16，则 `K.align_to(32)`*仍* 的大小为 16。",
        "translate": ""
    },
    {
        "source": "Returns an error if the combination of `self.size()` and the given `align` violates the conditions listed in [`Layout::from_size_align`].",
        "suggest": "如果 `self.size()` 和给定的 `align` 的组合违反 [`Layout::from_size_align`] 中列出的条件，则返回错误。",
        "translate": ""
    },
    {
        "source": "Returns the amount of padding we must insert after `self` to ensure that the following address will satisfy `align` (measured in bytes).",
        "suggest": "返回必须在 `self` 之后插入的填充量，以确保以下地址满足 `align` (以字节为单位)。",
        "translate": ""
    },
    {
        "source": "e.g., if `self.size()` is 9, then `self.padding_needed_for(4)` returns 3, because that is the minimum number of bytes of padding required to get a 4-aligned address (assuming that the corresponding memory block starts at a 4-aligned address).",
        "suggest": "例如，如果 `self.size()` 为 9，则 `self.padding_needed_for(4)` 返回 3，因为这是获得 4 对齐地址所需的最小填充字节数 (假设相应的存储块从 4 对齐地址开始)。",
        "translate": ""
    },
    {
        "source": "The return value of this function has no meaning if `align` is not a power-of-two.",
        "suggest": "如果 `align` 不是 2 的幂，则此函数的返回值没有意义。",
        "translate": ""
    },
    {
        "source": "Note that the utility of the returned value requires `align` to be less than or equal to the alignment of the starting address for the whole allocated block of memory.",
        "suggest": "注意，返回值的实用程序要求 `align` 小于或等于整个分配的内存块的起始地址的对齐方式。",
        "translate": ""
    },
    {
        "source": "One way to satisfy this constraint is to ensure `align <= self.align()`.",
        "suggest": "满足此约束的一种方法是确保 `align <= self.align()`。",
        "translate": ""
    },
    {
        "source": "Rounded up value is:",
        "suggest": "向上取整的值为:",
        "translate": ""
    },
    {
        "source": "and then we return the padding difference:",
        "suggest": "然后返回填充差异:",
        "translate": ""
    },
    {
        "source": "We use modular arithmetic throughout:",
        "suggest": "我们在整个过程中都使用模块化的算法:",
        "translate": ""
    },
    {
        "source": "align is guaranteed to be > 0, so align - 1 is always valid.",
        "suggest": "align 保证 > 0，因此 align - 1 始终有效。",
        "translate": ""
    },
    {
        "source": "can overflow by at most `align - 1`, so the &-mask with `!(align - 1)` will ensure that in the case of overflow, `len_rounded_up` will itself be 0.",
        "suggest": "&-mask with `!(align - 1)` 最多可以溢出 `align - 1`，因此 &-mask with `!(align - 1)` 将确保 `len_rounded_up` 本身为 0。",
        "translate": ""
    },
    {
        "source": "Thus the returned padding, when added to `len`, yields 0, which trivially satisfies the alignment `align`.",
        "suggest": "因此，当返回的填充添加到 `len` 时，将产生 0，该填充简单地满足了 `align` 的对齐方式。",
        "translate": ""
    },
    {
        "source": "(Of course, attempts to allocate blocks of memory whose size and padding overflow in the above manner should cause the allocator to yield an error anyway.)",
        "suggest": "(当然，尝试以上述方式分配其大小和填充溢出的内存块无论如何都会导致分配器产生错误。)",
        "translate": ""
    },
    {
        "source": "Creates a layout by rounding the size of this layout up to a multiple of the layout's alignment.",
        "suggest": "通过将布局的大小四舍五入到布局的对齐方式的倍数来创建布局。",
        "translate": ""
    },
    {
        "source": "This is equivalent to adding the result of `padding_needed_for` to the layout's current size.",
        "suggest": "这等效于将 `padding_needed_for` 的结果添加到布局的当前大小。",
        "translate": ""
    },
    {
        "source": "This cannot overflow.",
        "suggest": "这不会溢出。",
        "translate": ""
    },
    {
        "source": "Quoting from the invariant of Layout:",
        "suggest": "引用 Layout 的不变式:",
        "translate": ""
    },
    {
        "source": "when rounded up to the nearest multiple of `align`,",
        "suggest": "当四舍五入到 `align` 的最接近倍数时，",
        "translate": ""
    },
    {
        "source": "must not overflow (i.e., the rounded value must be less than",
        "suggest": "不得溢出 (即，四舍五入的值必须小于",
        "translate": ""
    },
    {
        "source": "Creates a layout describing the record for `n` instances of `self`, with a suitable amount of padding between each to ensure that each instance is given its requested size and alignment.",
        "suggest": "创建一个布局，以描述 `self` 的 `n` 实例的记录，并在每个实例之间使用适当的填充量，以确保为每个实例提供其请求的大小和对齐方式。",
        "translate": ""
    },
    {
        "source": "On success, returns `(k, offs)` where `k` is the layout of the array and `offs` is the distance between the start of each element in the array.",
        "suggest": "成功后，返回 `(k, offs)`，其中 `k` 是数组的布局，`offs` 是数组中每个元素的起点之间的距离。",
        "translate": ""
    },
    {
        "source": "On arithmetic overflow, returns `LayoutError`.",
        "suggest": "算术溢出时，返回 `LayoutError`。",
        "translate": ""
    },
    {
        "source": "self.align is already known to be valid and alloc_size has been padded already.",
        "suggest": "已知 self.align 是有效的，并且 alloc_size 已被填充。",
        "translate": ""
    },
    {
        "source": "Creates a layout describing the record for `self` followed by `next`, including any necessary padding to ensure that `next` will be properly aligned, but *no trailing padding*.",
        "suggest": "创建一个布局，描述 `self` 的记录，后跟 `next` 的记录，包括确保 `next` 正确对齐但必须填充 *no trailing* 的所有必要填充。",
        "translate": ""
    },
    {
        "source": "In order to match C representation layout `repr(C)`, you should call `pad_to_align` after extending the layout with all fields.",
        "suggest": "为了匹配 C 表示形式的布局 `repr(C)`，应在扩展了所有字段的布局后调用 `pad_to_align`。",
        "translate": ""
    },
    {
        "source": "(There is no way to match the default Rust representation layout `repr(Rust)`, as it is unspecified.)",
        "suggest": "(由于未指定，因此无法匹配默认的 Rust 表示形式布局 `repr(Rust)`。)",
        "translate": ""
    },
    {
        "source": "Note that the alignment of the resulting layout will be the maximum of those of `self` and `next`, in order to ensure alignment of both parts.",
        "suggest": "请注意，最终布局的对齐方式将是 `self` 和 `next` 的最大对齐方式，以确保两个部分的对齐方式。",
        "translate": ""
    },
    {
        "source": "Returns `Ok((k, offset))`, where `k` is layout of the concatenated record and `offset` is the relative location, in bytes, of the start of the `next` embedded within the concatenated record (assuming that the record itself starts at offset 0).",
        "suggest": "返回 `Ok((k, offset))`，其中 `k` 是串联记录的布局，`offset` 是嵌入在串联记录中的 `next` 起始位置的相对位置 (以字节为单位) (假定记录本身从偏移量 0 开始)。",
        "translate": ""
    },
    {
        "source": "To calculate the layout of a `#[repr(C)]` structure and the offsets of the fields from its fields' layouts:",
        "suggest": "要计算 `#[repr(C)]` 结构体的布局以及字段与其字段布局的偏移量，请执行以下操作:",
        "translate": ""
    },
    {
        "source": "Creates a layout describing the record for `n` instances of `self`, with no padding between each instance.",
        "suggest": "创建一个布局，该布局描述 `self` 的 `n` 实例的记录，每个实例之间没有填充。",
        "translate": ""
    },
    {
        "source": "Note that, unlike `repeat`, `repeat_packed` does not guarantee that the repeated instances of `self` will be properly aligned, even if a given instance of `self` is properly aligned.",
        "suggest": "请注意，与 `repeat` 不同，即使给定的 `self` 实例正确对齐，`repeat_packed` 也不能保证 `self` 的重复实例将正确对齐。",
        "translate": ""
    },
    {
        "source": "In other words, if the layout returned by `repeat_packed` is used to allocate an array, it is not guaranteed that all elements in the array will be properly aligned.",
        "suggest": "换句话说，如果使用 `repeat_packed` 返回的布局来分配数组，则不能保证数组中的所有元素都将正确对齐。",
        "translate": ""
    },
    {
        "source": "Creates a layout describing the record for `self` followed by `next` with no additional padding between the two.",
        "suggest": "创建一个布局，描述 `self` 和 `next` 的记录，两者之间没有其他填充。",
        "translate": ""
    },
    {
        "source": "Since no padding is inserted, the alignment of `next` is irrelevant, and is not incorporated *at all* into the resulting layout.",
        "suggest": "由于没有插入填充，因此 `next` 的对齐方式是无关紧要的，并且不会将 *at all* 合并到结果布局中。",
        "translate": ""
    },
    {
        "source": "Creates a layout describing the record for a `[T; n]`.",
        "suggest": "创建一个布局，描述 `[T; n]` 的记录。",
        "translate": ""
    },
    {
        "source": "The parameters given to `Layout::from_size_align` or some other `Layout` constructor do not satisfy its documented constraints.",
        "suggest": "给 `Layout::from_size_align` 或其他 `Layout` 构造函数的参数不满足其记录的约束。",
        "translate": ""
    },
    {
        "source": "(we need this for downstream impl of trait Error)",
        "suggest": "(对于 trait 错误的下游隐含我们需要此功能)",
        "translate": ""
    },
    {
        "source": "The `AllocError` error indicates an allocation failure that may be due to resource exhaustion or to something wrong when combining the given input arguments with this allocator.",
        "suggest": "`AllocError` 错误表示分配失败，这可能是由于资源耗尽或将给定输入参数与此分配器组合在一起时出错所致。",
        "translate": ""
    },
    {
        "source": "An implementation of `Allocator` can allocate, grow, shrink, and deallocate arbitrary blocks of data described via [`Layout`][].",
        "suggest": "`Allocator` 的实现可以分配，增长，收缩和释放通过 [`Layout`][] 描述的任意数据块。",
        "translate": ""
    },
    {
        "source": "is designed to be implemented on ZSTs, references, or smart pointers because having an allocator like `MyAlloc([u8; N])` cannot be moved, without updating the pointers to the allocated memory.",
        "suggest": "之所以将其设计为在 ZST，引用或智能指针上实现，是因为如果不更新指向已分配内存的指针，则无法移动具有 `MyAlloc([u8; N])` 之类的分配器。",
        "translate": ""
    },
    {
        "source": "Unlike [`GlobalAlloc`][], zero-sized allocations are allowed in `Allocator`.",
        "suggest": "与 [`GlobalAlloc`][] 不同，`Allocator` 允许零大小的分配。",
        "translate": ""
    },
    {
        "source": "If an underlying allocator does not support this (like jemalloc) or return a null pointer (such as `libc::malloc`), this must be caught by the implementation.",
        "suggest": "如果基础分配器不支持此功能 (例如 jemalloc) 或返回空指针 (例如 `libc::malloc`)，则必须由实现捕获。",
        "translate": ""
    },
    {
        "source": "Currently allocated memory",
        "suggest": "当前分配的内存",
        "translate": ""
    },
    {
        "source": "the starting address for that memory block was previously returned by [`allocate`], [`grow`], or [`shrink`], and",
        "suggest": "该内存块的起始地址先前由 [`allocate`]，[`grow`] 或 [`shrink`] 返回，并且",
        "translate": ""
    },
    {
        "source": "the memory block has not been subsequently deallocated, where blocks are either deallocated directly by being passed to [`deallocate`] or were changed by being passed to [`grow`] or [`shrink`] that returns `Ok`.",
        "suggest": "内存块随后并未被释放，其中的块要么通过传递到 [`deallocate`] 直接释放，要么通过传递到返回 `Ok` 的 [`grow`] 或 [`shrink`] 进行了更改。",
        "translate": ""
    },
    {
        "source": "If `grow` or `shrink` have returned `Err`, the passed pointer remains valid.",
        "suggest": "如果 `grow` 或 `shrink` 返回了 `Err`，则传递的指针保持有效。",
        "translate": ""
    },
    {
        "source": "Memory fitting",
        "suggest": "内存拟合",
        "translate": ""
    },
    {
        "source": "Some of the methods require that a layout *fit* a memory block.",
        "suggest": "有些方法要求布局适合内存块。",
        "translate": ""
    },
    {
        "source": "What it means for a layout to \"fit\" a memory block means (or equivalently, for a memory block to \"fit\" a layout) is that the following conditions must hold:",
        "suggest": "对于到 \"fit\" 的布局，存储块意味着 (或者，对于到 \"fit\" 的存储块，布局意味着) 必须满足以下条件:",
        "translate": ""
    },
    {
        "source": "The block must be allocated with the same alignment as [`layout.align()`], and",
        "suggest": "必须以与 [`layout.align()`] 相同的对齐方式分配该块，并且",
        "translate": ""
    },
    {
        "source": "The provided [`layout.size()`] must fall in the range `min ..= max`, where:",
        "suggest": "提供的 [`layout.size()`] 必须在 `min ..= max` 范围内，其中:",
        "translate": ""
    },
    {
        "source": "is the size of the layout most recently used to allocate the block, and",
        "suggest": "是最近用于分配块的布局的大小，并且",
        "translate": ""
    },
    {
        "source": "is the latest actual size returned from [`allocate`], [`grow`], or [`shrink`].",
        "suggest": "是从 [`allocate`]，[`grow`] 或 [`shrink`] 返回的最新实际大小。",
        "translate": ""
    },
    {
        "source": "Memory blocks returned from an allocator must point to valid memory and retain their validity until the instance and all of its clones are dropped,",
        "suggest": "从分配器返回的内存块必须指向有效内存并保持其有效性，直到丢弃实例及其所有克隆为止，",
        "translate": ""
    },
    {
        "source": "cloning or moving the allocator must not invalidate memory blocks returned from this allocator.",
        "suggest": "克隆或移动分配器不得使此分配器返回的内存块无效。",
        "translate": ""
    },
    {
        "source": "A cloned allocator must behave like the same allocator, and",
        "suggest": "克隆的分配器的行为必须类似于相同的分配器，并且",
        "translate": ""
    },
    {
        "source": "any pointer to a memory block which is [*currently allocated*] may be passed to any other method of the allocator.",
        "suggest": "指向 [*currently allocated*] 的存储块的任何指针都可以传递给分配器的任何其他方法。",
        "translate": ""
    },
    {
        "source": "Attempts to allocate a block of memory.",
        "suggest": "尝试分配一块内存。",
        "translate": ""
    },
    {
        "source": "On success, returns a [`NonNull<[u8]>`][NonNull] meeting the size and alignment guarantees of `layout`.",
        "suggest": "成功后，返回满足 `layout` 大小和对齐保证的 [`NonNull<[u8]>`][NonNull]。",
        "translate": ""
    },
    {
        "source": "The returned block may have a larger size than specified by `layout.size()`, and may or may not have its contents initialized.",
        "suggest": "返回的块的大小可能大于 `layout.size()` 指定的大小，并且可能已初始化或未初始化其内容。",
        "translate": ""
    },
    {
        "source": "Returning `Err` indicates that either memory is exhausted or `layout` does not meet allocator's size or alignment constraints.",
        "suggest": "返回 `Err` 表示内存已耗尽，或者 `layout` 不满足分配器的大小或对齐约束。",
        "translate": ""
    },
    {
        "source": "Implementations are encouraged to return `Err` on memory exhaustion rather than panicking or aborting, but this is not a strict requirement.",
        "suggest": "鼓励实现在内存耗尽时返回 `Err`，而不是恐慌或终止，但是这不是严格的要求。",
        "translate": ""
    },
    {
        "source": "Behaves like `allocate`, but also ensures that the returned memory is zero-initialized.",
        "suggest": "行为类似于 `allocate`，但也确保返回的内存被零初始化。",
        "translate": ""
    },
    {
        "source": "`alloc` returns a valid memory block",
        "suggest": "`alloc` 返回有效的内存块",
        "translate": ""
    },
    {
        "source": "Deallocates the memory referenced by `ptr`.",
        "suggest": "释放 `ptr` 引用的内存。",
        "translate": ""
    },
    {
        "source": "must denote a block of memory [*currently allocated*] via this allocator, and",
        "suggest": "必须通过此分配器表示一个内存块 [*currently allocated*]，并且",
        "translate": ""
    },
    {
        "source": "must [*fit*] that block of memory.",
        "suggest": "必须 [*fit*] 该内存块。",
        "translate": ""
    },
    {
        "source": "Attempts to extend the memory block.",
        "suggest": "尝试扩展内存块。",
        "translate": ""
    },
    {
        "source": "Returns a new [`NonNull<[u8]>`][NonNull] containing a pointer and the actual size of the allocated memory.",
        "suggest": "返回一个新的 [`NonNull<[u8]>`][NonNull]，其中包含一个指针和分配的内存的实际大小。",
        "translate": ""
    },
    {
        "source": "The pointer is suitable for holding data described by `new_layout`.",
        "suggest": "该指针适用于保存 `new_layout` 描述的数据。",
        "translate": ""
    },
    {
        "source": "To accomplish this, the allocator may extend the allocation referenced by `ptr` to fit the new layout.",
        "suggest": "为此，分配器可以扩展 `ptr` 引用的分配以适合新的布局。",
        "translate": ""
    },
    {
        "source": "If this returns `Ok`, then ownership of the memory block referenced by `ptr` has been transferred to this allocator.",
        "suggest": "如果返回 `Ok`，则 `ptr` 引用的内存块的所有权已转移到此分配器。",
        "translate": ""
    },
    {
        "source": "The memory may or may not have been freed, and should be considered unusable unless it was transferred back to the caller again via the return value of this method.",
        "suggest": "内存可能已释放，也可能尚未释放，除非已通过此方法的返回值再次将其转移回调用方，否则应将其视为不可用。",
        "translate": ""
    },
    {
        "source": "If this method returns `Err`, then ownership of the memory block has not been transferred to this allocator, and the contents of the memory block are unaltered.",
        "suggest": "如果此方法返回 `Err`，则该存储块的所有权尚未转移到此分配器，并且该存储块的内容未更改。",
        "translate": ""
    },
    {
        "source": "must denote a block of memory [*currently allocated*] via this allocator.",
        "suggest": "必须通过此分配器表示一个内存 [*currently allocated*] 块。",
        "translate": ""
    },
    {
        "source": "must [*fit*] that block of memory (The `new_layout` argument need not fit it.).",
        "suggest": "必须 [*fit*] 该内存块 (`new_layout` 参数不需要适合它。)。",
        "translate": ""
    },
    {
        "source": "must be greater than or equal to `old_layout.size()`.",
        "suggest": "必须大于或等于 `old_layout.size()`。",
        "translate": ""
    },
    {
        "source": "Returns `Err` if the new layout does not meet the allocator's size and alignment constraints of the allocator, or if growing otherwise fails.",
        "suggest": "如果新布局不符合分配器的大小和分配器的对齐约束，或者如果增长失败，则返回 `Err`。",
        "translate": ""
    },
    {
        "source": "because `new_layout.size()` must be greater than or equal to `old_layout.size()`, both the old and new memory allocation are valid for reads and writes for `old_layout.size()` bytes.",
        "suggest": "因为 `new_layout.size()` 必须大于或等于 `old_layout.size()`，所以旧的和新的内存分配对于 `old_layout.size()` 字节的读取和写入均有效。",
        "translate": ""
    },
    {
        "source": "Behaves like `grow`, but also ensures that the new contents are set to zero before being returned.",
        "suggest": "行为类似于 `grow`，但也确保在返回新内容之前将其设置为零。",
        "translate": ""
    },
    {
        "source": "The memory block will contain the following contents after a successful call to",
        "suggest": "成功调用后，该存储块将包含以下内容",
        "translate": ""
    },
    {
        "source": "Bytes `0..old_layout.size()` are preserved from the original allocation.",
        "suggest": "字节 `0..old_layout.size()` 从原始分配中保留。",
        "translate": ""
    },
    {
        "source": "Bytes `old_layout.size()..old_size` will either be preserved or zeroed, depending on the allocator implementation.",
        "suggest": "字节 `old_layout.size()..old_size` 将保留还是清零，具体取决于分配器的实现。",
        "translate": ""
    },
    {
        "source": "refers to the size of the memory block prior to the `grow_zeroed` call, which may be larger than the size that was originally requested when it was allocated.",
        "suggest": "指的是 `grow_zeroed` 调用之前的内存块的大小，它可能大于分配时最初请求的大小。",
        "translate": ""
    },
    {
        "source": "Bytes `old_size..new_size` are zeroed.",
        "suggest": "字节 `old_size..new_size` 被清零。",
        "translate": ""
    },
    {
        "source": "`new_size` refers to the size of the memory block returned by the `grow_zeroed` call.",
        "suggest": "`new_size` 是指 `grow_zeroed` 调用返回的存储块的大小。",
        "translate": ""
    },
    {
        "source": "Attempts to shrink the memory block.",
        "suggest": "尝试缩小内存块。",
        "translate": ""
    },
    {
        "source": "To accomplish this, the allocator may shrink the allocation referenced by `ptr` to fit the new layout.",
        "suggest": "为此，分配器可以缩小 `ptr` 引用的分配以适合新的布局。",
        "translate": ""
    },
    {
        "source": "must be smaller than or equal to `old_layout.size()`.",
        "suggest": "必须小于或等于 `old_layout.size()`。",
        "translate": ""
    },
    {
        "source": "Returns `Err` if the new layout does not meet the allocator's size and alignment constraints of the allocator, or if shrinking otherwise fails.",
        "suggest": "如果新的布局不符合分配器的大小和分配器的对齐约束，或者缩小失败，则返回 `Err`。",
        "translate": ""
    },
    {
        "source": "because `new_layout.size()` must be lower than or equal to `old_layout.size()`, both the old and new memory allocation are valid for reads and writes for `new_layout.size()` bytes.",
        "suggest": "因为 `new_layout.size()` 必须小于或等于 `old_layout.size()`，所以旧的和新的内存分配对于 `new_layout.size()` 字节的读取和写入均有效。",
        "translate": ""
    },
    {
        "source": "Creates a \"by reference\" adaptor for this instance of `Allocator`.",
        "suggest": "为此 `Allocator` 实例创建 \"by reference\" 适配器。",
        "translate": ""
    },
    {
        "source": "The returned adaptor also implements `Allocator` and will simply borrow this.",
        "suggest": "返回的适配器还实现了 `Allocator`，将仅借用此适配器。",
        "translate": ""
    },
    {
        "source": "the safety contract must be upheld by the caller",
        "suggest": "调用者必须坚持安全保证",
        "translate": ""
    },
    {
        "source": "You're more likely to want this:",
        "suggest": "您更可能希望这样做:",
        "translate": ""
    },
    {
        "source": "than this:",
        "suggest": "比这个:",
        "translate": ""
    },
    {
        "source": "Logger function for any type that implements Debug.",
        "suggest": "用于实现 Debug 的任何类型的 Logger 函数。",
        "translate": ""
    },
    {
        "source": "Try to convert our value to a `String`.",
        "suggest": "尝试将我们的值转换为 `String`。",
        "translate": ""
    },
    {
        "source": "If successful, we want to output the String`'s length as well as its value.",
        "suggest": "如果成功，我们要输出 String 的长度及其值。",
        "translate": ""
    },
    {
        "source": "If not, it's a different type: just print it out unadorned.",
        "suggest": "如果不是，那是另一种类型: 只需将其打印出来而没有装饰。",
        "translate": ""
    },
    {
        "source": "This function wants to log its parameter out prior to doing work with it.",
        "suggest": "该函数要先注销其参数，然后再使用它。",
        "translate": ""
    },
    {
        "source": "...do some other work",
        "suggest": "... 做一些其他的工作",
        "translate": ""
    },
    {
        "source": "This module implements the `Any` trait, which enables dynamic typing of any `'static` type through runtime reflection.",
        "suggest": "该模块实现了 `Any` trait，它可以通过运行时反射来动态键入任何 `'static` 类型。",
        "translate": ""
    },
    {
        "source": "itself can be used to get a `TypeId`, and has more features when used as a trait object.",
        "suggest": "本身可以用来获取 `TypeId`，并用作 trait 对象时具有更多功能。",
        "translate": ""
    },
    {
        "source": "As `&dyn Any` (a borrowed trait object), it has the `is` and `downcast_ref` methods, to test if the contained value is of a given type, and to get a reference to the inner value as a type.",
        "suggest": "作为 `&dyn Any` (借用的 trait 对象)，它具有 `is` 和 `downcast_ref` 方法，以测试所包含的值是否为给定类型，并对该类型的内部值进行引用。",
        "translate": ""
    },
    {
        "source": "As `&mut dyn Any`, there is also the `downcast_mut` method, for getting a mutable reference to the inner value.",
        "suggest": "作为 `&mut dyn Any`，还有 `downcast_mut` 方法，用于获取内部值的变量引用。",
        "translate": ""
    },
    {
        "source": "adds the `downcast` method, which attempts to convert to a `Box<T>`.",
        "suggest": "添加了 `downcast` 方法，该方法尝试转换为 `Box<T>`。",
        "translate": ""
    },
    {
        "source": "See the [`Box`] documentation for the full details.",
        "suggest": "有关完整的详细信息，请参见 [`Box`] 文档。",
        "translate": ""
    },
    {
        "source": "Note that `&dyn Any` is limited to testing whether a value is of a specified concrete type, and cannot be used to test whether a type implements a trait.",
        "suggest": "请注意，`&dyn Any` 仅限于测试值是否为指定的具体类型，而不能用于测试某个类型是否实现 trait。",
        "translate": ""
    },
    {
        "source": "Smart pointers and `dyn Any`",
        "suggest": "智能指针和 `dyn Any`",
        "translate": ""
    },
    {
        "source": "One piece of behavior to keep in mind when using `Any` as a trait object, especially with types like `Box<dyn Any>` or `Arc<dyn Any>`, is that simply calling `.type_id()` on the value will produce the `TypeId` of the *container*, not the underlying trait object.",
        "suggest": "将 `Any` 用作 trait 对象时要记住的一种行为，尤其是对于 `Box<dyn Any>` 或 `Arc<dyn Any>` 之类的类型，只需在值上调用 `.type_id()` 即可生成 *容器* 的 `TypeId`，而不是基础 trait 对象。",
        "translate": ""
    },
    {
        "source": "This can be avoided by converting the smart pointer into a `&dyn Any` instead, which will return the object's `TypeId`.",
        "suggest": "可以通过将智能指针转换为 `&dyn Any` 来避免，这将返回对象的 `TypeId`。",
        "translate": ""
    },
    {
        "source": "Consider a situation where we want to log out a value passed to a function.",
        "suggest": "考虑一下我们要注销传递给函数的值的情况。",
        "translate": ""
    },
    {
        "source": "We know the value we're working on implements Debug, but we don't know its concrete type.",
        "suggest": "我们知道我们正在实现的值实现了 Debug，但是我们不知道它的具体类型。",
        "translate": ""
    },
    {
        "source": "We want to give special treatment to certain types: in this case printing out the length of String values prior to their value.",
        "suggest": "我们要对某些类型进行特殊处理: 在这种情况下，应先打印 String 值的长度，然后再打印它们的值。",
        "translate": ""
    },
    {
        "source": "We don't know the concrete type of our value at compile time, so we need to use runtime reflection instead.",
        "suggest": "我们在编译时不知道我们值的具体类型，因此我们需要使用运行时反射。",
        "translate": ""
    },
    {
        "source": "Any trait",
        "suggest": "任何 trait",
        "translate": ""
    },
    {
        "source": "A trait to emulate dynamic typing.",
        "suggest": "trait 来模拟动态类型。",
        "translate": ""
    },
    {
        "source": "Most types implement `Any`.",
        "suggest": "大多数类型实现 `Any`。",
        "translate": ""
    },
    {
        "source": "However, any type which contains a non-`'static` reference does not.",
        "suggest": "但是，任何包含非 `static' 引用的类型都不会。",
        "translate": ""
    },
    {
        "source": "See the [module-level documentation][mod] for more details.",
        "suggest": "有关更多详细信息，请参见 [模块级文档][mod]。",
        "translate": ""
    },
    {
        "source": "This trait is not unsafe, though we rely on the specifics of it's sole impl's `type_id` function in unsafe code (e.g., `downcast`).",
        "suggest": "这个 trait 并不是不安全的，尽管我们依靠不安全代码 (例如 `downcast`) 中唯一的 impl 的 `type_id` 函数的细节。",
        "translate": ""
    },
    {
        "source": "Normally, that would be a problem, but because the only impl of `Any` is a blanket implementation, no other code can implement `Any`.",
        "suggest": "通常，这将是一个问题，但是由于 `Any` 的唯一含义是全面实现，因此没有其他代码可以实现 `Any`。",
        "translate": ""
    },
    {
        "source": "We could plausibly make this trait unsafe -- it would not cause breakage, since we control all the implementations -- but we choose not to as that's both not really necessary and may confuse users about the distinction of unsafe traits and unsafe methods (i.e., `type_id` would still be safe to call, but we would likely want to indicate as such in documentation).",
        "suggest": "我们可以合理地使此 trait 不安全 - 因为我们控制所有实现，因此不会造成破坏 - 但我们选择不这样做，因为这既不是真正必要的，并且可能使用户混淆不安全的 traits 和不安全的方法 (即，`type_id` 仍然可以安全调用，但我们可能希望在文档中对此进行说明。",
        "translate": ""
    },
    {
        "source": "Gets the `TypeId` of `self`.",
        "suggest": "获取 `self` 的 `TypeId`。",
        "translate": ""
    },
    {
        "source": "Extension methods for Any trait objects.",
        "suggest": "任何 trait 对象的扩展方法。",
        "translate": ""
    },
    {
        "source": "Ensure that the result of e.g., joining a thread can be printed and hence used with `unwrap`.",
        "suggest": "确保可以打印出例如连接螺纹的结果，并因此可以与 `unwrap` 一起使用。",
        "translate": ""
    },
    {
        "source": "May eventually no longer be needed if dispatch works with upcasting.",
        "suggest": "如果调度与向上转换一起使用，则最终可能不再需要。",
        "translate": ""
    },
    {
        "source": "Returns `true` if the boxed type is the same as `T`.",
        "suggest": "如果 boxed 类型与 `T` 相同，则返回 `true`。",
        "translate": ""
    },
    {
        "source": "Get `TypeId` of the type this function is instantiated with.",
        "suggest": "获取实例化此函数的类型的 `TypeId`。",
        "translate": ""
    },
    {
        "source": "Get `TypeId` of the type in the trait object (`self`).",
        "suggest": "在 trait 对象 (`self`) 中获取该类型的 `TypeId`。",
        "translate": ""
    },
    {
        "source": "Compare both `TypeId`s on equality.",
        "suggest": "比较两个 `TypeId` 的相等性。",
        "translate": ""
    },
    {
        "source": "Returns some reference to the boxed value if it is of type `T`, or `None` if it isn't.",
        "suggest": "如果 boxed 的类型为 `T`，则返回一些引用，如果不是，则返回 `None`。",
        "translate": ""
    },
    {
        "source": "just checked whether we are pointing to the correct type, and we can rely on that check for memory safety because we have implemented Any for all types;",
        "suggest": "只需检查我们是否指向正确的类型，就可以依靠该检查来检查内存安全性，因为我们对所有类型都实现了 Any;",
        "translate": ""
    },
    {
        "source": "no other impls can exist as they would conflict with our impl.",
        "suggest": "没有其他迹象可能会存在，因为它们会与我们的迹象发生冲突。",
        "translate": ""
    },
    {
        "source": "Returns some mutable reference to the boxed value if it is of type `T`, or `None` if it isn't.",
        "suggest": "如果 boxed 的类型为 `T`，则返回一些可变引用; 如果不是，则返回 `None`。",
        "translate": ""
    },
    {
        "source": "Forwards to the method defined on the type `Any`.",
        "suggest": "转发到在 `Any` 类型上定义的方法。",
        "translate": ""
    },
    {
        "source": "TypeID and its methods",
        "suggest": "TypeID 及其方法",
        "translate": ""
    },
    {
        "source": "A `TypeId` represents a globally unique identifier for a type.",
        "suggest": "`TypeId` 代表类型的全局唯一标识符。",
        "translate": ""
    },
    {
        "source": "Each `TypeId` is an opaque object which does not allow inspection of what's inside but does allow basic operations such as cloning, comparison, printing, and showing.",
        "suggest": "每个 `TypeId` 是不透明的对象，它不允许检查内部内容，但可以进行基本操作，例如克隆，比较，打印和显示。",
        "translate": ""
    },
    {
        "source": "A `TypeId` is currently only available for types which ascribe to `'static`, but this limitation may be removed in the future.",
        "suggest": "`TypeId` 当前仅适用于归因于 `'static` 的类型，但是可以在 future 中消除此限制。",
        "translate": ""
    },
    {
        "source": "While `TypeId` implements `Hash`, `PartialOrd`, and `Ord`, it is worth noting that the hashes and ordering will vary between Rust releases.",
        "suggest": "虽然 `TypeId` 实现 `Hash`，`PartialOrd` 和 `Ord`，但值得注意的是，在 Rust 版本之间，哈希值和顺序将有所不同。",
        "translate": ""
    },
    {
        "source": "Beware of relying on them inside of your code!",
        "suggest": "当心在代码中依赖它们!",
        "translate": ""
    },
    {
        "source": "Returns the `TypeId` of the type this generic function has been instantiated with.",
        "suggest": "返回已实例化此泛型函数的类型的 `TypeId`。",
        "translate": ""
    },
    {
        "source": "Returns the name of a type as a string slice.",
        "suggest": "以字符串切片的形式返回类型的名称。",
        "translate": ""
    },
    {
        "source": "This is intended for diagnostic use.",
        "suggest": "这旨在用于诊断。",
        "translate": ""
    },
    {
        "source": "The exact contents and format of the string returned are not specified, other than being a best-effort description of the type.",
        "suggest": "除了作为尽力而为的类型描述之外，未指定返回的字符串的确切内容和格式。",
        "translate": ""
    },
    {
        "source": "For example, amongst the strings that `type_name::<Option<String>>()` might return are `\"Option<String>\"` and `\"std::option::Option<std::string::String>\"`.",
        "suggest": "例如，在 `type_name::<Option<String>>()` 可能返回的字符串中，有 `\"Option<String>\"` 和 `\"std::option::Option<std::string::String>\"`。",
        "translate": ""
    },
    {
        "source": "The returned string must not be considered to be a unique identifier of a type as multiple types may map to the same type name.",
        "suggest": "返回的字符串不得视为类型的唯一标识符，因为多个类型可能会 map 变为相同的类型名称。",
        "translate": ""
    },
    {
        "source": "Similarly, there is no guarantee that all parts of a type will appear in the returned string: for example, lifetime specifiers are currently not included.",
        "suggest": "同样，不能保证类型的所有部分都将出现在返回的字符串中: 例如，当前不包括生命周期说明符。",
        "translate": ""
    },
    {
        "source": "In addition, the output may change between versions of the compiler.",
        "suggest": "此外，输出可能会在编译器的版本之间改变。",
        "translate": ""
    },
    {
        "source": "The current implementation uses the same infrastructure as compiler diagnostics and debuginfo, but this is not guaranteed.",
        "suggest": "当前的实现使用与编译器诊断和 debuginfo 相同的基础结构，但这不能保证。",
        "translate": ""
    },
    {
        "source": "Returns the name of the type of the pointed-to value as a string slice.",
        "suggest": "以字符串切片的形式返回指向的值的类型的名称。",
        "translate": ""
    },
    {
        "source": "This is the same as `type_name::<T>()`, but can be used where the type of a variable is not easily available.",
        "suggest": "这与 `type_name::<T>()` 相同，但是可以在不容易获得变量类型的地方使用。",
        "translate": ""
    },
    {
        "source": "For example, `type_name_of_val::<Option<String>>(None)` could return `\"Option<String>\"` or `\"std::option::Option<std::string::String>\"`, but not `\"foobar\"`.",
        "suggest": "例如，`type_name_of_val::<Option<String>>(None)` 可以返回 `\"Option<String>\"` 或 `\"std::option::Option<std::string::String>\"`，但不能返回 `\"foobar\"`。",
        "translate": ""
    },
    {
        "source": "This function does not resolve trait objects, meaning that `type_name_of_val(&7u32 as &dyn Debug)` may return `\"dyn Debug\"`, but not `\"u32\"`.",
        "suggest": "此函数不能解析 trait 对象，这意味着 `type_name_of_val(&7u32 as &dyn Debug)` 可以返回 `\"dyn Debug\"`，但不能返回 `\"u32\"`。",
        "translate": ""
    },
    {
        "source": "The type name should not be considered a unique identifier of a type;",
        "suggest": "类型名称不应视为类型的唯一标识符;",
        "translate": ""
    },
    {
        "source": "multiple types may share the same type name.",
        "suggest": "多个类型可以共享相同的类型名称。",
        "translate": ""
    },
    {
        "source": "Prints the default integer and float types.",
        "suggest": "打印默认的整数和浮点类型。",
        "translate": ""
    },
    {
        "source": "The type of `value` is a `i32` here, instead of `&i32`",
        "suggest": "`value` 的类型在这里是 `i32`，而不是 `&i32`",
        "translate": ""
    },
    {
        "source": "Defines the `IntoIter` owned iterator for arrays.",
        "suggest": "为数组定义 `IntoIter` 拥有的迭代器。",
        "translate": ""
    },
    {
        "source": "A by-value [array] iterator.",
        "suggest": "一个按值的 [array] 迭代器。",
        "translate": ""
    },
    {
        "source": "This is the array we are iterating over.",
        "suggest": "这是我们要遍历的数组。",
        "translate": ""
    },
    {
        "source": "Elements with index `i` where `alive.start <= i < alive.end` have not been yielded yet and are valid array entries.",
        "suggest": "索引为 `i` 的元素 (尚未生成 `alive.start <= i < alive.end`) 是有效的数组条目。",
        "translate": ""
    },
    {
        "source": "Elements with indices `i < alive.start` or `i >= alive.end` have been yielded already and must not be accessed anymore!",
        "suggest": "索引为 `i < alive.start` 或 `i >= alive.end` 的元素已经产生，不能再访问了!",
        "translate": ""
    },
    {
        "source": "Those dead elements might even be in a completely uninitialized state!",
        "suggest": "那些死元素甚至可能处于完全未初始化的状态!",
        "translate": ""
    },
    {
        "source": "So the invariants are:",
        "suggest": "因此，不变式为:",
        "translate": ""
    },
    {
        "source": "is alive (i.e. contains valid elements)",
        "suggest": "还活着 (即包含有效元素)",
        "translate": ""
    },
    {
        "source": "and `data[alive.end..]` are dead (i.e. the elements were already read and must not be touched anymore!)",
        "suggest": "和 `data[alive.end..]` 已死 (即，元素已被读取，不能再触摸! )",
        "translate": ""
    },
    {
        "source": "The elements in `data` that have not been yielded yet.",
        "suggest": "`data` 中尚未产生的元素。",
        "translate": ""
    },
    {
        "source": "Creates a new iterator over the given `array`.",
        "suggest": "在给定的 `array` 上创建一个新的迭代器。",
        "translate": ""
    },
    {
        "source": "this method might be deprecated in the future, after [`IntoIterator` is implemented for arrays][array-into-iter].",
        "suggest": "[`IntoIterator` is implemented for arrays][array-into-iter] 之后，可能在 future 中不推荐使用此方法。",
        "translate": ""
    },
    {
        "source": "The transmute here is actually safe.",
        "suggest": "此处的转换实际上是安全的。",
        "translate": ""
    },
    {
        "source": "The docs of `MaybeUninit` promise:",
        "suggest": "`MaybeUninit` promise 的文档:",
        "translate": ""
    },
    {
        "source": "is guaranteed to have the same size and alignment",
        "suggest": "保证具有相同的大小和对齐方式",
        "translate": ""
    },
    {
        "source": "as `T`.",
        "suggest": "作为 `T`。",
        "translate": ""
    },
    {
        "source": "The docs even show a transmute from an array of `MaybeUninit<T>` to an array of `T`.",
        "suggest": "该文档甚至显示了从 `MaybeUninit<T>` 数组到 `T` 数组的转换。",
        "translate": ""
    },
    {
        "source": "With that, this initialization satisfies the invariants.",
        "suggest": "这样，该初始化就满足了不变性。",
        "translate": ""
    },
    {
        "source": "actually use `mem::transmute` here, once it works with const generics:",
        "suggest": "一旦与 const 泛型一起使用，就可以在这里实际使用 `mem::transmute`:",
        "translate": ""
    },
    {
        "source": "Until then, we can use `mem::transmute_copy` to create a bitwise copy as a different type, then forget `array` so that it is not dropped.",
        "suggest": "在此之前，我们可以使用 `mem::transmute_copy` 创建不同类型的按位副本，然后忘记 `array`，这样它就不会被丢弃。",
        "translate": ""
    },
    {
        "source": "Returns an immutable slice of all elements that have not been yielded yet.",
        "suggest": "返回尚未屈服的所有元素的不可变切片。",
        "translate": ""
    },
    {
        "source": "We know that all elements within `alive` are properly initialized.",
        "suggest": "我们知道 `alive` 中的所有元素都已正确初始化。",
        "translate": ""
    },
    {
        "source": "Returns a mutable slice of all elements that have not been yielded yet.",
        "suggest": "返回所有尚未屈服的元素的可变切片。",
        "translate": ""
    },
    {
        "source": "Get the next index from the front.",
        "suggest": "从前面获取下一个索引。",
        "translate": ""
    },
    {
        "source": "Increasing `alive.start` by 1 maintains the invariant regarding `alive`.",
        "suggest": "`alive.start` 增加 1 将保持 `alive` 的不变性。",
        "translate": ""
    },
    {
        "source": "However, due to this change, for a short time, the alive zone is not `data[alive]` anymore, but `data[idx..alive.end]`.",
        "suggest": "但是，由于此更改，在短时间内，活动区域不再是 `data[alive]`，而是 `data[idx..alive.end]`。",
        "translate": ""
    },
    {
        "source": "Read the element from the array.",
        "suggest": "从数组中读取元素。",
        "translate": ""
    },
    {
        "source": "`idx` is an index into the former \"alive\" region of the array.",
        "suggest": "`idx` 是数组前 \"alive\" 区域的索引。",
        "translate": ""
    },
    {
        "source": "Reading this element means that `data[idx]` is regarded as dead now (i.e.",
        "suggest": "读取此元素意味着 `data[idx]` 现在被视为已失效 (即",
        "translate": ""
    },
    {
        "source": "do not touch).",
        "suggest": "请勿触摸)。",
        "translate": ""
    },
    {
        "source": "As `idx` was the start of the alive-zone, the alive zone is now `data[alive]` again, restoring all invariants.",
        "suggest": "由于 `idx` 是活动区域的开始，因此活动区域现在又是 `data[alive]`，恢复了所有不可变变量。",
        "translate": ""
    },
    {
        "source": "Get the next index from the back.",
        "suggest": "从后面获取下一个索引。",
        "translate": ""
    },
    {
        "source": "Decreasing `alive.end` by 1 maintains the invariant regarding `alive`.",
        "suggest": "`alive.end` 减 1 保持 `alive` 不变。",
        "translate": ""
    },
    {
        "source": "However, due to this change, for a short time, the alive zone is not `data[alive]` anymore, but `data[alive.start..=idx]`.",
        "suggest": "但是，由于此更改，在短时间内，活动区域不再是 `data[alive]`，而是 `data[alive.start..=idx]`。",
        "translate": ""
    },
    {
        "source": "As `idx` was the end of the alive-zone, the alive zone is now `data[alive]` again, restoring all invariants.",
        "suggest": "由于 `idx` 是活动区域的结尾，因此活动区域现在又是 `data[alive]`，还原了所有不可变变量。",
        "translate": ""
    },
    {
        "source": "This is safe: `as_mut_slice` returns exactly the sub-slice of elements that have not been moved out yet and that remain to be dropped.",
        "suggest": "这是安全的: `as_mut_slice` 精确地返回尚未移出但仍要丢弃的元素的子切片。",
        "translate": ""
    },
    {
        "source": "Will never underflow due to the invariant `alive.start <= alive.end`.",
        "suggest": "不会因 `alive.start <= alive.end` 不变而下溢。",
        "translate": ""
    },
    {
        "source": "The iterator indeed reports the correct length.",
        "suggest": "迭代器确实报告了正确的长度。",
        "translate": ""
    },
    {
        "source": "The number of \"alive\" elements (that will still be yielded) is the length of the range `alive`.",
        "suggest": "\"alive\" 元素的数量 (仍将产生) 是 `alive` 范围的长度。",
        "translate": ""
    },
    {
        "source": "This range is decremented in length in either `next` or `next_back`.",
        "suggest": "在 `next` 或 `next_back` 中，此范围的长度减小。",
        "translate": ""
    },
    {
        "source": "It is always decremented by 1 in those methods, but only if `Some(_)` is returned.",
        "suggest": "在这些方法中，它总是减 1，但前提是要返回 `Some(_)`。",
        "translate": ""
    },
    {
        "source": "Note, we don't really need to match the exact same alive range, so we can just clone into offset 0 regardless of where `self` is.",
        "suggest": "注意，我们实际上并不需要完全匹配相同的有效范围，因此无论 `self` 在哪里，我们都可以克隆到偏移量 0 中。",
        "translate": ""
    },
    {
        "source": "Clone all alive elements.",
        "suggest": "克隆所有活动元素。",
        "translate": ""
    },
    {
        "source": "Write a clone into the new array, then update its alive range.",
        "suggest": "将克隆写入新阵列，然后更新其有效范围。",
        "translate": ""
    },
    {
        "source": "If cloning panics, we'll correctly drop the previous items.",
        "suggest": "如果克隆发生 panics，我们将正确丢弃前一个项。",
        "translate": ""
    },
    {
        "source": "Only print the elements that were not yielded yet: we cannot access the yielded elements anymore.",
        "suggest": "只打印尚未屈服的元素: 我们无法再访问屈服的元素。",
        "translate": ""
    },
    {
        "source": "We can still access the original array: it has not been moved.",
        "suggest": "我们仍然可以访问原始数组: 它尚未移动。",
        "translate": ""
    },
    {
        "source": "Implementations of things like `Eq` for fixed-length arrays up to a certain length.",
        "suggest": "`Eq` 之类的东西的实现，用于达到一定长度的固定长度数组。",
        "translate": ""
    },
    {
        "source": "Eventually, we should be able to generalize to all lengths.",
        "suggest": "最终，我们应该能够全面推广。",
        "translate": ""
    },
    {
        "source": "Converts a reference to `T` into a reference to an array of length 1 (without copying).",
        "suggest": "将 quotes 转换为 `T`，将 quotes 转换为长度为 1 的数组 (不进行复制)。",
        "translate": ""
    },
    {
        "source": "Converting `&T` to `&[T; 1]` is sound.",
        "suggest": "将 `&T` 转换为 `&[T; 1]` 是声音。",
        "translate": ""
    },
    {
        "source": "Converts a mutable reference to `T` into a mutable reference to an array of length 1 (without copying).",
        "suggest": "将变量引用转换为 `T`，将变量引用转换为长度为 1 的数组 (不进行复制)。",
        "translate": ""
    },
    {
        "source": "Converting `&mut T` to `&mut [T; 1]` is sound.",
        "suggest": "将 `&mut T` 转换为 `&mut [T; 1]` 是声音。",
        "translate": ""
    },
    {
        "source": "Utility trait implemented only on arrays of fixed size",
        "suggest": "实用程序 trait 仅在固定大小的数组上实现",
        "translate": ""
    },
    {
        "source": "This trait can be used to implement other traits on fixed-size arrays without causing much metadata bloat.",
        "suggest": "trait 可用于在固定大小的数组上实现其他 traits，而不会引起大量的元数据膨胀。",
        "translate": ""
    },
    {
        "source": "The trait is marked unsafe in order to restrict implementors to fixed-size arrays.",
        "suggest": "trait 被标记为不安全，以便将实现者限制为固定大小的数组。",
        "translate": ""
    },
    {
        "source": "A user of this trait can assume that implementors have the exact layout in memory of a fixed size array (for example, for unsafe initialization).",
        "suggest": "trait 的用户可以假定实现者在固定大小的数组的内存中具有准确的布局 (例如，用于不安全的初始化)。",
        "translate": ""
    },
    {
        "source": "Note that the traits [`AsRef`] and [`AsMut`] provide similar methods for types that may not be fixed-size arrays.",
        "suggest": "请注意，traits [`AsRef`] 和 [`AsMut`] 为可能不是固定大小的数组的类型提供了类似的方法。",
        "translate": ""
    },
    {
        "source": "Implementors should prefer those traits instead.",
        "suggest": "实现者应改用那些 traits。",
        "translate": ""
    },
    {
        "source": "Converts the array to immutable slice",
        "suggest": "将数组转换为不可变切片",
        "translate": ""
    },
    {
        "source": "Converts the array to mutable slice",
        "suggest": "将数组转换为可变切片",
        "translate": ""
    },
    {
        "source": "The error type returned when a conversion from a slice to an array fails.",
        "suggest": "从切片到数组的转换失败时返回的错误类型。",
        "translate": ""
    },
    {
        "source": "ok because we just checked that the length fits",
        "suggest": "好的，因为我们只是检查了长度是否合适",
        "translate": ""
    },
    {
        "source": "some less important impls are omitted to reduce code bloat __impl_slice_eq2!",
        "suggest": "省略一些不太重要的提示，以减少代码膨胀 __impl_slice_eq2!",
        "translate": ""
    },
    {
        "source": "Implements comparison of arrays [lexicographically](Ord#lexicographical-comparison).",
        "suggest": "实现数组 [按字典顺序](Ord#lexicographical-comparison) 的比较。",
        "translate": ""
    },
    {
        "source": "The Default impls cannot be done with const generics because `[T; 0]` doesn't require Default to be implemented, and having different impl blocks for different numbers isn't supported yet.",
        "suggest": "不能使用 const 泛型来完成 Default impls，因为 `[T; 0]` 不需要实现 Default，并且尚不支持针对不同数字使用不同的 impl 块。",
        "translate": ""
    },
    {
        "source": "Returns an array of the same size as `self`, with function `f` applied to each element in order.",
        "suggest": "返回大小与 `self` 相同的数组，并将函数 `f` 按顺序应用于每个元素。",
        "translate": ""
    },
    {
        "source": "we know for certain that this iterator will yield exactly `N` items.",
        "suggest": "我们肯定知道该迭代器将产生完全 `N` 项。",
        "translate": ""
    },
    {
        "source": "'Zips up' two arrays into a single array of pairs.",
        "suggest": "将两个阵列压缩为成对的单个阵列。",
        "translate": ""
    },
    {
        "source": "returns a new array where every element is a tuple where the first element comes from the first array, and the second element comes from the second array.",
        "suggest": "返回一个新数组，其中每个元素都是一个元组，其中第一个元素来自第一个数组，第二个元素来自第二个数组。",
        "translate": ""
    },
    {
        "source": "In other words, it zips two arrays together, into a single one.",
        "suggest": "换句话说，它将两个数组压缩在一起，成为一个数组。",
        "translate": ""
    },
    {
        "source": "Returns a slice containing the entire array.",
        "suggest": "返回包含整个数组的切片。",
        "translate": ""
    },
    {
        "source": "Returns a mutable slice containing the entire array.",
        "suggest": "返回包含整个数组的可变切片。",
        "translate": ""
    },
    {
        "source": "Borrows each element and returns an array of references with the same size as `self`.",
        "suggest": "借用每个元素，并返回一个引用数组，其大小与 `self` 相同。",
        "translate": ""
    },
    {
        "source": "This method is particularly useful if combined with other methods, like [`map`](#method.map).",
        "suggest": "如果与其他方法 (例如 [`map`](#method.map)) 结合使用，则此方法特别有用。",
        "translate": ""
    },
    {
        "source": "This way, you can avoid moving the original array if its elements are not `Copy`.",
        "suggest": "这样，如果原始数组的元素不是 `Copy`，则可以避免移动原始数组。",
        "translate": ""
    },
    {
        "source": "Borrows each element mutably and returns an array of mutable references with the same size as `self`.",
        "suggest": "借用每个元素，并返回与 `self` 相同大小的可变引用数组。",
        "translate": ""
    },
    {
        "source": "Pulls `N` items from `iter` and returns them as an array.",
        "suggest": "从 `iter` 中提取 `N` 项，并将它们作为数组返回。",
        "translate": ""
    },
    {
        "source": "If the iterator yields fewer than `N` items, this function exhibits undefined behavior.",
        "suggest": "如果迭代器产生的结果少于 `N` 项，则此函数显示未定义的行为。",
        "translate": ""
    },
    {
        "source": "See [`collect_into_array`] for more information.",
        "suggest": "有关更多信息，请参见 [`collect_into_array`]。",
        "translate": ""
    },
    {
        "source": "It is up to the caller to guarantee that `iter` yields at least `N` items.",
        "suggest": "取决于调用方，以确保 `iter` 至少产生 `N` 项。",
        "translate": ""
    },
    {
        "source": "Violating this condition causes undefined behavior.",
        "suggest": "违反此条件会导致未定义的行为。",
        "translate": ""
    },
    {
        "source": "`TrustedLen` here is somewhat of an experiment.",
        "suggest": "`TrustedLen` 在这里有点实验。",
        "translate": ""
    },
    {
        "source": "This is just an internal function, so feel free to remove if this bound turns out to be a bad idea.",
        "suggest": "这只是一个内联函数，因此如果发现此绑定不是一个好主意，请随时删除。",
        "translate": ""
    },
    {
        "source": "In that case, remember to also remove the lower bound `debug_assert!` below!",
        "suggest": "在这种情况下，请记住还要移除下面的下限 `debug_assert!`!",
        "translate": ""
    },
    {
        "source": "covered by the function contract.",
        "suggest": "函数契约涵盖的范围。",
        "translate": ""
    },
    {
        "source": "Since the iterator is passed as a mutable reference and this function calls `next` at most `N` times, the iterator can still be used afterwards to retrieve the remaining items.",
        "suggest": "由于迭代器是作为变量引用传递的，并且此函数最多 `N` 次调用 `next`，因此以后仍然可以使用迭代器来检索剩余项。",
        "translate": ""
    },
    {
        "source": "If `iter.next()` panicks, all items already yielded by the iterator are dropped.",
        "suggest": "如果 `iter.next()` 出现 panic，则丢弃迭代器已经生成的所有项。",
        "translate": ""
    },
    {
        "source": "An empty array is always inhabited and has no validity invariants.",
        "suggest": "空数组总是有人居住，没有有效性不变式。",
        "translate": ""
    },
    {
        "source": "this raw slice will contain only initialized objects.",
        "suggest": "此原始切片将仅包含初始化的对象。",
        "translate": ""
    },
    {
        "source": "`guard.initialized` starts at 0, is increased by one in the loop and the loop is aborted once it reaches N (which is `array.len()`).",
        "suggest": "`guard.initialized` 从 0 开始，在循环中加 1，一旦到达 N (`array.len()`)，循环就中止。",
        "translate": ""
    },
    {
        "source": "Check if the whole array was initialized.",
        "suggest": "检查整个数组是否已初始化。",
        "translate": ""
    },
    {
        "source": "the condition above asserts that all elements are initialized.",
        "suggest": "以上条件断言所有元素都已初始化。",
        "translate": ""
    },
    {
        "source": "This is only reached if the iterator is exhausted before `guard.initialized` reaches `N`.",
        "suggest": "仅当 `guard.initialized` 到达 `N` 之前迭代器已耗尽时，才可以达到此目的。",
        "translate": ""
    },
    {
        "source": "Also note that `guard` is dropped here, dropping all already initialized elements.",
        "suggest": "还要注意的是，这里将 `guard` 放在了这里，丢弃了所有已经初始化的元素。",
        "translate": ""
    },
    {
        "source": "Operations on ASCII strings and characters.",
        "suggest": "对 ASCII 字符串和字符的操作。",
        "translate": ""
    },
    {
        "source": "Most string operations in Rust act on UTF-8 strings.",
        "suggest": "Rust 中的大多数字符串操作都作用于 UTF-8 字符串。",
        "translate": ""
    },
    {
        "source": "However, at times it makes more sense to only consider the ASCII character set for a specific operation.",
        "suggest": "但是，有时只考虑针对特定操作的 ASCII 字符集更有意义。",
        "translate": ""
    },
    {
        "source": "The [`escape_default`] function provides an iterator over the bytes of an escaped version of the character given.",
        "suggest": "[`escape_default`] 函数在给定字符的转义版本的字节上提供迭代器。",
        "translate": ""
    },
    {
        "source": "An iterator over the escaped version of a byte.",
        "suggest": "在字节的转义版本上进行迭代的迭代器。",
        "translate": ""
    },
    {
        "source": "This `struct` is created by the [`escape_default`] function.",
        "suggest": "该 `struct` 由 [`escape_default`] 函数创建。",
        "translate": ""
    },
    {
        "source": "Returns an iterator that produces an escaped version of a `u8`.",
        "suggest": "返回一个迭代器，该迭代器生成 `u8` 的转义版本。",
        "translate": ""
    },
    {
        "source": "The default is chosen with a bias toward producing literals that are legal in a variety of languages, including C++11 and similar C-family languages.",
        "suggest": "选择默认值时会偏向于生成在多种语言 (包括 C++ 11 和类似的 C 系列语言) 中都合法的字面量。",
        "translate": ""
    },
    {
        "source": "The exact rules are:",
        "suggest": "确切的规则是:",
        "translate": ""
    },
    {
        "source": "Tab is escaped as `\\t`.",
        "suggest": "制表符被转义为 `\\t`。",
        "translate": ""
    },
    {
        "source": "Carriage return is escaped as `\\r`.",
        "suggest": "回车符被转义为 `\\r`。",
        "translate": ""
    },
    {
        "source": "Line feed is escaped as `\\n`.",
        "suggest": "换行符转为 `\\n`。",
        "translate": ""
    },
    {
        "source": "Single quote is escaped as `\\'`.",
        "suggest": "单引号转义为 `\\'`。",
        "translate": ""
    },
    {
        "source": "Double quote is escaped as `\\\"`.",
        "suggest": "双引号转义为 `\\\"`。",
        "translate": ""
    },
    {
        "source": "Backslash is escaped as `\\\\`.",
        "suggest": "反斜杠转义为 `\\\\`。",
        "translate": ""
    },
    {
        "source": "Any character in the 'printable ASCII' range `0x20` ..",
        "suggest": "`可打印 ASCII` 范围 `0x20` .. 中的任何字符",
        "translate": ""
    },
    {
        "source": "`0x7e` inclusive is not escaped.",
        "suggest": "`0x7e` (含 `0x7e`) 不会转义。",
        "translate": ""
    },
    {
        "source": "Any other chars are given hex escapes of the form '\\xNN'.",
        "suggest": "任何其他字符都以 '\\xNN' 形式给出十六进制转义。",
        "translate": ""
    },
    {
        "source": "Unicode escapes are never generated by this function.",
        "suggest": "此函数从不生成 Unicode 转义。",
        "translate": ""
    },
    {
        "source": "ok because `escape_default` created only valid utf-8 data",
        "suggest": "好的，因为 `escape_default` 仅创建了有效的 utf-8 数据",
        "translate": ""
    },
    {
        "source": "Returns `Some(t)` if the `bool` is `true`, or `None` otherwise.",
        "suggest": "如果 `bool` 是 `true`，则返回 `Some(t)`，否则返回 `None`。",
        "translate": ""
    },
    {
        "source": "Returns `Some(f())` if the `bool` is `true`, or `None` otherwise.",
        "suggest": "如果 `bool` 是 `true`，则返回 `Some(f())`，否则返回 `None`。",
        "translate": ""
    },
    {
        "source": "fields omitted",
        "suggest": "字段省略",
        "translate": ""
    },
    {
        "source": "A trait for borrowing data.",
        "suggest": "借用数据的 trait。",
        "translate": ""
    },
    {
        "source": "In Rust, it is common to provide different representations of a type for different use cases.",
        "suggest": "在 Rust 中，通常为不同的用例提供类型的不同表示形式。",
        "translate": ""
    },
    {
        "source": "For instance, storage location and management for a value can be specifically chosen as appropriate for a particular use via pointer types such as [`Box<T>`] or [`Rc<T>`].",
        "suggest": "例如，可以通过指针类型 (例如 [`Box<T>`] 或 [`Rc<T>`]) 为特定用途适当地选择值的存储位置和管理。",
        "translate": ""
    },
    {
        "source": "Beyond these generic wrappers that can be used with any type, some types provide optional facets providing potentially costly functionality.",
        "suggest": "除了这些可以与任何类型一起使用的泛型包装之外，某些类型还提供了可选的构面，从而提供了可能昂贵的功能。",
        "translate": ""
    },
    {
        "source": "An example for such a type is [`String`] which adds the ability to extend a string to the basic [`str`].",
        "suggest": "这种类型的一个示例是 [`String`]，它增加了将字符串扩展到基本 [`str`] 的功能。",
        "translate": ""
    },
    {
        "source": "This requires keeping additional information unnecessary for a simple, immutable string.",
        "suggest": "这要求保持简单的不可变字符串不需要的其他信息。",
        "translate": ""
    },
    {
        "source": "These types provide access to the underlying data through references to the type of that data.",
        "suggest": "这些类型通过引用该数据的类型来提供对基础数据的访问。",
        "translate": ""
    },
    {
        "source": "They are said to be ‘borrowed as’ that type.",
        "suggest": "据说它们是借来的那种类型的。",
        "translate": ""
    },
    {
        "source": "For instance, a [`Box<T>`] can be borrowed as `T` while a [`String`] can be borrowed as `str`.",
        "suggest": "例如，可以将 [`Box<T>`] 作为 `T` 借用，而可以将 [`String`] 作为 `str` 借用。",
        "translate": ""
    },
    {
        "source": "Types express that they can be borrowed as some type `T` by implementing `Borrow<T>`, providing a reference to a `T` in the trait’s [`borrow`] method.",
        "suggest": "类型表示可以通过实现 `Borrow<T>` 来借用它们作为某种类型的 `T`，并在 trait 的 [`borrow`] 方法中对 `T` 进行引用。",
        "translate": ""
    },
    {
        "source": "A type is free to borrow as several different types.",
        "suggest": "一个类型可以自由借用为几种不同的类型。",
        "translate": ""
    },
    {
        "source": "If it wishes to mutably borrow as the type – allowing the underlying data to be modified, it can additionally implement [`BorrowMut<T>`].",
        "suggest": "如果希望将类型可变为借用-允许修改基础数据，则可以另外实现 [`BorrowMut<T>`]。",
        "translate": ""
    },
    {
        "source": "Further, when providing implementations for additional traits, it needs to be considered whether they should behave identical to those of the underlying type as a consequence of acting as a representation of that underlying type.",
        "suggest": "此外，在为其他 traits 提供实现时，需要考虑由于充当该基础类型的表示而导致它们的行为是否与基础类型的行为相同。",
        "translate": ""
    },
    {
        "source": "Generic code typically uses `Borrow<T>` when it relies on the identical behavior of these additional trait implementations.",
        "suggest": "当泛型代码依赖于这些其他 trait 实现的相同行为时，通常会使用 `Borrow<T>`。",
        "translate": ""
    },
    {
        "source": "These traits will likely appear as additional trait bounds.",
        "suggest": "这些 traits 可能会显示为其他 trait bounds。",
        "translate": ""
    },
    {
        "source": "In particular `Eq`, `Ord` and `Hash` must be equivalent for borrowed and owned values: `x.borrow() == y.borrow()` should give the same result as `x == y`.",
        "suggest": "特别是对于借用和拥有的值，`Eq`，`Ord` 和 `Hash` 必须等效: `x.borrow() == y.borrow()` 的结果应与 `x == y` 相同。",
        "translate": ""
    },
    {
        "source": "If generic code merely needs to work for all types that can provide a reference to related type `T`, it is often better to use [`AsRef<T>`] as more types can safely implement it.",
        "suggest": "如果泛型代码只需要为可以为相关类型 `T` 提供引用的所有类型工作，则通常最好使用 [`AsRef<T>`]，因为更多类型可以安全地实现它。",
        "translate": ""
    },
    {
        "source": "As a data collection, [`HashMap<K, V>`] owns both keys and values.",
        "suggest": "作为数据集合，[`HashMap<K, V>`] 同时拥有键和值。",
        "translate": ""
    },
    {
        "source": "If the key’s actual data is wrapped in a managing type of some kind, it should, however, still be possible to search for a value using a reference to the key’s data.",
        "suggest": "如果键的实际数据包装在某种管理类型中，则仍然应该可以使用对键数据的引用来搜索值。",
        "translate": ""
    },
    {
        "source": "For instance, if the key is a string, then it is likely stored with the hash map as a [`String`], while it should be possible to search using a [`&str`][`str`].",
        "suggest": "例如，如果键是一个字符串，则它很可能与哈希 map 一起存储为 [`String`]，而应该可以使用 [`&str`][`str`] 进行搜索。",
        "translate": ""
    },
    {
        "source": "Thus, `insert` needs to operate on a `String` while `get` needs to be able to use a `&str`.",
        "suggest": "因此，`insert` 需要在 `String` 上运行，而 `get` 需要能够使用 `&str`。",
        "translate": ""
    },
    {
        "source": "Slightly simplified, the relevant parts of `HashMap<K, V>` look like this:",
        "suggest": "略有简化，`HashMap<K, V>` 的相关部分如下所示:",
        "translate": ""
    },
    {
        "source": "The entire hash map is generic over a key type `K`.",
        "suggest": "整个哈希 map 在键类型 `K` 上是泛型的。",
        "translate": ""
    },
    {
        "source": "Because these keys are stored with the hash map, this type has to own the key’s data.",
        "suggest": "由于这些键存储在哈希 map 中，因此该类型必须拥有键的数据。",
        "translate": ""
    },
    {
        "source": "When inserting a key-value pair, the map is given such a `K` and needs to find the correct hash bucket and check if the key is already present based on that `K`.",
        "suggest": "插入键值对时，会给 map 这样的 `K`，并且需要找到正确的哈希值存储区，并根据该 `K` 检查键是否已存在。",
        "translate": ""
    },
    {
        "source": "It therefore requires `K: Hash + Eq`.",
        "suggest": "因此，它需要 `K: Hash + Eq`。",
        "translate": ""
    },
    {
        "source": "When searching for a value in the map, however, having to provide a reference to a `K` as the key to search for would require to always create such an owned value.",
        "suggest": "但是，在 map 中搜索值时，必须提供 `K` 的引用作为搜索键，这要求始终创建此类拥有的值。",
        "translate": ""
    },
    {
        "source": "For string keys, this would mean a `String` value needs to be created just for the search for cases where only a `str` is available.",
        "suggest": "对于字符串键，这意味着仅在搜索仅 `str` 可用的情况下，才需要创建 `String` 值。",
        "translate": ""
    },
    {
        "source": "Instead, the `get` method is generic over the type of the underlying key data, called `Q` in the method signature above.",
        "suggest": "相反，`get` 方法是基础键数据类型的泛型，在上面的方法签名中称为 `Q`。",
        "translate": ""
    },
    {
        "source": "It states that `K` borrows as a `Q` by requiring that `K: Borrow<Q>`.",
        "suggest": "它通过要求 `K: Borrow<Q>` 来声明 `K` 借用为 `Q`。",
        "translate": ""
    },
    {
        "source": "By additionally requiring `Q: Hash + Eq`, it signals the requirement that `K` and `Q` have implementations of the `Hash` and `Eq` traits that produce identical results.",
        "suggest": "通过额外要求 `Q: Hash + Eq`，它表示要求 `K` 和 `Q` 具有 `Hash` 和 `Eq` traits 的实现，它们会产生相同的结果。",
        "translate": ""
    },
    {
        "source": "The implementation of `get` relies in particular on identical implementations of `Hash` by determining the key’s hash bucket by calling `Hash::hash` on the `Q` value even though it inserted the key based on the hash value calculated from the `K` value.",
        "suggest": "`get` 的实现尤其依赖于 `Hash` 的相同实现，即通过基于 `Q` 值计算出的哈希值插入键，通过在 `Q` 值上调用 `Hash::hash` 来确定键的哈希存储桶。",
        "translate": ""
    },
    {
        "source": "As a consequence, the hash map breaks if a `K` wrapping a `Q` value produces a different hash than `Q`.",
        "suggest": "结果，如果包装了 `Q` 值的 `K` 产生与 `Q` 不同的哈希，则哈希 map 会中断。",
        "translate": ""
    },
    {
        "source": "For instance, imagine you have a type that wraps a string but compares ASCII letters ignoring their case:",
        "suggest": "例如，假设您有一个包裹字符串但比较 ASCII 字母而忽略大小写的类型:",
        "translate": ""
    },
    {
        "source": "Because two equal values need to produce the same hash value, the implementation of `Hash` needs to ignore ASCII case, too:",
        "suggest": "因为两个相等的值需要产生相同的哈希值，所以 `Hash` 的实现也需要忽略 ASCII 大小写:",
        "translate": ""
    },
    {
        "source": "Can `CaseInsensitiveString` implement `Borrow<str>`?",
        "suggest": "`CaseInsensitiveString` 可以实现 `Borrow<str>` 吗?",
        "translate": ""
    },
    {
        "source": "It certainly can provide a reference to a string slice via its contained owned string.",
        "suggest": "它当然可以通过其包含的拥有的字符串为字符串片段提供引用。",
        "translate": ""
    },
    {
        "source": "But because its `Hash` implementation differs, it behaves differently from `str` and therefore must not, in fact, implement `Borrow<str>`.",
        "suggest": "但是由于 `Hash` 的实现方式不同，所以它的行为与 `str` 不同，因此，实际上，一定不能实现 `Borrow<str>`。",
        "translate": ""
    },
    {
        "source": "If it wants to allow others access to the underlying `str`, it can do that via `AsRef<str>` which doesn’t carry any extra requirements.",
        "suggest": "如果它希望允许其他人访问基础 `str`，则可以通过 `AsRef<str>` 来实现，而 `AsRef<str>` 则没有任何额外的要求。",
        "translate": ""
    },
    {
        "source": "Immutably borrows from an owned value.",
        "suggest": "从拥有的值中一成不变地借用。",
        "translate": ""
    },
    {
        "source": "A trait for mutably borrowing data.",
        "suggest": "用于可变借用数据的 trait。",
        "translate": ""
    },
    {
        "source": "As a companion to [`Borrow<T>`] this trait allows a type to borrow as an underlying type by providing a mutable reference.",
        "suggest": "作为 [`Borrow<T>`] 的伴侣，此 trait 通过提供变量引用允许类型借用作为基础类型。",
        "translate": ""
    },
    {
        "source": "See [`Borrow<T>`] for more information on borrowing as another type.",
        "suggest": "请参见 [`Borrow<T>`]，以了解更多有关借用另一种类型的信息。",
        "translate": ""
    },
    {
        "source": "Mutably borrows from an owned value.",
        "suggest": "从拥有的值中借用。",
        "translate": ""
    },
    {
        "source": "Create a new block to limit the scope of the dynamic borrow",
        "suggest": "创建一个新块以限制动态借用的作用域",
        "translate": ""
    },
    {
        "source": "Note that if we had not let the previous borrow of the cache fall out of scope then the subsequent borrow would cause a dynamic thread panic.",
        "suggest": "请注意，如果我们没有让缓存的上一次借用离开作用域，那么后续的借用将导致动态线程 panic。",
        "translate": ""
    },
    {
        "source": "This is the major hazard of using `RefCell`.",
        "suggest": "这是使用 `RefCell` 的主要危险。",
        "translate": ""
    },
    {
        "source": "Expensive computation goes here",
        "suggest": "昂贵的计算在这里",
        "translate": ""
    },
    {
        "source": "`my_struct` is immutable my_struct.regular_field = new_value;",
        "suggest": "`my_struct` 是不可变 my_struct.regular_field =new_value;",
        "translate": ""
    },
    {
        "source": "although `my_struct` is immutable, `special_field` is a `Cell`, which can always be mutated",
        "suggest": "尽管 `my_struct` 是不可变的，但是 `special_field` 是 `Cell`，可以随时对其进行修改",
        "translate": ""
    },
    {
        "source": "this causes a panic",
        "suggest": "这导致 panic",
        "translate": ""
    },
    {
        "source": "Get multiple / concurrent / shared references to the same `x`.",
        "suggest": "对同一个 `x` 获取多个 / 并发 / 共享引用。",
        "translate": ""
    },
    {
        "source": "within this scope there are no other references to `x`'s contents, so ours is effectively unique.",
        "suggest": "在此作用域内，对 x 的内容没有其他引用，因此我们的内容实际上是唯一的。",
        "translate": ""
    },
    {
        "source": "borrow --+",
        "suggest": "借用 --+",
        "translate": ""
    },
    {
        "source": "cannot go beyond this point -------------------+",
        "suggest": "不能超出这一点 --- ----------------+",
        "translate": ""
    },
    {
        "source": "within this scope nobody expects to have exclusive access to `x`'s contents, so we can have multiple shared accesses concurrently.",
        "suggest": "在此作用域内，没有人期望对 x 的内容具有独占访问权，因此我们可以同时进行多个共享访问。",
        "translate": ""
    },
    {
        "source": "with exclusive accesses,",
        "suggest": "具有独占访问权，",
        "translate": ""
    },
    {
        "source": "is a transparent no-op wrapper, so no need for `unsafe` here.",
        "suggest": "是透明的无操作包装器，因此这里不需要 `unsafe`。",
        "translate": ""
    },
    {
        "source": "Get a compile-time-checked unique reference to `x`.",
        "suggest": "获得对 `x` 进行编译时检查的唯一引用。",
        "translate": ""
    },
    {
        "source": "With an exclusive reference, we can mutate the contents for free.",
        "suggest": "使用独家引用，我们可以免费更改内容。",
        "translate": ""
    },
    {
        "source": "Or, equivalently:",
        "suggest": "或者，等效地:",
        "translate": ""
    },
    {
        "source": "When we own the value, we can extract the contents for free.",
        "suggest": "当我们拥有该值时，我们可以免费提取内容。",
        "translate": ""
    },
    {
        "source": "Shareable mutable containers.",
        "suggest": "可共享的可变容器。",
        "translate": ""
    },
    {
        "source": "Rust memory safety is based on this rule: Given an object `T`, it is only possible to have one of the following:",
        "suggest": "Rust 内存安全基于以下规则: 给定对象 `T`，则只能具有以下之一:",
        "translate": ""
    },
    {
        "source": "Having several immutable references (`&T`) to the object (also known as **aliasing**).",
        "suggest": "对对象具有多个不可变引用 (`&T`) (也称为别名)。",
        "translate": ""
    },
    {
        "source": "Having one mutable reference (`&mut T`) to the object (also known as **mutability**).",
        "suggest": "对对象有一个可变引用 (`&mut T`) (也称为 **可变性**)。",
        "translate": ""
    },
    {
        "source": "This is enforced by the Rust compiler.",
        "suggest": "这由 Rust 编译器强制执行。",
        "translate": ""
    },
    {
        "source": "However, there are situations where this rule is not flexible enough.",
        "suggest": "但是，在某些情况下，此规则不够灵活。",
        "translate": ""
    },
    {
        "source": "Sometimes it is required to have multiple references to an object and yet mutate it.",
        "suggest": "有时需要对一个对象进行多次引用，然后对其进行可变的。",
        "translate": ""
    },
    {
        "source": "Shareable mutable containers exist to permit mutability in a controlled manner, even in the presence of aliasing.",
        "suggest": "存在共享的可变容器以允许以受控的方式进行可变性，即使在出现混叠的情况下也是如此。",
        "translate": ""
    },
    {
        "source": "Both [`Cell<T>`] and [`RefCell<T>`] allow doing this in a single-threaded way.",
        "suggest": "[`Cell<T>`] 和 [`RefCell<T>`] 都允许以单线程方式执行此操作。",
        "translate": ""
    },
    {
        "source": "However, neither `Cell<T>` nor `RefCell<T>` are thread safe (they do not implement [`Sync`]).",
        "suggest": "但是，`Cell<T>` 和 `RefCell<T>` 都不是线程安全的 (它们不实现 [`Sync`])。",
        "translate": ""
    },
    {
        "source": "If you need to do aliasing and mutation between multiple threads it is possible to use [`Mutex<T>`], [`RwLock<T>`] or [`atomic`] types.",
        "suggest": "如果需要在多个线程之间进行别名和可变的，则可以使用 [`Mutex<T>`]，[`RwLock<T>`] 或 [`atomic`] 类型。",
        "translate": ""
    },
    {
        "source": "Values of the `Cell<T>` and `RefCell<T>` types may be mutated through shared references (i.e.",
        "suggest": "`Cell<T>` 和 `RefCell<T>` 类型的值可以通过共享引用 (例如",
        "translate": ""
    },
    {
        "source": "the common `&T` type), whereas most Rust types can only be mutated through unique (`&mut T`) references.",
        "suggest": "常见的 `&T` 类型)，而大多数 Rust 类型只能通过唯一的 (`&mut T`) 引用进行可变的。",
        "translate": ""
    },
    {
        "source": "We say that `Cell<T>` and `RefCell<T>` provide 'interior mutability', in contrast with typical Rust types that exhibit 'inherited mutability'.",
        "suggest": "我们说 `Cell<T>` 和 `RefCell<T>` 提供了内部可变性，而典型的 Rust 类型却表现出继承的可变性。",
        "translate": ""
    },
    {
        "source": "Cell types come in two flavors: `Cell<T>` and `RefCell<T>`.",
        "suggest": "Cell 类型有两种: `Cell<T>` 和 `RefCell<T>`。",
        "translate": ""
    },
    {
        "source": "`Cell<T>` implements interior mutability by moving values in and out of the `Cell<T>`.",
        "suggest": "`Cell<T>` 通过将值移入和移出 `Cell<T>` 来实现内部可变性。",
        "translate": ""
    },
    {
        "source": "To use references instead of values, one must use the `RefCell<T>` type, acquiring a write lock before mutating.",
        "suggest": "要使用 quot 代替值，必须使用 `RefCell<T>` 类型，在可变之前获取一个写锁。",
        "translate": ""
    },
    {
        "source": "`Cell<T>` provides methods to retrieve and change the current interior value:",
        "suggest": "`Cell<T>` 提供了检索和更改当前内部值的方法:",
        "translate": ""
    },
    {
        "source": "For types that implement [`Copy`], the [`get`](Cell::get) method retrieves the current interior value.",
        "suggest": "对于实现 [`Copy`] 的类型，[`get`](Cell::get) 方法检索当前内部值。",
        "translate": ""
    },
    {
        "source": "For types that implement [`Default`], the [`take`](Cell::take) method replaces the current interior value with [`Default::default()`] and returns the replaced value.",
        "suggest": "对于实现 [`Default`] 的类型，[`take`](Cell::take) 方法将当前内部值替换为 [`Default::default()`]，然后返回替换后的值。",
        "translate": ""
    },
    {
        "source": "For all types, the [`replace`](Cell::replace) method replaces the current interior value and returns the replaced value and the [`into_inner`](Cell::into_inner) method consumes the `Cell<T>` and returns the interior value.",
        "suggest": "对于所有类型，[`replace`](Cell::replace) 方法将替换当前内部值并返回替换后的值，而 [`into_inner`](Cell::into_inner) 方法将使用 `Cell<T>` 并返回内部值。",
        "translate": ""
    },
    {
        "source": "Additionally, the [`set`](Cell::set) method replaces the interior value, dropping the replaced value.",
        "suggest": "此外，[`set`](Cell::set) 方法替换内部值，丢弃替换后的值。",
        "translate": ""
    },
    {
        "source": "uses Rust's lifetimes to implement 'dynamic borrowing', a process whereby one can claim temporary, exclusive, mutable access to the inner value.",
        "suggest": "使用 Rust 的生命周期实现动态借用，这一过程使人们可以要求临时，排他，可变地访问内部值。",
        "translate": ""
    },
    {
        "source": "Borrows for `RefCell<T>`s are tracked 'at runtime', unlike Rust's native reference types which are entirely tracked statically, at compile time.",
        "suggest": "借用 for`RefCell<T>s 是在` 运行时 ` 被跟踪的，这与 Rust 的原生引用类型不同，后者在编译时是完全静态跟踪的。",
        "translate": ""
    },
    {
        "source": "Because `RefCell<T>` borrows are dynamic it is possible to attempt to borrow a value that is already mutably borrowed;",
        "suggest": "由于 `RefCell<T>` 借用是动态的，因此可以尝试借用已经可变借用的值;",
        "translate": ""
    },
    {
        "source": "when this happens it results in thread panic.",
        "suggest": "发生这种情况时，将导致线程 panic。",
        "translate": ""
    },
    {
        "source": "When to choose interior mutability",
        "suggest": "何时选择内部可变性",
        "translate": ""
    },
    {
        "source": "The more common inherited mutability, where one must have unique access to mutate a value, is one of the key language elements that enables Rust to reason strongly about pointer aliasing, statically preventing crash bugs.",
        "suggest": "更常见的继承的可变性 (其中必须具有对值的唯一访问权) 是使 Rust 能够强烈考虑指针别名的关键语言元素之一，从而可以静态地防止崩溃错误。",
        "translate": ""
    },
    {
        "source": "Because of that, inherited mutability is preferred, and interior mutability is something of a last resort.",
        "suggest": "因此，首选继承的可变性，而内部可变性则是不得已而为之。",
        "translate": ""
    },
    {
        "source": "Since cell types enable mutation where it would otherwise be disallowed though, there are occasions when interior mutability might be appropriate, or even *must* be used, e.g.",
        "suggest": "由于细胞类型可以实现原本不允许的可变的，因此有时可能需要内部可变性，甚至必须 *使用*",
        "translate": ""
    },
    {
        "source": "Introducing mutability 'inside' of something immutable",
        "suggest": "介绍事物的可变性 'inside'",
        "translate": ""
    },
    {
        "source": "Implementation details of logically-immutable methods.",
        "suggest": "逻辑不可变方法的实现细节。",
        "translate": ""
    },
    {
        "source": "Mutating implementations of [`Clone`].",
        "suggest": "更改 [`Clone`] 的实现。",
        "translate": ""
    },
    {
        "source": "Many shared smart pointer types, including [`Rc<T>`] and [`Arc<T>`], provide containers that can be cloned and shared between multiple parties.",
        "suggest": "许多共享的智能指针类型，包括 [`Rc<T>`] 和 [`Arc<T>`]，都提供了可以在多方之间克隆和共享的容器。",
        "translate": ""
    },
    {
        "source": "Because the contained values may be multiply-aliased, they can only be borrowed with `&`, not `&mut`.",
        "suggest": "由于所包含的值可能会被乘以别名，因此只能通过 `&` 借用，而不能通过 `&mut` 借用。",
        "translate": ""
    },
    {
        "source": "Without cells it would be impossible to mutate data inside of these smart pointers at all.",
        "suggest": "没有单元，根本不可能在这些智能指针中对数据进行可变的。",
        "translate": ""
    },
    {
        "source": "It's very common then to put a `RefCell<T>` inside shared pointer types to reintroduce mutability:",
        "suggest": "然后将 `RefCell<T>` 放在共享指针类型中以重新引入可变性是很常见的:",
        "translate": ""
    },
    {
        "source": "Note that this example uses `Rc<T>` and not `Arc<T>`.",
        "suggest": "请注意，此示例使用 `Rc<T>` 而不是 `Arc<T>`。",
        "translate": ""
    },
    {
        "source": "`RefCell<T>`s are for single-threaded scenarios.",
        "suggest": "`RefCell<T>`s 用于单线程方案。",
        "translate": ""
    },
    {
        "source": "Consider using [`RwLock<T>`] or [`Mutex<T>`] if you need shared mutability in a multi-threaded situation.",
        "suggest": "如果在多线程情况下需要共享可变性，请考虑使用 [`RwLock<T>`] 或 [`Mutex<T>`]。",
        "translate": ""
    },
    {
        "source": "Implementation details of logically-immutable methods",
        "suggest": "逻辑不可变方法的实现细节",
        "translate": ""
    },
    {
        "source": "Occasionally it may be desirable not to expose in an API that there is mutation happening \"under the hood\".",
        "suggest": "有时可能希望不要在 API 中公开 \"under the hood\" 发生了可变的。",
        "translate": ""
    },
    {
        "source": "This may be because logically the operation is immutable, but e.g., caching forces the implementation to perform mutation;",
        "suggest": "这可能是因为逻辑上该操作是不可变的，但是例如，缓存会强制实现执行可变的;",
        "translate": ""
    },
    {
        "source": "or because you must employ mutation to implement a trait method that was originally defined to take `&self`.",
        "suggest": "或因为必须使用可变来实现最初定义为采用 `&self` 的 trait 方法。",
        "translate": ""
    },
    {
        "source": "Mutating implementations of `Clone`",
        "suggest": "改变 `Clone` 的实现",
        "translate": ""
    },
    {
        "source": "This is simply a special - but common - case of the previous: hiding mutability for operations that appear to be immutable.",
        "suggest": "这只是前一种情况的一种特殊情况 - 但很常见 - 在看起来不可变的操作中隐藏了可变性。",
        "translate": ""
    },
    {
        "source": "The [`clone`](Clone::clone) method is expected to not change the source value, and is declared to take `&self`, not `&mut self`.",
        "suggest": "预期 [`clone`](Clone::clone) 方法不会更改源值，并声明采用 `&self`，而不是 `&mut self`。",
        "translate": ""
    },
    {
        "source": "Therefore, any mutation that happens in the `clone` method must use cell types.",
        "suggest": "因此，在 `clone` 方法中发生的任何可变的都必须使用细胞类型。",
        "translate": ""
    },
    {
        "source": "For example, [`Rc<T>`] maintains its reference counts within a `Cell<T>`.",
        "suggest": "例如，[`Rc<T>`] 在 `Cell<T>` 内保持其引用计数。",
        "translate": ""
    },
    {
        "source": "A mutable memory location.",
        "suggest": "可变的内存位置。",
        "translate": ""
    }
]
