[
    {
        "source": "Accept two writes, then return Ok(0) on subsequent ones",
        "suggest": "接受两次写入，然后在后续写入中返回 Ok(0)",
        "translate": ""
    },
    {
        "source": "This will flush partial, which will succeed, but then return Ok(0) when flushing \" Line End\\n\"",
        "suggest": "这将部分刷新，这将成功，但是在刷新 \" Line End\\n\" 时返回 Ok(0)",
        "translate": ""
    },
    {
        "source": "LineWriter has a custom `write_all`;",
        "suggest": "LineWriter 有一个自定义 `write_all`;",
        "translate": ""
    },
    {
        "source": "make sure it works correctly",
        "suggest": "确保它正常工作",
        "translate": ""
    },
    {
        "source": "Only write 5 bytes at a time",
        "suggest": "一次只能写入 5 个字节",
        "translate": ""
    },
    {
        "source": "Only accept up to 3 writes of up to 5 bytes each",
        "suggest": "仅接受最多 3 次写入，每次写入最多 5 个字节",
        "translate": ""
    },
    {
        "source": "An error from write_all leaves everything in an indeterminate state, so there's nothing else to test here",
        "suggest": "来自 write_all 的错误使所有内容都处于不确定状态，因此这里没有其他可测试的内容",
        "translate": ""
    },
    {
        "source": "Under certain circumstances, the old implementation of LineWriter would try to buffer \"to the last newline\" but be forced to buffer less than that, leading to inappropriate partial line writes.",
        "suggest": "在某些情况下，LineWriter 的旧实现将尝试缓冲 \"to the last newline\"，但是被迫缓冲不到 \"to the last newline\"，从而导致不适当的部分行写操作。",
        "translate": ""
    },
    {
        "source": "Regression test for that issue.",
        "suggest": "针对该问题进行回归测试。",
        "translate": ""
    },
    {
        "source": "Write only up to 5 bytes at a time",
        "suggest": "一次最多只能写入 5 个字节",
        "translate": ""
    },
    {
        "source": "When content is written, LineWriter will try to write blocks A, B, C, and D.",
        "suggest": "写入内容时，LineWriter 将尝试写入块 A，B，C 和 D。",
        "translate": ""
    },
    {
        "source": "Only block A will succeed.",
        "suggest": "只有块 A 将成功。",
        "translate": ""
    },
    {
        "source": "Under the old behavior, LineWriter would then try to buffer B, C and D, but because its capacity is 10, it will only be able to buffer B and C.",
        "suggest": "在旧的行为下，LineWriter 随后将尝试缓冲 B，C 和 D，但是由于其容量为 10，因此只能缓冲 B 和 C。",
        "translate": ""
    },
    {
        "source": "We don't want to buffer partial lines concurrent with whole lines, so the correct behavior is to buffer only block B (out to the newline)",
        "suggest": "我们不想用全行来缓冲部分行并发，因此正确的行为是只缓冲块 B (到换行处)",
        "translate": ""
    },
    {
        "source": "Same as test_partial_multiline_buffering, but in the event NO full lines fit in the buffer, just buffer as much as possible",
        "suggest": "与 test_partial_multiline_buffering 相同，但是在缓冲区中没有整行的情况下，请尽可能多地缓冲",
        "translate": ""
    },
    {
        "source": "When content is written, LineWriter will try to write blocks A, B, and C.",
        "suggest": "写入内容时，LineWriter 将尝试写入块 A，B 和 C。",
        "translate": ""
    },
    {
        "source": "Under the old behavior, LineWriter would then try to buffer B and C, but because its capacity is 5, it will only be able to buffer part of B.",
        "suggest": "在旧的行为下，LineWriter 然后将尝试缓冲 B 和 C，但是由于其容量为 5，因此只能缓冲 B 的一部分。",
        "translate": ""
    },
    {
        "source": "Because it's not possible for it to buffer any complete lines, it should buffer as much of B as possible",
        "suggest": "因为它不可能缓冲任何完整的行，所以它应该尽可能缓冲 B",
        "translate": ""
    },
    {
        "source": "Test that a normal, formatted writeln only results in a single write call to the underlying writer.",
        "suggest": "测试正常格式化的 writeln 仅导致对基础 writer 的单次写入调用。",
        "translate": ""
    },
    {
        "source": "A naive implementation of LineWriter::write_all results in two writes: one of the buffered data, and another of the final substring in the formatted set",
        "suggest": "LineWriter::write_all 的简单实现会导致两次写入: 一次缓冲的数据，另一次写入格式化集中的最后一个子字符串",
        "translate": ""
    },
    {
        "source": "Under a naive implementation of LineWriter, this will result in two writes: \"hello, world\" and \"!\\n\", because write() has to flush the buffer before attempting to write the last \"!\\n\".",
        "suggest": "在 LineWriter 的简单实现下，这将导致两次写入: \"hello, world\" 和 \"!\\n\"，因为 write() 必须在尝试写入最后一个 \"!\\n\" 之前刷新缓冲区。",
        "translate": ""
    },
    {
        "source": "write_all shouldn't have this limitation.",
        "suggest": "write_all 不应有此限制。",
        "translate": ""
    },
    {
        "source": "Copies the entire contents of a reader into a writer.",
        "suggest": "将 reader 的全部内容复制到 writer 中。",
        "translate": ""
    },
    {
        "source": "This function will continuously read data from `reader` and then write it into `writer` in a streaming fashion until `reader` returns EOF.",
        "suggest": "此函数将连续从 `reader` 读取数据，然后以流方式将其写入 `writer`，直到 `reader` 返回 EOF。",
        "translate": ""
    },
    {
        "source": "On success, the total number of bytes that were copied from `reader` to `writer` is returned.",
        "suggest": "成功后，将返回从 `reader` 复制到 `writer` 的字节总数。",
        "translate": ""
    },
    {
        "source": "If you’re wanting to copy the contents of one file to another and you’re working with filesystem paths, see the [`fs::copy`] function.",
        "suggest": "如果要将一个文件的内容复制到另一个文件，并且正在使用文件系统路径，请参见 [`fs::copy`] 函数。",
        "translate": ""
    },
    {
        "source": "This function will return an error immediately if any call to [`read`] or [`write`] returns an error.",
        "suggest": "如果对 [`read`] 或 [`write`] 的任何调用返回错误，则此函数将立即返回错误。",
        "translate": ""
    },
    {
        "source": "All instances of [`ErrorKind::Interrupted`] are handled by this function and the underlying operation is retried.",
        "suggest": "此函数将处理 [`ErrorKind::Interrupted`] 的所有实例，并重试基础操作。",
        "translate": ""
    },
    {
        "source": "The userspace read-write-loop implementation of `io::copy` that is used when OS-specific specializations for copy offloading are not available or not applicable.",
        "suggest": "`io::copy` 的用户空间读写循环实现，当特定于 OS 的专门用于复制卸载的专业化不可用或不适用时，将使用该 `io::copy`。",
        "translate": ""
    },
    {
        "source": "Specialization of the read-write loop that either uses a stack buffer or reuses the internal buffer of a BufWriter",
        "suggest": "使用栈缓冲区或重用 BufWriter 的内部缓冲区的读写循环的特殊化",
        "translate": ""
    },
    {
        "source": "This creates a (mut) reference to a slice of _uninitialized_ integers, which is **undefined behavior**",
        "suggest": "这将创建 (mut) 对 _uninitialized_ 整数切片的引用，这是 **未定义的行为**",
        "translate": ""
    },
    {
        "source": "Only the standard library gets to soundly \"ignore\" this, based on its privileged knowledge of unstable rustc internals;",
        "suggest": "基于标准库对不稳定 rustc 内部的权限知识，只有标准库才能做到这一点。",
        "translate": ""
    },
    {
        "source": "EOF reached",
        "suggest": "到达 EOF",
        "translate": ""
    },
    {
        "source": "The initializer contract guarantees that either it or `read` will have initialized these bytes.",
        "suggest": "初始化契约保证它或 `read` 都将初始化这些字节。",
        "translate": ""
    },
    {
        "source": "And we just checked that the number of bytes is within the buffer capacity.",
        "suggest": "我们只是检查了字节数是否在缓冲区容量之内。",
        "translate": ""
    },
    {
        "source": "Read again if the buffer still has enough capacity, as BufWriter itself would do This will occur if the reader returns short reads",
        "suggest": "如果缓冲区仍然有足够的容量，则重新读取，如 BufWriter 本身那样。如果 reader 返回短读，则会发生这种情况",
        "translate": ""
    },
    {
        "source": "a library function we've written",
        "suggest": "我们编写的库函数",
        "translate": ""
    },
    {
        "source": "all went well",
        "suggest": "一切顺利",
        "translate": ""
    },
    {
        "source": "Here's some code that uses this library function.",
        "suggest": "这是一些使用此库函数的代码。",
        "translate": ""
    },
    {
        "source": "We might want to use a BufReader here for efficiency, but let's keep this example focused.",
        "suggest": "我们可能想在此处使用 BufReader 来提高效率，但让我们继续关注此示例。",
        "translate": ""
    },
    {
        "source": "now let's write a test",
        "suggest": "现在让我们编写一个测试",
        "translate": ""
    },
    {
        "source": "setting up a real File is much slower than an in-memory buffer, let's use a cursor instead",
        "suggest": "设置一个真实的文件要比内存中的缓冲区慢得多，让我们用游标代替",
        "translate": ""
    },
    {
        "source": "A `Cursor` wraps an in-memory buffer and provides it with a [`Seek`] implementation.",
        "suggest": "`Cursor` 包装内存中的缓冲区，并为其提供 [`Seek`] 实现。",
        "translate": ""
    },
    {
        "source": "`Cursor`s are used with in-memory buffers, anything implementing [`AsRef`]`<[u8]>`, to allow them to implement [`Read`] and/or [`Write`], allowing these buffers to be used anywhere you might use a reader or writer that does actual I/O.",
        "suggest": "Cursor 与内存缓冲区一起使用，任何实现 [`AsRef`]`<[u8]>` 的东西都允许它们实现 [`Read`] 或者 [`Write`]，从而允许在实际使用 I/O 的 reader 或 writer 的任何地方使用这些缓冲区。",
        "translate": ""
    },
    {
        "source": "The standard library implements some I/O traits on various types which are commonly used as a buffer, like `Cursor<`[`Vec`]`<u8>>` and `Cursor<`[`&[u8]`][bytes]`>`.",
        "suggest": "标准库在通常用作缓冲区的各种类型 (例如 `Cursor<`[`Vec`]`<u8>>` 和 `Cursor<`[`&[u8]`][bytes]`>`) 上实现了一些 I/O traits。",
        "translate": ""
    },
    {
        "source": "We may want to write bytes to a [`File`] in our production code, but use an in-memory buffer in our tests.",
        "suggest": "我们可能想在生产代码中将字节写入 [`File`]，但在测试中使用内存缓冲区。",
        "translate": ""
    },
    {
        "source": "We can do this with",
        "suggest": "我们可以做到这一点",
        "translate": ""
    },
    {
        "source": "Creates a new cursor wrapping the provided underlying in-memory buffer.",
        "suggest": "创建一个新的游标，其中包含提供的基础内存缓冲区。",
        "translate": ""
    },
    {
        "source": "Cursor initial position is `0` even if underlying buffer (e.g., [`Vec`]) is not empty.",
        "suggest": "即使基础缓冲区 (例如 [`Vec`]) 不为空，游标的初始位置也为 `0`。",
        "translate": ""
    },
    {
        "source": "So writing to cursor starts with overwriting [`Vec`] content, not with appending to it.",
        "suggest": "因此，写游标始于覆盖 [`Vec`] 内容，而不是附加到其上。",
        "translate": ""
    },
    {
        "source": "Consumes this cursor, returning the underlying value.",
        "suggest": "使用此游标，返回基础值。",
        "translate": ""
    },
    {
        "source": "Gets a reference to the underlying value in this cursor.",
        "suggest": "获取此游标中的基础值的引用。",
        "translate": ""
    },
    {
        "source": "Gets a mutable reference to the underlying value in this cursor.",
        "suggest": "获取此游标中基础值的可变引用。",
        "translate": ""
    },
    {
        "source": "Care should be taken to avoid modifying the internal I/O state of the underlying value as it may corrupt this cursor's position.",
        "suggest": "应注意避免修改基础值的内部 I/O 状态，因为它可能损坏此游标的位置。",
        "translate": ""
    },
    {
        "source": "Returns the current position of this cursor.",
        "suggest": "返回此游标的当前位置。",
        "translate": ""
    },
    {
        "source": "Sets the position of this cursor.",
        "suggest": "设置此游标的位置。",
        "translate": ""
    },
    {
        "source": "Non-resizing write implementation",
        "suggest": "非调整大小的写实现",
        "translate": ""
    },
    {
        "source": "Resizing write implementation",
        "suggest": "调整写实现的大小",
        "translate": ""
    },
    {
        "source": "Make sure the internal buffer is as least as big as where we currently are",
        "suggest": "确保内部缓冲区的大小至少等于当前的大小",
        "translate": ""
    },
    {
        "source": "use `resize` so that the zero filling is as efficient as possible",
        "suggest": "使用 `resize`，以便零位填充尽可能高效",
        "translate": ""
    },
    {
        "source": "Figure out what bytes will be used to overwrite what's currently there (left), and what will be appended on the end (right)",
        "suggest": "找出将用于覆盖 (left) 当前内容的字节，以及将附加在 (right) 末尾的字节",
        "translate": ""
    },
    {
        "source": "Bump us forward",
        "suggest": "让我们前进",
        "translate": ""
    },
    {
        "source": "we have to call all of these UFCS style right now since method resolution won't implicitly drop the Send+Sync bounds",
        "suggest": "我们现在必须调用所有这些 UFCS 样式，因为方法解析不会隐式地丢弃 Send + Sync 边界",
        "translate": ""
    },
    {
        "source": "errors can be created from strings",
        "suggest": "可以从字符串创建错误",
        "translate": ""
    },
    {
        "source": "errors can also be created from other errors",
        "suggest": "错误也可以从其他错误中创建",
        "translate": ""
    },
    {
        "source": "Will print \"raw OS error: ...\".",
        "suggest": "将打印 \"raw OS error: ...\"。",
        "translate": ""
    },
    {
        "source": "Will print \"Not an OS error\".",
        "suggest": "将打印 \"Not an OS error\"。",
        "translate": ""
    },
    {
        "source": "Will print \"No inner error\".",
        "suggest": "将打印 \"No inner error\"。",
        "translate": ""
    },
    {
        "source": "Will print \"Inner error: ...\".",
        "suggest": "将打印 \"Inner error: ...\"。",
        "translate": ""
    },
    {
        "source": "Will print \"Other\".",
        "suggest": "将打印 \"Other\"。",
        "translate": ""
    },
    {
        "source": "Will print \"AddrInUse\".",
        "suggest": "将打印 \"AddrInUse\"。",
        "translate": ""
    },
    {
        "source": "A specialized [`Result`] type for I/O operations.",
        "suggest": "I/O 操作的专用 [`Result`] 类型。",
        "translate": ""
    },
    {
        "source": "This type is broadly used across [`std::io`] for any operation which may produce an error.",
        "suggest": "[`std::io`] 广泛使用此类型进行可能产生错误的任何操作。",
        "translate": ""
    },
    {
        "source": "This typedef is generally used to avoid writing out [`io::Error`] directly and is otherwise a direct mapping to [`Result`].",
        "suggest": "通常使用这种 typedef 来避免直接写出 [`io::Error`]，否则直接映射到 [`Result`]。",
        "translate": ""
    },
    {
        "source": "While usual Rust style is to import types directly, aliases of [`Result`] often are not, to make it easier to distinguish between them.",
        "suggest": "通常的 Rust 样式是直接导入类型，而 [`Result`] 的别名通常不是，以便于区分它们。",
        "translate": ""
    },
    {
        "source": "is generally assumed to be [`std::result::Result`][`Result`], and so users of this alias will generally use `io::Result` instead of shadowing the [prelude]'s import of [`std::result::Result`][`Result`].",
        "suggest": "通常将其假定为 [`std::result::Result`][`Result`]，因此使用这个别名的用户通常将使用 `io::Result`，而不是隐藏 [`std::result::Result`][`Result`] 的 [prelude] 导入。",
        "translate": ""
    },
    {
        "source": "A convenience function that bubbles an `io::Result` to its caller:",
        "suggest": "一个方便的函数，将 `io::Result` 冒泡给其调用者:",
        "translate": ""
    },
    {
        "source": "The error type for I/O operations of the [`Read`], [`Write`], [`Seek`], and associated traits.",
        "suggest": "[`Read`]，[`Write`]，[`Seek`] 和关联的 traits 的 I/O 操作的错误类型。",
        "translate": ""
    },
    {
        "source": "Errors mostly originate from the underlying OS, but custom instances of `Error` can be created with crafted error messages and a particular value of [`ErrorKind`].",
        "suggest": "错误主要来自底层操作系统，但可以使用精心制作的错误消息和特定的 [`ErrorKind`] 值来创建 `Error` 的自定义实例。",
        "translate": ""
    },
    {
        "source": "A list specifying general categories of I/O error.",
        "suggest": "一个列表，指定 I/O 错误的常规类别。",
        "translate": ""
    },
    {
        "source": "This list is intended to grow over time and it is not recommended to exhaustively match against it.",
        "suggest": "此列表旨在随着时间的增长而增长，不建议对其进行详尽的匹配。",
        "translate": ""
    },
    {
        "source": "It is used with the [`io::Error`] type.",
        "suggest": "与 [`io::Error`] 类型一起使用。",
        "translate": ""
    },
    {
        "source": "An entity was not found, often a file.",
        "suggest": "找不到实体，通常是文件。",
        "translate": ""
    },
    {
        "source": "The operation lacked the necessary privileges to complete.",
        "suggest": "该操作缺少完成操作所需的权限。",
        "translate": ""
    },
    {
        "source": "The connection was refused by the remote server.",
        "suggest": "远程服务器拒绝了连接。",
        "translate": ""
    },
    {
        "source": "The connection was reset by the remote server.",
        "suggest": "连接已由远程服务器重置。",
        "translate": ""
    },
    {
        "source": "The connection was aborted (terminated) by the remote server.",
        "suggest": "(terminated) 连接被远程服务器中止。",
        "translate": ""
    },
    {
        "source": "The network operation failed because it was not connected yet.",
        "suggest": "网络操作失败，因为尚未连接。",
        "translate": ""
    },
    {
        "source": "A socket address could not be bound because the address is already in use elsewhere.",
        "suggest": "无法绑定套接字地址，因为该地址已在其他地方使用。",
        "translate": ""
    },
    {
        "source": "A nonexistent interface was requested or the requested address was not local.",
        "suggest": "请求了不存在的接口，或者请求的地址不是本地的。",
        "translate": ""
    },
    {
        "source": "The operation failed because a pipe was closed.",
        "suggest": "操作失败，因为管道已关闭。",
        "translate": ""
    },
    {
        "source": "An entity already exists, often a file.",
        "suggest": "一个实体已经存在，通常是一个文件。",
        "translate": ""
    },
    {
        "source": "The operation needs to block to complete, but the blocking operation was requested to not occur.",
        "suggest": "该操作需要阻止才能完成，但是请求阻止操作不会发生。",
        "translate": ""
    },
    {
        "source": "A parameter was incorrect.",
        "suggest": "参数不正确。",
        "translate": ""
    },
    {
        "source": "Data not valid for the operation were encountered.",
        "suggest": "遇到对该操作无效的数据。",
        "translate": ""
    },
    {
        "source": "Unlike [`InvalidInput`], this typically means that the operation parameters were valid, however the error was caused by malformed input data.",
        "suggest": "与 [`InvalidInput`] 不同，这通常意味着操作参数有效，但是该错误是由格式错误的输入数据引起的。",
        "translate": ""
    },
    {
        "source": "For example, a function that reads a file into a string will error with `InvalidData` if the file's contents are not valid UTF-8.",
        "suggest": "例如，如果文件的内容无效 UTF-8，则将文件读入字符串的函数将出现 `InvalidData` 错误。",
        "translate": ""
    },
    {
        "source": "The I/O operation's timeout expired, causing it to be canceled.",
        "suggest": "I/O 操作的超时已到期，导致其被取消。",
        "translate": ""
    },
    {
        "source": "An error returned when an operation could not be completed because a call to [`write`] returned [`Ok(0)`].",
        "suggest": "由于调用 [`write`] 返回 [`Ok(0)`] 而无法完成操作时，返回错误。",
        "translate": ""
    },
    {
        "source": "This typically means that an operation could only succeed if it wrote a particular number of bytes but only a smaller number of bytes could be written.",
        "suggest": "这通常意味着操作只有在写入特定数量的字节后才能成功，但是只能写入较少的字节数才能成功。",
        "translate": ""
    },
    {
        "source": "This operation was interrupted.",
        "suggest": "该操作被中断。",
        "translate": ""
    },
    {
        "source": "Interrupted operations can typically be retried.",
        "suggest": "通常可以重试中断的操作。",
        "translate": ""
    },
    {
        "source": "Any I/O error not part of this list.",
        "suggest": "任何 I/O 错误都不属于此列表。",
        "translate": ""
    },
    {
        "source": "Errors that are `Other` now may move to a different or a new [`ErrorKind`] variant in the future.",
        "suggest": "现在，`Other` 错误可能会移动到 future 中的另一个 [`ErrorKind`] 成员或新的 [`ErrorKind`] 成员。",
        "translate": ""
    },
    {
        "source": "It is not recommended to match an error against `Other` and to expect any additional characteristics, e.g., a specific [`Error::raw_os_error`] return value.",
        "suggest": "不建议将错误与 `Other` 匹配，并且不要期望任何其他特征，例如，特定的 [`Error::raw_os_error`] 返回值。",
        "translate": ""
    },
    {
        "source": "An error returned when an operation could not be completed because an \"end of file\" was reached prematurely.",
        "suggest": "由于过早到达 \"end of file\" 而无法完成操作时，返回错误。",
        "translate": ""
    },
    {
        "source": "This typically means that an operation could only succeed if it read a particular number of bytes but only a smaller number of bytes could be read.",
        "suggest": "通常，这意味着操作只有在读取特定数量的字节后才能成功，但是只能读取较少的字节。",
        "translate": ""
    },
    {
        "source": "Intended for use for errors not exposed to the user, where allocating onto the heap (for normal construction via Error::new) is too costly.",
        "suggest": "旨在用于未暴露给用户的错误，因为分配到堆上 (通过 Error::new 进行常规构建) 的代价太高了。",
        "translate": ""
    },
    {
        "source": "Converts an [`ErrorKind`] into an [`Error`].",
        "suggest": "将 [`ErrorKind`] 转换为 [`Error`]。",
        "translate": ""
    },
    {
        "source": "This conversion allocates a new error with a simple representation of error kind.",
        "suggest": "此转换使用错误类型的简单表示来分配新错误。",
        "translate": ""
    },
    {
        "source": "Creates a new I/O error from a known kind of error as well as an arbitrary error payload.",
        "suggest": "根据已知的错误以及任意错误有效负载创建新的 I/O 错误。",
        "translate": ""
    },
    {
        "source": "This function is used to generically create I/O errors which do not originate from the OS itself.",
        "suggest": "此函数通常用于创建 I/O 错误，这些错误并非源于操作系统本身。",
        "translate": ""
    },
    {
        "source": "The `error` argument is an arbitrary payload which will be contained in this [`Error`].",
        "suggest": "`error` 参数是将包含在此 [`Error`] 中的任意有效负载。",
        "translate": ""
    },
    {
        "source": "Returns an error representing the last OS error which occurred.",
        "suggest": "返回代表最近发生的操作系统错误的错误。",
        "translate": ""
    },
    {
        "source": "This function reads the value of `errno` for the target platform (e.g.",
        "suggest": "该函数读取目标平台的 `errno` 值 (例如，",
        "translate": ""
    },
    {
        "source": "on Windows) and will return a corresponding instance of [`Error`] for the error code.",
        "suggest": "在 Windows 上)，并会返回相应的 [`Error`] 实例作为错误代码。",
        "translate": ""
    },
    {
        "source": "Creates a new instance of an [`Error`] from a particular OS error code.",
        "suggest": "根据特定的操作系统错误代码创建 [`Error`] 的新实例。",
        "translate": ""
    },
    {
        "source": "On Linux:",
        "suggest": "在 Linux 上:",
        "translate": ""
    },
    {
        "source": "On Windows:",
        "suggest": "在 Windows 上:",
        "translate": ""
    },
    {
        "source": "Returns the OS error that this error represents (if any).",
        "suggest": "返回此错误表示的操作系统错误 (如果有)。",
        "translate": ""
    },
    {
        "source": "If this [`Error`] was constructed via [`last_os_error`] or [`from_raw_os_error`], then this function will return [`Some`], otherwise it will return [`None`].",
        "suggest": "如果此 [`Error`] 是通过 [`last_os_error`] 或 [`from_raw_os_error`] 构造的，则此函数将返回 [`Some`]，否则它将返回 [`None`]。",
        "translate": ""
    },
    {
        "source": "Returns a reference to the inner error wrapped by this error (if any).",
        "suggest": "返回对此错误包装的内部错误 (如果有) 的引用。",
        "translate": ""
    },
    {
        "source": "If this [`Error`] was constructed via [`new`] then this function will return [`Some`], otherwise it will return [`None`].",
        "suggest": "如果此 [`Error`] 是通过 [`new`] 构造的，则此函数将返回 [`Some`]，否则它将返回 [`None`]。",
        "translate": ""
    },
    {
        "source": "Returns a mutable reference to the inner error wrapped by this error (if any).",
        "suggest": "返回对此错误包装的内部错误的可变引用 (如果有)。",
        "translate": ""
    },
    {
        "source": "Consumes the `Error`, returning its inner error (if any).",
        "suggest": "消耗 `Error`，并返回其内部错误 (如果有)。",
        "translate": ""
    },
    {
        "source": "Returns the corresponding [`ErrorKind`] for this error.",
        "suggest": "返回与此错误对应的 [`ErrorKind`]。",
        "translate": ""
    },
    {
        "source": "Forwarding implementations",
        "suggest": "转发实现",
        "translate": ""
    },
    {
        "source": "In-memory buffer implementations",
        "suggest": "内存中缓冲区的实现",
        "translate": ""
    },
    {
        "source": "Read is implemented for `&[u8]` by copying from the slice.",
        "suggest": "通过从切片复制为 `&[u8]` 实现读取。",
        "translate": ""
    },
    {
        "source": "Note that reading updates the slice to point to the yet unread part.",
        "suggest": "请注意，读取将更新切片以指向尚未读取的部分。",
        "translate": ""
    },
    {
        "source": "The slice will be empty when EOF is reached.",
        "suggest": "到达 EOF 时，切片将为空。",
        "translate": ""
    },
    {
        "source": "First check if the amount of bytes we want to read is small:",
        "suggest": "首先检查我们要读取的字节数是否很小:",
        "translate": ""
    },
    {
        "source": "will generally expand to a call to `memcpy`, and for a single byte the overhead is significant.",
        "suggest": "通常将扩展到 `memcpy` 的调用，并且对于单个字节而言，开销是很大的。",
        "translate": ""
    },
    {
        "source": "Write is implemented for `&mut [u8]` by copying into the slice, overwriting its data.",
        "suggest": "通过将 `&mut [u8]` 复制到切片中并覆盖其数据来实现写入。",
        "translate": ""
    },
    {
        "source": "Note that writing updates the slice to point to the yet unwritten part.",
        "suggest": "请注意，编写会更新切片以指向尚未编写的部分。",
        "translate": ""
    },
    {
        "source": "The slice will be empty when it has been completely overwritten.",
        "suggest": "完全覆盖后，切片将为空。",
        "translate": ""
    },
    {
        "source": "If the number of bytes to be written exceeds the size of the slice, write operations will return short writes: ultimately, `Ok(0)`;",
        "suggest": "如果要写入的字节数超过了切片的大小，则写入操作将返回短写入: 最终为 `Ok(0)`; 否则为 `Ok(0)`。",
        "translate": ""
    },
    {
        "source": "in this situation, `write_all` returns an error of kind `ErrorKind::WriteZero`.",
        "suggest": "在这种情况下，`write_all` 返回类型为 `ErrorKind::WriteZero` 的错误。",
        "translate": ""
    },
    {
        "source": "Write is implemented for `Vec<u8>` by appending to the vector.",
        "suggest": "通过将 `Vec<u8>` 附加到 vector 来实现写操作。",
        "translate": ""
    },
    {
        "source": "The vector will grow as needed.",
        "suggest": "vector 将根据需要增长。",
        "translate": ""
    },
    {
        "source": "read up to 10 bytes",
        "suggest": "最多读取 10 个字节",
        "translate": ""
    },
    {
        "source": "skip to the last 10 bytes of the file",
        "suggest": "跳到文件的最后 10 个字节",
        "translate": ""
    },
    {
        "source": "read a line into buffer",
        "suggest": "将一行读入缓冲区",
        "translate": ""
    },
    {
        "source": "write a byte to the buffer",
        "suggest": "向缓冲区写入一个字节",
        "translate": ""
    },
    {
        "source": "the buffer is flushed once writer goes out of scope",
        "suggest": "writer 离开作用域后，将刷新缓冲区",
        "translate": ""
    },
    {
        "source": "read the whole file",
        "suggest": "读取整个文件",
        "translate": ""
    },
    {
        "source": "read into a String, so that you don't need to do the conversion.",
        "suggest": "读入一个字符串，这样就不需要进行转换。",
        "translate": ""
    },
    {
        "source": "and more!",
        "suggest": "和更多!",
        "translate": ""
    },
    {
        "source": "See the other methods for more details.",
        "suggest": "有关更多详细信息，请参见其他方法。",
        "translate": ""
    },
    {
        "source": "etc... it works exactly as a File does!",
        "suggest": "等等... 它的工作原理与文件一样!",
        "translate": ""
    },
    {
        "source": "read exactly 10 bytes",
        "suggest": "精确读取 10 个字节",
        "translate": ""
    },
    {
        "source": "read at most 5 bytes",
        "suggest": "最多读取 5 个字节",
        "translate": ""
    },
    {
        "source": "drop our &mut reference so we can use f again",
        "suggest": "丢弃 &mut 引用，以便我们可以再次使用 f",
        "translate": ""
    },
    {
        "source": "original file still usable, read the rest",
        "suggest": "原始文件仍然可用，请读取其余内容",
        "translate": ""
    },
    {
        "source": "read the value into a String.",
        "suggest": "将值读入字符串。",
        "translate": ""
    },
    {
        "source": "We could use any Read method here, this is just one example.",
        "suggest": "我们可以在这里使用任何 Read 方法，这只是一个示例。",
        "translate": ""
    },
    {
        "source": "read at most five bytes",
        "suggest": "最多读取五个字节",
        "translate": ""
    },
    {
        "source": "Mark 10 bytes as read.",
        "suggest": "将 10 个字节标记为已读。",
        "translate": ""
    },
    {
        "source": "Writes some prefix of the byte string, not necessarily all of it.",
        "suggest": "写入字节字符串的某些前缀，不一定要全部。",
        "translate": ""
    },
    {
        "source": "the contents of `bufs` is now undefined, see the Notes section.",
        "suggest": "`bufs` 的内容现在是不确定的，请参见说明部分。",
        "translate": ""
    },
    {
        "source": "this call",
        "suggest": "这个",
        "translate": ""
    },
    {
        "source": "turns into this:",
        "suggest": "变成这样:",
        "translate": ""
    },
    {
        "source": "we can use reference just like our original buffer",
        "suggest": "我们可以像使用原始缓冲区一样使用引用",
        "translate": ""
    },
    {
        "source": "move the cursor 42 bytes from the start of the file",
        "suggest": "从文件的开头将游标移动 42 个字节",
        "translate": ""
    },
    {
        "source": "work with buffer",
        "suggest": "使用缓冲区",
        "translate": ""
    },
    {
        "source": "ensure the bytes we worked with aren't returned again later",
        "suggest": "确保我们处理过的字节以后不再返回",
        "translate": ""
    },
    {
        "source": "cursor is at 'l'",
        "suggest": "游标在 'l'",
        "translate": ""
    },
    {
        "source": "cursor is at 'i'",
        "suggest": "游标在 'i'",
        "translate": ""
    },
    {
        "source": "cursor is at EOF",
        "suggest": "游标在 EOF 处",
        "translate": ""
    },
    {
        "source": "cursor is at 'f'",
        "suggest": "游标在 'f'",
        "translate": ""
    },
    {
        "source": "cursor is at 'b'",
        "suggest": "游标在 'b'",
        "translate": ""
    },
    {
        "source": "Traits, helpers, and type definitions for core I/O functionality.",
        "suggest": "core I/O 功能的 Traits，助手和类型定义。",
        "translate": ""
    },
    {
        "source": "The `std::io` module contains a number of common things you'll need when doing input and output.",
        "suggest": "`std::io` 模块包含许多在执行输入和输出时需要的常见操作。",
        "translate": ""
    },
    {
        "source": "The most core part of this module is the [`Read`] and [`Write`] traits, which provide the most general interface for reading and writing input and output.",
        "suggest": "该模块中最 core 的部分是 [`Read`] 和 [`Write`] traits，它们提供用于读取和写入输入和输出的最通用接口。",
        "translate": ""
    },
    {
        "source": "Read and Write",
        "suggest": "读和写",
        "translate": ""
    },
    {
        "source": "Because they are traits, [`Read`] and [`Write`] are implemented by a number of other types, and you can implement them for your types too.",
        "suggest": "因为它们是 traits，所以 [`Read`] 和 [`Write`] 由许多其他类型实现，您也可以为您的类型实现它们。",
        "translate": ""
    },
    {
        "source": "As such, you'll see a few different types of I/O throughout the documentation in this module: [`File`]s, [`TcpStream`]s, and sometimes even [`Vec<T>`]s.",
        "suggest": "这样，您将在此模块的整个文档中看到几种不同类型的 I/O: [`File`]，[`TcpStream`]，有时甚至是 [`Vec<T>`]。",
        "translate": ""
    },
    {
        "source": "For example, [`Read`] adds a [`read`][`Read::read`] method, which we can use on [`File`]s:",
        "suggest": "例如，[`Read`] 添加了 [`read`][`Read::read`] 方法，我们可以在 [`File`] 上使用该方法:",
        "translate": ""
    },
    {
        "source": "and [`Write`] are so important, implementors of the two traits have a nickname: readers and writers.",
        "suggest": "和 [`Write`] 非常重要，两个 traits 的实现者都有一个昵称: readers 和 writers。",
        "translate": ""
    },
    {
        "source": "So you'll sometimes see 'a reader' instead of 'a type that implements the [`Read`] trait'.",
        "suggest": "因此，有时您会看到 `reader` 而不是 `实现 [`Read`] trait 的类型`。",
        "translate": ""
    },
    {
        "source": "Much easier!",
        "suggest": "容易得多!",
        "translate": ""
    },
    {
        "source": "Seek and BufRead",
        "suggest": "Seek 和 BufRead",
        "translate": ""
    },
    {
        "source": "Beyond that, there are two important traits that are provided: [`Seek`] and [`BufRead`].",
        "suggest": "除此之外，还提供了两个重要的 traits: [`Seek`] 和 [`BufRead`]。",
        "translate": ""
    },
    {
        "source": "Both of these build on top of a reader to control how the reading happens.",
        "suggest": "两者都建立在 reader 的顶部，以控制读取的方式。",
        "translate": ""
    },
    {
        "source": "lets you control where the next byte is coming from:",
        "suggest": "让您控制下一个字节的来源:",
        "translate": ""
    },
    {
        "source": "uses an internal buffer to provide a number of other ways to read, but to show it off, we'll need to talk about buffers in general.",
        "suggest": "使用内部缓冲区来提供许多其他读取方式，但是为了展示它，我们通常需要讨论缓冲区。",
        "translate": ""
    },
    {
        "source": "Keep reading!",
        "suggest": "继续阅读!",
        "translate": ""
    },
    {
        "source": "BufReader and BufWriter",
        "suggest": "BufReader 和 BufWriter",
        "translate": ""
    },
    {
        "source": "Byte-based interfaces are unwieldy and can be inefficient, as we'd need to be making near-constant calls to the operating system.",
        "suggest": "基于字节的接口笨拙且效率低下，因为我们需要对操作系统进行近乎恒定的调用。",
        "translate": ""
    },
    {
        "source": "To help with this, `std::io` comes with two structs, [`BufReader`] and [`BufWriter`], which wrap readers and writers.",
        "suggest": "为了解决这个问题，`std::io` 带有两个结构体 [`BufReader`] 和 [`BufWriter`]，它们包装了 readers 和 writers。",
        "translate": ""
    },
    {
        "source": "The wrapper uses a buffer, reducing the number of calls and providing nicer methods for accessing exactly what you want.",
        "suggest": "包装器使用缓冲区，从而减少了调用次数，并提供了更好的方法来访问所需的内容。",
        "translate": ""
    },
    {
        "source": "For example, [`BufReader`] works with the [`BufRead`] trait to add extra methods to any reader:",
        "suggest": "例如，[`BufReader`] 与 [`BufRead`] trait 一起为任何 reader 添加额外的方法:",
        "translate": ""
    },
    {
        "source": "doesn't add any new ways of writing;",
        "suggest": "没有添加任何新的写作方式;",
        "translate": ""
    },
    {
        "source": "it just buffers every call to [`write`][`Write::write`]:",
        "suggest": "它只是缓冲每个调用到 [`write`][`Write::write`]:",
        "translate": ""
    },
    {
        "source": "Standard input and output",
        "suggest": "标准输入输出",
        "translate": ""
    },
    {
        "source": "A very common source of input is standard input:",
        "suggest": "输入的一个非常常见的来源是标准输入:",
        "translate": ""
    },
    {
        "source": "Note that you cannot use the [`?` operator] in functions that do not return a [`Result<T, E>`][`Result`].",
        "suggest": "请注意，不能在不返回 [`Result<T, E>`][`Result`] 的函数中使用 [`?` operator]。",
        "translate": ""
    },
    {
        "source": "Instead, you can call [`.unwrap()`] or `match` on the return value to catch any possible errors:",
        "suggest": "相反，您可以在返回值上调用 [`.unwrap()`] 或 `match` 来捕获任何可能的错误:",
        "translate": ""
    },
    {
        "source": "And a very common source of output is standard output:",
        "suggest": "标准输出是一个非常常见的输出源:",
        "translate": ""
    },
    {
        "source": "Of course, using [`io::stdout`] directly is less common than something like [`println!`].",
        "suggest": "当然，直接使用 [`io::stdout`] 比使用 [`println!`] 少见。",
        "translate": ""
    },
    {
        "source": "Iterator types",
        "suggest": "迭代器类型",
        "translate": ""
    },
    {
        "source": "A large number of the structures provided by `std::io` are for various ways of iterating over I/O.",
        "suggest": "`std::io` 提供的大量结构用于在 I/O 上进行迭代的各种方式。",
        "translate": ""
    },
    {
        "source": "For example, [`Lines`] is used to split over lines:",
        "suggest": "例如，[`Lines`] 用于拆分多行:",
        "translate": ""
    },
    {
        "source": "There are a number of [functions][functions-list] that offer access to various features.",
        "suggest": "有许多 [函数][functions-list] 提供对各种功能的访问。",
        "translate": ""
    },
    {
        "source": "For example, we can use three of these functions to copy everything from standard input to standard output:",
        "suggest": "例如，我们可以使用以下三个函数将所有内容从标准输入复制到标准输出:",
        "translate": ""
    },
    {
        "source": "Last, but certainly not least, is [`io::Result`].",
        "suggest": "最后但并非最不重要的是 [`io::Result`]。",
        "translate": ""
    },
    {
        "source": "This type is used as the return type of many `std::io` functions that can cause an error, and can be returned from your own functions as well.",
        "suggest": "此类型用作许多 `std::io` 函数的返回类型，它们可能导致错误，也可以从您自己的函数中返回。",
        "translate": ""
    },
    {
        "source": "Many of the examples in this module use the [`?` operator]:",
        "suggest": "该模块中的许多示例都使用 [`?` operator]:",
        "translate": ""
    },
    {
        "source": "The return type of `read_input()`, [`io::Result<()>`][`io::Result`], is a very common type for functions which don't have a 'real' return value, but do want to return errors if they happen.",
        "suggest": "`read_input()` 的返回类型 [`io::Result<()>`][`io::Result`] 是函数的一种非常常见的类型，它没有 'real' 返回值，但是希望在发生错误时返回错误。",
        "translate": ""
    },
    {
        "source": "In this case, the only purpose of this function is to read the line and print it, so we use `()`.",
        "suggest": "在这种情况下，此函数的唯一目的是读取并打印该行，因此我们使用 `()`。",
        "translate": ""
    },
    {
        "source": "Many I/O functions throughout the standard library are documented to indicate what various library or syscalls they are delegated to.",
        "suggest": "记录了整个标准库中的许多 I/O 函数，以指示将它们委派给的各种库或 syscall。",
        "translate": ""
    },
    {
        "source": "This is done to help applications both understand what's happening under the hood as well as investigate any possibly unclear semantics.",
        "suggest": "这样做是为了帮助应用程序了解幕后的情况以及调查任何可能不清楚的语义。",
        "translate": ""
    },
    {
        "source": "Note, however, that this is informative, not a binding contract.",
        "suggest": "但是请注意，这只是提供信息，而不是有约束力的契约。",
        "translate": ""
    },
    {
        "source": "The implementation of many of these functions are subject to change over time and may call fewer or more syscalls/library functions.",
        "suggest": "其中许多函数的实现会随时间而变化，并且可能调用更少或更多的 syscalls/library 函数。",
        "translate": ""
    },
    {
        "source": "A few methods below (read_to_string, read_line) will append data into a `String` buffer, but we need to be pretty careful when doing this.",
        "suggest": "下面的一些方法 (read_to_string，read_line) 会将数据追加到 `String` 缓冲区中，但是在执行此操作时我们需要非常小心。",
        "translate": ""
    },
    {
        "source": "The implementation will just call `.as_mut_vec()` and then delegate to a byte-oriented reading method, but we must ensure that when returning we never leave `buf` in a state such that it contains invalid UTF-8 in its bounds.",
        "suggest": "该实现将只是调用 `.as_mut_vec()`，然后委派给一个面向字节的读取方法，但我们必须确保在返回时，切勿将 `buf` 保持在其边界内包含无效 UTF-8 的状态。",
        "translate": ""
    },
    {
        "source": "To this end, we use an RAII guard (to protect against panics) which updates the length of the string when it is dropped.",
        "suggest": "为此，我们使用了 RAII 保护器 (以防止 panics)，该保护器会在丢弃字符串时更新字符串的长度。",
        "translate": ""
    },
    {
        "source": "This guard initially truncates the string to the prior length and only after we've validated that the new contents are valid UTF-8 do we allow it to set a longer length.",
        "suggest": "此保护程序最初将字符串截断为先前的长度，只有在我们确认新内容有效 UTF-8 之后，才允许它设置更长的长度。",
        "translate": ""
    },
    {
        "source": "The unsafety in this function is twofold:",
        "suggest": "此函数的不安全性是双重的:",
        "translate": ""
    },
    {
        "source": "We're looking at the raw bytes of `buf`, so we take on the burden of UTF-8 checks.",
        "suggest": "我们正在查看 `buf` 的原始字节，因此我们承担了 UTF-8 检查的负担。",
        "translate": ""
    },
    {
        "source": "We're passing a raw buffer to the function `f`, and it is expected that the function only *appends* bytes to the buffer. We'll get undefined behavior if existing bytes are overwritten to have non-UTF-8 data.",
        "suggest": "我们正在将原始缓冲区传递给函数 `f`，并且期望该函数仅附加字节到缓冲区。如果现有字节被覆盖以具有非 UTF-8 数据，我们将得到未定义的行为。",
        "translate": ""
    },
    {
        "source": "This uses an adaptive system to extend the vector when it fills.",
        "suggest": "当填充 vector 时，它将使用自适应系统来对其进行扩展。",
        "translate": ""
    },
    {
        "source": "We want to avoid paying to allocate and zero a huge chunk of memory if the reader only has 4 bytes while still making large reads if the reader does have a ton of data to return.",
        "suggest": "如果 reader 只有 4 个字节，而 reader 确实有大量数据要返回，那么我们要避免花大钱分配零内存。",
        "translate": ""
    },
    {
        "source": "Simply tacking on an extra DEFAULT_BUF_SIZE space every time is 4,500 times (!) slower than a default reservation size of 32 if the reader has a very small amount of data to return.",
        "suggest": "如果 reader 返回的数据量非常小，则每次简单地增加 DEFAULT_BUF_SIZE 的额外空间就比默认保留大小 32 慢 X4X 的 4,500 倍。",
        "translate": ""
    },
    {
        "source": "Because we're extending the buffer with uninitialized data for trusted readers, we need to make sure to truncate that if any of this panics.",
        "suggest": "因为我们正在使用未初始化的数据扩展受信任 readers 的缓冲区，所以我们需要确保截断该 panics 中的任何一个。",
        "translate": ""
    },
    {
        "source": "We can't allow bogus values from read.",
        "suggest": "我们不允许读取伪造的值。",
        "translate": ""
    },
    {
        "source": "If it is too large, the returned vec could have its length set past its capacity, or if it overflows the vec could be shortened which could create an invalid string if this is called via read_to_string.",
        "suggest": "如果太大，则返回的 vec 的长度可能会超出其容量，或者如果溢出，则会缩短 vec，如果通过 read_to_string 调用，则会创建无效的字符串。",
        "translate": ""
    },
    {
        "source": "The `Read` trait allows for reading bytes from a source.",
        "suggest": "`Read` trait 允许从源读取字节。",
        "translate": ""
    },
    {
        "source": "Implementors of the `Read` trait are called 'readers'.",
        "suggest": "`Read` trait 的实现者称为 'readers'。",
        "translate": ""
    },
    {
        "source": "Readers are defined by one required method, [`read()`].",
        "suggest": "Readers 由一种必需的方法 [`read()`] 定义。",
        "translate": ""
    },
    {
        "source": "Each call to [`read()`] will attempt to pull bytes from this source into a provided buffer.",
        "suggest": "对 [`read()`] 的每次调用都会尝试将字节从此源拉入提供的缓冲区。",
        "translate": ""
    },
    {
        "source": "A number of other methods are implemented in terms of [`read()`], giving implementors a number of ways to read bytes while only needing to implement a single method.",
        "suggest": "[`read()`] 还实现了许多其他方法，从而为实现者提供了多种读取字节的方式，而只需要实现一种方法即可。",
        "translate": ""
    },
    {
        "source": "Readers are intended to be composable with one another.",
        "suggest": "Readers 旨在彼此组成。",
        "translate": ""
    },
    {
        "source": "Many implementors throughout [`std::io`] take and provide types which implement the `Read` trait.",
        "suggest": "[`std::io`] 上的许多实现器都采用并提供实现 `Read` trait 的类型。",
        "translate": ""
    },
    {
        "source": "Please note that each call to [`read()`] may involve a system call, and therefore, using something that implements [`BufRead`], such as [`BufReader`], will be more efficient.",
        "suggest": "请注意，对 [`read()`] 的每次调用都可能涉及一个系统调用，因此，使用实现 [`BufRead`] 的东西 (例如 [`BufReader`]) 会更加有效。",
        "translate": ""
    },
    {
        "source": "[`File`]s implement `Read`:",
        "suggest": "[`File`] 的工具 `Read`:",
        "translate": ""
    },
    {
        "source": "Read from [`&str`] because [`&[u8]`][prim@slice] implements `Read`:",
        "suggest": "从 [`&str`] 读取，因为 [`&[u8]`][prim@slice] 实现了 `Read`:",
        "translate": ""
    },
    {
        "source": "Pull some bytes from this source into the specified buffer, returning how many bytes were read.",
        "suggest": "从该源中提取一些字节到指定的缓冲区中，返回读取的字节数。",
        "translate": ""
    },
    {
        "source": "This function does not provide any guarantees about whether it blocks waiting for data, but if an object needs to block for a read and cannot, it will typically signal this via an [`Err`] return value.",
        "suggest": "该函数不提供有关是否阻塞等待数据的任何保证，但是如果 object 需要阻塞读取而不能阻塞，则通常会通过 [`Err`] 返回值来发出信号。",
        "translate": ""
    },
    {
        "source": "If the return value of this method is [`Ok(n)`], then implementations must guarantee that `0 <= n <= buf.len()`.",
        "suggest": "如果此方法的返回值为 [`Ok(n)`]，则实现必须保证 `0 <= n <= buf.len()`。",
        "translate": ""
    },
    {
        "source": "A nonzero `n` value indicates that the buffer `buf` has been filled in with `n` bytes of data from this source.",
        "suggest": "`n` 值非零表示缓冲区 `buf` 已填充有来自该源的 `n` 字节的数据。",
        "translate": ""
    },
    {
        "source": "If `n` is `0`, then it can indicate one of two scenarios:",
        "suggest": "如果 `n` 是 `0`，则它可以指示以下两种情况之一:",
        "translate": ""
    },
    {
        "source": "This reader has reached its \"end of file\" and will likely no longer be able to produce bytes.",
        "suggest": "reader 已到达其 \"end of file\"，可能不再能够产生字节。",
        "translate": ""
    },
    {
        "source": "Note that this does not mean that the reader will *always* no longer be able to produce bytes.",
        "suggest": "请注意，这并不意味着 reader 总是会不再能够生成字节。",
        "translate": ""
    },
    {
        "source": "The buffer specified was 0 bytes in length.",
        "suggest": "指定的缓冲区的长度为 0 个字节。",
        "translate": ""
    },
    {
        "source": "It is not an error if the returned value `n` is smaller than the buffer size, even when the reader is not at the end of the stream yet.",
        "suggest": "如果返回值 `n` 小于缓冲区大小，即使 reader 不在流的末尾，也不会出错。",
        "translate": ""
    },
    {
        "source": "This may happen for example because fewer bytes are actually available right now (e. g. being close to end-of-file) or because read() was interrupted by a signal.",
        "suggest": "例如，这可能是因为现在实际可用的字节较少 (例如，接近文件末尾) 或 read() 被信号中断。",
        "translate": ""
    },
    {
        "source": "As this trait is safe to implement, callers cannot rely on `n <= buf.len()` for safety.",
        "suggest": "由于此 trait 可以安全实现，因此调用者不能依靠 `n <= buf.len()` 来保证安全。",
        "translate": ""
    },
    {
        "source": "Extra care needs to be taken when `unsafe` functions are used to access the read bytes.",
        "suggest": "当使用 `unsafe` 函数访问读取的字节时，需要格外小心。",
        "translate": ""
    },
    {
        "source": "Callers have to ensure that no unchecked out-of-bounds accesses are possible even if `n > buf.len()`.",
        "suggest": "调用者必须确保即使 `n > buf.len()` 也不能进行未经检查的越界访问。",
        "translate": ""
    },
    {
        "source": "No guarantees are provided about the contents of `buf` when this function is called, implementations cannot rely on any property of the contents of `buf` being true.",
        "suggest": "调用此函数时，不能保证 `buf` 的内容，实现不能依赖 `buf` 内容的任何属性为 true。",
        "translate": ""
    },
    {
        "source": "It is recommended that *implementations* only write data to `buf` instead of reading its contents.",
        "suggest": "建议 `implementations` 仅将数据写入 `buf`，而不要读取其内容。",
        "translate": ""
    },
    {
        "source": "Correspondingly, however, *callers* of this method may not assume any guarantees about how the implementation uses `buf`.",
        "suggest": "但是，相应地，此方法的 *调用者* 不能对实现如何使用 `buf` 做出任何保证。",
        "translate": ""
    },
    {
        "source": "The trait is safe to implement, so it is possible that the code that's supposed to write to the buffer might also read from it.",
        "suggest": "trait 可以安全地实现，因此应该写到缓冲区的代码也可能会从中读取。",
        "translate": ""
    },
    {
        "source": "It is your responsibility to make sure that `buf` is initialized before calling `read`.",
        "suggest": "您有责任在调用 `read` 之前确保 `buf` 已初始化。",
        "translate": ""
    },
    {
        "source": "Calling `read` with an uninitialized `buf` (of the kind one obtains via [`MaybeUninit<T>`]) is not safe, and can lead to undefined behavior.",
        "suggest": "用未初始化的 `buf` (通过 [`MaybeUninit<T>`] 获得的那种) 来调用 `read` 是不安全的，并且可能导致未定义的行为。",
        "translate": ""
    },
    {
        "source": "If this function encounters any form of I/O or other error, an error variant will be returned.",
        "suggest": "如果此函数遇到任何形式的 I/O 或其他错误，将返回一个错误成员。",
        "translate": ""
    },
    {
        "source": "If an error is returned then it must be guaranteed that no bytes were read.",
        "suggest": "如果返回错误，则必须保证未读取任何字节。",
        "translate": ""
    },
    {
        "source": "An error of the [`ErrorKind::Interrupted`] kind is non-fatal and the read operation should be retried if there is nothing else to do.",
        "suggest": "[`ErrorKind::Interrupted`] 类型的错误是非致命错误，如果没有其他事情可做，则应重试读取操作。",
        "translate": ""
    },
    {
        "source": "Like `read`, except that it reads into a slice of buffers.",
        "suggest": "与 `read` 相似，不同之处在于它读入缓冲区的一部分。",
        "translate": ""
    },
    {
        "source": "Data is copied to fill each buffer in order, with the final buffer written to possibly being only partially filled.",
        "suggest": "复制数据以按顺序填充每个缓冲区，而写入的最终缓冲区可能仅被部分填充。",
        "translate": ""
    },
    {
        "source": "This method must behave equivalently to a single call to `read` with concatenated buffers.",
        "suggest": "此方法必须等效于使用级联缓冲区对 `read` 的单个调用。",
        "translate": ""
    },
    {
        "source": "The default implementation calls `read` with either the first nonempty buffer provided, or an empty one if none exists.",
        "suggest": "默认实现使用提供的第一个非空缓冲区调用 `read`，如果不存在，则为空。",
        "translate": ""
    },
    {
        "source": "Determines if this `Read`er has an efficient `read_vectored` implementation.",
        "suggest": "确定此 `Read` 是否具有有效的 `read_vectored` 实现。",
        "translate": ""
    },
    {
        "source": "If a `Read`er does not override the default `read_vectored` implementation, code using it may want to avoid the method all together and coalesce writes into a single buffer for higher performance.",
        "suggest": "如果 `Read` 没有覆盖默认的 `read_vectored` 实现，则使用它的代码可能希望完全避免使用该方法，并合并写入单个缓冲区以提高性能。",
        "translate": ""
    },
    {
        "source": "The default implementation returns `false`.",
        "suggest": "默认实现返回 `false`。",
        "translate": ""
    },
    {
        "source": "Determines if this `Read`er can work with buffers of uninitialized memory.",
        "suggest": "确定该 `Reader` 是否可以与未初始化内存的缓冲区一起使用。",
        "translate": ""
    },
    {
        "source": "The default implementation returns an initializer which will zero buffers.",
        "suggest": "默认实现返回一个初始化，它将零个缓冲区。",
        "translate": ""
    },
    {
        "source": "If a `Read`er guarantees that it can work properly with uninitialized memory, it should call [`Initializer::nop()`].",
        "suggest": "如果 `Reader' 保证它可以与未初始化的内存一起正常工作，则应调用 [`Initializer::nop()`]。",
        "translate": ""
    },
    {
        "source": "See the documentation for [`Initializer`] for details.",
        "suggest": "有关详细信息，请参见 [`Initializer`] 的文档。",
        "translate": ""
    },
    {
        "source": "The behavior of this method must be independent of the state of the `Read`er - the method only takes `&self` so that it can be used through trait objects.",
        "suggest": "该方法的行为必须独立于 `Reader` 的状态 - 该方法仅使用 `&self`，以便可以通过 trait 对象使用它。",
        "translate": ""
    },
    {
        "source": "This method is unsafe because a `Read`er could otherwise return a non-zeroing `Initializer` from another `Read` type without an `unsafe` block.",
        "suggest": "这种方法是不安全的，因为 `Read` 可能会从另一个没有 `unsafe` 块的 `Read` 类型返回非归零的 `Initializer`。",
        "translate": ""
    },
    {
        "source": "Read all bytes until EOF in this source, placing them into `buf`.",
        "suggest": "读取所有字节，直到此源中的 EOF 为止，然后将它们放入 `buf`。",
        "translate": ""
    },
    {
        "source": "All bytes read from this source will be appended to the specified buffer `buf`.",
        "suggest": "从该源读取的所有字节都将附加到指定的缓冲区 `buf`。",
        "translate": ""
    },
    {
        "source": "This function will continuously call [`read()`] to append more data to `buf` until [`read()`] returns either [`Ok(0)`] or an error of non-[`ErrorKind::Interrupted`] kind.",
        "suggest": "该函数将不断调用 [`read()`] 来向 `buf` 附加更多数据，直到 [`read()`] 返回 [`Ok(0)`] 或非 [`ErrorKind::Interrupted`] 类型的错误为止。",
        "translate": ""
    },
    {
        "source": "If successful, this function will return the total number of bytes read.",
        "suggest": "如果成功，此函数将返回读取的字节总数。",
        "translate": ""
    },
    {
        "source": "If this function encounters an error of the kind [`ErrorKind::Interrupted`] then the error is ignored and the operation will continue.",
        "suggest": "如果此函数遇到 [`ErrorKind::Interrupted`] 类型的错误，则该错误将被忽略，并且操作将继续。",
        "translate": ""
    },
    {
        "source": "If any other read error is encountered then this function immediately returns.",
        "suggest": "如果遇到任何其他读取错误，则此函数立即返回。",
        "translate": ""
    },
    {
        "source": "Any bytes which have already been read will be appended to `buf`.",
        "suggest": "任何已读取的字节将被附加到 `buf`。",
        "translate": ""
    },
    {
        "source": "(See also the [`std::fs::read`] convenience function for reading from a file.)",
        "suggest": "(有关读取文件的信息，另请参见 [`std::fs::read`] 便利函数。)",
        "translate": ""
    },
    {
        "source": "Read all bytes until EOF in this source, appending them to `buf`.",
        "suggest": "读取所有字节，直到该源中的 EOF 为止，然后将它们附加到 `buf`。",
        "translate": ""
    },
    {
        "source": "If successful, this function returns the number of bytes which were read and appended to `buf`.",
        "suggest": "如果成功，则此函数返回已读取并附加到 `buf` 的字节数。",
        "translate": ""
    },
    {
        "source": "If the data in this stream is *not* valid UTF-8 then an error is returned and `buf` is unchanged.",
        "suggest": "如果此流中的数据 *不是* 有效的 UTF-8，则返回错误，并且 `buf` 不变。",
        "translate": ""
    },
    {
        "source": "See [`read_to_end`] for other error semantics.",
        "suggest": "有关其他错误语义，请参见 [`read_to_end`]。",
        "translate": ""
    },
    {
        "source": "(See also the [`std::fs::read_to_string`] convenience function for reading from a file.)",
        "suggest": "(有关读取文件的信息，另请参见 [`std::fs::read_to_string`] 便利函数。)",
        "translate": ""
    },
    {
        "source": "Note that we do *not* call `.read_to_end()` here.",
        "suggest": "请注意，我们在这里 *不* 调用 `.read_to_end()`。",
        "translate": ""
    },
    {
        "source": "We are passing `&mut Vec<u8>` (the raw contents of `buf`) into the `read_to_end` method to fill it up.",
        "suggest": "我们将 `&mut Vec<u8>` (`buf` 的原始内容) 传递给 `read_to_end` 方法以填充它。",
        "translate": ""
    },
    {
        "source": "An arbitrary implementation could overwrite the entire contents of the vector, not just append to it (which is what we are expecting).",
        "suggest": "任意实现都可以覆盖 vector 的全部内容，而不仅仅是追加到 vector (这是我们所期望的)。",
        "translate": ""
    },
    {
        "source": "To prevent extraneously checking the UTF-8-ness of the entire buffer we pass it to our hardcoded `read_to_end` implementation which we know is guaranteed to only read data into the end of the buffer.",
        "suggest": "为了避免不必要地检查整个缓冲区的 UTF-8 大小，我们将其传递给我们的硬编码 `read_to_end` 实现，我们知道可以保证只将数据读入缓冲区的末尾。",
        "translate": ""
    },
    {
        "source": "Read the exact number of bytes required to fill `buf`.",
        "suggest": "读取填充 `buf` 所需的确切字节数。",
        "translate": ""
    },
    {
        "source": "This function reads as many bytes as necessary to completely fill the specified buffer `buf`.",
        "suggest": "该函数读取所需的字节数以完全填充指定的缓冲区 `buf`。",
        "translate": ""
    },
    {
        "source": "It is recommended that implementations only write data to `buf` instead of reading its contents.",
        "suggest": "建议实现仅将数据写入 `buf`，而不读取其内容。",
        "translate": ""
    },
    {
        "source": "The documentation on [`read`] has a more detailed explanation on this subject.",
        "suggest": "[`read`] 上的文档对此主题有更详细的说明。",
        "translate": ""
    },
    {
        "source": "If this function encounters an \"end of file\" before completely filling the buffer, it returns an error of the kind [`ErrorKind::UnexpectedEof`].",
        "suggest": "如果此函数在完全填充缓冲区之前遇到 \"end of file\"，它将返回 [`ErrorKind::UnexpectedEof`] 类型的错误。",
        "translate": ""
    },
    {
        "source": "The contents of `buf` are unspecified in this case.",
        "suggest": "在这种情况下，`buf` 的内容未指定。",
        "translate": ""
    },
    {
        "source": "If this function returns an error, it is unspecified how many bytes it has read, but it will never read more than would be necessary to completely fill the buffer.",
        "suggest": "如果此函数返回错误，则无法确定已读取多少字节，但读取的字节数永远不会超过完全填充缓冲区所需的字节数。",
        "translate": ""
    },
    {
        "source": "Creates a \"by reference\" adaptor for this instance of `Read`.",
        "suggest": "为此 `Read` 实例创建 \"by reference\" 适配器。",
        "translate": ""
    },
    {
        "source": "The returned adaptor also implements `Read` and will simply borrow this current reader.",
        "suggest": "返回的适配器还实现了 `Read`，并将仅借用此当前的 reader。",
        "translate": ""
    },
    {
        "source": "Transforms this `Read` instance to an [`Iterator`] over its bytes.",
        "suggest": "将此 `Read` 实例的字节数转换为 [`Iterator`]。",
        "translate": ""
    },
    {
        "source": "The returned type implements [`Iterator`] where the `Item` is [`Result`]`<`[`u8`]`,",
        "suggest": "返回的类型实现 [`Iterator`]，其中 `Item` 为 [`Result`]`<`[`u8`]`，",
        "translate": ""
    },
    {
        "source": "The yielded item is [`Ok`] if a byte was successfully read and [`Err`] otherwise.",
        "suggest": "如果成功读取了一个字节，则产生的项为 [`Ok`]，否则为 [`Err`]。",
        "translate": ""
    },
    {
        "source": "EOF is mapped to returning [`None`] from this iterator.",
        "suggest": "EOF 映射为从此迭代器返回 [`None`]。",
        "translate": ""
    },
    {
        "source": "Creates an adaptor which will chain this stream with another.",
        "suggest": "创建一个适配器，它将将此流与另一个流链接。",
        "translate": ""
    },
    {
        "source": "The returned `Read` instance will first read all bytes from this object until EOF is encountered.",
        "suggest": "返回的 `Read` 实例将首先从该 object 读取所有字节，直到遇到 EOF。",
        "translate": ""
    },
    {
        "source": "Afterwards the output is equivalent to the output of `next`.",
        "suggest": "之后，输出等同于 `next` 的输出。",
        "translate": ""
    },
    {
        "source": "Creates an adaptor which will read at most `limit` bytes from it.",
        "suggest": "创建一个适配器，该适配器最多可以从中读取 `limit` 字节。",
        "translate": ""
    },
    {
        "source": "This function returns a new instance of `Read` which will read at most `limit` bytes, after which it will always return EOF ([`Ok(0)`]).",
        "suggest": "此函数返回 `Read` 的新实例，该实例最多读取 `limit` 字节，此后它将始终返回 EOF ([`Ok(0)`])。",
        "translate": ""
    },
    {
        "source": "Any read errors will not count towards the number of bytes read and future calls to [`read()`] may succeed.",
        "suggest": "任何读取错误都不会计入读取的字节数，并且 [`read()`] 的 future 调用可能会成功。",
        "translate": ""
    },
    {
        "source": "Read all bytes from a [reader][Read] into a new [`String`].",
        "suggest": "将 [reader][Read] 的所有字节读入新的 [`String`]。",
        "translate": ""
    },
    {
        "source": "This is a convenience function for [`Read::read_to_string`].",
        "suggest": "这是 [`Read::read_to_string`] 的便捷函数。",
        "translate": ""
    },
    {
        "source": "Using this function avoids having to create a variable first and provides more type safety since you can only get the buffer out if there were no errors.",
        "suggest": "使用此函数避免了必须先创建变量，并且提供了更多的类型安全性，因为只有在没有错误的情况下才可以取出缓冲区。",
        "translate": ""
    },
    {
        "source": "(If you use [`Read::read_to_string`] you have to remember to check whether the read succeeded because otherwise your buffer will be empty or only partially full.)",
        "suggest": "(如果使用 [`Read::read_to_string`]，则必须记住检查读取是否成功，否则缓冲区将为空或仅部分充满。)",
        "translate": ""
    },
    {
        "source": "The downside of this function's increased ease of use and type safety is that it gives you less control over performance.",
        "suggest": "该函数提高了易用性和类型安全性的缺点是，它使您对性能的控制较少。",
        "translate": ""
    },
    {
        "source": "For example, you can't pre-allocate memory like you can using [`String::with_capacity`] and [`Read::read_to_string`].",
        "suggest": "例如，您不能像使用 [`String::with_capacity`] 和 [`Read::read_to_string`] 一样预先分配内存。",
        "translate": ""
    },
    {
        "source": "Also, you can't re-use the buffer if an error occurs while reading.",
        "suggest": "另外，如果读取时发生错误，则无法重新使用缓冲区。",
        "translate": ""
    },
    {
        "source": "In many cases, this function's performance will be adequate and the ease of use and type safety tradeoffs will be worth it.",
        "suggest": "在许多情况下，此函数的性能将是适当的，并且易于使用和类型安全性的折衷是值得的。",
        "translate": ""
    },
    {
        "source": "However, there are cases where you need more control over performance, and in those cases you should definitely use [`Read::read_to_string`] directly.",
        "suggest": "但是，在某些情况下，您需要对性能进行更多控制，在这些情况下，您绝对应该直接使用 [`Read::read_to_string`]。",
        "translate": ""
    },
    {
        "source": "This function forces you to handle errors because the output (the `String`) is wrapped in a [`Result`].",
        "suggest": "此函数迫使您处理错误，因为输出 (`String`) 包装在 [`Result`] 中。",
        "translate": ""
    },
    {
        "source": "See [`Read::read_to_string`] for the errors that can occur.",
        "suggest": "有关可能发生的错误，请参见 [`Read::read_to_string`]。",
        "translate": ""
    },
    {
        "source": "If any error occurs, you will get an [`Err`], so you don't have to worry about your buffer being empty or partially full.",
        "suggest": "如果发生任何错误，您将得到 [`Err`]，因此您不必担心缓冲区为空或部分已满。",
        "translate": ""
    },
    {
        "source": "A buffer type used with `Read::read_vectored`.",
        "suggest": "`Read::read_vectored` 使用的缓冲区类型。",
        "translate": ""
    },
    {
        "source": "It is semantically a wrapper around an `&mut [u8]`, but is guaranteed to be ABI compatible with the `iovec` type on Unix platforms and `WSABUF` on Windows.",
        "suggest": "从语义上来说，它是 `&mut [u8]` 的包装，但是可以保证与 Unix 平台上的 `iovec` 类型和 Windows 上的 `WSABUF` 具有 ABI 兼容性。",
        "translate": ""
    },
    {
        "source": "Creates a new `IoSliceMut` wrapping a byte slice.",
        "suggest": "创建一个新的 `IoSliceMut`，包装一个字节切片。",
        "translate": ""
    },
    {
        "source": "Panics on Windows if the slice is larger than 4GB.",
        "suggest": "如果切片大于 4GB，则在 Windows 上使用 Panics。",
        "translate": ""
    },
    {
        "source": "Advance the internal cursor of the slice.",
        "suggest": "前进切片的内部游标。",
        "translate": ""
    },
    {
        "source": "Elements in the slice may be modified if the cursor is not advanced to the end of the slice.",
        "suggest": "如果游标没有移到切片的末尾，则可以修改切片中的元素。",
        "translate": ""
    },
    {
        "source": "For example if we have a slice of buffers with 2 `IoSliceMut`s, both of length 8, and we advance the cursor by 10 bytes the first `IoSliceMut` will be untouched however the second will be modified to remove the first 2 bytes (10 - 8).",
        "suggest": "例如，如果我们有一个带有 2 个 `IoSliceMut` 的缓冲区切片，两个缓冲区的长度均为 8，并且我们将游标前进了 10 个字节，则第一个 `IoSliceMut` 将保持不变，但是第二个 `IoSliceMut` 将被修改以删除前 2 个字节 (10-8)。",
        "translate": ""
    },
    {
        "source": "Number of buffers to remove.",
        "suggest": "要删除的缓冲区数。",
        "translate": ""
    },
    {
        "source": "Total length of all the to be removed buffers.",
        "suggest": "所有要删除的缓冲区的总长度。",
        "translate": ""
    },
    {
        "source": "A buffer type used with `Write::write_vectored`.",
        "suggest": "`Write::write_vectored` 使用的缓冲区类型。",
        "translate": ""
    },
    {
        "source": "It is semantically a wrapper around an `&[u8]`, but is guaranteed to be ABI compatible with the `iovec` type on Unix platforms and `WSABUF` on Windows.",
        "suggest": "从语义上来说，它是 `&[u8]` 的包装，但是可以保证与 Unix 平台上的 `iovec` 类型和 Windows 上的 `WSABUF` 具有 ABI 兼容性。",
        "translate": ""
    },
    {
        "source": "Creates a new `IoSlice` wrapping a byte slice.",
        "suggest": "创建一个新的 `IoSlice`，包装一个字节切片。",
        "translate": ""
    },
    {
        "source": "For example if we have a slice of buffers with 2 `IoSlice`s, both of length 8, and we advance the cursor by 10 bytes the first `IoSlice` will be untouched however the second will be modified to remove the first 2 bytes (10 - 8).",
        "suggest": "例如，如果我们有一个缓冲区切片，缓冲区的长度均为 2`IoSlice'，长度均为 8，并且将游标向前移动了 10 个字节，则第一个 `IoSlice` 将保持不变，但是第二个 `IoSlice` 将被修改以删除前两个字节 (10-8)。",
        "translate": ""
    },
    {
        "source": "Mark 10 bytes as written.",
        "suggest": "将 10 个字节标记为已写入。",
        "translate": ""
    },
    {
        "source": "bufs = IoSlice::advance(bufs, 10);",
        "suggest": "bufs=IoSlice::advance (bufs，10) ;",
        "translate": ""
    },
    {
        "source": "A type used to conditionally initialize buffers passed to `Read` methods.",
        "suggest": "一种类型，用于有条件地初始化传递给 `Read` 方法的缓冲区。",
        "translate": ""
    },
    {
        "source": "Returns a new `Initializer` which will zero out buffers.",
        "suggest": "返回一个新的 `Initializer`，它将缓冲区归零。",
        "translate": ""
    },
    {
        "source": "Returns a new `Initializer` which will not zero out buffers.",
        "suggest": "返回不会将缓冲区归零的新 `Initializer`。",
        "translate": ""
    },
    {
        "source": "This may only be called by `Read`ers which guarantee that they will not read from buffers passed to `Read` methods, and that the return value of the method accurately reflects the number of bytes that have been written to the head of the buffer.",
        "suggest": "这只能由 `Read` 调用，该 `Read` 保证它们不会从传递给 `Read` 方法的缓冲区中读取，并且该方法的返回值准确地反映了已写入缓冲区头部的字节数。",
        "translate": ""
    },
    {
        "source": "Indicates if a buffer should be initialized.",
        "suggest": "指示是否应初始化缓冲区。",
        "translate": ""
    },
    {
        "source": "Initializes a buffer if necessary.",
        "suggest": "必要时初始化缓冲区。",
        "translate": ""
    },
    {
        "source": "A trait for objects which are byte-oriented sinks.",
        "suggest": "trait 用于面向字节的 sinks 的对象。",
        "translate": ""
    },
    {
        "source": "Implementors of the `Write` trait are sometimes called 'writers'.",
        "suggest": "`Write` trait 的实现者有时称为 'writers'。",
        "translate": ""
    },
    {
        "source": "Writers are defined by two required methods, [`write`] and [`flush`]:",
        "suggest": "Writers 由两种必需的方法 [`write`] 和 [`flush`] 定义:",
        "translate": ""
    },
    {
        "source": "The [`write`] method will attempt to write some data into the object, returning how many bytes were successfully written.",
        "suggest": "[`write`] 方法将尝试将一些数据写入 object，返回成功写入的字节数。",
        "translate": ""
    },
    {
        "source": "The [`flush`] method is useful for adaptors and explicit buffers themselves for ensuring that all buffered data has been pushed out to the 'true sink'.",
        "suggest": "[`flush`] 方法对于适配器和显式缓冲区本身很有用，以确保所有缓冲数据都已推送到 `true sink`。",
        "translate": ""
    },
    {
        "source": "Writers are intended to be composable with one another.",
        "suggest": "Writers 旨在彼此组成。",
        "translate": ""
    },
    {
        "source": "Many implementors throughout [`std::io`] take and provide types which implement the `Write` trait.",
        "suggest": "[`std::io`] 上的许多实现器都采用并提供实现 `Write` trait 的类型。",
        "translate": ""
    },
    {
        "source": "The trait also provides convenience methods like [`write_all`], which calls `write` in a loop until its entire input has been written.",
        "suggest": "trait 还提供了便捷的方法，例如 [`write_all`]，它在循环中调用 `write`，直到其整个输入被写入为止。",
        "translate": ""
    },
    {
        "source": "Write a buffer into this writer, returning how many bytes were written.",
        "suggest": "在此 writer 中写入一个缓冲区，返回写入的字节数。",
        "translate": ""
    },
    {
        "source": "This function will attempt to write the entire contents of `buf`, but the entire write may not succeed, or the write may also generate an error.",
        "suggest": "该函数将尝试写入 `buf` 的全部内容，但是整个写入可能不会成功，或者该写入也可能会产生错误。",
        "translate": ""
    },
    {
        "source": "A call to `write` represents *at most one* attempt to write to any wrapped object.",
        "suggest": "对 `write` 的调用表示 *at most 对任何包装的 object 进行写操作的尝试。",
        "translate": ""
    },
    {
        "source": "Calls to `write` are not guaranteed to block waiting for data to be written, and a write which would otherwise block can be indicated through an [`Err`] variant.",
        "suggest": "不能保证对 `write` 的调用会阻塞等待数据写入的等待，否则可以通过 [`Err`] 成员指示将阻塞的写入。",
        "translate": ""
    },
    {
        "source": "If the return value is [`Ok(n)`] then it must be guaranteed that `n <= buf.len()`.",
        "suggest": "如果返回值为 [`Ok(n)`]，则必须保证 `n <= buf.len()`。",
        "translate": ""
    },
    {
        "source": "A return value of `0` typically means that the underlying object is no longer able to accept bytes and will likely not be able to in the future as well, or that the buffer provided is empty.",
        "suggest": "`0` 的返回值通常意味着基础 object 不再能够接受字节，并且可能也无法在 future 中接收，或者提供的缓冲区为空。",
        "translate": ""
    },
    {
        "source": "Each call to `write` may generate an I/O error indicating that the operation could not be completed.",
        "suggest": "对 `write` 的每次调用都可能产生 I/O 错误，指示操作无法完成。",
        "translate": ""
    },
    {
        "source": "If an error is returned then no bytes in the buffer were written to this writer.",
        "suggest": "如果返回错误，则缓冲区中没有字节写入此 writer。",
        "translate": ""
    },
    {
        "source": "It is **not** considered an error if the entire buffer could not be written to this writer.",
        "suggest": "如果无法将整个缓冲区写入此 writer，则不认为是错误。",
        "translate": ""
    },
    {
        "source": "An error of the [`ErrorKind::Interrupted`] kind is non-fatal and the write operation should be retried if there is nothing else to do.",
        "suggest": "[`ErrorKind::Interrupted`] 类型的错误是非致命错误，如果没有其他事情可做，则应重试写入操作。",
        "translate": ""
    },
    {
        "source": "Like [`write`], except that it writes from a slice of buffers.",
        "suggest": "类似于 [`write`]，不同之处在于它是从缓冲区片段中写入数据的。",
        "translate": ""
    },
    {
        "source": "Data is copied from each buffer in order, with the final buffer read from possibly being only partially consumed.",
        "suggest": "数据是按顺序从每个缓冲区复制的，从中读取的最终缓冲区可能仅被部分消耗。",
        "translate": ""
    },
    {
        "source": "This method must behave as a call to [`write`] with the buffers concatenated would.",
        "suggest": "此方法必须与串联的缓冲区对 [`write`] 的调用相同。",
        "translate": ""
    },
    {
        "source": "The default implementation calls [`write`] with either the first nonempty buffer provided, or an empty one if none exists.",
        "suggest": "默认实现使用提供的第一个非空缓冲区调用 [`write`]，如果不存在，则为空。",
        "translate": ""
    },
    {
        "source": "Determines if this `Write`r has an efficient [`write_vectored`] implementation.",
        "suggest": "确定此 `Write`r 是否具有有效的 [`write_vectored`] 实现。",
        "translate": ""
    },
    {
        "source": "If a `Write`r does not override the default [`write_vectored`] implementation, code using it may want to avoid the method all together and coalesce writes into a single buffer for higher performance.",
        "suggest": "如果 `Write`r 没有覆盖默认的 [`write_vectored`] 实现，则使用它的代码可能希望完全避免使用该方法，并合并写入单个缓冲区以提高性能。",
        "translate": ""
    },
    {
        "source": "Flush this output stream, ensuring that all intermediately buffered contents reach their destination.",
        "suggest": "刷新此输出流，确保所有中间缓冲的内容均到达其目的地。",
        "translate": ""
    },
    {
        "source": "It is considered an error if not all bytes could be written due to I/O errors or EOF being reached.",
        "suggest": "如果由于 I/O 错误或达到 EOF 而无法写入所有字节，则认为是错误。",
        "translate": ""
    },
    {
        "source": "Attempts to write an entire buffer into this writer.",
        "suggest": "尝试将整个缓冲区写入此 writer。",
        "translate": ""
    },
    {
        "source": "This method will continuously call [`write`] until there is no more data to be written or an error of non-[`ErrorKind::Interrupted`] kind is returned.",
        "suggest": "此方法将连续调用 [`write`]，直到没有更多数据要写入或返回非 [`ErrorKind::Interrupted`] 类型的错误为止。",
        "translate": ""
    },
    {
        "source": "This method will not return until the entire buffer has been successfully written or such an error occurs.",
        "suggest": "在成功写入整个缓冲区或发生此类错误之前，此方法将不会返回。",
        "translate": ""
    },
    {
        "source": "The first error that is not of [`ErrorKind::Interrupted`] kind generated from this method will be returned.",
        "suggest": "从此方法生成的不是 [`ErrorKind::Interrupted`] 类型的第一个错误将被返回。",
        "translate": ""
    },
    {
        "source": "If the buffer contains no data, this will never call [`write`].",
        "suggest": "如果缓冲区不包含任何数据，则永远不会调用 [`write`]。",
        "translate": ""
    },
    {
        "source": "This function will return the first error of non-[`ErrorKind::Interrupted`] kind that [`write`] returns.",
        "suggest": "该函数将返回 [`write`] 返回的第一个非 -[`ErrorKind::Interrupted`] 类型的错误。",
        "translate": ""
    },
    {
        "source": "Attempts to write multiple buffers into this writer.",
        "suggest": "尝试将多个缓冲区写入此 writer。",
        "translate": ""
    },
    {
        "source": "This method will continuously call [`write_vectored`] until there is no more data to be written or an error of non-[`ErrorKind::Interrupted`] kind is returned.",
        "suggest": "此方法将连续调用 [`write_vectored`]，直到没有更多数据要写入或返回非 [`ErrorKind::Interrupted`] 类型的错误为止。",
        "translate": ""
    },
    {
        "source": "This method will not return until all buffers have been successfully written or such an error occurs.",
        "suggest": "在成功写入所有缓冲区或发生此类错误之前，此方法将不会返回。",
        "translate": ""
    },
    {
        "source": "If the buffer contains no data, this will never call [`write_vectored`].",
        "suggest": "如果缓冲区不包含任何数据，则永远不会调用 [`write_vectored`]。",
        "translate": ""
    },
    {
        "source": "Unlike [`write_vectored`], this takes a *mutable* reference to a slice of [`IoSlice`]s, not an immutable one.",
        "suggest": "与 [`write_vectored`] 不同，这需要对 [`IoSlice`] 的切片进行 *可变* 引用，而不是不可变。",
        "translate": ""
    },
    {
        "source": "That's because we need to modify the slice to keep track of the bytes already written.",
        "suggest": "那是因为我们需要修改切片以跟踪已写入的字节。",
        "translate": ""
    },
    {
        "source": "Once this function returns, the contents of `bufs` are unspecified, as this depends on how many calls to [`write_vectored`] were necessary.",
        "suggest": "此函数返回后，将不指定 `bufs` 的内容，这取决于需要对 [`write_vectored`] 进行多少次调用。",
        "translate": ""
    },
    {
        "source": "It is best to understand this function as taking ownership of `bufs` and to not use `bufs` afterwards.",
        "suggest": "最好将此函数理解为拥有 `bufs` 的所有权，并且此后不使用 `bufs`。",
        "translate": ""
    },
    {
        "source": "The underlying buffers, to which the [`IoSlice`]s point (but not the [`IoSlice`]s themselves), are unchanged and can be reused.",
        "suggest": "[IoSlice] 指向的基础缓冲区 (而不是 [IoSlice] 本身) 是不变的，可以重用。",
        "translate": ""
    },
    {
        "source": "Guarantee that bufs is empty if it contains no data, to avoid calling write_vectored if there is no data to be written.",
        "suggest": "如果 bufs 不包含任何数据，请确保它为空，以避免在没有要写入的数据时调用 write_vectored。",
        "translate": ""
    },
    {
        "source": "Writes a formatted string into this writer, returning any error encountered.",
        "suggest": "将格式化的字符串写入此 writer，返回遇到的任何错误。",
        "translate": ""
    },
    {
        "source": "This method is primarily used to interface with the [`format_args!()`] macro, but it is rare that this should explicitly be called.",
        "suggest": "该方法主要用于与 [`format_args!()`] 宏进行接口连接，但是很少需要显式调用它。",
        "translate": ""
    },
    {
        "source": "The [`write!()`] macro should be favored to invoke this method instead.",
        "suggest": "应优先使用 [`write!()`] 宏来调用此方法。",
        "translate": ""
    },
    {
        "source": "This function internally uses the [`write_all`] method on this trait and hence will continuously write data so long as no errors are received.",
        "suggest": "此函数内部在此 trait 上使用 [`write_all`] 方法，因此只要没有收到错误，就将连续写入数据。",
        "translate": ""
    },
    {
        "source": "This also means that partial writes are not indicated in this signature.",
        "suggest": "这也意味着此签名中未指示部分写入。",
        "translate": ""
    },
    {
        "source": "This function will return any I/O error reported while formatting.",
        "suggest": "此函数将返回格式化时报告的任何 I/O 错误。",
        "translate": ""
    },
    {
        "source": "Create a shim which translates a Write to a fmt::Write and saves off I/O errors.",
        "suggest": "创建一个垫片，该垫片将 Write 转换为 fmt::Write 并避免 I/O 错误。",
        "translate": ""
    },
    {
        "source": "instead of discarding them",
        "suggest": "而不是丢弃它们",
        "translate": ""
    },
    {
        "source": "check if the error came from the underlying `Write` or not",
        "suggest": "检查错误是否来自基础 `Write`",
        "translate": ""
    },
    {
        "source": "Creates a \"by reference\" adaptor for this instance of `Write`.",
        "suggest": "为此 `Write` 实例创建 \"by reference\" 适配器。",
        "translate": ""
    },
    {
        "source": "The returned adaptor also implements `Write` and will simply borrow this current writer.",
        "suggest": "返回的适配器还实现了 `Write`，将仅借用此当前的 writer。",
        "translate": ""
    },
    {
        "source": "The `Seek` trait provides a cursor which can be moved within a stream of bytes.",
        "suggest": "`Seek` trait 提供了一个游标，可以在字节流中移动它。",
        "translate": ""
    },
    {
        "source": "The stream typically has a fixed size, allowing seeking relative to either end or the current offset.",
        "suggest": "流通常具有固定的大小，允许相对于端点或当前偏移量进行搜索。",
        "translate": ""
    },
    {
        "source": "[`File`]s implement `Seek`:",
        "suggest": "[`File`] 的工具 `Seek`:",
        "translate": ""
    },
    {
        "source": "Seek to an offset, in bytes, in a stream.",
        "suggest": "在流中寻找以字节为单位的偏移量。",
        "translate": ""
    },
    {
        "source": "A seek beyond the end of a stream is allowed, but behavior is defined by the implementation.",
        "suggest": "允许在流的末尾进行查找，但是行为由实现定义。",
        "translate": ""
    },
    {
        "source": "If the seek operation completed successfully, this method returns the new position from the start of the stream.",
        "suggest": "如果查找操作成功完成，则此方法从流的开头返回新位置。",
        "translate": ""
    },
    {
        "source": "That position can be used later with [`SeekFrom::Start`].",
        "suggest": "该位置以后可以与 [`SeekFrom::Start`] 一起使用。",
        "translate": ""
    },
    {
        "source": "Seeking to a negative offset is considered an error.",
        "suggest": "寻求负偏移被认为是错误。",
        "translate": ""
    },
    {
        "source": "Returns the length of this stream (in bytes).",
        "suggest": "返回此流的长度 (以字节为单位)。",
        "translate": ""
    },
    {
        "source": "This method is implemented using up to three seek operations.",
        "suggest": "此方法最多使用三个查找操作来实现。",
        "translate": ""
    },
    {
        "source": "If this method returns successfully, the seek position is unchanged (i.e. the position before calling this method is the same as afterwards).",
        "suggest": "如果此方法成功返回，则搜索位置不变 (即，调用此方法之前的位置与之后的位置相同)。",
        "translate": ""
    },
    {
        "source": "However, if this method returns an error, the seek position is unspecified.",
        "suggest": "但是，如果此方法返回错误，则未指定搜索位置。",
        "translate": ""
    },
    {
        "source": "If you need to obtain the length of *many* streams and you don't care about the seek position afterwards, you can reduce the number of seek operations by simply calling `seek(SeekFrom::End(0))` and using its return value (it is also the stream length).",
        "suggest": "如果您需要获取 *多个* 流的长度，并且以后不再关心查找位置，则可以通过简单地调用 `seek(SeekFrom::End(0))` 并使用其返回值 (它也是流的长度) 来减少查找操作的次数。",
        "translate": ""
    },
    {
        "source": "Note that length of a stream can change over time (for example, when data is appended to a file).",
        "suggest": "请注意，流的长度可以随时间变化 (例如，将数据附加到文件时)。",
        "translate": ""
    },
    {
        "source": "So calling this method multiple times does not necessarily return the same length each time.",
        "suggest": "因此，多次调用此方法不一定每次都返回相同的长度。",
        "translate": ""
    },
    {
        "source": "Avoid seeking a third time when we were already at the end of the stream.",
        "suggest": "当我们已经走到尽头时，请避免再寻求第三次机会。",
        "translate": ""
    },
    {
        "source": "The branch is usually way cheaper than a seek operation.",
        "suggest": "分支通常比查找操作便宜。",
        "translate": ""
    },
    {
        "source": "This is equivalent to `self.seek(SeekFrom::Current(0))`.",
        "suggest": "这等效于 `self.seek(SeekFrom::Current(0))`。",
        "translate": ""
    },
    {
        "source": "Enumeration of possible methods to seek within an I/O object.",
        "suggest": "列举可能在 I/O object 中进行搜索的方法。",
        "translate": ""
    },
    {
        "source": "It is used by the [`Seek`] trait.",
        "suggest": "[`Seek`] trait 使用它。",
        "translate": ""
    },
    {
        "source": "Sets the offset to the provided number of bytes.",
        "suggest": "将偏移量设置为提供的字节数。",
        "translate": ""
    },
    {
        "source": "Sets the offset to the size of this object plus the specified number of bytes.",
        "suggest": "将偏移量设置为此 object 的大小加上指定的字节数。",
        "translate": ""
    },
    {
        "source": "It is possible to seek beyond the end of an object, but it's an error to seek before byte 0.",
        "suggest": "可以在 object 的末尾进行查找，但是在字节 0 之前进行查找是错误的。",
        "translate": ""
    },
    {
        "source": "Sets the offset to the current position plus the specified number of bytes.",
        "suggest": "将偏移量设置为当前位置加上指定的字节数。",
        "translate": ""
    },
    {
        "source": "A `BufRead` is a type of `Read`er which has an internal buffer, allowing it to perform extra ways of reading.",
        "suggest": "`BufRead` 是带有内部缓冲区的 `Read` 类型，它可以执行其他读取方式。",
        "translate": ""
    },
    {
        "source": "For example, reading line-by-line is inefficient without using a buffer, so if you want to read by line, you'll need `BufRead`, which includes a [`read_line`] method as well as a [`lines`] iterator.",
        "suggest": "例如，在不使用缓冲区的情况下，逐行读取效率很低，因此，如果要逐行读取，则需要 `BufRead`，其中包括 [`read_line`] 方法和 [`lines`] 迭代器。",
        "translate": ""
    },
    {
        "source": "A locked standard input implements `BufRead`:",
        "suggest": "锁定的标准输入实现 `BufRead`:",
        "translate": ""
    },
    {
        "source": "If you have something that implements [`Read`], you can use the [`BufReader` type][`BufReader`] to turn it into a `BufRead`.",
        "suggest": "如果您具有实现 [`Read`] 的功能，则可以使用 [`BufReader` type][`BufReader`] 将其转换为 `BufRead`。",
        "translate": ""
    },
    {
        "source": "For example, [`File`] implements [`Read`], but not `BufRead`.",
        "suggest": "例如，[`File`] 实现 [`Read`]，但不实现 `BufRead`。",
        "translate": ""
    },
    {
        "source": "to the rescue!",
        "suggest": "抢救!",
        "translate": ""
    },
    {
        "source": "Returns the contents of the internal buffer, filling it with more data from the inner reader if it is empty.",
        "suggest": "返回内部缓冲区的内容，如果内部缓冲区为空，则使用内部 reader 中的更多数据填充内部缓冲区。",
        "translate": ""
    },
    {
        "source": "This function is a lower-level call.",
        "suggest": "此函数是较低级别的调用。",
        "translate": ""
    },
    {
        "source": "It needs to be paired with the [`consume`] method to function properly.",
        "suggest": "它需要与 [`consume`] 方法配对才能正确执行功能。",
        "translate": ""
    },
    {
        "source": "When calling this method, none of the contents will be \"read\" in the sense that later calling `read` may return the same contents.",
        "suggest": "当调用此方法时，任何内容都不是 \"read\"，因为稍后调用 `read` 可能会返回相同的内容。",
        "translate": ""
    },
    {
        "source": "As such, [`consume`] must be called with the number of bytes that are consumed from this buffer to ensure that the bytes are never returned twice.",
        "suggest": "因此，必须使用此缓冲区消耗的字节数来调用 [`consume`]，以确保字节永远不会返回两次。",
        "translate": ""
    },
    {
        "source": "An empty buffer returned indicates that the stream has reached EOF.",
        "suggest": "返回的空缓冲区表示流已达到 EOF。",
        "translate": ""
    },
    {
        "source": "This function will return an I/O error if the underlying reader was read, but returned an error.",
        "suggest": "如果已读取基础 reader，但此函数返回错误，则此函数将返回 I/O 错误。",
        "translate": ""
    },
    {
        "source": "Tells this buffer that `amt` bytes have been consumed from the buffer, so they should no longer be returned in calls to `read`.",
        "suggest": "告诉此缓冲区 `amt` 字节已从缓冲区中消耗掉，因此在调用 `read` 时不再应返回它们。",
        "translate": ""
    },
    {
        "source": "This function does not perform any I/O, it simply informs this object that some amount of its buffer, returned from [`fill_buf`], has been consumed and should no longer be returned.",
        "suggest": "该函数不执行任何 I/O，它只是通知 object 从 [`fill_buf`] 返回的某些缓冲区已被消耗，不应再返回。",
        "translate": ""
    },
    {
        "source": "As such, this function may do odd things if [`fill_buf`] isn't called before calling it.",
        "suggest": "因此，如果在调用 [`fill_buf`] 之前未对其进行调用，则此函数可能会做一些奇怪的事情。",
        "translate": ""
    },
    {
        "source": "The `amt` must be `<=` the number of bytes in the buffer returned by [`fill_buf`].",
        "suggest": "`amt` 必须为 `<=`，即 [`fill_buf`] 返回的缓冲区中的字节数。",
        "translate": ""
    },
    {
        "source": "Since `consume()` is meant to be used with [`fill_buf`], that method's example includes an example of `consume()`.",
        "suggest": "由于 `consume()` 旨在与 [`fill_buf`] 一起使用，因此该方法的示例包括 `consume()` 的示例。",
        "translate": ""
    },
    {
        "source": "Read all bytes into `buf` until the delimiter `byte` or EOF is reached.",
        "suggest": "将所有字节读入 `buf`，直到到达定界符 `byte` 或 EOF。",
        "translate": ""
    },
    {
        "source": "This function will read bytes from the underlying stream until the delimiter or EOF is found.",
        "suggest": "该函数将从底层流中读取字节，直到找到定界符或 EOF。",
        "translate": ""
    },
    {
        "source": "Once found, all bytes up to, and including, the delimiter (if found) will be appended to `buf`.",
        "suggest": "一旦找到，定界符 (包括定界符) 之前 (包括找到) 的所有字节都将附加到 `buf`。",
        "translate": ""
    },
    {
        "source": "This function is blocking and should be used carefully: it is possible for an attacker to continuously send bytes without ever sending the delimiter or EOF.",
        "suggest": "该函数正在阻塞，应谨慎使用: 攻击者有可能连续发送字节而无需发送定界符或 EOF。",
        "translate": ""
    },
    {
        "source": "This function will ignore all instances of [`ErrorKind::Interrupted`] and will otherwise return any errors returned by [`fill_buf`].",
        "suggest": "该函数将忽略 [`ErrorKind::Interrupted`] 的所有实例，否则将返回 [`fill_buf`] 返回的任何错误。",
        "translate": ""
    },
    {
        "source": "If an I/O error is encountered then all bytes read so far will be present in `buf` and its length will have been adjusted appropriately.",
        "suggest": "如果遇到 I/O 错误，则 `buf` 中将存在到目前为止已读取的所有字节，并且已对其长度进行了适当的调整。",
        "translate": ""
    },
    {
        "source": "is a type that implements `BufRead`.",
        "suggest": "是实现 `BufRead` 的类型。",
        "translate": ""
    },
    {
        "source": "In this example, we use [`Cursor`] to read all the bytes in a byte slice in hyphen delimited segments:",
        "suggest": "在此示例中，我们使用 [`Cursor`] 读取以连字符分隔的段中的字节片中的所有字节:",
        "translate": ""
    },
    {
        "source": "Read all bytes until a newline (the `0xA` byte) is reached, and append them to the provided buffer.",
        "suggest": "读取所有字节，直到到达换行符 (`0xA` 字节)，然后将它们附加到提供的缓冲区中。",
        "translate": ""
    },
    {
        "source": "This function will read bytes from the underlying stream until the newline delimiter (the `0xA` byte) or EOF is found.",
        "suggest": "该函数将从底层流中读取字节，直到找到换行符 (`0xA` 字节) 或 EOF。",
        "translate": ""
    },
    {
        "source": "If this function returns [`Ok(0)`], the stream has reached EOF.",
        "suggest": "如果此函数返回 [`Ok(0)`]，则流已到达 EOF。",
        "translate": ""
    },
    {
        "source": "This function is blocking and should be used carefully: it is possible for an attacker to continuously send bytes without ever sending a newline or EOF.",
        "suggest": "该函数正在阻塞，应谨慎使用: 攻击者有可能连续发送字节而无需发送换行符或 EOF。",
        "translate": ""
    },
    {
        "source": "This function has the same error semantics as [`read_until`] and will also return an error if the read bytes are not valid UTF-8.",
        "suggest": "该函数与 [`read_until`] 具有相同的错误语义，如果读取的字节无效，则还将返回错误。",
        "translate": ""
    },
    {
        "source": "If an I/O error is encountered then `buf` may contain some bytes already read in the event that all data read so far was valid UTF-8.",
        "suggest": "如果遇到 I/O 错误，则 `buf` 可能包含一些已读取的字节，如果到目前为止读取的所有数据都是有效的 UTF-8。",
        "translate": ""
    },
    {
        "source": "Note that we are not calling the `.read_until` method here, but rather our hardcoded implementation.",
        "suggest": "请注意，我们不是在这里调用 `.read_until` 方法，而是我们的硬编码实现。",
        "translate": ""
    },
    {
        "source": "For more details as to why, see the comments in `read_to_end`.",
        "suggest": "有关原因的更多详细信息，请参见 `read_to_end` 中的注释。",
        "translate": ""
    },
    {
        "source": "Returns an iterator over the contents of this reader split on the byte `byte`.",
        "suggest": "返回对该字节 `byte` 上的 reader 拆分内容的迭代器。",
        "translate": ""
    },
    {
        "source": "The iterator returned from this function will return instances of [`io::Result`]`<`[`Vec<u8>`]`>`.",
        "suggest": "从此函数返回的迭代器将返回 [`io::Result`]`<`[`Vec<u8>`]`>` 的实例。",
        "translate": ""
    },
    {
        "source": "Each vector returned will *not* have the delimiter byte at the end.",
        "suggest": "返回的每个 vector 都不会在末尾有定界符字节。",
        "translate": ""
    },
    {
        "source": "This function will yield errors whenever [`read_until`] would have also yielded an error.",
        "suggest": "只要 [`read_until`] 也产生错误，此函数就会产生错误。",
        "translate": ""
    },
    {
        "source": "In this example, we use [`Cursor`] to iterate over all hyphen delimited segments in a byte slice",
        "suggest": "在此示例中，我们使用 [`Cursor`] 遍历字节切片中的所有连字符分隔的段",
        "translate": ""
    },
    {
        "source": "Returns an iterator over the lines of this reader.",
        "suggest": "返回此 reader 的各行上的迭代器。",
        "translate": ""
    },
    {
        "source": "The iterator returned from this function will yield instances of [`io::Result`]`<`[`String`]`>`.",
        "suggest": "从此函数返回的迭代器将产生 [`io::Result`]`<`[`String`]`>` 的实例。",
        "translate": ""
    },
    {
        "source": "Each string returned will *not* have a newline byte (the `0xA` byte) or `CRLF` (`0xD`, `0xA` bytes) at the end.",
        "suggest": "返回的每个字符串 *不会* 在末尾有换行符 (`0xA` 字节) 或 `CRLF` (`0xD`，`0xA` 字节)。",
        "translate": ""
    },
    {
        "source": "In this example, we use [`Cursor`] to iterate over all the lines in a byte slice.",
        "suggest": "在此示例中，我们使用 [`Cursor`] 遍历字节切片中的所有行。",
        "translate": ""
    },
    {
        "source": "Each line of the iterator has the same error semantics as [`BufRead::read_line`].",
        "suggest": "迭代器的每一行都具有与 [`BufRead::read_line`] 相同的错误语义。",
        "translate": ""
    },
    {
        "source": "Adaptor to chain together two readers.",
        "suggest": "将两个 readers 链接在一起的适配器。",
        "translate": ""
    },
    {
        "source": "This struct is generally created by calling [`chain`] on a reader.",
        "suggest": "通常通过在 reader 上调用 [`chain`] 来创建此结构体。",
        "translate": ""
    },
    {
        "source": "Please see the documentation of [`chain`] for more details.",
        "suggest": "请参见 [`chain`] 的文档以获取更多详细信息。",
        "translate": ""
    },
    {
        "source": "Consumes the `Chain`, returning the wrapped readers.",
        "suggest": "消耗 `Chain`，返回包装的 readers。",
        "translate": ""
    },
    {
        "source": "Gets references to the underlying readers in this `Chain`.",
        "suggest": "在此 `Chain` 中获得对基础 readers 的引用。",
        "translate": ""
    },
    {
        "source": "Gets mutable references to the underlying readers in this `Chain`.",
        "suggest": "获取此 `Chain` 中基础 readers 的可变引用。",
        "translate": ""
    },
    {
        "source": "Care should be taken to avoid modifying the internal I/O state of the underlying readers as doing so may corrupt the internal state of this `Chain`.",
        "suggest": "应注意避免修改基础 readers 的内部 I/O 状态，因为这样做可能会破坏该 `Chain` 的内部状态。",
        "translate": ""
    },
    {
        "source": "Reader adaptor which limits the bytes read from an underlying reader.",
        "suggest": "Reader 适配器，用于限制从基础 reader 读取的字节。",
        "translate": ""
    },
    {
        "source": "This struct is generally created by calling [`take`] on a reader.",
        "suggest": "通常通过在 reader 上调用 [`take`] 来创建此结构体。",
        "translate": ""
    },
    {
        "source": "Please see the documentation of [`take`] for more details.",
        "suggest": "请参见 [`take`] 的文档以获取更多详细信息。",
        "translate": ""
    },
    {
        "source": "Returns the number of bytes that can be read before this instance will return EOF.",
        "suggest": "返回在此实例返回 EOF 之前可以读取的字节数。",
        "translate": ""
    },
    {
        "source": "This instance may reach `EOF` after reading fewer bytes than indicated by this method if the underlying [`Read`] instance reaches EOF.",
        "suggest": "如果基础 [`Read`] 实例达到 EOF，则在读取的字节数少于此方法指示的字节数之后，此实例可能到达 `EOF`。",
        "translate": ""
    },
    {
        "source": "Sets the number of bytes that can be read before this instance will return EOF.",
        "suggest": "设置在此实例返回 EOF 之前可以读取的字节数。",
        "translate": ""
    },
    {
        "source": "This is the same as constructing a new `Take` instance, so the amount of bytes read and the previous limit value don't matter when calling this method.",
        "suggest": "这与构造新的 `Take` 实例相同，因此在调用此方法时，读取的字节数和先前的限制值无关紧要。",
        "translate": ""
    },
    {
        "source": "Consumes the `Take`, returning the wrapped reader.",
        "suggest": "消耗 `Take`，返回包装的 reader。",
        "translate": ""
    },
    {
        "source": "Care should be taken to avoid modifying the internal I/O state of the underlying reader as doing so may corrupt the internal limit of this `Take`.",
        "suggest": "应注意避免修改基础 reader 的内部 I/O 状态，因为这样做可能会破坏该 `Take` 的内部限制。",
        "translate": ""
    },
    {
        "source": "Don't call into inner reader at all at EOF because it may still block",
        "suggest": "在 EOF 根本不要调用内部 reader，因为它可能仍然会阻塞",
        "translate": ""
    },
    {
        "source": "Pass in a reservation_size closure that respects the current value of limit for each read.",
        "suggest": "传递一个 reserve_size 闭包，该包尊重每次读取的 limit 的当前值。",
        "translate": ""
    },
    {
        "source": "If we hit the read limit, this prevents the final zero-byte read from allocating again.",
        "suggest": "如果我们达到读取限制，这将阻止最终的零字节读取再次分配。",
        "translate": ""
    },
    {
        "source": "Don't let callers reset the limit by passing an overlarge value",
        "suggest": "不要让调用者通过传递超大值来重置限制",
        "translate": ""
    },
    {
        "source": "An iterator over `u8` values of a reader.",
        "suggest": "reader 的 `u8` 值上的迭代器。",
        "translate": ""
    },
    {
        "source": "This struct is generally created by calling [`bytes`] on a reader.",
        "suggest": "通常通过在 reader 上调用 [`bytes`] 来创建此结构体。",
        "translate": ""
    },
    {
        "source": "Please see the documentation of [`bytes`] for more details.",
        "suggest": "请参见 [`bytes`] 的文档以获取更多详细信息。",
        "translate": ""
    },
    {
        "source": "An iterator over the contents of an instance of `BufRead` split on a particular byte.",
        "suggest": "对 `BufRead` 实例的内容进行迭代的迭代器，该实例在特定字节上拆分。",
        "translate": ""
    },
    {
        "source": "This struct is generally created by calling [`split`] on a `BufRead`.",
        "suggest": "通常通过在 `BufRead` 上调用 [`split`] 来创建此结构体。",
        "translate": ""
    },
    {
        "source": "Please see the documentation of [`split`] for more details.",
        "suggest": "请参见 [`split`] 的文档以获取更多详细信息。",
        "translate": ""
    },
    {
        "source": "An iterator over the lines of an instance of `BufRead`.",
        "suggest": "`BufRead` 实例的行上的迭代器。",
        "translate": ""
    },
    {
        "source": "This struct is generally created by calling [`lines`] on a `BufRead`.",
        "suggest": "通常通过在 `BufRead` 上调用 [`lines`] 来创建此结构体。",
        "translate": ""
    },
    {
        "source": "Please see the documentation of [`lines`] for more details.",
        "suggest": "请参见 [`lines`] 的文档以获取更多详细信息。",
        "translate": ""
    },
    {
        "source": "The I/O Prelude.",
        "suggest": "I/O Prelude。",
        "translate": ""
    },
    {
        "source": "The purpose of this module is to alleviate imports of many common I/O traits by adding a glob import to the top of I/O heavy modules:",
        "suggest": "该模块的目的是通过在 I/O 重型模块的顶部添加全局导入来减轻许多常见 I/O traits 的导入:",
        "translate": ""
    },
    {
        "source": "We get `Stdin` here.",
        "suggest": "我们在这里得到 `Stdin`。",
        "translate": ""
    },
    {
        "source": "We get `StdinLock` here.",
        "suggest": "我们在这里得到 `StdinLock`。",
        "translate": ""
    },
    {
        "source": "is dropped here.",
        "suggest": "在这里丢弃。",
        "translate": ""
    },
    {
        "source": "Used by the test crate to capture the output of the print macros and panics.",
        "suggest": "测试 crate 用于捕获打印宏和 panics 的输出。",
        "translate": ""
    },
    {
        "source": "Flag to indicate OUTPUT_CAPTURE is used.",
        "suggest": "指示使用 OUTPUT_CAPTURE 的标志。",
        "translate": ""
    },
    {
        "source": "If it is None and was never set on any thread, this flag is set to false, and OUTPUT_CAPTURE can be safely ignored on all threads, saving some time and memory registering an unused thread local.",
        "suggest": "如果它为 None 并且从未在任何线程上设置，则此标志设置为 false，并且可以安全地在所有线程上忽略 OUTPUT_CAPTURE，从而节省了时间和内存，以在本地注册未使用的线程。",
        "translate": ""
    },
    {
        "source": "Note about memory ordering: This contains information about whether a thread local variable might be in use.",
        "suggest": "有关内存排序的注意事项: 它包含有关是否可能正在使用线程局部变量的信息。",
        "translate": ""
    },
    {
        "source": "Although this is a global flag, the memory ordering between threads does not matter: we only want this flag to have a consistent order between set_output_capture and print_to *within the same thread*.",
        "suggest": "尽管这是一个 γ 标志，但线程之间的内存顺序无关紧要: 我们只希望此标志在 set_output_capture 和 print_to *within the 相同线程* 之间具有一致的顺序。",
        "translate": ""
    },
    {
        "source": "Within the same thread, things always have a perfectly consistent order.",
        "suggest": "在同一线程中，事物始终具有完全一致的顺序。",
        "translate": ""
    },
    {
        "source": "So Ordering::Relaxed is fine.",
        "suggest": "所以 Ordering::Relaxed 很好。",
        "translate": ""
    },
    {
        "source": "A handle to a raw instance of the standard input stream of this process.",
        "suggest": "此进程的标准输入流的原始实例的句柄。",
        "translate": ""
    },
    {
        "source": "This handle is not synchronized or buffered in any fashion.",
        "suggest": "此句柄不以任何方式同步或缓冲。",
        "translate": ""
    },
    {
        "source": "Constructed via the `std::io::stdio::stdin_raw` function.",
        "suggest": "通过 `std::io::stdio::stdin_raw` 函数构造。",
        "translate": ""
    },
    {
        "source": "A handle to a raw instance of the standard output stream of this process.",
        "suggest": "此进程的标准输出流的原始实例的句柄。",
        "translate": ""
    },
    {
        "source": "Constructed via the `std::io::stdio::stdout_raw` function.",
        "suggest": "通过 `std::io::stdio::stdout_raw` 函数构造。",
        "translate": ""
    },
    {
        "source": "Constructed via the `std::io::stdio::stderr_raw` function.",
        "suggest": "通过 `std::io::stdio::stderr_raw` 函数构造。",
        "translate": ""
    },
    {
        "source": "Constructs a new raw handle to the standard input of this process.",
        "suggest": "为这个进程的标准输入创建一个新的原始句柄。",
        "translate": ""
    },
    {
        "source": "The returned handle does not interact with any other handles created nor handles returned by `std::io::stdin`.",
        "suggest": "返回的句柄不与任何其他创建的句柄交互，也不与 `std::io::stdin` 返回的句柄交互。",
        "translate": ""
    },
    {
        "source": "Data buffered by the `std::io::stdin` handles is **not** available to raw handles returned from this function.",
        "suggest": "`std::io::stdin` 句柄缓冲的数据对于从此函数返回的原始句柄不可用。",
        "translate": ""
    },
    {
        "source": "The returned handle has no external synchronization or buffering.",
        "suggest": "返回的句柄没有外部同步或缓冲。",
        "translate": ""
    },
    {
        "source": "Constructs a new raw handle to the standard output stream of this process.",
        "suggest": "为该进程的标准输出流创建一个新的原始句柄。",
        "translate": ""
    },
    {
        "source": "The returned handle does not interact with any other handles created nor handles returned by `std::io::stdout`.",
        "suggest": "返回的句柄不与任何其他创建的句柄交互，也不与 `std::io::stdout` 返回的句柄交互。",
        "translate": ""
    },
    {
        "source": "Note that data is buffered by the `std::io::stdout` handles so writes which happen via this raw handle may appear before previous writes.",
        "suggest": "请注意，数据由 `std::io::stdout` 句柄缓冲，因此通过此原始句柄发生的写操作可能会在之前的写操作之前出现。",
        "translate": ""
    },
    {
        "source": "The returned handle has no external synchronization or buffering layered on top.",
        "suggest": "返回的句柄顶部没有分层的外部同步或缓冲。",
        "translate": ""
    },
    {
        "source": "Constructs a new raw handle to the standard error stream of this process.",
        "suggest": "为该进程的标准错误流创建一个新的原始句柄。",
        "translate": ""
    },
    {
        "source": "The returned handle does not interact with any other handles created nor handles returned by `std::io::stderr`.",
        "suggest": "返回的句柄不与任何其他创建的句柄交互，也不与 `std::io::stderr` 返回的句柄交互。",
        "translate": ""
    },
    {
        "source": "A handle to the standard input stream of a process.",
        "suggest": "进程的标准输入流的句柄。",
        "translate": ""
    },
    {
        "source": "Each handle is a shared reference to a global buffer of input data to this process.",
        "suggest": "每个句柄都是对该进程输入数据的全局缓冲区的共享引用。",
        "translate": ""
    },
    {
        "source": "A handle can be `lock`'d to gain full access to [`BufRead`] methods (e.g., `.lines()`).",
        "suggest": "可以对句柄进行 `lock`，以获取对 [`BufRead`] 方法 (例如 `.lines()`) 的完全访问权限。",
        "translate": ""
    },
    {
        "source": "Reads to this handle are otherwise locked with respect to other reads.",
        "suggest": "否则，将针对其他读取锁定对此句柄的读取。",
        "translate": ""
    },
    {
        "source": "This handle implements the `Read` trait, but beware that concurrent reads of `Stdin` must be executed with care.",
        "suggest": "该句柄实现了 `Read` trait，但请注意，必须谨慎执行 `Stdin` 的并发读取。",
        "translate": ""
    },
    {
        "source": "Created by the [`io::stdin`] method.",
        "suggest": "由 [`io::stdin`] 方法创建。",
        "translate": ""
    },
    {
        "source": "Windows Portability Consideration",
        "suggest": "Windows 可移植性注意事项",
        "translate": ""
    },
    {
        "source": "When operating in a console, the Windows implementation of this stream does not support non-UTF-8 byte sequences.",
        "suggest": "在控制台中操作时，此流的 Windows 实现不支持非 UTF-8 字节序列。",
        "translate": ""
    },
    {
        "source": "Attempting to read bytes that are not valid UTF-8 will return an error.",
        "suggest": "尝试读取无效的 UTF-8 字节将返回错误。",
        "translate": ""
    },
    {
        "source": "A locked reference to the [`Stdin`] handle.",
        "suggest": "[`Stdin`] 句柄的锁定引用。",
        "translate": ""
    },
    {
        "source": "This handle implements both the [`Read`] and [`BufRead`] traits, and is constructed via the [`Stdin::lock`] method.",
        "suggest": "该句柄同时实现 [`Read`] 和 [`BufRead`] traits，并通过 [`Stdin::lock`] 方法构造。",
        "translate": ""
    },
    {
        "source": "Constructs a new handle to the standard input of the current process.",
        "suggest": "为当前进程的标准输入创建一个新的句柄。",
        "translate": ""
    },
    {
        "source": "Each handle returned is a reference to a shared global buffer whose access is synchronized via a mutex.",
        "suggest": "返回的每个句柄都是对共享缓冲区的引用，该缓冲区的访问通过互斥锁进行同步。",
        "translate": ""
    },
    {
        "source": "If you need more explicit control over locking, see the [`Stdin::lock`] method.",
        "suggest": "如果需要对锁定进行更明确的控制，请参见 [`Stdin::lock`] 方法。",
        "translate": ""
    },
    {
        "source": "Using implicit synchronization:",
        "suggest": "使用隐式同步:",
        "translate": ""
    },
    {
        "source": "Using explicit synchronization:",
        "suggest": "使用显式同步:",
        "translate": ""
    },
    {
        "source": "Locks this handle to the standard input stream, returning a readable guard.",
        "suggest": "将此句柄锁定到标准输入流，返回可读的保护。",
        "translate": ""
    },
    {
        "source": "The lock is released when the returned lock goes out of scope.",
        "suggest": "当返回的锁离开作用域时，将释放该锁。",
        "translate": ""
    },
    {
        "source": "The returned guard also implements the [`Read`] and [`BufRead`] traits for accessing the underlying data.",
        "suggest": "返回的防护还实现了用于访问基础数据的 [`Read`] 和 [`BufRead`] traits。",
        "translate": ""
    },
    {
        "source": "Locks this handle and reads a line of input, appending it to the specified buffer.",
        "suggest": "锁定此句柄并读取输入行，并将其添加到指定的缓冲区。",
        "translate": ""
    },
    {
        "source": "For detailed semantics of this method, see the documentation on [`BufRead::read_line`].",
        "suggest": "有关此方法的详细语义，请参见 [`BufRead::read_line`] 上的文档。",
        "translate": ""
    },
    {
        "source": "You can run the example one of two ways:",
        "suggest": "您可以通过以下两种方式之一运行示例:",
        "translate": ""
    },
    {
        "source": "Pipe some text to it, e.g.,",
        "suggest": "用管道将一些文本发送给它，例如，",
        "translate": ""
    },
    {
        "source": "Give it text interactively by running the executable directly, in which case it will wait for the Enter key to be pressed before continuing",
        "suggest": "通过直接运行可执行文件以交互方式输入文本，在这种情况下，它将等待按下 Enter 键，然后继续",
        "translate": ""
    },
    {
        "source": "only used by platform-dependent io::copy specializations, i.e. unused on some platforms",
        "suggest": "仅由依赖于平台的 io::copy 专业使用，即在某些平台上未使用",
        "translate": ""
    },
    {
        "source": "A handle to the global standard output stream of the current process.",
        "suggest": "当前进程的标准输出流的句柄。",
        "translate": ""
    },
    {
        "source": "Each handle shares a global buffer of data to be written to the standard output stream.",
        "suggest": "每个句柄共享一个待写入标准输出流的数据缓冲区。",
        "translate": ""
    },
    {
        "source": "Access is also synchronized via a lock and explicit control over locking is available via the [`lock`] method.",
        "suggest": "访问也可以通过锁定来同步，并且可以通过 [`lock`] 方法对锁定进行显式控制。",
        "translate": ""
    },
    {
        "source": "Created by the [`io::stdout`] method.",
        "suggest": "由 [`io::stdout`] 方法创建。",
        "translate": ""
    },
    {
        "source": "Attempting to write bytes that are not valid UTF-8 will return an error.",
        "suggest": "尝试写入无效的 UTF-8 字节将返回错误。",
        "translate": ""
    },
    {
        "source": "this should be LineWriter or BufWriter depending on the state of stdout (tty or not).",
        "suggest": "根据 stdout 的状态 (是否为 tty)，它应该是 LineWriter 或 BufWriter。",
        "translate": ""
    },
    {
        "source": "Note that if this is not line buffered it should also flush-on-panic or some form of flush-on-abort.",
        "suggest": "请注意，如果这不是行缓冲的，则还应该在 panic 上进行刷新或在终止时进行某种形式的刷新。",
        "translate": ""
    },
    {
        "source": "A locked reference to the [`Stdout`] handle.",
        "suggest": "[`Stdout`] 句柄的锁定引用。",
        "translate": ""
    },
    {
        "source": "This handle implements the [`Write`] trait, and is constructed via the [`Stdout::lock`] method.",
        "suggest": "该句柄实现 [`Write`] trait，并通过 [`Stdout::lock`] 方法构造。",
        "translate": ""
    },
    {
        "source": "Constructs a new handle to the standard output of the current process.",
        "suggest": "为当前进程的标准输出创建一个新的句柄。",
        "translate": ""
    },
    {
        "source": "If you need more explicit control over locking, see the [`Stdout::lock`] method.",
        "suggest": "如果需要对锁定进行更明确的控制，请参见 [`Stdout::lock`] 方法。",
        "translate": ""
    },
    {
        "source": "Flush the data and disable buffering during shutdown by replacing the line writer by one with zero buffering capacity.",
        "suggest": "通过用零缓冲容量将行 writer 替换为 1，刷新数据并在关闭期间禁用缓冲。",
        "translate": ""
    },
    {
        "source": "We use try_lock() instead of lock(), because someone might have leaked a StdoutLock, which would otherwise cause a deadlock here.",
        "suggest": "我们使用 try_lock() 代替 lock()，因为有人可能泄漏了 StdoutLock，否则将在此处导致死锁。",
        "translate": ""
    },
    {
        "source": "Locks this handle to the standard output stream, returning a writable guard.",
        "suggest": "将此句柄锁定到标准输出流，返回可写防护。",
        "translate": ""
    },
    {
        "source": "The returned guard also implements the `Write` trait for writing data.",
        "suggest": "返回的防护还实现 `Write` trait 来写入数据。",
        "translate": ""
    },
    {
        "source": "A handle to the standard error stream of a process.",
        "suggest": "进程的标准错误流的句柄。",
        "translate": ""
    },
    {
        "source": "For more information, see the [`io::stderr`] method.",
        "suggest": "有关更多信息，请参见 [`io::stderr`] 方法。",
        "translate": ""
    },
    {
        "source": "A locked reference to the [`Stderr`] handle.",
        "suggest": "[`Stderr`] 句柄的锁定引用。",
        "translate": ""
    },
    {
        "source": "This handle implements the [`Write`] trait and is constructed via the [`Stderr::lock`] method.",
        "suggest": "该句柄实现 [`Write`] trait，并通过 [`Stderr::lock`] 方法构造。",
        "translate": ""
    },
    {
        "source": "Constructs a new handle to the standard error of the current process.",
        "suggest": "为当前进程的标准错误创建一个新的句柄。",
        "translate": ""
    },
    {
        "source": "This handle is not buffered.",
        "suggest": "此句柄未缓冲。",
        "translate": ""
    },
    {
        "source": "Note that unlike `stdout()` we don't use `at_exit` here to register a destructor.",
        "suggest": "请注意，与 `stdout()` 不同，我们在这里不使用 `at_exit` 注册析构函数。",
        "translate": ""
    },
    {
        "source": "Stderr is not buffered , so there's no need to run a destructor for flushing the buffer",
        "suggest": "stderr 未缓冲，因此无需运行析构函数来刷新缓冲区",
        "translate": ""
    },
    {
        "source": "Locks this handle to the standard error stream, returning a writable guard.",
        "suggest": "将此句柄锁定到标准错误流，返回可写防护。",
        "translate": ""
    },
    {
        "source": "The returned guard also implements the [`Write`] trait for writing data.",
        "suggest": "返回的防护还实现 [`Write`] trait 来写入数据。",
        "translate": ""
    },
    {
        "source": "Sets the thread-local output capture buffer and returns the old one.",
        "suggest": "设置线程本地输出捕获缓冲区并返回旧的缓冲区。",
        "translate": ""
    },
    {
        "source": "OUTPUT_CAPTURE is definitely None since OUTPUT_CAPTURE_USED is false.",
        "suggest": "OUTPUT_CAPTURE 绝对为 None，因为 OUTPUT_CAPTURE_USED 为 false。",
        "translate": ""
    },
    {
        "source": "Write `args` to the capture buffer if enabled and possible, or `global_s` otherwise.",
        "suggest": "将 `args` 写入捕获缓冲区 (如果已启用且可能的话)，否则将其写入 `global_s`。",
        "translate": ""
    },
    {
        "source": "`label` identifies the stream in a panic message.",
        "suggest": "`label` 在 panic 消息中标识流。",
        "translate": ""
    },
    {
        "source": "This function is used to print error messages, so it takes extra care to avoid causing a panic when `local_s` is unusable.",
        "suggest": "此函数用于打印错误消息，因此在 `local_s` 不可用时要格外小心，以免引起 panic。",
        "translate": ""
    },
    {
        "source": "For instance, if the TLS key for the local stream is already destroyed, or if the local stream is locked by another thread, it will just fall back to the global stream.",
        "suggest": "例如，如果本地流的 TLS 密钥已被破坏，或者如果本地流已被另一个线程锁定，它就会回退到全局流。",
        "translate": ""
    },
    {
        "source": "However, if the actual I/O causes an error, this function does panic.",
        "suggest": "但是，如果实际的 I/O 导致错误，则此函数执行 panic。",
        "translate": ""
    },
    {
        "source": "Note that we completely remove a local sink to write to in case our printing recursively panics/prints, so the recursive panic/print goes to the global sink instead of our local sink.",
        "suggest": "请注意，如果我们以递归方式打印 panics/prints，我们将完全删除要写入的本地 sink，因此，递归 panic/print 会转到 sink，而不是我们的本地 sink。",
        "translate": ""
    },
    {
        "source": "Succesfully wrote to capture buffer.",
        "suggest": "成功写入捕获缓冲区。",
        "translate": ""
    },
    {
        "source": "make sure the optimized (early returning) method is being used",
        "suggest": "确保使用了优化的 (早期返回) 方法",
        "translate": ""
    },
    {
        "source": "Check that size hint matches buffer contents",
        "suggest": "检查大小提示是否与缓冲区内容匹配",
        "translate": ""
    },
    {
        "source": "Check that size hint matches buffer contents after advancing",
        "suggest": "前进后检查大小提示是否与缓冲区内容匹配",
        "translate": ""
    },
    {
        "source": "All `asserts` are duplicated here to make sure the method does not change anything about the seek state.",
        "suggest": "所有 `asserts` 都在此处重复，以确保该方法不会更改任何与搜索状态有关的内容。",
        "translate": ""
    },
    {
        "source": "A simple example reader which uses the default implementation of read_to_end.",
        "suggest": "一个简单的示例 reader，它使用 read_to_end 的默认实现。",
        "translate": ""
    },
    {
        "source": "generally needs to over-allocate, both for efficiency and so that it can distinguish EOF.",
        "suggest": "通常，为了提高效率和使其能够区分 EOF，都需要过度分配。",
        "translate": ""
    },
    {
        "source": "Assert that this is the case with this simple ExampleSliceReader struct, which uses the default implementation of read_to_end.",
        "suggest": "断言这种简单的 ExampleSliceReader 结构体就是这种情况，它使用 read_to_end 的默认实现。",
        "translate": ""
    },
    {
        "source": "Even though vec1 is allocated with exactly enough capacity for the read, read_to_end will allocate more space here.",
        "suggest": "即使为 vec1 分配了足够的读取容量，read_to_end 仍将在此处分配更多空间。",
        "translate": ""
    },
    {
        "source": "However, std::io::Take includes an implementation of read_to_end that will not allocate when the limit has already been reached.",
        "suggest": "但是，std::io::Take 包含 read_to_end 的实现，当达到限制时将不分配该实现。",
        "translate": ""
    },
    {
        "source": "In this case, vec2 never grows.",
        "suggest": "在这种情况下，vec2 永远不会增长。",
        "translate": ""
    },
    {
        "source": "Only in a single buffer..",
        "suggest": "仅在单个缓冲区中。",
        "translate": ""
    },
    {
        "source": "Removing a buffer, leaving others as is.",
        "suggest": "删除缓冲区，其他保持原样。",
        "translate": ""
    },
    {
        "source": "Removing a buffer and removing from the next buffer.",
        "suggest": "删除缓冲区并从下一个缓冲区删除。",
        "translate": ""
    },
    {
        "source": "Shouldn't panic.",
        "suggest": "不应该 panic。",
        "translate": ""
    },
    {
        "source": "Going beyond the total length should be ok.",
        "suggest": "超过总长度应该没问题。",
        "translate": ""
    },
    {
        "source": "Create a new writer that reads from at most `n_bufs` and reads `per_call` bytes (in total) per call to write.",
        "suggest": "创建一个新的 writer，每个调用最多读取 `n_bufs` 并读取 `per_call` 字节 (总共)。",
        "translate": ""
    },
    {
        "source": "Read at most 2 bytes.",
        "suggest": "最多读取 2 个字节。",
        "translate": ""
    },
    {
        "source": "Only read from first buf.",
        "suggest": "仅从第一个缓冲区读取。",
        "translate": ""
    },
    {
        "source": "Read at most 3 bytes from two buffers.",
        "suggest": "从两个缓冲区读取最多 3 个字节。",
        "translate": ""
    },
    {
        "source": "Read at most 3 bytes from three buffers.",
        "suggest": "从三个缓冲区读取最多 3 个字节。",
        "translate": ""
    },
    {
        "source": "Becomes unreadable otherwise.",
        "suggest": "否则变得不可读。",
        "translate": ""
    },
    {
        "source": "A reader which is always at EOF.",
        "suggest": "始终处于 EOF 的 reader。",
        "translate": ""
    },
    {
        "source": "This struct is generally created by calling [`empty()`].",
        "suggest": "通常通过调用 [`empty()`] 来创建此结构体。",
        "translate": ""
    },
    {
        "source": "Please see the documentation of [`empty()`] for more details.",
        "suggest": "请参见 [`empty()`] 的文档以获取更多详细信息。",
        "translate": ""
    },
    {
        "source": "Constructs a new handle to an empty reader.",
        "suggest": "为空的 reader 创建一个新的句柄。",
        "translate": ""
    },
    {
        "source": "All reads from the returned reader will return [`Ok`]`(0)`.",
        "suggest": "从返回的 reader 进行的所有读取将返回 [`Ok`]`(0)`。",
        "translate": ""
    },
    {
        "source": "A slightly sad example of not reading anything into a buffer:",
        "suggest": "不将任何内容读入缓冲区的一个令人悲伤的示例:",
        "translate": ""
    },
    {
        "source": "A reader which yields one byte over and over and over and over and over and...",
        "suggest": "一个 reader，一个又一个的字节，一个又一个的字节，一个又一个的字节。",
        "translate": ""
    },
    {
        "source": "This struct is generally created by calling [`repeat()`].",
        "suggest": "通常通过调用 [`repeat()`] 来创建此结构体。",
        "translate": ""
    },
    {
        "source": "Please see the documentation of [`repeat()`] for more details.",
        "suggest": "请参见 [`repeat()`] 的文档以获取更多详细信息。",
        "translate": ""
    },
    {
        "source": "Creates an instance of a reader that infinitely repeats one byte.",
        "suggest": "创建 reader 的实例，该实例无限重复一个字节。",
        "translate": ""
    },
    {
        "source": "All reads from this reader will succeed by filling the specified buffer with the given byte.",
        "suggest": "通过用给定的字节填充指定的缓冲区，从 reader 进行的所有读取将成功。",
        "translate": ""
    },
    {
        "source": "A writer which will move data into the void.",
        "suggest": "一个 writer，它将数据移入无效空间。",
        "translate": ""
    },
    {
        "source": "This struct is generally created by calling [`sink`].",
        "suggest": "通常通过调用 [`sink`] 来创建此结构体。",
        "translate": ""
    },
    {
        "source": "Please see the documentation of [`sink()`] for more details.",
        "suggest": "请参见 [`sink()`] 的文档以获取更多详细信息。",
        "translate": ""
    },
    {
        "source": "Creates an instance of a writer which will successfully consume all data.",
        "suggest": "创建 writer 的实例，该实例将成功使用所有数据。",
        "translate": ""
    },
    {
        "source": "All calls to [`write`] on the returned instance will return `Ok(buf.len())` and the contents of the buffer will not be inspected.",
        "suggest": "在返回的实例上对 [`write`] 的所有调用都将返回 `Ok(buf.len())`，并且不会检查缓冲区的内容。",
        "translate": ""
    },
    {
        "source": "Now you can use the names `memory` and `network` to refer to `std::mem` and `std::net`.",
        "suggest": "现在，您可以使用名称 `memory` 和 `network` 来引用 `std::mem` 和 `std::net`。",
        "translate": ""
    },
    {
        "source": "breaks from inner loop, let's outer loop continue.",
        "suggest": "从内循环中断，让外循环继续。",
        "translate": ""
    },
    {
        "source": "breaks from outer loop, and directly to \"Bye\".",
        "suggest": "从外部循环中断，并直接到达 \"Bye\"。",
        "translate": ""
    },
    {
        "source": "first number in Fibonacci sequence over 10:",
        "suggest": "斐波纳契数列中第一个超过 10 的数字:",
        "translate": ""
    },
    {
        "source": "Printing odd numbers by skipping even ones",
        "suggest": "通过跳过偶数来打印奇数",
        "translate": ""
    },
    {
        "source": "Print Odd numbers under 30 with unit <= 5",
        "suggest": "使用单元 <= 5 打印 30 以下的奇数",
        "translate": ""
    },
    {
        "source": "implicitly added to the root of every Rust project",
        "suggest": "隐式添加到每个 Rust 项目的根目录",
        "translate": ""
    },
    {
        "source": "would loop forever otherwise",
        "suggest": "否则将永远循环",
        "translate": ""
    },
    {
        "source": "something else",
        "suggest": "其他的东西",
        "translate": ""
    },
    {
        "source": "not shadowing",
        "suggest": "不遮蔽",
        "translate": ""
    },
    {
        "source": "Exit when `i` is 64.",
        "suggest": "`i` 为 64 时退出。",
        "translate": ""
    },
    {
        "source": "all other numbers",
        "suggest": "所有其他数字",
        "translate": ""
    },
    {
        "source": "x is no longer available",
        "suggest": "x 不再可用",
        "translate": ""
    },
    {
        "source": "A mutable variable in the parameter list of a function.",
        "suggest": "函数的参数列表中的可变变量。",
        "translate": ""
    },
    {
        "source": "Modifying a mutable variable.",
        "suggest": "修改可变变量。",
        "translate": ""
    },
    {
        "source": "Taking a mutable reference.",
        "suggest": "采取可变引用。",
        "translate": ""
    },
    {
        "source": "A mutable reference cannot be taken to a non-mutable variable.",
        "suggest": "可变引用不能用于非可变变量。",
        "translate": ""
    },
    {
        "source": "Passing a mutable reference.",
        "suggest": "通过可变引用。",
        "translate": ""
    },
    {
        "source": "The variable 'maybe_name' is consumed here ...",
        "suggest": "变量 'maybe_name' 在这里使用...",
        "translate": ""
    },
    {
        "source": "and is now unavailable.",
        "suggest": "现在不可用。",
        "translate": ""
    },
    {
        "source": "Using `ref`, the value is borrowed, not moved ...",
        "suggest": "使用 `ref`，该值是借用的，而不是移动的...",
        "translate": ""
    },
    {
        "source": "so it's available here!",
        "suggest": "所以可以在这里!",
        "translate": ""
    },
    {
        "source": "No `self`.",
        "suggest": "没有 `self`。",
        "translate": ""
    },
    {
        "source": "Consuming `self`.",
        "suggest": "消耗 `self`。",
        "translate": ""
    },
    {
        "source": "Borrowing `self`.",
        "suggest": "借用 `self`。",
        "translate": ""
    },
    {
        "source": "Borrowing `self` mutably.",
        "suggest": "借用 `self` 可变。",
        "translate": ""
    },
    {
        "source": "This method must be called with a `Type::` prefix.",
        "suggest": "必须使用 `Type::` 前缀调用此方法。",
        "translate": ""
    },
    {
        "source": "Those two calls produces the same result.",
        "suggest": "这两个调用产生相同的结果。",
        "translate": ""
    },
    {
        "source": "Borrowing is handled automatically with the second syntax.",
        "suggest": "使用第二种语法会自动处理借用。",
        "translate": ""
    },
    {
        "source": "Borrowing mutably is handled automatically too with the second syntax.",
        "suggest": "第二种语法也会自动处理可变借用。",
        "translate": ""
    },
    {
        "source": "is a `Node` here.",
        "suggest": "这里是 `Node`。",
        "translate": ""
    },
    {
        "source": "This line causes an error",
        "suggest": "该行导致错误",
        "translate": ""
    },
    {
        "source": "With a strictly read-only static, references will have the same address",
        "suggest": "对于严格只读的静态，引用将具有相同的地址",
        "translate": ""
    },
    {
        "source": "A static item can be used just like a variable in many cases",
        "suggest": "在许多情况下，可以像使用变量一样使用静态项",
        "translate": ""
    },
    {
        "source": "call a's foo function",
        "suggest": "调用 a 的 foo 函数",
        "translate": ""
    },
    {
        "source": "u8_len_1, u8_len_2 and u8_len_3 are equivalent",
        "suggest": "u8_len_1，u8_len_2 和 u8_len_3 是等效的",
        "translate": ""
    },
    {
        "source": "associated type declaration",
        "suggest": "关联类型声明",
        "translate": ""
    },
    {
        "source": "associated type definition",
        "suggest": "关联类型定义",
        "translate": ""
    },
    {
        "source": "Normally changing the length of a vector is done using one of the safe operations instead, such as `truncate`, `resize`, `extend`, or `clear`.",
        "suggest": "通常，使用安全操作之一 (例如 `truncate`，`resize`，`extend` 或 `clear`) 来更改 vector 的长度。",
        "translate": ""
    },
    {
        "source": "must be less than or equal to `capacity()`.",
        "suggest": "必须小于或等于 `capacity()`。",
        "translate": ""
    },
    {
        "source": "Dereference the given pointer.",
        "suggest": "解引用给定的指针。",
        "translate": ""
    },
    {
        "source": "must be aligned and must not be dangling.",
        "suggest": "必须对齐并且不能悬空。",
        "translate": ""
    },
    {
        "source": "`a` has not been dropped and references are always aligned, so `b` is a valid address.",
        "suggest": "`a` 尚未丢弃，并且引用始终对齐，因此 `b` 是有效地址。",
        "translate": ""
    },
    {
        "source": "Implementors of this trait must guarantee an element is always accessible with index 3.",
        "suggest": "trait 的实现者必须保证元素始终可以通过索引 3 访问。",
        "translate": ""
    },
    {
        "source": "Returns a reference to the element with index 3 in `&self`.",
        "suggest": "返回 `&self` 中索引为 3 的元素的引用。",
        "translate": ""
    },
    {
        "source": "The implementation of `ThreeIndexable` for `[T; 4]` is `unsafe` because the implementor must abide by a contract the compiler cannot check but as a programmer we know there will always be a valid element at index 3 to access.",
        "suggest": "`[T; 4]` 的 `ThreeIndexable` 实现是 `unsafe`，因为实现者必须遵守编译器无法检查的契约，但作为一名程序员，我们知道在索引 3 处总会有一个有效元素要访问。",
        "translate": ""
    },
    {
        "source": "implementing the trait means there always is an element with index 3 accessible.",
        "suggest": "实现 trait 意味着总是有一个索引为 3 的元素可以访问。",
        "translate": ""
    },
    {
        "source": "Does not compile !",
        "suggest": "不编译!",
        "translate": ""
    },
    {
        "source": "Reading the fields of an union is always unsafe",
        "suggest": "读取一个 union 的字段总是不安全的",
        "translate": ""
    },
    {
        "source": "Updating through any of the field will modify all of them",
        "suggest": "通过任何字段进行更新都会修改所有字段",
        "translate": ""
    },
    {
        "source": "Matching the field `f` provides an `f32`.",
        "suggest": "匹配字段 `f` 将提供 `f32`。",
        "translate": ""
    },
    {
        "source": "This will not compile because the field has already been borrowed, even if only immutably",
        "suggest": "这将不会编译，因为该字段已被借用，即使只是一成不变",
        "translate": ""
    },
    {
        "source": "Cast between types, or rename an import.",
        "suggest": "在类型之间进行转换，或重命名导入。",
        "translate": ""
    },
    {
        "source": "is most commonly used to turn primitive types into other primitive types, but it has other uses that include turning pointers into addresses, addresses into pointers, and pointers into other pointers.",
        "suggest": "最常用于将基本类型转换为其他基本类型，但它还有其他用途，包括将指针转换为地址、将地址转换为指针以及将指针转换为其他指针。",
        "translate": ""
    },
    {
        "source": "In general, any cast that can be performed via ascribing the type can also be done using `as`, so instead of writing `let x: u32 = 123`, you can write `let x = 123 as u32` (note: `let x: u32 = 123` would be best in that situation).",
        "suggest": "通常，任何可以通过指定类型执行的强制转换也可以使用 `as` 完成，因此，除了编写 `let x: u32 = 123` 之外，您还可以编写 `let x = 123 as u32` (注意: 在这种情况下，`let x: u32 = 123` 最好)。",
        "translate": ""
    },
    {
        "source": "The same is not true in the other direction, however;",
        "suggest": "但是，在另一个方向上并非如此。",
        "translate": ""
    },
    {
        "source": "explicitly using `as` allows a few more coercions that aren't allowed implicitly, such as changing the type of a raw pointer or turning closures into raw pointers.",
        "suggest": "显式使用 `as` 可以允许更多隐式不允许的强制，例如更改裸指针的类型或将闭包转换为裸指针。",
        "translate": ""
    },
    {
        "source": "can be seen as the primitive for `From` and `Into`: `as` only works  with primitives (`u8`, `bool`, `str`, pointers, ...) whereas `From` and `Into`  also works with types like `String` or `Vec`.",
        "suggest": "可以看作是 `From` 和 `Into` 的原语: `as` 仅适用于原语 (`u8`，`bool`，`str`，指针等)，而 `From` 和 `Into` 也适用于 `String` 或 `Vec` 等类型。",
        "translate": ""
    },
    {
        "source": "can also be used with the `_` placeholder when the destination type can be inferred.",
        "suggest": "当可以推断目标类型时，也可以与 `_` 占位符一起使用。",
        "translate": ""
    },
    {
        "source": "Note that this can cause inference breakage and usually such code should use an explicit type for both clarity and stability.",
        "suggest": "请注意，这可能会导致推理中断，通常，此类代码应使用显式类型以确保清晰度和稳定性。",
        "translate": ""
    },
    {
        "source": "This is most useful when converting pointers using `as *const _` or `as *mut _` though the [`cast`][const-cast] method is recommended over `as *const _` and it is [the same][mut-cast] for `as *mut _`: those methods make the intent clearer.",
        "suggest": "使用 `as *const _` 或 `as* mut _` 转换指针时，这是最有用的，尽管 `as *const _` 推荐使用 [`cast`][const-cast] 方法，而 `as* mut _` 则建议使用 [the same][mut-cast]: 这些方法使意图更清晰。",
        "translate": ""
    },
    {
        "source": "is also used to rename imports in [`use`] and [`extern crate`][`crate`] statements:",
        "suggest": "还用于重命名 [`use`] 和 [`extern crate`][`crate`] 语句中的导入:",
        "translate": ""
    },
    {
        "source": "For more information on what `as` is capable of, see the [Reference].",
        "suggest": "有关 `as` 的功能的更多信息，请参见 [Reference]。",
        "translate": ""
    },
    {
        "source": "Exit early from a loop.",
        "suggest": "从循环中提前退出。",
        "translate": ""
    },
    {
        "source": "When `break` is encountered, execution of the associated loop body is immediately terminated.",
        "suggest": "遇到 `break` 时，将立即终止关联循环体的执行。",
        "translate": ""
    },
    {
        "source": "A break expression is normally associated with the innermost loop enclosing the `break` but a label can be used to specify which enclosing loop is affected.",
        "suggest": "break 表达式通常与包围 `break` 的最里面的循环相关联，但是可以使用标签来指定哪个包围循环受到影响。",
        "translate": ""
    },
    {
        "source": "When associated with `loop`, a break expression may be used to return a value from that loop.",
        "suggest": "与 `loop` 关联时，可以使用 break 表达式从该循环返回一个值。",
        "translate": ""
    },
    {
        "source": "This is only valid with `loop` and not with any other type of loop.",
        "suggest": "这仅对 `loop` 有效，对其他任何类型的循环均无效。",
        "translate": ""
    },
    {
        "source": "If no value is specified, `break;` returns `()`.",
        "suggest": "如果未指定任何值，则 `break;` 返回 `()`。",
        "translate": ""
    },
    {
        "source": "Every `break` within a loop must return the same type.",
        "suggest": "循环中的每个 `break` 必须返回相同的类型。",
        "translate": ""
    },
    {
        "source": "For more details consult the [Reference on \"break expression\"] and the [Reference on \"break and loop values\"].",
        "suggest": "有关更多详细信息，请咨询 [Reference on \"break expression\"] 和 [Reference on \"break and loop values\"]。",
        "translate": ""
    },
    {
        "source": "Compile-time constants and compile-time evaluable functions.",
        "suggest": "编译时常量和编译时可评估函数。",
        "translate": ""
    },
    {
        "source": "Compile-time constants",
        "suggest": "编译时常量",
        "translate": ""
    },
    {
        "source": "Sometimes a certain value is used many times throughout a program, and it can become inconvenient to copy it over and over.",
        "suggest": "有时，某个值在整个程序中会多次使用，并且一遍又一遍地复制它会变得很不方便。",
        "translate": ""
    },
    {
        "source": "What's more, it's not always possible or desirable to make it a variable that gets carried around to each function that needs it.",
        "suggest": "而且，使其成为每个需要它的函数的变量并非总是可能或不希望的。",
        "translate": ""
    },
    {
        "source": "In these cases, the `const` keyword provides a convenient alternative to code duplication:",
        "suggest": "在这些情况下，`const` 关键字为代码复制提供了一种方便的替代方法:",
        "translate": ""
    },
    {
        "source": "Constants must be explicitly typed;",
        "suggest": "常量必须显式地输入。",
        "translate": ""
    },
    {
        "source": "unlike with `let`, you can't ignore their type and let the compiler figure it out.",
        "suggest": "与 `let` 不同，您不能忽略它们的类型并让编译器确定它的类型。",
        "translate": ""
    },
    {
        "source": "Any constant value can be defined in a `const`, which in practice happens to be most things that would be reasonable to have in a constant (barring `const fn`s).",
        "suggest": "可以在 `const` 中定义任何常量值，而实际上 `const` 恰好是大多数在常量中合理的东西 (除非使用 const fn`s)。",
        "translate": ""
    },
    {
        "source": "For example, you can't have a [`File`] as a `const`.",
        "suggest": "例如，您不能将 [`File`] 作为 `const`。",
        "translate": ""
    },
    {
        "source": "The only lifetime allowed in a constant is `'static`, which is the lifetime that encompasses all others in a Rust program.",
        "suggest": "常量中唯一允许的生命周期是 `'static`，它是 Rust 程序中包含所有其他生命周期的生命周期。",
        "translate": ""
    },
    {
        "source": "For example, if you wanted to define a constant string, it would look like this:",
        "suggest": "例如，如果您想定义一个常量字符串，它将看起来像这样:",
        "translate": ""
    },
    {
        "source": "Thanks to static lifetime elision, you usually don't have to explicitly use `'static`:",
        "suggest": "多亏了静态生命周期省略，您通常不必显式使用 `'static`:",
        "translate": ""
    },
    {
        "source": "items looks remarkably similar to `static` items, which introduces some confusion as to which one should be used at which times.",
        "suggest": "该项看起来与 `static` 项非常相似，后者在何时应使用哪个引起了一些混淆。",
        "translate": ""
    },
    {
        "source": "To put it simply, constants are inlined wherever they're used, making using them identical to simply replacing the name of the `const` with its value.",
        "suggest": "简而言之，常量在任何使用它们的地方都被内联，使用它们与简单地用它的值替换 `const` 的名称是相同的。",
        "translate": ""
    },
    {
        "source": "Static variables, on the other hand, point to a single location in memory, which all accesses share.",
        "suggest": "另一方面，静态变量指向内存中所有访问共享的单个位置。",
        "translate": ""
    },
    {
        "source": "This means that, unlike with constants, they can't have destructors, and act as a single value across the entire codebase.",
        "suggest": "这意味着，与常量不同，它们不能具有析构函数，并且在整个代码库中都可以充当单个值。",
        "translate": ""
    },
    {
        "source": "Constants, like statics, should always be in `SCREAMING_SNAKE_CASE`.",
        "suggest": "常量 (如静态变量) 应始终位于 `SCREAMING_SNAKE_CASE` 中。",
        "translate": ""
    },
    {
        "source": "For more detail on `const`, see the [Rust Book] or the [Reference].",
        "suggest": "有关 `const` 的更多详细信息，请参见 [Rust Book] 或 [Reference]。",
        "translate": ""
    },
    {
        "source": "Compile-time evaluable functions",
        "suggest": "编译时可评估函数",
        "translate": ""
    },
    {
        "source": "The other main use of the `const` keyword is in `const fn`.",
        "suggest": "`const` 关键字的另一个主要用途是在 `const fn` 中。",
        "translate": ""
    },
    {
        "source": "This marks a function as being callable in the body of a `const` or `static` item and in array initializers (commonly called \"const contexts\").",
        "suggest": "这将一个函数标记为可以在 `const` 或 `static` 项的主体中以及在数组初始化程序 (通常称为 \"const contexts\") 中被调用。",
        "translate": ""
    },
    {
        "source": "are restricted in the set of operations they can perform, to ensure that they can be evaluated at compile-time.",
        "suggest": "限制它们可以执行的一组操作，以确保可以在编译时对其进行评估。",
        "translate": ""
    },
    {
        "source": "See the [Reference][const-eval] for more detail.",
        "suggest": "有关更多详细信息，请参见 [Reference][const-eval]。",
        "translate": ""
    },
    {
        "source": "Turning a `fn` into a `const fn` has no effect on run-time uses of that function.",
        "suggest": "将 `fn` 转换为 `const fn` 对该函数的运行时使用没有影响。",
        "translate": ""
    },
    {
        "source": "Other uses of `const`",
        "suggest": "`const` 的其他用途",
        "translate": ""
    },
    {
        "source": "The `const` keyword is also used in raw pointers in combination with `mut`, as seen in `*const T` and `*mut T`.",
        "suggest": "`const` 关键字也与 `mut` 一起用于裸指针中，如 `*const T` 和 `* mut T` 所示。",
        "translate": ""
    },
    {
        "source": "More about `const` as used in raw pointers can be read at the Rust docs for the [pointer primitive].",
        "suggest": "可以在 [指针原语][pointer primitive] 的 Rust 文档中阅读有关裸指针中使用的 `const` 的更多信息。",
        "translate": ""
    },
    {
        "source": "Skip to the next iteration of a loop.",
        "suggest": "跳到循环的下一个迭代。",
        "translate": ""
    },
    {
        "source": "When `continue` is encountered, the current iteration is terminated, returning control to the loop head, typically continuing with the next iteration.",
        "suggest": "遇到 `continue` 时，当前迭代终止，将控制权返回到循环头，通常继续进行下一个迭代。",
        "translate": ""
    },
    {
        "source": "Like `break`, `continue` is normally associated with the innermost enclosing loop, but labels may be used to specify the affected loop.",
        "suggest": "与 `break` 一样，`continue` 通常与最里面的循环相关联，但是可以使用标签来指定受影响的循环。",
        "translate": ""
    },
    {
        "source": "See [continue expressions] from the reference for more details.",
        "suggest": "有关更多详细信息，请参见参考中的 [continue 表达式][continue expressions]。",
        "translate": ""
    },
    {
        "source": "A Rust binary or library.",
        "suggest": "Rust 二进制或库。",
        "translate": ""
    },
    {
        "source": "The primary use of the `crate` keyword is as a part of `extern crate` declarations, which are used to specify a dependency on a crate external to the one it's declared in.",
        "suggest": "`crate` 关键字的主要用途是 `extern crate` 声明的一部分，该声明用于指定对 crate 的依赖，该依赖在其声明的外部。",
        "translate": ""
    },
    {
        "source": "Crates are the fundamental compilation unit of Rust code, and can be seen as libraries or projects.",
        "suggest": "Crates 是 Rust 代码的基本编译单元，可以看作是库或项目。",
        "translate": ""
    },
    {
        "source": "More can be read about crates in the [Reference].",
        "suggest": "可以在 [Reference] 中了解有关 crates 的更多信息。",
        "translate": ""
    },
    {
        "source": "The `as` keyword can be used to change what the crate is referred to as in your project.",
        "suggest": "`as` 关键字可用于更改 crate 在您的项目中的含义。",
        "translate": ""
    },
    {
        "source": "If a crate name includes a dash, it is implicitly imported with the dashes replaced by underscores.",
        "suggest": "如果 crate 名称包含破折号，则将其隐式导入，并用下划线代替破折号。",
        "translate": ""
    },
    {
        "source": "can also be used as in conjunction with `pub` to signify that the item it's attached to is public only to other members of the same crate it's in.",
        "suggest": "也可以与 `pub` 一起使用，以表示它所附加的项仅对它所在的同一 crate 的其他成员是公共的。",
        "translate": ""
    },
    {
        "source": "is also used to represent the absolute path of a module, where `crate` refers to the root of the current crate.",
        "suggest": "也用于表示模块的绝对路径，其中 `crate` 指向当前 crate 的根。",
        "translate": ""
    },
    {
        "source": "For instance, `crate::foo::bar` refers to the name `bar` inside the module `foo`, from anywhere else in the same crate.",
        "suggest": "例如，`crate::foo::bar` 在同一 crate 中的任何其他位置引用模块 `foo` 内部的名称 `bar`。",
        "translate": ""
    },
    {
        "source": "What expression to evaluate when an [`if`] condition evaluates to [`false`].",
        "suggest": "[`if`] 条件评估为 [`false`] 时要评估的表达式。",
        "translate": ""
    },
    {
        "source": "expressions are optional.",
        "suggest": "表达式是可选的。",
        "translate": ""
    },
    {
        "source": "When no else expressions are supplied it is assumed to evaluate to the unit type `()`.",
        "suggest": "如果未提供其他表达式，则假定计算结果为单元类型 `()`。",
        "translate": ""
    },
    {
        "source": "The type that the `else` blocks evaluate to must be compatible with the type that the `if` block evaluates to.",
        "suggest": "`else` 块求值的类型必须与 `if` 块求值的类型兼容。",
        "translate": ""
    },
    {
        "source": "As can be seen below, `else` must be followed by either: `if`, `if let`, or a block `{}` and it will return the value of that expression.",
        "suggest": "如下所示，`else` 后面必须是: `if`，`if let` 或块 `{}`，它将返回该表达式的值。",
        "translate": ""
    },
    {
        "source": "Here's another example but here we do not try and return an expression:",
        "suggest": "这是另一个示例，但是在这里我们不尝试返回表达式:",
        "translate": ""
    },
    {
        "source": "The above is _still_ an expression but it will always evaluate to `()`.",
        "suggest": "上面是 _still_ 的表达式，但它将始终为 `()`。",
        "translate": ""
    },
    {
        "source": "There is possibly no limit to the number of `else` blocks that could follow an `if` expression however if you have several then a [`match`] expression might be preferable.",
        "suggest": "跟随 `if` 表达式的 `else` 块的数量可能没有限制，但是，如果有多个，则最好使用 [`match`] 表达式。",
        "translate": ""
    },
    {
        "source": "Read more about control flow in the [Rust Book].",
        "suggest": "在 [Rust 书][Rust Book] 中阅读更多关于控制流的信息。",
        "translate": ""
    },
    {
        "source": "A type that can be any one of several variants.",
        "suggest": "可以是几个成员中任何一个的类型。",
        "translate": ""
    },
    {
        "source": "Enums in Rust are similar to those of other compiled languages like C, but have important differences that make them considerably more powerful.",
        "suggest": "Rust 中的枚举与其他编译语言 (如 C) 相似，但有一些重要区别，使它们的功能更加强大。",
        "translate": ""
    },
    {
        "source": "What Rust calls enums are more commonly known as [Algebraic Data Types][ADT] if you're coming from a functional programming background.",
        "suggest": "如果您来自函数式编程背景，那么 Rust 所谓的枚举通常被称为 [代数数据类型][ADT]。",
        "translate": ""
    },
    {
        "source": "The important detail is that each enum variant can have data to go along with it.",
        "suggest": "重要的细节是每个枚举成员都可以拥有数据。",
        "translate": ""
    },
    {
        "source": "The first enum shown is the usual kind of enum you'd find in a C-style language.",
        "suggest": "显示的第一个枚举是在 C 风格语言中常见的一种枚举。",
        "translate": ""
    },
    {
        "source": "The second shows off a hypothetical example of something storing location data, with `Coord` being any other type that's needed, for example a struct.",
        "suggest": "第二个示例展示了一个存储位置数据的假设示例，其中 `Coord` 是需要的任何其他类型，例如结构体。",
        "translate": ""
    },
    {
        "source": "The third example demonstrates the kind of data a variant can store, ranging from nothing, to a tuple, to an anonymous struct.",
        "suggest": "第三个示例演示了成员可以存储的数据类型，从无到有，到元组，再到匿名结构体。",
        "translate": ""
    },
    {
        "source": "Instantiating enum variants involves explicitly using the enum's name as its namespace, followed by one of its variants.",
        "suggest": "实例化枚举成员涉及显式地使用枚举的名称作为它的命名空间，后跟一个成员。",
        "translate": ""
    },
    {
        "source": "would be an example from above.",
        "suggest": "从上面是一个例子。",
        "translate": ""
    },
    {
        "source": "When data follows along with a variant, such as with rust's built-in [`Option`] type, the data is added as the type describes, for example `Option::Some(123)`.",
        "suggest": "当数据跟一个成员一起使用时，例如 rust 的内置 [`Option`] 类型，该数据将按类型描述添加，例如 `Option::Some(123)`。",
        "translate": ""
    },
    {
        "source": "The same follows with struct-like variants, with things looking like `ComplexEnum::LotsOfThings { usual_struct_stuff:",
        "suggest": "类似于结构体的成员也是如此，类似 ` ComplexEnum::LotsOfThings {通常 _struct_stuff:",
        "translate": ""
    },
    {
        "source": "Empty Enums are similar to [`!`] in that they cannot be instantiated at all, and are used mainly to mess with the type system in interesting ways.",
        "suggest": "空枚举与 [`!`] 相似，因为它们根本无法实例化，并且主要用于以有趣的方式弄乱类型系统。",
        "translate": ""
    },
    {
        "source": "For more information, take a look at the [Rust Book] or the [Reference]",
        "suggest": "有关更多信息，请查看 [Rust Book] 或 [Reference]",
        "translate": ""
    },
    {
        "source": "Link to or import external code.",
        "suggest": "链接到或导入外部代码。",
        "translate": ""
    },
    {
        "source": "The `extern` keyword is used in two places in Rust.",
        "suggest": "`extern` 关键字在 Rust 中的两个位置使用。",
        "translate": ""
    },
    {
        "source": "One is in conjunction with the [`crate`] keyword to make your Rust code aware of other Rust crates in your project, i.e.,",
        "suggest": "一种是与 [`crate`] 关键字结合使用，以使您的 Rust 代码了解项目中的其他 Rust crates，即，",
        "translate": ""
    },
    {
        "source": "The other use is in foreign function interfaces (FFI).",
        "suggest": "另一个用途是在外部函数接口 (FFI) 中。",
        "translate": ""
    },
    {
        "source": "is used in two different contexts within FFI.",
        "suggest": "在 FFI 中用于两个不同的上下文。",
        "translate": ""
    },
    {
        "source": "The first is in the form of external blocks, for declaring function interfaces that Rust code can call foreign code by.",
        "suggest": "第一种是外部块的形式，用于声明 Rust 代码可以调用外部代码的函数接口。",
        "translate": ""
    },
    {
        "source": "This code would attempt to link with `libmy_c_library.so` on unix-like systems and `my_c_library.dll` on Windows at runtime, and panic if it can't find something to link to.",
        "suggest": "该代码将在运行时尝试与类 Unix 系统上的 `libmy_c_library.so` 和 Windows 上的 `my_c_library.dll` 链接，如果找不到要链接的内容，则尝试与 panic 链接。",
        "translate": ""
    },
    {
        "source": "Rust code could then use `my_c_function` as if it were any other unsafe Rust function.",
        "suggest": "然后，Rust 代码可以使用 `my_c_function`，就好像它是其他任何不安全的 Rust 函数一样。",
        "translate": ""
    },
    {
        "source": "Working with non-Rust languages and FFI is inherently unsafe, so wrappers are usually built around C APIs.",
        "suggest": "使用非 Rust 语言和 FFI 本质上是不安全的，因此包装程序通常围绕 C API 构建。",
        "translate": ""
    },
    {
        "source": "The mirror use case of FFI is also done via the `extern` keyword:",
        "suggest": "FFI 的镜像用例也通过 `extern` 关键字完成:",
        "translate": ""
    },
    {
        "source": "If compiled as a dylib, the resulting .so could then be linked to from a C library, and the function could be used as if it was from any other library.",
        "suggest": "如果编译为 dylib，则可以将 C00 库链接到生成的 .so，并且可以像使用任何其他库一样使用该函数。",
        "translate": ""
    },
    {
        "source": "For more information on FFI, check the [Rust book] or the [Reference].",
        "suggest": "有关 FFI 的更多信息，请检查 [Rust book] 或 [Reference]。",
        "translate": ""
    },
    {
        "source": "A value of type [`bool`] representing logical **false**.",
        "suggest": "[`bool`] 类型的值，表示逻辑 **false**。",
        "translate": ""
    },
    {
        "source": "is the logical opposite of [`true`].",
        "suggest": "与 [`true`] 逻辑相反。",
        "translate": ""
    },
    {
        "source": "See the documentation for [`true`] for more information.",
        "suggest": "有关更多信息，请参见 [`true`] 的文档。",
        "translate": ""
    },
    {
        "source": "A function or function pointer.",
        "suggest": "一个函数或函数指针。",
        "translate": ""
    },
    {
        "source": "Functions are the primary way code is executed within Rust.",
        "suggest": "函数是在 Rust 中执行代码的主要方式。",
        "translate": ""
    },
    {
        "source": "Function blocks, usually just called functions, can be defined in a variety of different places and be assigned many different attributes and modifiers.",
        "suggest": "通常称为函数的函数块可以在各种不同的位置定义，并分配有许多不同的属性和修饰符。",
        "translate": ""
    },
    {
        "source": "Standalone functions that just sit within a module not attached to anything else are common, but most functions will end up being inside [`impl`] blocks, either on another type itself, or as a trait impl for that type.",
        "suggest": "仅位于未附加任何模块的模块中的独立函数是常见的，但是大多数函数最终将最终位于 [`impl`] 块中，或者位于另一种类型本身上，或者作为该类型的 trait 隐式实现。",
        "translate": ""
    },
    {
        "source": "In addition to presenting fixed types in the form of `fn name(arg: type, ..) -> return_type`, functions can also declare a list of type parameters along with trait bounds that they fall into.",
        "suggest": "除了以 `fn name(arg: type, ..) -> return_type` 形式显示固定类型外，函数还可以声明类型参数列表以及它们所属的 trait bounds。",
        "translate": ""
    },
    {
        "source": "Declaring trait bounds in the angle brackets is functionally identical to using a `where` clause.",
        "suggest": "在尖括号中声明 trait bounds 在功能上与使用 `where` 子句相同。",
        "translate": ""
    },
    {
        "source": "It's up to the programmer to decide which works better in each situation, but `where` tends to be better when things get longer than one line.",
        "suggest": "由程序员决定在每种情况下哪种效果更好，但是当事情长于一行时，`where` 往往会更好。",
        "translate": ""
    },
    {
        "source": "Along with being made public via `pub`, `fn` can also have an [`extern`] added for use in FFI.",
        "suggest": "除了通过 `pub` 公开之外，`fn` 还可以添加 [`extern`] 以用于 FFI。",
        "translate": ""
    },
    {
        "source": "For more information on the various types of functions and how they're used, consult the [Rust book] or the [Reference].",
        "suggest": "有关各种类型的函数以及如何使用它们的更多信息，请查阅 [Rust book] 或 [Reference]。",
        "translate": ""
    },
    {
        "source": "Iteration with [`in`], trait implementation with [`impl`], or [higher-ranked trait bounds] (`for<'a>`).",
        "suggest": "使用 [`in`] 进行迭代，使用 [`impl`] 或 [higher-ranked trait bounds] (`for<'a>`) 实现 trait。",
        "translate": ""
    },
    {
        "source": "The `for` keyword is used in many syntactic locations:",
        "suggest": "`for` 关键字在许多语法位置中使用:",
        "translate": ""
    },
    {
        "source": "is used in for-in-loops (see below).",
        "suggest": "用于循环中 (请参见下文)。",
        "translate": ""
    },
    {
        "source": "is used when implementing traits as in `impl Trait for Type` (see [`impl`] for more info on that).",
        "suggest": "如在 `impl Trait for Type` 中实现 traits 时使用 (有关此信息，请参见 [`impl`])。",
        "translate": ""
    },
    {
        "source": "is also used for [higher-ranked trait bounds] as in `for<'a> &'a T: PartialEq<i32>`.",
        "suggest": "与 `for<'a> &'a T: PartialEq<i32>` 一样，也用于 [higher-ranked trait bounds]。",
        "translate": ""
    },
    {
        "source": "for-in-loops, or to be more precise, iterator loops, are a simple syntactic sugar over a common practice within Rust, which is to loop over anything that implements [`IntoIterator`] until the iterator returned by `.into_iter()` returns `None` (or the loop body uses `break`).",
        "suggest": "for-in 循环，或更确切地说，是迭代器循环，是 Rust 中一种常见实践上的简单语法糖，它遍历所有实现 [`IntoIterator`] 的对象，直到 `.into_iter()` 返回的迭代器返回 `None` (或循环体使用 `break`)。",
        "translate": ""
    },
    {
        "source": "As shown in the example above, `for` loops (along with all other loops) can be tagged, using similar syntax to lifetimes (only visually similar, entirely distinct in practice).",
        "suggest": "如上面的示例所示，可以使用与生命周期相似的语法 (仅在视觉上相似，实际上完全不同) 来标记 `for` 循环 (以及所有其他循环)。",
        "translate": ""
    },
    {
        "source": "Giving the same tag to `break` breaks the tagged loop, which is useful for inner loops.",
        "suggest": "给 `break` 提供相同的标记会中断标记的循环，这对于内部循环很有用。",
        "translate": ""
    },
    {
        "source": "It is definitely not a goto.",
        "suggest": "绝对不是 goto。",
        "translate": ""
    },
    {
        "source": "A `for` loop expands as shown:",
        "suggest": "`for` 循环如下图所示展开:",
        "translate": ""
    },
    {
        "source": "More details on the functionality shown can be seen at the [`IntoIterator`] docs.",
        "suggest": "有关所显示功能的更多详细信息，请参见 [`IntoIterator`] 文档。",
        "translate": ""
    },
    {
        "source": "For more information on for-loops, see the [Rust book] or the [Reference].",
        "suggest": "有关 for 循环的更多信息，请参见 [Rust book] 或 [Reference]。",
        "translate": ""
    },
    {
        "source": "See also, [`loop`],",
        "suggest": "另请参见 [`loop`]，",
        "translate": ""
    },
    {
        "source": "Evaluate a block if a condition holds.",
        "suggest": "如果条件成立，则评估一个块。",
        "translate": ""
    },
    {
        "source": "is a familiar construct to most programmers, and is the main way you'll often do logic in your code.",
        "suggest": "是大多数程序员熟悉的结构，并且是您经常在代码中执行逻辑的主要方式。",
        "translate": ""
    },
    {
        "source": "However, unlike in most languages, `if` blocks can also act as expressions.",
        "suggest": "但是，与大多数语言不同，`if` 块也可以充当表达式。",
        "translate": ""
    },
    {
        "source": "Shown above are the three typical forms an `if` block comes in.",
        "suggest": "上面显示的是 `if` 块的三种典型形式。",
        "translate": ""
    },
    {
        "source": "First is the usual kind of thing you'd see in many languages, with an optional `else` block.",
        "suggest": "首先是带有多种 `else` 块的多种语言中常见的事物。",
        "translate": ""
    },
    {
        "source": "Second uses `if` as an expression, which is only possible if all branches return the same type.",
        "suggest": "第二种使用 `if` 作为表达式，仅当所有分支都返回相同类型时才有可能。",
        "translate": ""
    },
    {
        "source": "An `if` expression can be used everywhere you'd expect.",
        "suggest": "`if` 表达式可以在您期望的任何地方使用。",
        "translate": ""
    },
    {
        "source": "The third kind of `if` block is an `if let` block, which behaves similarly to using a `match` expression:",
        "suggest": "第三种 `if` 块是 `if let` 块，其行为类似于使用 `match` 表达式:",
        "translate": ""
    },
    {
        "source": "Each kind of `if` expression can be mixed and matched as needed.",
        "suggest": "每种 `if` 表达式都可以根据需要进行混合和匹配。",
        "translate": ""
    },
    {
        "source": "The `if` keyword is used in one other place in Rust, namely as a part of pattern matching itself, allowing patterns such as `Some(x) if x > 200` to be used.",
        "suggest": "`if` 关键字在 Rust 中的另一个位置使用，即作为样式匹配自身的一部分，从而允许使用诸如 `Some(x) if x > 200` 的样式。",
        "translate": ""
    },
    {
        "source": "For more information on `if` expressions, see the [Rust book] or the [Reference].",
        "suggest": "有关 `if` 表达式的更多信息，请参见 [Rust book] 或 [Reference]。",
        "translate": ""
    },
    {
        "source": "Implement some functionality for a type.",
        "suggest": "为类型实现一些功能。",
        "translate": ""
    },
    {
        "source": "The `impl` keyword is primarily used to define implementations on types.",
        "suggest": "`impl` 关键字主要用于定义类型的实现。",
        "translate": ""
    },
    {
        "source": "Inherent implementations are standalone, while trait implementations are used to implement traits for types, or other traits.",
        "suggest": "固有实现是独立的，而 trait 实现则用于为类型或其他 traits 实现 traits。",
        "translate": ""
    },
    {
        "source": "Functions and consts can both be defined in an implementation.",
        "suggest": "函数和 const 都可以在实现中定义。",
        "translate": ""
    },
    {
        "source": "A function defined in an `impl` block can be standalone, meaning it would be called like `Foo::bar()`.",
        "suggest": "`impl` 块中定义的函数可以是独立的，这意味着将其称为 `Foo::bar()`。",
        "translate": ""
    },
    {
        "source": "If the function takes `self`, `&self`, or `&mut self` as its first argument, it can also be called using method-call syntax, a familiar feature to any object oriented programmer, like `foo.bar()`.",
        "suggest": "如果该函数将 `self`，`&self` 或 `&mut self` 作为它的第一个参数，则也可以使用方法调用语法来调用它，这是任何面向 object 的程序员 (如 `foo.bar()`) 都熟悉的功能。",
        "translate": ""
    },
    {
        "source": "For more information on implementations, see the [Rust book][book1] or the [Reference].",
        "suggest": "有关实现的更多信息，请参见 [Rust book][book1] 或 [Reference]。",
        "translate": ""
    },
    {
        "source": "The other use of the `impl` keyword is in `impl Trait` syntax, which can be seen as a shorthand for \"a concrete type that implements this trait\".",
        "suggest": "`impl` 关键字的另一个用法是 `impl Trait` 语法，可以将其视为 \"a concrete type that implements this trait\" 的简写。",
        "translate": ""
    },
    {
        "source": "Its primary use is working with closures, which have type definitions generated at compile time that can't be simply typed out.",
        "suggest": "它的主要用途是与闭包一起使用，闭包具有在编译时生成的类型定义，不能简单地将其键入。",
        "translate": ""
    },
    {
        "source": "For more information on `impl Trait` syntax, see the [Rust book][book2].",
        "suggest": "有关 `impl Trait` 语法的更多信息，请参见 [Rust book][book2]。",
        "translate": ""
    },
    {
        "source": "Iterate over a series of values with [`for`].",
        "suggest": "使用 [`for`] 迭代一系列值。",
        "translate": ""
    },
    {
        "source": "The expression immediately following `in` must implement the [`IntoIterator`] trait.",
        "suggest": "`in` 之后的表达式必须实现 [`IntoIterator`] trait。",
        "translate": ""
    },
    {
        "source": "Literal Examples:",
        "suggest": "字面量示例:",
        "translate": ""
    },
    {
        "source": "Iterate over an exclusive range up to but excluding 3.",
        "suggest": "迭代一个唯一的范围，但不超过 3。",
        "translate": ""
    },
    {
        "source": "Iterate over an inclusive range up to and including 3.",
        "suggest": "迭代包含 3 的范围 (包括 3)。",
        "translate": ""
    },
    {
        "source": "(Read more about [range patterns])",
        "suggest": "(了解有关 [range patterns] 的更多信息)",
        "translate": ""
    },
    {
        "source": "Bind a value to a variable.",
        "suggest": "将值绑定到变量。",
        "translate": ""
    },
    {
        "source": "The primary use for the `let` keyword is in `let` statements, which are used to introduce a new set of variables into the current scope, as given by a pattern.",
        "suggest": "`let` 关键字的主要用途是在 `let` 语句中，该语句用于将一组新变量引入到当前的作用域中，如模式所示。",
        "translate": ""
    },
    {
        "source": "The pattern is most commonly a single variable, which means no pattern matching is done and the expression given is bound to the variable.",
        "suggest": "模式通常是单个变量，这意味着不进行模式匹配，并且给定的表达式已绑定到该变量。",
        "translate": ""
    },
    {
        "source": "Apart from that, patterns used in `let` bindings can be as complicated as needed, given that the pattern is exhaustive.",
        "suggest": "除此之外，鉴于 `let` 绑定是详尽无遗的，因此可以根据需要将其复杂化。",
        "translate": ""
    },
    {
        "source": "See the [Rust book][book1] for more information on pattern matching.",
        "suggest": "有关模式匹配的更多信息，请参见 [Rust book][book1]。",
        "translate": ""
    },
    {
        "source": "The type of the pattern is optionally given afterwards, but if left blank is automatically inferred by the compiler if possible.",
        "suggest": "以后可以选择提供模式的类型，但是如果可能的话，编译器会自动推断出是否留空。",
        "translate": ""
    },
    {
        "source": "Variables in Rust are immutable by default, and require the `mut` keyword to be made mutable.",
        "suggest": "Rust 中的变量默认情况下是不可变的，并且要求将 `mut` 关键字设置为可变。",
        "translate": ""
    },
    {
        "source": "Multiple variables can be defined with the same name, known as shadowing.",
        "suggest": "可以使用相同的名称定义多个变量，称为阴影。",
        "translate": ""
    },
    {
        "source": "This doesn't affect the original variable in any way beyond being unable to directly access it beyond the point of shadowing.",
        "suggest": "除了无法在阴影点之外直接访问它之外，这不会以任何方式影响原始变量。",
        "translate": ""
    },
    {
        "source": "It continues to remain in scope, getting dropped only when it falls out of scope.",
        "suggest": "它继续保留在作用域中，只有在它离开离开作用域时才被丢弃。",
        "translate": ""
    },
    {
        "source": "Shadowed variables don't need to have the same type as the variables shadowing them.",
        "suggest": "带阴影的变量不需要与带阴影的变量具有相同的类型。",
        "translate": ""
    },
    {
        "source": "Other places the `let` keyword is used include along with [`if`], in the form of `if let` expressions.",
        "suggest": "`let` 关键字使用的其他位置包括 `if let` 表达式形式的 [`if`]。",
        "translate": ""
    },
    {
        "source": "They're useful if the pattern being matched isn't exhaustive, such as with enumerations.",
        "suggest": "如果匹配的模式不是穷举的 (例如枚举)，则它们很有用。",
        "translate": ""
    },
    {
        "source": "also exists, which runs a loop with a pattern matched value until that pattern can't be matched.",
        "suggest": "也存在，它使用模式匹配值运行循环，直到该模式无法匹配为止。",
        "translate": ""
    },
    {
        "source": "For more information on the `let` keyword, see the [Rust book][book2] or the [Reference]",
        "suggest": "有关 `let` 关键字的更多信息，请参见 [Rust book][book2] 或 [Reference]。",
        "translate": ""
    },
    {
        "source": "Loop while a condition is upheld.",
        "suggest": "保持条件时循环播放。",
        "translate": ""
    },
    {
        "source": "A `while` expression is used for predicate loops.",
        "suggest": "`while` 表达式用于谓词循环。",
        "translate": ""
    },
    {
        "source": "The `while` expression runs the conditional expression before running the loop body, then runs the loop body if the conditional expression evaluates to `true`, or exits the loop otherwise.",
        "suggest": "`while` 表达式在运行循环主体之前先运行条件表达式，然后在条件表达式的计算结果为 `true` 时运行循环主体，否则退出循环。",
        "translate": ""
    },
    {
        "source": "Like the [`for`] expression, we can use `break` and `continue`.",
        "suggest": "像 [`for`] 表达式一样，我们可以使用 `break` 和 `continue`。",
        "translate": ""
    },
    {
        "source": "A `while` expression cannot break with a value and always evaluates to `()` unlike [`loop`].",
        "suggest": "`while` 表达式不能用值中断，并且总是与 [`loop`] 不同而求值为 `()`。",
        "translate": ""
    },
    {
        "source": "As `if` expressions have their pattern matching variant in `if let`, so too do `while` expressions with `while let`.",
        "suggest": "由于 `if` 表达式在 `if let` 中具有其模式匹配成员，因此 `while` 表达式与 `while let` 也是如此。",
        "translate": ""
    },
    {
        "source": "The `while let` expression matches the pattern against the expression, then runs the loop body if pattern matching succeeds, or exits the loop otherwise.",
        "suggest": "`while let` 表达式将模式与该表达式进行匹配，如果模式匹配成功，则运行循环主体，否则退出循环。",
        "translate": ""
    },
    {
        "source": "We can use `break` and `continue` in `while let` expressions just like in `while`.",
        "suggest": "就像在 `while` 中一样，我们可以在 `while let` 表达式中使用 `break` 和 `continue`。",
        "translate": ""
    },
    {
        "source": "For more information on `while` and loops in general, see the [reference].",
        "suggest": "有关 `while` 和常规循环的更多信息，请参见 [reference]。",
        "translate": ""
    },
    {
        "source": "See also, [`for`],",
        "suggest": "另请参见 [`for`]，",
        "translate": ""
    },
    {
        "source": "Loop indefinitely.",
        "suggest": "无限循环。",
        "translate": ""
    },
    {
        "source": "is used to define the simplest kind of loop supported in Rust.",
        "suggest": "用于定义 Rust 支持的最简单的循环类型。",
        "translate": ""
    },
    {
        "source": "It runs the code inside it until the code uses `break` or the program exits.",
        "suggest": "它在其中运行代码，直到代码使用 `break` 或程序退出为止。",
        "translate": ""
    },
    {
        "source": "Unlike the other kinds of loops in Rust (`while`, `while let`, and `for`), loops can be used as expressions that return values via `break`.",
        "suggest": "与 Rust 中的其他类型的循环 (`while`，`while let` 和 `for`) 不同，循环可以用作通过 `break` 返回值的表达式。",
        "translate": ""
    },
    {
        "source": "Every `break` in a loop has to have the same type.",
        "suggest": "循环中的每个 `break` 必须具有相同的类型。",
        "translate": ""
    },
    {
        "source": "When it's not explicitly giving something, `break;` returns `()`.",
        "suggest": "如果未明确给出任何内容，则 `break;` 返回 `()`。",
        "translate": ""
    },
    {
        "source": "For more information on `loop` and loops in general, see the [Reference].",
        "suggest": "有关 `loop` 和常规循环的更多信息，请参见 [Reference]。",
        "translate": ""
    },
    {
        "source": "Control flow based on pattern matching.",
        "suggest": "基于模式匹配的控制流。",
        "translate": ""
    },
    {
        "source": "can be used to run code conditionally.",
        "suggest": "可用于有条件地运行代码。",
        "translate": ""
    },
    {
        "source": "Every pattern must be handled exhaustively either explicitly or by using wildcards like `_` in the `match`.",
        "suggest": "必须显式或通过使用通配符 (例如 `match` 中的 `_`) 来详尽地处理每个模式。",
        "translate": ""
    },
    {
        "source": "Since `match` is an expression, values can also be returned.",
        "suggest": "由于 `match` 是表达式，因此也可以返回值。",
        "translate": ""
    },
    {
        "source": "can be used to gain access to the inner members of an enum and use them directly.",
        "suggest": "可以用来获取枚举的内部成员并直接使用它们。",
        "translate": ""
    },
    {
        "source": "For more information on `match` and matching in general, see the [Reference].",
        "suggest": "有关 `match` 和常规匹配的更多信息，请参见 [Reference]。",
        "translate": ""
    },
    {
        "source": "Organize code into [modules].",
        "suggest": "将代码整理到 [模块][modules] 中。",
        "translate": ""
    },
    {
        "source": "Use `mod` to create new [modules] to encapsulate code, including other modules:",
        "suggest": "使用 `mod` 创建新的 [模块][modules] 来封装代码，包括其他模块:",
        "translate": ""
    },
    {
        "source": "Like [`struct`]s and [`enum`]s, a module and its content are private by default, unaccessible to code outside of the module.",
        "suggest": "和 [`struct`] 和 [`enum`] 一样，默认情况下，模块及其内容是私有的，无法在模块外部进行代码访问。",
        "translate": ""
    },
    {
        "source": "To learn more about allowing access, see the documentation for the [`pub`] keyword.",
        "suggest": "要了解有关允许访问的更多信息，请参见 [`pub`] 关键字的文档。",
        "translate": ""
    },
    {
        "source": "Capture a [closure]'s environment by value.",
        "suggest": "按值捕获 [闭包][closure] 的环境。",
        "translate": ""
    },
    {
        "source": "converts any variables captured by reference or mutable reference to owned by value variables.",
        "suggest": "将通过引用或可变引用捕获的任何变量转换为值变量所拥有的变量。",
        "translate": ""
    },
    {
        "source": "`move` closures may still implement [`Fn`] or [`FnMut`], even though they capture variables by `move`.",
        "suggest": "即使 `move` 闭包通过 `move` 捕获变量，它们仍然可以实现 [`Fn`] 或 [`FnMut`]。",
        "translate": ""
    },
    {
        "source": "This is because the traits implemented by a closure type are determined by *what* the closure does with captured values, not *how* it captures them:",
        "suggest": "这是因为由闭包类型实现的 traits 是由闭包对捕获的值进行的操作 (而不是对捕获值的方式) 确定的:",
        "translate": ""
    },
    {
        "source": "is often used when [threads] are involved.",
        "suggest": "涉及 [线程][threads] 时经常使用。",
        "translate": ""
    },
    {
        "source": "is also valid before an async block.",
        "suggest": "在异步块之前也有效。",
        "translate": ""
    },
    {
        "source": "For more information on the `move` keyword, see the [closure]'s section of the Rust book or the [threads] section",
        "suggest": "有关 `move` 关键字的更多信息，请参见 Rust 书的 [闭包][closure] 部分或 [线程][threads] 部分",
        "translate": ""
    },
    {
        "source": "A mutable variable, reference, or pointer.",
        "suggest": "可变变量，引用或指针。",
        "translate": ""
    },
    {
        "source": "can be used in several situations.",
        "suggest": "可以在几种情况下使用。",
        "translate": ""
    },
    {
        "source": "The first is mutable variables, which can be used anywhere you can bind a value to a variable name.",
        "suggest": "第一个是变量变量，它可以在可以将值绑定到变量名称的任何地方使用。",
        "translate": ""
    },
    {
        "source": "Some examples:",
        "suggest": "一些例子:",
        "translate": ""
    },
    {
        "source": "The second is mutable references.",
        "suggest": "第二个是可变引用。",
        "translate": ""
    },
    {
        "source": "They can be created from `mut` variables and must be unique: no other variables can have a mutable reference, nor a shared reference.",
        "suggest": "它们可以从 `mut` 变量创建，并且必须唯一: 其他变量不能具有变量引用，也不能具有共享引用。",
        "translate": ""
    },
    {
        "source": "Mutable raw pointers work much like mutable references, with the added possibility of not pointing to a valid object.",
        "suggest": "可变裸指针的工作方式与可变引用非常相似，但有可能无法指向有效的 object。",
        "translate": ""
    },
    {
        "source": "The syntax is `*mut Type`.",
        "suggest": "语法为 `*mut Type`。",
        "translate": ""
    },
    {
        "source": "More information on mutable references and pointers can be found in``` [Reference].",
        "suggest": "在 [Reference] 中可以找到有关可变引用和指针的更多信息。",
        "translate": ""
    },
    {
        "source": "Make an item visible to others.",
        "suggest": "使一个项目对其他人可见。",
        "translate": ""
    },
    {
        "source": "The keyword `pub` makes any module, function, or data structure accessible from inside of external modules.",
        "suggest": "关键字 `pub` 使得可以从外部模块内部访问任何模块，函数或数据结构体。",
        "translate": ""
    },
    {
        "source": "The `pub` keyword may also be used in a `use` declaration to re-export an identifier from a namespace.",
        "suggest": "`pub` 关键字也可以在 `use` 声明中使用，以重命名名称空间中的标识符。",
        "translate": ""
    },
    {
        "source": "For more information on the `pub` keyword, please see the visibility section of the [reference] and for some examples, see [Rust by Example].",
        "suggest": "有关 `pub` 关键字的更多信息，请参见 [reference] 的可见性部分，有关某些示例，请参见 [Rust 示例][Rust by Example]。",
        "translate": ""
    },
    {
        "source": "[Rust by Example]:../rust-by-example/mod/visibility.html",
        "suggest": "[Rust by Example]:../rust-by-example/mod/visibility.html",
        "translate": ""
    },
    {
        "source": "Bind by reference during pattern matching.",
        "suggest": "在模式匹配期间由引用绑定。",
        "translate": ""
    },
    {
        "source": "annotates pattern bindings to make them borrow rather than move.",
        "suggest": "注解模式绑定，使它们借用而不是移动。",
        "translate": ""
    },
    {
        "source": "It is **not** a part of the pattern as far as matching is concerned: it does not affect *whether* a value is matched, only *how* it is matched.",
        "suggest": "就匹配而言，它不是模式的一部分: 不影响 *是否* 匹配值，仅 *如何* 匹配。",
        "translate": ""
    },
    {
        "source": "By default, [`match`] statements consume all they can, which can sometimes be a problem, when you don't really need the value to be moved and owned:",
        "suggest": "默认情况下，当您实际上不需要移动和拥有值时，[`match`] 语句将尽一切可能使用，这有时可能是个问题:",
        "translate": ""
    },
    {
        "source": "Using the `ref` keyword, the value is only borrowed, not moved, making it available for use after the [`match`] statement:",
        "suggest": "使用 `ref` 关键字，该值仅被借用，而不移动，从而使它可在 [`match`] 语句之后使用:",
        "translate": ""
    },
    {
        "source": "denotes that your pattern expects a reference to an object.",
        "suggest": "表示您的模式需要 object 的引用。",
        "translate": ""
    },
    {
        "source": "Hence `&` is a part of said pattern: `&Foo` matches different objects than `Foo` does.",
        "suggest": "因此，`&` 是所述模式的一部分: `&Foo` 与 `Foo` 匹配不同的对象。",
        "translate": ""
    },
    {
        "source": "indicates that you want a reference to an unpacked value.",
        "suggest": "表示您希望对未包装的值进行引用。",
        "translate": ""
    },
    {
        "source": "It is not matched against: `Foo(ref foo)` matches the same objects as `Foo(foo)`.",
        "suggest": "不匹配: `Foo(ref foo)` 与 `Foo(foo)` 匹配相同的对象。",
        "translate": ""
    },
    {
        "source": "See also the [Reference] for more information.",
        "suggest": "有关更多信息，请参见 [Reference]。",
        "translate": ""
    },
    {
        "source": "Return a value from a function.",
        "suggest": "从函数返回值。",
        "translate": ""
    },
    {
        "source": "A `return` marks the end of an execution path in a function:",
        "suggest": "`return` 在函数中标记执行路径的结尾:",
        "translate": ""
    },
    {
        "source": "is not needed when the returned value is the last expression in the function.",
        "suggest": "当返回值是函数中的最后一个表达式时，则不需要。",
        "translate": ""
    },
    {
        "source": "In this case the `;` is omitted:",
        "suggest": "在这种情况下，将省略 `;`:",
        "translate": ""
    },
    {
        "source": "returns from the function immediately (an \"early return\"):",
        "suggest": "立即从函数 (\"early return\") 返回:",
        "translate": ""
    },
    {
        "source": "The receiver of a method, or the current module.",
        "suggest": "方法的接收者，或当前模块。",
        "translate": ""
    },
    {
        "source": "is used in two situations: referencing the current module and marking the receiver of a method.",
        "suggest": "在两种情况下使用: 引用当前模块和标记方法的接收者。",
        "translate": ""
    },
    {
        "source": "In paths, `self` can be used to refer to the current module, either in a [`use`] statement or in a path to access an element:",
        "suggest": "在路径中，`self` 可用于在 [`use`] 语句中或在访问元素的路径中引用当前模块:",
        "translate": ""
    },
    {
        "source": "Is functionally the same as:",
        "suggest": "在功能上与以下内容相同:",
        "translate": ""
    },
    {
        "source": "Using `self` to access an element in the current module:",
        "suggest": "使用 `self` 访问当前模块中的元素:",
        "translate": ""
    },
    {
        "source": "as the current receiver for a method allows to omit the parameter type most of the time.",
        "suggest": "因为当前方法的接收者允许大部分时间省略参数类型。",
        "translate": ""
    },
    {
        "source": "With the exception of this particularity, `self` is used much like any other parameter:",
        "suggest": "除了这种特殊性，`self` 的用法与任何其他参数非常相似:",
        "translate": ""
    },
    {
        "source": "Note that this automatic conversion when calling `foo.method()` is not limited to the examples above.",
        "suggest": "请注意，调用 `foo.method()` 时的这种自动转换不限于以上示例。",
        "translate": ""
    },
    {
        "source": "See the [Reference] for more information.",
        "suggest": "有关更多信息，请参见 [Reference]。",
        "translate": ""
    },
    {
        "source": "Once rustdoc can handle URL conflicts on case insensitive file systems, we can remove the three next lines and put back:",
        "suggest": "一旦 rustdoc 可以处理不区分大小写的文件系统上的 URL 冲突，我们就可以删除下三行并放回去:",
        "translate": ""
    },
    {
        "source": "The implementing type within a [`trait`] or [`impl`] block, or the current type within a type definition.",
        "suggest": "[`trait`] 或 [`impl`] 块中的实现类型，或类型定义中的当前类型。",
        "translate": ""
    },
    {
        "source": "Within a type definition:",
        "suggest": "在类型定义内:",
        "translate": ""
    },
    {
        "source": "In an [`impl`] block:",
        "suggest": "在 [`impl`] 块中:",
        "translate": ""
    },
    {
        "source": "Generic parameters are implicit with `Self`:",
        "suggest": "`Self` 隐含了泛型参数:",
        "translate": ""
    },
    {
        "source": "In a [`trait`] definition and related [`impl`] block:",
        "suggest": "在 [`trait`] 定义和相关的 [`impl`] 块中:",
        "translate": ""
    },
    {
        "source": "A static item is a value which is valid for the entire duration of your program (a `'static` lifetime).",
        "suggest": "静态项是在程序的整个持续时间 (`'static` 生命周期) 内有效的值。",
        "translate": ""
    },
    {
        "source": "On the surface, `static` items seem very similar to [`const`]s: both contain a value, both require type annotations and both can only be initialized with constant functions and values.",
        "suggest": "从表面上看，`static` 项与 [`const`] 非常相似: 两者都包含一个值，都需要类型注解，并且都只能使用常量函数和值进行初始化。",
        "translate": ""
    },
    {
        "source": "However, `static`s are notably different in that they represent a location in memory.",
        "suggest": "但是，`static` 与众不同之处在于它们表示内存中的一个位置。",
        "translate": ""
    },
    {
        "source": "That means that you can have references to `static` items and potentially even modify them, making them essentially global variables.",
        "suggest": "这意味着您可以引用 `static` 项，甚至可以对其进行修改，从而使它们本质上是变量。",
        "translate": ""
    },
    {
        "source": "Static items do not call [`drop`] at the end of the program.",
        "suggest": "静态项不要在程序末尾调用 [`drop`]。",
        "translate": ""
    },
    {
        "source": "There are two types of `static` items: those declared in association with the [`mut`] keyword and those without.",
        "suggest": "`static` 项有两种类型: 与 [`mut`] 关键字关联声明的 `static` 项和没有 [`mut`] 关键字的 `static` 项。",
        "translate": ""
    },
    {
        "source": "Static items cannot be moved:",
        "suggest": "静态项无法移动:",
        "translate": ""
    },
    {
        "source": "Simple `static`s",
        "suggest": "简单的 `static`",
        "translate": ""
    },
    {
        "source": "Accessing non-[`mut`] `static` items is considered safe, but some restrictions apply.",
        "suggest": "访问非 [`mut`] `static` 项被认为是安全的，但存在一些限制。",
        "translate": ""
    },
    {
        "source": "Most notably, the type of a `static` value needs to implement the [`Sync`] trait, ruling out interior mutability containers like [`RefCell`].",
        "suggest": "最值得注意的是，`static` 值的类型需要实现 [`Sync`] trait，排除内部可变性容器 (如 [`RefCell`])。",
        "translate": ""
    },
    {
        "source": "Mutable `static`s",
        "suggest": "可变 `static`",
        "translate": ""
    },
    {
        "source": "If a `static` item is declared with the [`mut`] keyword, then it is allowed to be modified by the program.",
        "suggest": "如果使用 [`mut`] 关键字声明了 `static` 项，则程序允许对其进行修改。",
        "translate": ""
    },
    {
        "source": "However, accessing mutable `static`s can cause undefined behavior in a number of ways, for example due to data races in a multithreaded context.",
        "suggest": "但是，访问可变的 `static` 可能以多种方式导致未定义的行为，例如由于多线程上下文中的数据竞争。",
        "translate": ""
    },
    {
        "source": "As such, all accesses to mutable `static`s require an [`unsafe`] block.",
        "suggest": "因此，对可变 `static` 的所有访问都需要一个 [`unsafe`] 块。",
        "translate": ""
    },
    {
        "source": "Despite their unsafety, mutable `static`s are necessary in many contexts:",
        "suggest": "尽管它们不安全，但是在许多情况下，可变的 static 是必需的:",
        "translate": ""
    },
    {
        "source": "they can be used to represent global state shared by the whole program or in [`extern`] blocks to bind to variables from C libraries.",
        "suggest": "它们可用于表示整个程序共享的状态或在 [`extern`] 块中绑定到 C 库中的变量。",
        "translate": ""
    },
    {
        "source": "In an [`extern`] block:",
        "suggest": "在 [`extern`] 块中:",
        "translate": ""
    },
    {
        "source": "Mutable `static`s, just like simple `static`s, have some restrictions that apply to them.",
        "suggest": "就像简单的静态变量一样，可变静态变量也有一些限制。",
        "translate": ""
    },
    {
        "source": "A type that is composed of other types.",
        "suggest": "由其他类型组成的类型。",
        "translate": ""
    },
    {
        "source": "Structs in Rust come in three flavors: Structs with named fields, tuple structs, and unit structs.",
        "suggest": "Rust 中的结构体有三种风格: 带有命名字段的结构体，元组结构体和单元结构体。",
        "translate": ""
    },
    {
        "source": "Regular structs are the most commonly used.",
        "suggest": "常规结构体是最常用的。",
        "translate": ""
    },
    {
        "source": "Each field defined within them has a name and a type, and once defined can be accessed using `example_struct.field` syntax.",
        "suggest": "它们中定义的每个字段都有一个名称和类型，一旦定义，就可以使用 `example_struct.field` 语法进行访问。",
        "translate": ""
    },
    {
        "source": "The fields of a struct share its mutability, so `foo.bar = 2;` would only be valid if `foo` was mutable.",
        "suggest": "结构体的字段共享其可变性，因此 `foo.bar = 2;` 仅在 `foo` 是可变的时才有效。",
        "translate": ""
    },
    {
        "source": "Adding `pub` to a field makes it visible to code in other modules, as well as allowing it to be directly accessed and modified.",
        "suggest": "在字段中添加 `pub` 使其可以在其他模块中的代码中看到，并且可以直接对其进行访问和修改。",
        "translate": ""
    },
    {
        "source": "Tuple structs are similar to regular structs, but its fields have no names.",
        "suggest": "元组结构体与常规结构体相似，但其字段没有名称。",
        "translate": ""
    },
    {
        "source": "They are used like tuples, with deconstruction possible via `let TupleStruct(x, y) = foo;` syntax.",
        "suggest": "它们像元组一样使用，可以通过 `let TupleStruct(x, y) = foo;` 语法进行解构。",
        "translate": ""
    },
    {
        "source": "For accessing individual variables, the same syntax is used as with regular tuples, namely `foo.0`, `foo.1`, etc, starting at zero.",
        "suggest": "为了访问单个变量，使用与常规元组相同的语法，即 `foo.0`，`foo.1` 等，从零开始。",
        "translate": ""
    },
    {
        "source": "Unit structs are most commonly used as marker.",
        "suggest": "单元结构体最常用作标记。",
        "translate": ""
    },
    {
        "source": "They have a size of zero bytes, but unlike empty enums they can be instantiated, making them isomorphic to the unit type `()`.",
        "suggest": "它们的大小为零字节，但是与空的枚举不同，它们可以实例化，使其与单元类型 `()` 同构。",
        "translate": ""
    },
    {
        "source": "Unit structs are useful when you need to implement a trait on something, but don't need to store any data inside it.",
        "suggest": "当您需要在某物上实现 trait 而不需要在其中存储任何数据时，单元结构体非常有用。",
        "translate": ""
    },
    {
        "source": "Structs can be instantiated in different ways, all of which can be mixed and matched as needed.",
        "suggest": "可以用不同的方式实例化结构体，所有方式都可以根据需要进行混合和匹配。",
        "translate": ""
    },
    {
        "source": "The most common way to make a new struct is via a constructor method such as `new()`, but when that isn't available (or you're writing the constructor itself), struct literal syntax is used:",
        "suggest": "生成新结构体的最常见方法是通过诸如 `new()` 之类的构造函数方法，但是当该方法不可用 (或者您正在编写构造函数本身) 时，将使用结构体字面量语法:",
        "translate": ""
    },
    {
        "source": "It's only possible to directly instantiate a struct using struct literal syntax when all of its fields are visible to you.",
        "suggest": "当您对结构体的所有字段都可见时，才可以使用结构体字面量语法直接实例化结构体。",
        "translate": ""
    },
    {
        "source": "There are a handful of shortcuts provided to make writing constructors more convenient, most common of which is the Field Init shorthand.",
        "suggest": "提供了一些快捷方式，以使编写构造函数更加方便，其中最常见的是缩写词初始化简写语法。",
        "translate": ""
    },
    {
        "source": "When there is a variable and a field of the same name, the assignment can be simplified from `field: field` into simply `field`.",
        "suggest": "当变量和字段具有相同的名称时，可以将分配从 `field: field` 简化为 `field`。",
        "translate": ""
    },
    {
        "source": "The following example of a hypothetical constructor demonstrates this:",
        "suggest": "假设的构造函数的以下示例说明了这一点:",
        "translate": ""
    },
    {
        "source": "Another shortcut for struct instantiation is available, used when you need to make a new struct that has the same values as most of a previous struct of the same type, called struct update syntax:",
        "suggest": "结构体实例化的另一种快捷方式是可用的，当您需要制作一个具有与大多数以前相同类型的结构体相同的值的新结构体时，可以使用该快捷方式，称为结构体更新语法:",
        "translate": ""
    },
    {
        "source": "Tuple structs are instantiated in the same way as tuples themselves, except with the struct's name as a prefix:",
        "suggest": "元组结构体以与元组本身相同的方式实例化，不同之处在于结构体的名称为前缀:",
        "translate": ""
    },
    {
        "source": "Empty structs are instantiated with just their name, and don't need anything else.",
        "suggest": "空结构体仅用其名称实例化，不需要其他任何东西。",
        "translate": ""
    },
    {
        "source": "Style conventions",
        "suggest": "样式约定",
        "translate": ""
    },
    {
        "source": "Structs are always written in CamelCase, with few exceptions.",
        "suggest": "结构体总是用骆驼命名法编写的，只有少数例外。",
        "translate": ""
    },
    {
        "source": "While the trailing comma on a struct's list of fields can be omitted, it's usually kept for convenience in adding and removing fields down the line.",
        "suggest": "虽然可以省略结构体的字段列表中的结尾逗号，但为了方便在行中添加和删除字段，通常将其保留下来。",
        "translate": ""
    },
    {
        "source": "For more information on structs, take a look at the [Rust Book][book] or the [Reference][reference].",
        "suggest": "有关结构体的更多信息，请查看 [Rust 书][book] 或 [reference]。",
        "translate": ""
    },
    {
        "source": "The parent of the current [module].",
        "suggest": "当前 [模块][module] 的父级。",
        "translate": ""
    },
    {
        "source": "It is also possible to use `super` multiple times: `super::super::foo`, going up the ancestor chain.",
        "suggest": "也可以多次使用 `super`: `super::super::foo`，在祖先链上进行。",
        "translate": ""
    },
    {
        "source": "A common interface for a group of types.",
        "suggest": "一组类型的通用接口。",
        "translate": ""
    },
    {
        "source": "A `trait` is like an interface that data types can implement.",
        "suggest": "`trait` 就像数据类型可以实现的接口。",
        "translate": ""
    },
    {
        "source": "When a type implements a trait it can be treated abstractly as that trait using generics or trait objects.",
        "suggest": "当类型实现 trait 时，可以使用泛型或 trait 对象抽象地将其视为 trait。",
        "translate": ""
    },
    {
        "source": "Traits can be made up of three varieties of associated items:",
        "suggest": "Traits 可以由三个关联项组成:",
        "translate": ""
    },
    {
        "source": "functions and methods",
        "suggest": "函数和方法",
        "translate": ""
    },
    {
        "source": "Traits may also contain additional type parameters.",
        "suggest": "Traits 也可能包含其他类型参数。",
        "translate": ""
    },
    {
        "source": "Those type parameters or the trait itself can be constrained by other traits.",
        "suggest": "这些类型参数或 trait 本身可以受到其他 traits 的约束。",
        "translate": ""
    },
    {
        "source": "Traits can serve as markers or carry other logical semantics that aren't expressed through their items.",
        "suggest": "Traits 可以用作标记或承载其他逻辑语义，这些逻辑语义不是通过其项表示的。",
        "translate": ""
    },
    {
        "source": "When a type implements that trait it is promising to uphold its contract.",
        "suggest": "当一个类型实现该 trait 时，它承诺遵守其契约。",
        "translate": ""
    },
    {
        "source": "and [`Sync`] are two such marker traits present in the standard library.",
        "suggest": "[`Sync`] 和 [`Sync`] 是标准库中存在的两个此类标记 traits。",
        "translate": ""
    },
    {
        "source": "See the [Reference][Ref-Traits] for a lot more information on traits.",
        "suggest": "有关 traits 的更多信息，请参见 [Reference][Ref-Traits]。",
        "translate": ""
    },
    {
        "source": "Traits are declared using the `trait` keyword.",
        "suggest": "Traits 使用 `trait` 关键字声明。",
        "translate": ""
    },
    {
        "source": "Types can implement them using [`impl`] `Trait` [`for`] `Type`:",
        "suggest": "类型可以使用 [`impl`] `Trait` [`for`] `Type` 来实现它们:",
        "translate": ""
    },
    {
        "source": "With an associated type:",
        "suggest": "带有关联类型:",
        "translate": ""
    },
    {
        "source": "Traits can be generic, with constraints or without:",
        "suggest": "Traits 可以是泛型，有约束或无约束:",
        "translate": ""
    },
    {
        "source": "Traits can build upon the requirements of other traits.",
        "suggest": "Traits 可以建立在其他 traits 的需求之上。",
        "translate": ""
    },
    {
        "source": "In the example below `Iterator` is a **supertrait** and `ThreeIterator` is a **subtrait**:",
        "suggest": "在下面的示例中，`Iterator` 是 **supertrait**，而 `ThreeIterator` 是 **subtrait**:",
        "translate": ""
    },
    {
        "source": "Traits can be used in functions, as parameters:",
        "suggest": "Traits 可以在函数中用作参数:",
        "translate": ""
    },
    {
        "source": "Or as return types:",
        "suggest": "或作为返回类型:",
        "translate": ""
    },
    {
        "source": "The use of the [`impl`] keyword in this position allows the function writer to hide the concrete type as an implementation detail which can change without breaking user's code.",
        "suggest": "在该位置使用 [`impl`] 关键字，函数 writer 可以将具体类型隐藏为实现细节，可以在不破坏用户代码的情况下对其进行更改。",
        "translate": ""
    },
    {
        "source": "Trait objects",
        "suggest": "Trait 对象",
        "translate": ""
    },
    {
        "source": "A *trait object* is an opaque value of another type that implements a set of traits.",
        "suggest": "*trait 对象* 是另一种实现一组 traits 的不透明值。",
        "translate": ""
    },
    {
        "source": "A trait object implements all specified traits as well as their supertraits (if any).",
        "suggest": "trait object 实现所有指定的 traits 及其上级特征 (如果有)。",
        "translate": ""
    },
    {
        "source": "The syntax is the following:",
        "suggest": "语法如下:",
        "translate": ""
    },
    {
        "source": "Only one `BaseTrait` can be used so this will not compile:",
        "suggest": "只能使用一个 `BaseTrait`，因此无法编译:",
        "translate": ""
    },
    {
        "source": "Neither will this, which is a syntax error:",
        "suggest": "这也不是，这是语法错误:",
        "translate": ""
    },
    {
        "source": "On the other hand, this is correct:",
        "suggest": "另一方面，这是正确的:",
        "translate": ""
    },
    {
        "source": "The [Reference][Ref-Trait-Objects] has more information about trait objects, their limitations and the differences between editions.",
        "suggest": "[Reference][Ref-Trait-Objects] 具有有关 trait 对象，它们的限制以及版本之间的差异的更多信息。",
        "translate": ""
    },
    {
        "source": "Unsafe traits",
        "suggest": "不安全的 traits",
        "translate": ""
    },
    {
        "source": "Some traits may be unsafe to implement.",
        "suggest": "某些 traits 可能不安全实现。",
        "translate": ""
    },
    {
        "source": "Using the [`unsafe`] keyword in front of the trait's declaration is used to mark this:",
        "suggest": "在 trait 声明的前面使用 [`unsafe`] 关键字进行标记:",
        "translate": ""
    },
    {
        "source": "Differences between the 2015 and 2018 editions",
        "suggest": "2015 年版和 2018 年版之间的差异",
        "translate": ""
    },
    {
        "source": "In the 2015 edition the parameters pattern was not needed for traits:",
        "suggest": "在 2015 版中，traits 不需要参数模式:",
        "translate": ""
    },
    {
        "source": "This behavior is no longer valid in edition 2018.",
        "suggest": "此行为在 2018 版中不再有效。",
        "translate": ""
    },
    {
        "source": "A value of type [`bool`] representing logical **true**.",
        "suggest": "[`bool`] 类型的值，表示逻辑 `true`。",
        "translate": ""
    },
    {
        "source": "Logically `true` is not equal to [`false`].",
        "suggest": "逻辑上 `true` 不等于 [`false`]。",
        "translate": ""
    },
    {
        "source": "Control structures that check for **true**",
        "suggest": "检查 **true** 的控制结构",
        "translate": ""
    },
    {
        "source": "Several of Rust's control structures will check for a `bool` condition evaluating to **true**.",
        "suggest": "Rust 的几个控制结构将检查 `bool` 条件是否评估为 `true`。",
        "translate": ""
    },
    {
        "source": "The condition in an [`if`] expression must be of type `bool`.",
        "suggest": "[`if`] 表达式中的条件必须为 `bool` 类型。",
        "translate": ""
    },
    {
        "source": "Whenever that condition evaluates to **true**, the `if` expression takes on the value of the first block.",
        "suggest": "只要该条件评估为 `true`，`if` 表达式就会采用第一个块的值。",
        "translate": ""
    },
    {
        "source": "If however, the condition evaluates to `false`, the expression takes on value of the `else` block if there is one.",
        "suggest": "但是，如果条件计算结果为 `false`，则表达式为 `else` 块的值 (如果有)。",
        "translate": ""
    },
    {
        "source": "is another control flow construct expecting a `bool`-typed condition.",
        "suggest": "是另一个控制流构造，期望使用 `bool` 类型的条件。",
        "translate": ""
    },
    {
        "source": "As long as the condition evaluates to **true**, the `while` loop will continually evaluate its associated block.",
        "suggest": "只要条件评估为 `true`，`while` 循环将连续评估其关联的块。",
        "translate": ""
    },
    {
        "source": "arms can have guard clauses on them.",
        "suggest": "分支上可以有保护子句。",
        "translate": ""
    },
    {
        "source": "Define an alias for an existing type.",
        "suggest": "为现有类型定义别名。",
        "translate": ""
    },
    {
        "source": "The syntax is `type Name = ExistingType;`.",
        "suggest": "语法为 `type Name = ExistingType;`。",
        "translate": ""
    },
    {
        "source": "does **not** create a new type:",
        "suggest": "不创建新类型:",
        "translate": ""
    },
    {
        "source": "In traits, `type` is used to declare an [associated type]:",
        "suggest": "在 traits 中，`type` 用于声明 [associated type]:",
        "translate": ""
    },
    {
        "source": "Code or interfaces whose [memory safety] cannot be verified by the type system.",
        "suggest": "[memory safety] 不能由类型系统验证的代码或接口。",
        "translate": ""
    },
    {
        "source": "The `unsafe` keyword has two uses: to declare the existence of contracts the compiler can't check (`unsafe fn` and `unsafe trait`), and to declare that a programmer has checked that these contracts have been upheld (`unsafe {}` and `unsafe impl`, but also `unsafe fn` -- see below).",
        "suggest": "`unsafe` 关键字有两个用途: 声明编译器无法检查的契约的存在 (`unsafe fn` 和 `unsafe trait`)，以及声明程序员检查了这些契约是否得到遵守 (`unsafe {}` 和 `unsafe impl`，还有 `unsafe fn` - 见下文)。",
        "translate": ""
    }
]
