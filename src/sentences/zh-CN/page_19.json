[
    {
        "source": "timed-out without the condition ever evaluating to false.",
        "suggest": "超时，条件永远不会为假。",
        "translate": ""
    },
    {
        "source": "access the locked mutex via result.0",
        "suggest": "通过 result.0 访问锁定的互斥锁",
        "translate": ""
    },
    {
        "source": "A type indicating whether a timed wait on a condition variable returned due to a time out or not.",
        "suggest": "指示是否因超时而返回的条件变量的定时等待的类型。",
        "translate": ""
    },
    {
        "source": "It is returned by the [`wait_timeout`] method.",
        "suggest": "它由 [`wait_timeout`] 方法返回。",
        "translate": ""
    },
    {
        "source": "Returns `true` if the wait was known to have timed out.",
        "suggest": "如果已知等待超时，则返回 `true`。",
        "translate": ""
    },
    {
        "source": "This example spawns a thread which will update the boolean value and then wait 100 milliseconds before notifying the condvar.",
        "suggest": "本示例生成一个线程，该线程将更新布尔值，然后等待 100 毫秒再通知 condvar。",
        "translate": ""
    },
    {
        "source": "The main thread will wait with a timeout on the condvar and then leave once the boolean has been updated and notified.",
        "suggest": "主线程将在 condvar 上等待超时，然后在布尔值已更新并通知后离开。",
        "translate": ""
    },
    {
        "source": "A Condition Variable",
        "suggest": "条件变量",
        "translate": ""
    },
    {
        "source": "Condition variables represent the ability to block a thread such that it consumes no CPU time while waiting for an event to occur.",
        "suggest": "条件变量表示阻塞线程的能力，以使线程在等待事件发生时不占用任何 CPU 时间。",
        "translate": ""
    },
    {
        "source": "Condition variables are typically associated with a boolean predicate (a condition) and a mutex.",
        "suggest": "条件变量通常与布尔谓词 (条件) 和互斥锁相关联。",
        "translate": ""
    },
    {
        "source": "The predicate is always verified inside of the mutex before determining that a thread must block.",
        "suggest": "在确定线程必须阻塞之前，始终在互斥锁内部验证该谓词。",
        "translate": ""
    },
    {
        "source": "Functions in this module will block the current **thread** of execution.",
        "suggest": "此模块中的函数将阻止当前的执行线程。",
        "translate": ""
    },
    {
        "source": "Note that any attempt to use multiple mutexes on the same condition variable may result in a runtime panic.",
        "suggest": "请注意，对同一条件变量使用多个互斥锁的任何尝试都可能导致运行时 panic。",
        "translate": ""
    },
    {
        "source": "Creates a new condition variable which is ready to be waited on and notified.",
        "suggest": "创建一个新的条件变量，可以随时等待它并通知它。",
        "translate": ""
    },
    {
        "source": "Blocks the current thread until this condition variable receives a notification.",
        "suggest": "阻塞当前线程，直到此条件变量收到通知为止。",
        "translate": ""
    },
    {
        "source": "This function will atomically unlock the mutex specified (represented by `guard`) and block the current thread.",
        "suggest": "该函数将自动解锁指定的互斥锁 (由 `guard` 表示) 并阻塞当前线程。",
        "translate": ""
    },
    {
        "source": "This means that any calls to [`notify_one`] or [`notify_all`] which happen logically after the mutex is unlocked are candidates to wake this thread up.",
        "suggest": "这意味着在互斥锁解锁后逻辑上发生的任何对 [`notify_one`] 或 [`notify_all`] 的调用都可以唤醒该线程。",
        "translate": ""
    },
    {
        "source": "When this function call returns, the lock specified will have been re-acquired.",
        "suggest": "当此函数调用返回时，将重新获得指定的锁。",
        "translate": ""
    },
    {
        "source": "Note that this function is susceptible to spurious wakeups.",
        "suggest": "请注意，此函数易受虚假唤醒的影响。",
        "translate": ""
    },
    {
        "source": "Condition variables normally have a boolean predicate associated with them, and the predicate must always be checked each time this function returns to protect against spurious wakeups.",
        "suggest": "条件变量通常具有与之关联的布尔谓词，并且每次此函数返回时都必须始终检查谓词，以防止虚假唤醒。",
        "translate": ""
    },
    {
        "source": "This function will return an error if the mutex being waited on is poisoned when this thread re-acquires the lock.",
        "suggest": "如果正在等待的互斥锁在此线程重新获取锁时中毒，则此函数将返回错误。",
        "translate": ""
    },
    {
        "source": "For more information, see information about [poisoning] on the [`Mutex`] type.",
        "suggest": "有关更多信息，请参见有关 [`Mutex`] 类型的 [poisoning] 的信息。",
        "translate": ""
    },
    {
        "source": "This function may [`panic!`] if it is used with more than one mutex over time.",
        "suggest": "如果长时间使用此函数与多个互斥锁，则该函数可能为 [`panic!`]。",
        "translate": ""
    },
    {
        "source": "Blocks the current thread until this condition variable receives a notification and the provided condition is false.",
        "suggest": "阻止当前线程，直到此条件变量接收到通知并且所提供的条件为 false 为止。",
        "translate": ""
    },
    {
        "source": "Waits on this condition variable for a notification, timing out after a specified duration.",
        "suggest": "等待此条件变量以获取通知，并在指定的持续时间后超时。",
        "translate": ""
    },
    {
        "source": "The semantics of this function are equivalent to [`wait`] except that the thread will be blocked for roughly no longer than `ms` milliseconds.",
        "suggest": "该函数的语义与 [`wait`] 等效，除了线程被阻塞的时间大约不超过 `ms` 毫秒。",
        "translate": ""
    },
    {
        "source": "This method should not be used for precise timing due to anomalies such as preemption or platform differences that may not cause the maximum amount of time waited to be precisely `ms`.",
        "suggest": "由于诸如抢占或平台差异之类的异常可能不会导致等待的最大时间精确为 `ms`，因此此方法不应用于精确的计时。",
        "translate": ""
    },
    {
        "source": "Note that the best effort is made to ensure that the time waited is measured with a monotonic clock, and not affected by the changes made to the system time.",
        "suggest": "请注意，已尽最大努力确保使用单调时钟来测量等待的时间，并且不受系统时间更改的影响。",
        "translate": ""
    },
    {
        "source": "The returned boolean is `false` only if the timeout is known to have elapsed.",
        "suggest": "仅当已知超时已经过去时，返回的布尔值为 `false`。",
        "translate": ""
    },
    {
        "source": "Like [`wait`], the lock specified will be re-acquired when this function returns, regardless of whether the timeout elapsed or not.",
        "suggest": "与 [`wait`] 一样，无论是否经过超时，都将在此函数返回时重新获取指定的锁。",
        "translate": ""
    },
    {
        "source": "The semantics of this function are equivalent to [`wait`] except that the thread will be blocked for roughly no longer than `dur`.",
        "suggest": "该函数的语义与 [`wait`] 等效，除了线程被阻塞的时间不超过 `dur`。",
        "translate": ""
    },
    {
        "source": "This method should not be used for precise timing due to anomalies such as preemption or platform differences that may not cause the maximum amount of time waited to be precisely `dur`.",
        "suggest": "由于诸如抢占或平台差异之类的异常可能不会导致等待的最大时间精确为 `dur`，因此此方法不应用于精确的计时。",
        "translate": ""
    },
    {
        "source": "This function is susceptible to spurious wakeups.",
        "suggest": "此函数易受虚假唤醒的影响。",
        "translate": ""
    },
    {
        "source": "Additionally, it is typically desirable for the timeout to not exceed some duration in spite of spurious wakes, thus the sleep-duration is decremented by the amount slept.",
        "suggest": "另外，尽管有虚假的唤醒，但通常还是希望超时不超过某个持续时间，因此睡眠时间会减少睡眠量。",
        "translate": ""
    },
    {
        "source": "Alternatively, use the `wait_timeout_while` method to wait with a timeout while a predicate is true.",
        "suggest": "或者，在谓词为 true 时，使用 `wait_timeout_while` 方法等待超时。",
        "translate": ""
    },
    {
        "source": "The returned [`WaitTimeoutResult`] value indicates if the timeout is known to have elapsed.",
        "suggest": "返回的 [`WaitTimeoutResult`] 值指示是否已知超时。",
        "translate": ""
    },
    {
        "source": "The semantics of this function are equivalent to [`wait_while`] except that the thread will be blocked for roughly no longer than `dur`.",
        "suggest": "该函数的语义与 [`wait_while`] 等效，除了线程被阻塞的时间不超过 `dur`。",
        "translate": ""
    },
    {
        "source": "The returned [`WaitTimeoutResult`] value indicates if the timeout is known to have elapsed without the condition being met.",
        "suggest": "返回的 [`WaitTimeoutResult`] 值指示是否已知超时已经过去，而没有满足条件。",
        "translate": ""
    },
    {
        "source": "Like [`wait_while`], the lock specified will be re-acquired when this function returns, regardless of whether the timeout elapsed or not.",
        "suggest": "与 [`wait_while`] 一样，无论是否经过超时，都将在此函数返回时重新获取指定的锁。",
        "translate": ""
    },
    {
        "source": "Wakes up one blocked thread on this condvar.",
        "suggest": "在此 condvar 上唤醒一个阻塞的线程。",
        "translate": ""
    },
    {
        "source": "If there is a blocked thread on this condition variable, then it will be woken up from its call to [`wait`] or [`wait_timeout`].",
        "suggest": "如果此条件变量上有阻塞的线程，则它将从其调用中唤醒到 [`wait`] 或 [`wait_timeout`]。",
        "translate": ""
    },
    {
        "source": "Calls to `notify_one` are not buffered in any way.",
        "suggest": "不会以任何方式缓冲对 `notify_one` 的调用。",
        "translate": ""
    },
    {
        "source": "To wake up all threads, see [`notify_all`].",
        "suggest": "要唤醒所有线程，请参见 [`notify_all`]。",
        "translate": ""
    },
    {
        "source": "Wakes up all blocked threads on this condvar.",
        "suggest": "唤醒此 condvar 上的所有阻塞线程。",
        "translate": ""
    },
    {
        "source": "This method will ensure that any current waiters on the condition variable are awoken.",
        "suggest": "此方法将确保唤醒条件变量上的所有当前侍者。",
        "translate": ""
    },
    {
        "source": "Calls to `notify_all()` are not buffered in any way.",
        "suggest": "不会以任何方式缓冲对 `notify_all()` 的调用。",
        "translate": ""
    },
    {
        "source": "To wake up only one thread, see [`notify_one`].",
        "suggest": "要仅唤醒一个线程，请参见 [`notify_one`]。",
        "translate": ""
    },
    {
        "source": "Creates a `Condvar` which is ready to be waited on and notified.",
        "suggest": "创建一个 `Condvar`，可以等待它并通知它。",
        "translate": ""
    },
    {
        "source": "Useful synchronization primitives.",
        "suggest": "有用的同步原语。",
        "translate": ""
    },
    {
        "source": "The need for synchronization",
        "suggest": "需要同步",
        "translate": ""
    },
    {
        "source": "Conceptually, a Rust program is a series of operations which will be executed on a computer.",
        "suggest": "从概念上讲，Rust 程序是将在计算机上执行的一系列操作。",
        "translate": ""
    },
    {
        "source": "The timeline of events happening in the program is consistent with the order of the operations in the code.",
        "suggest": "程序中发生的事件的时间线与代码中操作的顺序一致。",
        "translate": ""
    },
    {
        "source": "Consider the following code, operating on some global static variables:",
        "suggest": "考虑下面的代码，对某些静态变量进行操作:",
        "translate": ""
    },
    {
        "source": "It appears as if some variables stored in memory are changed, an addition is performed, result is stored in `A` and the variable `C` is modified twice.",
        "suggest": "似乎存储在存储器中的某些变量已更改，执行了加法运算，结果存储在 `A` 中，并且变量 `C` 被修改了两次。",
        "translate": ""
    },
    {
        "source": "When only a single thread is involved, the results are as expected:",
        "suggest": "当仅涉及单个线程时，结果如预期的那样:",
        "translate": ""
    },
    {
        "source": "the line `7 4 4` gets printed.",
        "suggest": "`7 4 4` 行被打印。",
        "translate": ""
    },
    {
        "source": "As for what happens behind the scenes, when optimizations are enabled the final generated machine code might look very different from the code:",
        "suggest": "至于幕后发生的情况，启用优化后，最终生成的机器代码可能看起来与代码有很大不同:",
        "translate": ""
    },
    {
        "source": "The first store to `C` might be moved before the store to `A` or `B`, _as if_ we had written `C = 4; A = 3; B = 4`.",
        "suggest": "`C` 的第一个存储区可能在存储区移至 `A` 或 `B` 之前已被移至 _as if_。",
        "translate": ""
    },
    {
        "source": "Assignment of `A + B` to `A` might be removed, since the sum can be stored in a temporary location until it gets printed, with the global variable never getting updated.",
        "suggest": "可以删除 `A + B` 到 `A` 的分配，因为总和可以存储在一个临时位置，直到打印出来为止，并且变量永远不会更新。",
        "translate": ""
    },
    {
        "source": "The final result could be determined just by looking at the code at compile time, so [constant folding] might turn the whole block into a simple `println!(\"7 4 4\")`.",
        "suggest": "最终结果可以仅通过在编译时查看代码来确定，因此 [constant folding] 可能会将整个块变成一个简单的 `println!(\"7 4 4\")`。",
        "translate": ""
    },
    {
        "source": "The compiler is allowed to perform any combination of these optimizations, as long as the final optimized code, when executed, produces the same results as the one without optimizations.",
        "suggest": "只要最终的优化代码在执行时产生的结果与没有优化的结果相同，编译器就可以执行这些优化的任何组合。",
        "translate": ""
    },
    {
        "source": "Due to the [concurrency] involved in modern computers, assumptions about the program's execution order are often wrong.",
        "suggest": "由于现代计算机中使用了 [并发][concurrency]，因此有关程序执行顺序的假设通常是错误的。",
        "translate": ""
    },
    {
        "source": "Access to global variables can lead to nondeterministic results, **even if** compiler optimizations are disabled, and it is **still possible** to introduce synchronization bugs.",
        "suggest": "即使禁用了编译器优化，**访问变量变量也可能导致不确定的结果，** 仍然可能 ** 引入同步错误。",
        "translate": ""
    },
    {
        "source": "Note that thanks to Rust's safety guarantees, accessing global (static) variables requires `unsafe` code, assuming we don't use any of the synchronization primitives in this module.",
        "suggest": "请注意，由于 Rust 的安全保证，假设我们在此模块中未使用任何同步原语，则访问 (static) 变量需要 `unsafe` 代码。",
        "translate": ""
    },
    {
        "source": "Out-of-order execution",
        "suggest": "乱序执行",
        "translate": ""
    },
    {
        "source": "Instructions can execute in a different order from the one we define, due to various reasons:",
        "suggest": "由于多种原因，指令的执行顺序与我们定义的顺序可以不同:",
        "translate": ""
    },
    {
        "source": "The **compiler** reordering instructions: If the compiler can issue an instruction at an earlier point, it will try to do so.",
        "suggest": "**编译器** 重新排序指令: 如果编译器可以在较早的时候发出指令，它将尝试这样做。",
        "translate": ""
    },
    {
        "source": "For example, it might hoist memory loads at the top of a code block, so that the CPU can start [prefetching] the values from memory.",
        "suggest": "例如，它可能会在代码块的顶部提升内存负载，以便 CPU 可以从内存中启动 [预取][prefetching] 值。",
        "translate": ""
    },
    {
        "source": "In single-threaded scenarios, this can cause issues when writing signal handlers or certain kinds of low-level code.",
        "suggest": "在单线程方案中，这可能会在编写信号处理程序或某些类型的代码时引起问题。",
        "translate": ""
    },
    {
        "source": "Use [compiler fences] to prevent this reordering.",
        "suggest": "使用 [compiler fences] 防止此重新排序。",
        "translate": ""
    },
    {
        "source": "A **single processor** executing instructions [out-of-order]:",
        "suggest": "一个单处理器 ** 执行指令 [out-of-order]:",
        "translate": ""
    },
    {
        "source": "Modern CPUs are capable of [superscalar] execution, i.e., multiple instructions might be executing at the same time, even though the machine code describes a sequential process.",
        "suggest": "现代的 CPU 能够执行 [超标量][superscalar]，也就是说，多个指令可能同时执行，即使机器代码描述的是一个顺序过程。",
        "translate": ""
    },
    {
        "source": "This kind of reordering is handled transparently by the CPU.",
        "suggest": "这种重新排序由 CPU 透明地处理。",
        "translate": ""
    },
    {
        "source": "A **multiprocessor** system executing multiple hardware threads at the same time: In multi-threaded scenarios, you can use two kinds of primitives to deal with synchronization:",
        "suggest": "同时执行多个硬件线程的 **多处理器** 系统: 在多线程方案中，可以使用两种原语来处理同步:",
        "translate": ""
    },
    {
        "source": "to ensure memory accesses are made visible to other CPUs in the right order.",
        "suggest": "确保以正确的顺序使内存访问对其他 CPU 可见。",
        "translate": ""
    },
    {
        "source": "to ensure simultaneous access to the same memory location doesn't lead to undefined behavior.",
        "suggest": "确保同时访问同一内存位置不会导致未定义的行为。",
        "translate": ""
    },
    {
        "source": "Higher-level synchronization objects",
        "suggest": "更高级别的同步对象",
        "translate": ""
    },
    {
        "source": "Most of the low-level synchronization primitives are quite error-prone and inconvenient to use, which is why the standard library also exposes some higher-level synchronization objects.",
        "suggest": "大多数同步原语都非常容易出错，使用起来也不方便，这就是为什么标准库还公开了一些更高级别的同步对象的原因。",
        "translate": ""
    },
    {
        "source": "These abstractions can be built out of lower-level primitives.",
        "suggest": "这些抽象可以在较低级别的原语基础上构建。",
        "translate": ""
    },
    {
        "source": "For efficiency, the sync objects in the standard library are usually implemented with help from the operating system's kernel, which is able to reschedule the threads while they are blocked on acquiring a lock.",
        "suggest": "为了提高效率，标准库中的同步对象通常是在操作系统内核的帮助下实现的，该内核可以在线程被锁定而被阻塞时重新安排线程的时间。",
        "translate": ""
    },
    {
        "source": "The following is an overview of the available synchronization objects:",
        "suggest": "以下是可用的同步对象的概述:",
        "translate": ""
    },
    {
        "source": "Atomically Reference-Counted pointer, which can be used in multithreaded environments to prolong the lifetime of some data until all the threads have finished using it.",
        "suggest": "原子引用计数指针，可在多线程环境中使用该指针来延长某些数据的生命周期，直到所有线程都使用完它为止。",
        "translate": ""
    },
    {
        "source": "Ensures multiple threads will wait for each other to reach a point in the program, before continuing execution all together.",
        "suggest": "确保在继续一起执行之前，多个线程将彼此等待到达程序中的某个点。",
        "translate": ""
    },
    {
        "source": "Condition Variable, providing the ability to block a thread while waiting for an event to occur.",
        "suggest": "条件变量，提供了在等待事件发生时阻止线程的功能。",
        "translate": ""
    },
    {
        "source": "Multi-producer, single-consumer queues, used for message-based communication.",
        "suggest": "多生产者，单消费者队列，用于基于消息的通信。",
        "translate": ""
    },
    {
        "source": "Can provide a lightweight inter-thread synchronisation mechanism, at the cost of some extra memory.",
        "suggest": "可以提供轻量级的线程间同步机制，但要花一些额外的内存。",
        "translate": ""
    },
    {
        "source": "Mutual Exclusion mechanism, which ensures that at most one thread at a time is able to access some data.",
        "suggest": "互斥机制，该机制确保一次最多只有一个线程能够访问某些数据。",
        "translate": ""
    },
    {
        "source": "Used for thread-safe, one-time initialization of a global variable.",
        "suggest": "用于线程安全的变量的一次性初始化。",
        "translate": ""
    },
    {
        "source": "Provides a mutual exclusion mechanism which allows multiple readers at the same time, while allowing only one writer at a time.",
        "suggest": "提供一种互斥机制，该机制同时允许多个 readers，而一次仅允许一个 writer。",
        "translate": ""
    },
    {
        "source": "In some cases, this can be more efficient than a mutex.",
        "suggest": "在某些情况下，这可能比互斥锁更有效。",
        "translate": ""
    },
    {
        "source": "Generic support for building blocking abstractions.",
        "suggest": "泛型支持构建阻塞抽象。",
        "translate": ""
    },
    {
        "source": "Converts to an unsafe usize value.",
        "suggest": "转换为不安全的 usize 值。",
        "translate": ""
    },
    {
        "source": "Useful for storing in a pipe's state flag.",
        "suggest": "对于存储在管道的状态标志中很有用。",
        "translate": ""
    },
    {
        "source": "Converts from an unsafe usize value.",
        "suggest": "从不安全的 usize 值转换。",
        "translate": ""
    },
    {
        "source": "Useful for retrieving a pipe's state flag.",
        "suggest": "对于检索管道的状态标志很有用。",
        "translate": ""
    },
    {
        "source": "Returns `true` if we wake up normally.",
        "suggest": "如果正常唤醒，则返回 `true`。",
        "translate": ""
    },
    {
        "source": "Create a simple streaming channel",
        "suggest": "创建一个简单的流媒体通道",
        "translate": ""
    },
    {
        "source": "Create a shared channel that can be sent along from many threads where tx is the sending half (tx for transmission), and rx is the receiving half (rx for receiving).",
        "suggest": "创建一个可以从许多线程一起发送的共享通道，其中 tx 是发送一半 (用于传输的 tx)，rx 是接收一半 (用于接收的 rx)。",
        "translate": ""
    },
    {
        "source": "The call to recv() will return an error because the channel has already hung up (or been deallocated)",
        "suggest": "调用 recv() 将返回错误，因为通道已挂起 (或已释放)",
        "translate": ""
    },
    {
        "source": "This will wait for the parent thread to start receiving",
        "suggest": "这将等待父线程开始接收",
        "translate": ""
    },
    {
        "source": "block for two seconds",
        "suggest": "阻塞两秒钟",
        "translate": ""
    },
    {
        "source": "Received immediately",
        "suggest": "立即收到",
        "translate": ""
    },
    {
        "source": "Received after 2 seconds",
        "suggest": "2 秒后收到",
        "translate": ""
    },
    {
        "source": "Nothing is in the buffer yet",
        "suggest": "缓冲区什么都没有了",
        "translate": ""
    },
    {
        "source": "First thread owns sender",
        "suggest": "第一个线程拥有发送者",
        "translate": ""
    },
    {
        "source": "Second thread owns sender2",
        "suggest": "第二个线程拥有 sender2",
        "translate": ""
    },
    {
        "source": "Create a sync_channel with buffer size 2",
        "suggest": "创建一个缓冲区大小为 2 的 sync_channel",
        "translate": ""
    },
    {
        "source": "First thread owns sync_sender",
        "suggest": "第一个线程拥有 sync_sender",
        "translate": ""
    },
    {
        "source": "Second thread owns sync_sender2",
        "suggest": "第二个线程拥有 sync_sender2",
        "translate": ""
    },
    {
        "source": "thread will now block since the buffer is full",
        "suggest": "由于缓冲区已满，线程现在将阻塞",
        "translate": ""
    },
    {
        "source": "will be printed now",
        "suggest": "现在将打印",
        "translate": ""
    },
    {
        "source": "Spawn off an expensive computation",
        "suggest": "Spawn 关闭昂贵的计算",
        "translate": ""
    },
    {
        "source": "Do some useful work for awhile",
        "suggest": "暂时做一些有用的工作",
        "translate": ""
    },
    {
        "source": "Let's see what that answer was",
        "suggest": "让我们看看答案是什么",
        "translate": ""
    },
    {
        "source": "this returns immediately",
        "suggest": "这立即返回",
        "translate": ""
    },
    {
        "source": "this will block until the previous message has been received",
        "suggest": "这将阻塞，直到收到上一条消息为止",
        "translate": ""
    },
    {
        "source": "This send is always successful",
        "suggest": "此发送始终成功",
        "translate": ""
    },
    {
        "source": "This send will fail because the receiver is gone",
        "suggest": "由于接收者不见了，因此发送失败",
        "translate": ""
    },
    {
        "source": "Create a rendezvous sync_channel with buffer size 0",
        "suggest": "创建一个缓冲区大小为 0 的集合点 sync_channel",
        "translate": ""
    },
    {
        "source": "Thread is now blocked until the message is received",
        "suggest": "现在线程被阻塞，直到收到消息为止",
        "translate": ""
    },
    {
        "source": "Create a sync_channel with buffer size 1",
        "suggest": "创建一个缓冲区大小为 1 的 sync_channel",
        "translate": ""
    },
    {
        "source": "Thread blocked",
        "suggest": "线程被阻塞",
        "translate": ""
    },
    {
        "source": "This will return an error and send no message if the buffer is full",
        "suggest": "如果缓冲区已满，这将返回错误并且不发送任何消息",
        "translate": ""
    },
    {
        "source": "Third message may have never been sent",
        "suggest": "第三条消息可能从未发送过",
        "translate": ""
    },
    {
        "source": "wait for the thread to join so we ensure the sender is dropped",
        "suggest": "等待线程加入，因此我们确保发送者已被丢弃",
        "translate": ""
    },
    {
        "source": "nothing is in the buffer yet",
        "suggest": "缓冲区中还没有任何东西",
        "translate": ""
    },
    {
        "source": "Multi-producer, single-consumer FIFO queue communication primitives.",
        "suggest": "多生产者，单消费者 FIFO 队列通信原语。",
        "translate": ""
    },
    {
        "source": "This module provides message-based communication over channels, concretely defined among three types:",
        "suggest": "该模块通过通道提供基于消息的通信，具体定义为以下三种类型:",
        "translate": ""
    },
    {
        "source": "A [`Sender`] or [`SyncSender`] is used to send data to a [`Receiver`].",
        "suggest": "[`Sender`] 或 [`SyncSender`] 用于将数据发送到 [`Receiver`]。",
        "translate": ""
    },
    {
        "source": "Both senders are clone-able (multi-producer) such that many threads can send simultaneously to one receiver (single-consumer).",
        "suggest": "两个发送者都是可克隆的 (multi-producer)，因此许多线程可以同时发送到一个接收者 (single-consumer)。",
        "translate": ""
    },
    {
        "source": "These channels come in two flavors:",
        "suggest": "这些通道有两种口味:",
        "translate": ""
    },
    {
        "source": "An asynchronous, infinitely buffered channel.",
        "suggest": "异步，无限缓冲的通道。",
        "translate": ""
    },
    {
        "source": "The [`channel`] function will return a `(Sender, Receiver)` tuple where all sends will be **asynchronous** (they never block).",
        "suggest": "[`channel`] 函数将返回 `(Sender, Receiver)` 元组，其中所有发送都是异步的 (它们从不阻塞)。",
        "translate": ""
    },
    {
        "source": "The channel conceptually has an infinite buffer.",
        "suggest": "通道在概念上具有无限的缓冲区。",
        "translate": ""
    },
    {
        "source": "A synchronous, bounded channel.",
        "suggest": "同步的有界通道。",
        "translate": ""
    },
    {
        "source": "The [`sync_channel`] function will return a `(SyncSender, Receiver)` tuple where the storage for pending messages is a pre-allocated buffer of a fixed size.",
        "suggest": "[`sync_channel`] 函数将返回 `(SyncSender, Receiver)` 元组，其中待处理消息的存储是固定大小的预分配缓冲区。",
        "translate": ""
    },
    {
        "source": "All sends will be **synchronous** by blocking until there is buffer space available.",
        "suggest": "所有的发送都将被阻塞，直到有可用的缓冲区空间。",
        "translate": ""
    },
    {
        "source": "Note that a bound of 0 is allowed, causing the channel to become a \"rendezvous\" channel where each sender atomically hands off a message to a receiver.",
        "suggest": "请注意，允许的界限为 0，从而使通道成为 \"rendezvous\" 通道，每个发送者在该通道上原子地将消息传递给接收者。",
        "translate": ""
    },
    {
        "source": "The send and receive operations on channels will all return a [`Result`] indicating whether the operation succeeded or not.",
        "suggest": "通道上的发送和接收操作都将返回 [`Result`]，指示该操作是否成功。",
        "translate": ""
    },
    {
        "source": "An unsuccessful operation is normally indicative of the other half of a channel having \"hung up\" by being dropped in its corresponding thread.",
        "suggest": "不成功的操作通常通过将其丢弃在相应线程中来指示具有 \"hung up\" 的通道的另一半。",
        "translate": ""
    },
    {
        "source": "Once half of a channel has been deallocated, most operations can no longer continue to make progress, so [`Err`] will be returned.",
        "suggest": "释放通道的一半后，大多数操作将不再继续进行，因此将返回 [`Err`]。",
        "translate": ""
    },
    {
        "source": "Many applications will continue to [`unwrap`] the results returned from this module, instigating a propagation of failure among threads if one unexpectedly dies.",
        "suggest": "许多应用程序将继续对该模块返回的结果进行 [`unwrap`] 处理，如果一个线程意外死亡，则会导致线程之间传播失败。",
        "translate": ""
    },
    {
        "source": "Shared usage:",
        "suggest": "共享用法:",
        "translate": ""
    },
    {
        "source": "Propagating panics:",
        "suggest": "传播 panics:",
        "translate": ""
    },
    {
        "source": "Synchronous channels:",
        "suggest": "同步通道:",
        "translate": ""
    },
    {
        "source": "A description of how Rust's channel implementation works",
        "suggest": "Rust 的通道实现的工作方式的描述",
        "translate": ""
    },
    {
        "source": "Channels are supposed to be the basic building block for all other concurrent primitives that are used in Rust.",
        "suggest": "通道应该是 Rust 中使用的所有其他并发原语的基本构建块。",
        "translate": ""
    },
    {
        "source": "As a result, the channel type needs to be highly optimized, flexible, and broad enough for use everywhere.",
        "suggest": "因此，通道类型需要高度优化，灵活并且足够广泛以在任何地方使用。",
        "translate": ""
    },
    {
        "source": "The choice of implementation of all channels is to be built on lock-free data structures.",
        "suggest": "所有通道的实现选择都将基于无锁数据结构。",
        "translate": ""
    },
    {
        "source": "The channels themselves are then consequently also lock-free data structures.",
        "suggest": "因此，通道本身也是无锁数据结构。",
        "translate": ""
    },
    {
        "source": "As always with lock-free code, this is a very \"here be dragons\" territory, especially because I'm unaware of any academic papers that have gone into great length about channels of these flavors.",
        "suggest": "与使用无锁代码一样，这是一个非常 \"here be dragons\" 的领域，尤其是因为我不知道任何有关这些类型的通道的学术论文都花了很多篇幅。",
        "translate": ""
    },
    {
        "source": "Flavors of channels",
        "suggest": "通道的味道",
        "translate": ""
    },
    {
        "source": "From the perspective of a consumer of this library, there is only one flavor of channel.",
        "suggest": "从该库的使用者的角度来看，只有一种味道的通道。",
        "translate": ""
    },
    {
        "source": "This channel can be used as a stream and cloned to allow multiple senders.",
        "suggest": "此通道可以用作流，并可以克隆以允许多个发送者。",
        "translate": ""
    },
    {
        "source": "Under the hood, however, there are actually three flavors of channels in play.",
        "suggest": "然而，在引擎盖下，实际上有三种口味的通道在起作用。",
        "translate": ""
    },
    {
        "source": "these channels are highly optimized for the one-send use case.",
        "suggest": "这些通道针对单发送用例进行了高度优化。",
        "translate": ""
    },
    {
        "source": "They contain as few atomics as possible and involve one and exactly one allocation.",
        "suggest": "它们包含尽可能少的原子，并且涉及一个且恰好是一个分配。",
        "translate": ""
    },
    {
        "source": "Streams - these channels are optimized for the non-shared use case.",
        "suggest": "流 - 这些通道针对非共享用例进行了优化。",
        "translate": ""
    },
    {
        "source": "They use a different concurrent queue that is more tailored for this use case.",
        "suggest": "他们使用了一个更适合此用例的不同并发队列。",
        "translate": ""
    },
    {
        "source": "The initial allocation of this flavor of channel is not optimized.",
        "suggest": "通道的这种风格的初始分配未优化。",
        "translate": ""
    },
    {
        "source": "Shared - this is the most general form of channel that this module offers, a channel with multiple senders.",
        "suggest": "共享 - 这是此模块提供的最通用的通道形式，即具有多个发送者的通道。",
        "translate": ""
    },
    {
        "source": "This type is as optimized as it can be, but the previous two types mentioned are much faster for their use-cases.",
        "suggest": "这种类型已尽可能地进行了优化，但是前面提到的两种类型在其用例方面要快得多。",
        "translate": ""
    },
    {
        "source": "Concurrent queues",
        "suggest": "并发队列",
        "translate": ""
    },
    {
        "source": "The basic idea of Rust's Sender/Receiver types is that send() never blocks, but recv() obviously blocks.",
        "suggest": "Rust 的 Sender/Receiver 类型的基本思想是 send() 永远不会阻塞，但 recv() 显然会阻塞。",
        "translate": ""
    },
    {
        "source": "This means that under the hood there must be some shared and concurrent queue holding all of the actual data.",
        "suggest": "这意味着在后台必须有一些共享和并发队列保存所有实际数据。",
        "translate": ""
    },
    {
        "source": "With two flavors of channels, two flavors of queues are also used.",
        "suggest": "对于两种通道，还使用两种队列。",
        "translate": ""
    },
    {
        "source": "We have chosen to use queues from a well-known author that are abbreviated as SPSC and MPSC (single producer, single consumer and multiple producer, single consumer).",
        "suggest": "我们选择使用知名作者 (简称为 SPSC 和 MPSC) 的队列 (单生产者，单一消费者，多生产者，单一消费者)。",
        "translate": ""
    },
    {
        "source": "SPSC queues are used for streams while MPSC queues are used for shared channels.",
        "suggest": "SPSC 队列用于流，而 MPSC 队列用于共享通道。",
        "translate": ""
    },
    {
        "source": "SPSC optimizations",
        "suggest": "SPSC 优化",
        "translate": ""
    },
    {
        "source": "The SPSC queue found online is essentially a linked list of nodes where one half of the nodes are the \"queue of data\" and the other half of nodes are a cache of unused nodes.",
        "suggest": "在线找到的 SPSC 队列实质上是节点的链表，其中一半节点是 \"queue of data\"，另一半节点是未使用节点的缓存。",
        "translate": ""
    },
    {
        "source": "The unused nodes are used such that an allocation is not required on every push() and a free doesn't need to happen on every pop().",
        "suggest": "使用未使用的节点，这样就不需要在每个 push() 上进行分配，并且不需要在每个 pop() 上进行分配。",
        "translate": ""
    },
    {
        "source": "As found online, however, the cache of nodes is of an infinite size.",
        "suggest": "然而，正如在网上发现的那样，节点的缓存是无限大的。",
        "translate": ""
    },
    {
        "source": "This means that if a channel at one point in its life had 50k items in the queue, then the queue will always have the capacity for 50k items.",
        "suggest": "这意味着，如果某个通道在其生命周期的某一点上有 50k 项，那么该队列将始终具有 50k 项的容量。",
        "translate": ""
    },
    {
        "source": "I believed that this was an unnecessary limitation of the implementation, so I have altered the queue to optionally have a bound on the cache size.",
        "suggest": "我认为这是对实现的不必要限制，因此我更改了队列以有选择地对缓存大小进行限制。",
        "translate": ""
    },
    {
        "source": "By default, streams will have an unbounded SPSC queue with a small-ish cache size.",
        "suggest": "默认情况下，流将具有无限制的 SPSC 队列，且缓存大小较小。",
        "translate": ""
    },
    {
        "source": "The hope is that the cache is still large enough to have very fast send() operations while not too large such that millions of channels can coexist at once.",
        "suggest": "希望缓存仍然足够大，可以进行非常快速的 send() 操作，而又不要太大，以至于数以百万计的通道可以一次共存。",
        "translate": ""
    },
    {
        "source": "MPSC optimizations",
        "suggest": "MPSC 优化",
        "translate": ""
    },
    {
        "source": "Right now the MPSC queue has not been optimized.",
        "suggest": "目前，MPSC 队列尚未优化。",
        "translate": ""
    },
    {
        "source": "Like the SPSC queue, it uses a linked list under the hood to earn its unboundedness, but I have not put forth much effort into having a cache of nodes similar to the SPSC queue.",
        "suggest": "像 SPSC 队列一样，它使用引擎盖下的链表来获取其无限制的内容，但是我并没有花太多精力来使节点的缓存类似于 SPSC 队列。",
        "translate": ""
    },
    {
        "source": "For now, I believe that this is \"ok\" because shared channels are not the most common type, but soon we may wish to revisit this queue choice and determine another candidate for backend storage of shared channels.",
        "suggest": "现在，我认为这是 \"ok\"，因为共享通道不是最常见的类型，但是不久之后，我们不妨重新访问此队列选择，并确定另一个用于共享通道的后端存储的候选对象。",
        "translate": ""
    },
    {
        "source": "Overview of the Implementation",
        "suggest": "实现概述",
        "translate": ""
    },
    {
        "source": "Now that there's a little background on the concurrent queues used, it's worth going into much more detail about the channels themselves.",
        "suggest": "既然使用的并发队列有一些背景知识，那么有必要进一步详细介绍通道本身。",
        "translate": ""
    },
    {
        "source": "The basic pseudocode for a send/recv are:",
        "suggest": "send/recv 的基本伪代码为:",
        "translate": ""
    },
    {
        "source": "As mentioned before, there are no locks in this implementation, only atomic instructions are used.",
        "suggest": "如前所述，此实现中没有锁，仅使用原子指令。",
        "translate": ""
    },
    {
        "source": "The internal atomic counter",
        "suggest": "内部原子计数器",
        "translate": ""
    },
    {
        "source": "Every channel has a shared counter with each half to keep track of the size of the queue.",
        "suggest": "每个通道都有一个共享的计数器，每个通道都有一个计数器，以跟踪队列的大小。",
        "translate": ""
    },
    {
        "source": "This counter is used to abort descheduling by the receiver and to know when to wake up on the sending side.",
        "suggest": "该计数器用于接收方终止调度，并知道何时在发送方唤醒。",
        "translate": ""
    },
    {
        "source": "As seen in the pseudocode, senders will increment this count and receivers will decrement the count.",
        "suggest": "从伪代码中可以看出，发送者将增加该计数，接收者将减少该计数。",
        "translate": ""
    },
    {
        "source": "The theory behind this is that if a sender sees a",
        "suggest": "其背后的理论是，如果发送者看到",
        "translate": ""
    },
    {
        "source": "count, it will wake up the receiver, and if the receiver sees a 1+ count, then it doesn't need to block.",
        "suggest": "计数，它将唤醒接收者，并且如果接收者看到 1 + 计数，则不需要阻塞。",
        "translate": ""
    },
    {
        "source": "The recv() method has a beginning call to pop(), and if successful, it needs to decrement the count.",
        "suggest": "recv() 方法从 pop() 开始调用，如果成功，则需要减少计数。",
        "translate": ""
    },
    {
        "source": "It is a crucial implementation detail that this decrement does *not* happen to the shared counter.",
        "suggest": "这是一个至关重要的实现细节，此减量不会 * 发生在共享计数器上。",
        "translate": ""
    },
    {
        "source": "If this were the case, then it would be possible for the counter to be very negative when there were no receivers waiting, in which case the senders would have to determine when it was actually appropriate to wake up a receiver.",
        "suggest": "如果是这样，那么在没有等待接收者的情况下，计数器可能会变得非常负数，在这种情况下，发送者将不得不确定何时真正适合唤醒接收者。",
        "translate": ""
    },
    {
        "source": "Instead, the \"steal count\" is kept track of separately (not atomically because it's only used by receivers), and then the decrement() call when descheduling will lump in all of the recent steals into one large decrement.",
        "suggest": "取而代之的是，\"steal count\" 被分开跟踪 (不是原子地，因为它仅由接收者使用)，然后在调度时将 decrement() 调用将最近的所有窃取都归为一个大的递减。",
        "translate": ""
    },
    {
        "source": "The implication of this is that if a sender sees a -1 count, then there's guaranteed to be a waiter waiting!",
        "suggest": "这意味着如果发送方看到 -1 计数，那么肯定有一个等待者在等!",
        "translate": ""
    },
    {
        "source": "Native Implementation",
        "suggest": "原生实现",
        "translate": ""
    },
    {
        "source": "A major goal of these channels is to work seamlessly on and off the runtime.",
        "suggest": "这些通道的主要目标是在运行时上上下下无缝工作。",
        "translate": ""
    },
    {
        "source": "All of the previous race conditions have been worded in terms of scheduler-isms (which is obviously not available without the runtime).",
        "suggest": "以前的所有竞争状态都用调度程序表述 (显然，没有运行时就无法使用)。",
        "translate": ""
    },
    {
        "source": "For now, native usage of channels (off the runtime) will fall back onto mutexes/cond vars for descheduling/atomic decisions.",
        "suggest": "目前，通道的原生用法 (在运行时关闭) 将回退到 mutexes/cond 变量上进行 descheduling/atomic 决策。",
        "translate": ""
    },
    {
        "source": "The no-contention path is still entirely lock-free, the \"deschedule\" blocks above are surrounded by a mutex and the \"wakeup\" blocks involve grabbing a mutex and signaling on a condition variable.",
        "suggest": "无争用路径仍然是完全无锁的，上面的 \"deschedule\" 块被互斥锁包围，而 \"wakeup\" 块涉及获取互斥锁并在条件变量上发出信号。",
        "translate": ""
    },
    {
        "source": "Being able to support selection over channels has greatly influenced this design, and not only does selection need to work inside the runtime, but also outside the runtime.",
        "suggest": "能够支持通过通道进行选择极大地影响了该设计，选择不仅需要在运行时内部进行，而且还需要在运行时外部进行。",
        "translate": ""
    },
    {
        "source": "The implementation is fairly straightforward.",
        "suggest": "该实现非常简单。",
        "translate": ""
    },
    {
        "source": "The goal of select() is not to return some data, but only to return which channel can receive data without blocking.",
        "suggest": "select() 的目标不是返回某些数据，而只是返回哪个通道可以无阻塞地接收数据。",
        "translate": ""
    },
    {
        "source": "The implementation is essentially the entire blocking procedure followed by an increment as soon as its woken up.",
        "suggest": "该实现实质上是整个阻塞进程，随后在其唤醒后立即进行递增。",
        "translate": ""
    },
    {
        "source": "The cancellation procedure involves an increment and swapping out of to_wake to acquire ownership of the thread to unblock.",
        "suggest": "取消进程涉及一个增量，并交换出 to_wake 来获取要解锁的线程的所有权。",
        "translate": ""
    },
    {
        "source": "Sadly this current implementation requires multiple allocations, so I have seen the throughput of select() be much worse than it should be.",
        "suggest": "可悲的是，当前的实现需要多个分配，因此我已经看到 select() 的吞吐量比应该的要差得多。",
        "translate": ""
    },
    {
        "source": "I do not believe that there is anything fundamental that needs to change about these channels, however, in order to support a more efficient select().",
        "suggest": "我认为，为了支持更高效的 select()，不需要对这些通道进行任何根本性的更改。",
        "translate": ""
    },
    {
        "source": "Select is now removed, so these factors are ready to be cleaned up!",
        "suggest": "Select 现在已删除，因此可以清除这些因素!",
        "translate": ""
    },
    {
        "source": "And now that you've seen all the races that I found and attempted to fix, here's the code for you to find some more!",
        "suggest": "现在，您已经看到了我发现并尝试解决的所有问题，下面是为您找到更多代码的代码!",
        "translate": ""
    },
    {
        "source": "The receiving half of Rust's [`channel`] (or [`sync_channel`]) type.",
        "suggest": "Rust 的 [`channel`] (或 [`sync_channel`]) 类型的接收一半。",
        "translate": ""
    },
    {
        "source": "This half can only be owned by one thread.",
        "suggest": "这一半只能由一个线程拥有。",
        "translate": ""
    },
    {
        "source": "Messages sent to the channel can be retrieved using [`recv`].",
        "suggest": "可以使用 [`recv`] 检索发送到通道的消息。",
        "translate": ""
    },
    {
        "source": "The receiver port can be sent from place to place, so long as it is not used to receive non-sendable things.",
        "suggest": "接收者端口可以在任何地方发送，只要它不用于接收不可发送的东西即可。",
        "translate": ""
    },
    {
        "source": "An iterator over messages on a [`Receiver`], created by [`iter`].",
        "suggest": "[`iter`] 在 [`Receiver`] 上创建的消息上的迭代器。",
        "translate": ""
    },
    {
        "source": "This iterator will block whenever [`next`] is called, waiting for a new message, and [`None`] will be returned when the corresponding channel has hung up.",
        "suggest": "每当调用 [`next`]，等待新消息时，此迭代器将阻塞，并且在相应的通道挂起时，将返回 [`None`]。",
        "translate": ""
    },
    {
        "source": "An iterator that attempts to yield all pending values for a [`Receiver`], created by [`try_iter`].",
        "suggest": "尝试产生 [`try_iter`] 创建的 [`Receiver`] 的所有挂起值的迭代器。",
        "translate": ""
    },
    {
        "source": "will be returned when there are no pending values remaining or if the corresponding channel has hung up.",
        "suggest": "当没有剩余的待处理值或相应的通道已挂断时，将返回。",
        "translate": ""
    },
    {
        "source": "This iterator will never block the caller in order to wait for data to become available.",
        "suggest": "该迭代器永远不会阻塞调用方，以等待数据可用。",
        "translate": ""
    },
    {
        "source": "Instead, it will return [`None`].",
        "suggest": "相反，它将返回 [`None`]。",
        "translate": ""
    },
    {
        "source": "An owning iterator over messages on a [`Receiver`], created by **Receiver::into_iter**.",
        "suggest": "[`Receiver`] 上由消息接收者拥有的迭代器，该迭代器由 **接收者::into_iter** 创建。",
        "translate": ""
    },
    {
        "source": "This iterator will block whenever [`next`] is called, waiting for a new message, and [`None`] will be returned if the corresponding channel has hung up.",
        "suggest": "每当调用 [`next`]，等待新消息时，此迭代器将阻塞，如果相应的通道已挂起，则将返回 [`None`]。",
        "translate": ""
    },
    {
        "source": "The sending-half of Rust's asynchronous [`channel`] type.",
        "suggest": "Rust 的异步 [`channel`] 类型的发送一半。",
        "translate": ""
    },
    {
        "source": "This half can only be owned by one thread, but it can be cloned to send to other threads.",
        "suggest": "这一半只能由一个线程拥有，但可以克隆以发送给其他线程。",
        "translate": ""
    },
    {
        "source": "Messages can be sent through this channel with [`send`].",
        "suggest": "可以使用 [`send`] 通过此通道发送消息。",
        "translate": ""
    },
    {
        "source": "The send port can be sent from place to place, so long as it is not used to send non-sendable things.",
        "suggest": "只要不用于发送不可发送的东西，发送端口就可以从一个地方发送到另一个地方。",
        "translate": ""
    },
    {
        "source": "The sending-half of Rust's synchronous [`sync_channel`] type.",
        "suggest": "Rust 的同步 [`sync_channel`] 类型的发送一半。",
        "translate": ""
    },
    {
        "source": "Messages can be sent through this channel with [`send`] or [`try_send`].",
        "suggest": "可以使用 [`send`] 或 [`try_send`] 通过此通道发送消息。",
        "translate": ""
    },
    {
        "source": "will block if there is no space in the internal buffer.",
        "suggest": "如果内部缓冲区中没有空间，则将阻塞。",
        "translate": ""
    },
    {
        "source": "An error returned from the [`Sender::send`] or [`SyncSender::send`] function on **channel**s.",
        "suggest": "X **X** 上的 [`Sender::send`] 或 [`SyncSender::send`] 函数返回错误。",
        "translate": ""
    },
    {
        "source": "A **send** operation can only fail if the receiving end of a channel is disconnected, implying that the data could never be received.",
        "suggest": "仅当通道的接收端断开连接时，发送操作才会失败，这意味着永远无法接收到数据。",
        "translate": ""
    },
    {
        "source": "The error contains the data being sent as a payload so it can be recovered.",
        "suggest": "错误包含正在作为有效负载发送的数据，因此可以对其进行恢复。",
        "translate": ""
    },
    {
        "source": "An error returned from the [`recv`] function on a [`Receiver`].",
        "suggest": "[`Receiver`] 上的 [`recv`] 函数返回错误。",
        "translate": ""
    },
    {
        "source": "The [`recv`] operation can only fail if the sending half of a [`channel`] (or [`sync_channel`]) is disconnected, implying that no further messages will ever be received.",
        "suggest": "仅当 [`channel`] (或 [`sync_channel`]) 的发送半部断开连接时，[`recv`] 操作才会失败，这意味着将再也不会收到任何消息。",
        "translate": ""
    },
    {
        "source": "This enumeration is the list of the possible reasons that [`try_recv`] could not return data when called.",
        "suggest": "该枚举是 [`try_recv`] 在调用时无法返回数据的可能原因的列表。",
        "translate": ""
    },
    {
        "source": "This can occur with both a [`channel`] and a [`sync_channel`].",
        "suggest": "[`channel`] 和 [`sync_channel`] 都可能发生这种情况。",
        "translate": ""
    },
    {
        "source": "This **channel** is currently empty, but the **Sender**(s) have not yet disconnected, so data may yet become available.",
        "suggest": "该 **通道** 当前为空，但 **发送器** 尚未断开连接，因此数据可能仍可用。",
        "translate": ""
    },
    {
        "source": "The **channel**'s sending half has become disconnected, and there will never be any more data received on it.",
        "suggest": "**通道** 的发送一半已断开，并且永远不会再收到任何数据。",
        "translate": ""
    },
    {
        "source": "This enumeration is the list of possible errors that made [`recv_timeout`] unable to return data when called.",
        "suggest": "该枚举是导致 [`recv_timeout`] 在调用时无法返回数据的可能错误的列表。",
        "translate": ""
    },
    {
        "source": "This enumeration is the list of the possible error outcomes for the [`try_send`] method.",
        "suggest": "此枚举是 [`try_send`] 方法可能出现的错误结果的列表。",
        "translate": ""
    },
    {
        "source": "The data could not be sent on the [`sync_channel`] because it would require that the callee block to send the data.",
        "suggest": "无法在 [`sync_channel`] 上发送数据，因为这将要求被调用方块发送数据。",
        "translate": ""
    },
    {
        "source": "If this is a buffered channel, then the buffer is full at this time.",
        "suggest": "如果这是一个缓冲的通道，则此时缓冲区已满。",
        "translate": ""
    },
    {
        "source": "If this is not a buffered channel, then there is no [`Receiver`] available to acquire the data.",
        "suggest": "如果这不是缓冲的通道，则没有 [`Receiver`] 可用于获取数据。",
        "translate": ""
    },
    {
        "source": "This [`sync_channel`]'s receiving half has disconnected, so the data could not be sent.",
        "suggest": "此 [`sync_channel`] 的接收部分已断开连接，因此无法发送数据。",
        "translate": ""
    },
    {
        "source": "The data is returned back to the callee in this case.",
        "suggest": "在这种情况下，数据将返回给被调用方。",
        "translate": ""
    },
    {
        "source": "Creates a new asynchronous channel, returning the sender/receiver halves.",
        "suggest": "创建一个新的异步通道，返回 sender/receiver 一半。",
        "translate": ""
    },
    {
        "source": "All data sent on the [`Sender`] will become available on the [`Receiver`] in the same order as it was sent, and no [`send`] will block the calling thread (this channel has an \"infinite buffer\", unlike [`sync_channel`], which will block after its buffer limit is reached).",
        "suggest": "在 [`Sender`] 上发送的所有数据将以与发送时相同的顺序在 [`Receiver`] 上可用，并且没有 [`send`] 将阻塞调用线程 (此通道具有一个 \"infinite buffer\"，与 [`sync_channel`] 不同，它将在达到其缓冲区限制后阻塞)。",
        "translate": ""
    },
    {
        "source": "will block until a message is available.",
        "suggest": "将阻止，直到有消息可用为止。",
        "translate": ""
    },
    {
        "source": "The [`Sender`] can be cloned to [`send`] to the same channel multiple times, but only one [`Receiver`] is supported.",
        "suggest": "[`Sender`] 可以多次克隆到 [`send`] 到同一通道，但是仅支持一个 [`Receiver`]。",
        "translate": ""
    },
    {
        "source": "If the [`Receiver`] is disconnected while trying to [`send`] with the [`Sender`], the [`send`] method will return a [`SendError`].",
        "suggest": "如果在尝试使用 [`Sender`] 进行 [`send`] 时断开 [`Receiver`] 的连接，则 [`send`] 方法将返回 [`SendError`]。",
        "translate": ""
    },
    {
        "source": "Similarly, if the [`Sender`] is disconnected while trying to [`recv`], the [`recv`] method will return a [`RecvError`].",
        "suggest": "同样，如果在尝试 [`recv`] 时断开 [`Sender`] 的连接，则 [`recv`] 方法将返回 [`RecvError`]。",
        "translate": ""
    },
    {
        "source": "Creates a new synchronous, bounded channel.",
        "suggest": "创建一个新的同步有界通道。",
        "translate": ""
    },
    {
        "source": "All data sent on the [`SyncSender`] will become available on the [`Receiver`] in the same order as it was sent.",
        "suggest": "[`SyncSender`] 上发送的所有数据将以与发送相同的顺序在 [`Receiver`] 上可用。",
        "translate": ""
    },
    {
        "source": "Like asynchronous [`channel`]s, the [`Receiver`] will block until a message becomes available.",
        "suggest": "像异步 [`channel`] 一样，[`Receiver`] 将阻塞直到消息可用为止。",
        "translate": ""
    },
    {
        "source": "differs greatly in the semantics of the sender, however.",
        "suggest": "但是，发送者的语义差异很大。",
        "translate": ""
    },
    {
        "source": "This channel has an internal buffer on which messages will be queued.",
        "suggest": "该通道具有内部缓冲区，消息将在该缓冲区上排队。",
        "translate": ""
    },
    {
        "source": "specifies the buffer size.",
        "suggest": "指定缓冲区大小。",
        "translate": ""
    },
    {
        "source": "When the internal buffer becomes full, future sends will *block* waiting for the buffer to open up.",
        "suggest": "当内部缓冲区已满时，future 将发送 *block*，等待缓冲区打开。",
        "translate": ""
    },
    {
        "source": "Note that a buffer size of 0 is valid, in which case this becomes \"rendezvous channel\" where each [`send`] will not return until a [`recv`] is paired with it.",
        "suggest": "请注意，缓冲区大小为 0 是有效的，在这种情况下，它变为 \"rendezvous channel\"，其中每个 [`send`] 在与 [`recv`] 配对之前不会返回。",
        "translate": ""
    },
    {
        "source": "The [`SyncSender`] can be cloned to [`send`] to the same channel multiple times, but only one [`Receiver`] is supported.",
        "suggest": "[`SyncSender`] 可以多次克隆到 [`send`] 到同一通道，但是仅支持一个 [`Receiver`]。",
        "translate": ""
    },
    {
        "source": "Like asynchronous channels, if the [`Receiver`] is disconnected while trying to [`send`] with the [`SyncSender`], the [`send`] method will return a [`SendError`].",
        "suggest": "与异步通道一样，如果在尝试使用 [`SyncSender`] 进行 [`send`] 时断开 [`Receiver`]，则 [`send`] 方法将返回 [`SendError`]。",
        "translate": ""
    },
    {
        "source": "Similarly, If the [`SyncSender`] is disconnected while trying to [`recv`], the [`recv`] method will return a [`RecvError`].",
        "suggest": "同样，如果在尝试 [`recv`] 时断开 [`SyncSender`] 的连接，则 [`recv`] 方法将返回 [`RecvError`]。",
        "translate": ""
    },
    {
        "source": "Attempts to send a value on this channel, returning it back if it could not be sent.",
        "suggest": "尝试在此通道上发送值，如果无法发送，则将其返回。",
        "translate": ""
    },
    {
        "source": "A successful send occurs when it is determined that the other end of the channel has not hung up already.",
        "suggest": "当确定通道的另一端尚未挂断时，发送成功。",
        "translate": ""
    },
    {
        "source": "An unsuccessful send would be one where the corresponding receiver has already been deallocated.",
        "suggest": "不成功的发送将是相应的接收者已被重新分配的发送。",
        "translate": ""
    },
    {
        "source": "Note that a return value of [`Err`] means that the data will never be received, but a return value of [`Ok`] does *not* mean that the data will be received.",
        "suggest": "请注意，返回值 [`Err`] 表示将永远不会接收到数据，但是 [`Ok`] 的返回值 *不是* 意味着将接收到数据。",
        "translate": ""
    },
    {
        "source": "It is possible for the corresponding receiver to hang up immediately after this function returns [`Ok`].",
        "suggest": "此函数返回 [`Ok`] 之后，相应的接收者有可能立即挂断。",
        "translate": ""
    },
    {
        "source": "This method will never block the current thread.",
        "suggest": "此方法永远不会阻塞当前线程。",
        "translate": ""
    },
    {
        "source": "This send cannot panic because the thread is asleep (we're looking at it), so the receiver can't go away.",
        "suggest": "此发送不能 panic，因为线程处于睡眠状态 (我们正在查看它)，因此接收者无法消失。",
        "translate": ""
    },
    {
        "source": "Sends a value on this synchronous channel.",
        "suggest": "在此同步通道上发送一个值。",
        "translate": ""
    },
    {
        "source": "This function will *block* until space in the internal buffer becomes available or a receiver is available to hand off the message to.",
        "suggest": "该函数将阻塞，直到内部缓冲区中的空间可用或接收者可以将消息传递给它为止。",
        "translate": ""
    },
    {
        "source": "Note that a successful send does *not* guarantee that the receiver will ever see the data if there is a buffer on this channel.",
        "suggest": "请注意，如果此通道上有缓冲区，则成功发送并不能保证接收者会看到数据。",
        "translate": ""
    },
    {
        "source": "Items may be enqueued in the internal buffer for the receiver to receive at a later time.",
        "suggest": "该项可能会排队在内部缓冲区中，以供接收者在以后的时间接收。",
        "translate": ""
    },
    {
        "source": "If the buffer size is 0, however, the channel becomes a rendezvous channel and it guarantees that the receiver has indeed received the data if this function returns success.",
        "suggest": "但是，如果缓冲区大小为 0，则通道成为集合通道，并且如果此函数返回成功，则它保证接收者确实已接收到数据。",
        "translate": ""
    },
    {
        "source": "This function will never panic, but it may return [`Err`] if the [`Receiver`] has disconnected and is no longer able to receive information.",
        "suggest": "此函数永远不会 panic，但是如果 [`Receiver`] 已断开连接并且不再能够接收信息，则它可能返回 [`Err`]。",
        "translate": ""
    },
    {
        "source": "Attempts to send a value on this channel without blocking.",
        "suggest": "尝试在此通道上发送值而不会阻塞。",
        "translate": ""
    },
    {
        "source": "This method differs from [`send`] by returning immediately if the channel's buffer is full or no receiver is waiting to acquire some data.",
        "suggest": "此方法不同于 [`send`]，如果通道的缓冲区已满或没有接收者正在等待获取某些数据，则立即返回。",
        "translate": ""
    },
    {
        "source": "Compared with [`send`], this function has two failure cases instead of one (one for disconnection, one for a full buffer).",
        "suggest": "与 [`send`] 相比，此函数有两种故障情况，而不是一种情况 (一种情况是断开连接，一种情况是完整的缓冲区)。",
        "translate": ""
    },
    {
        "source": "See [`send`] for notes about guarantees of whether the receiver has received the data or not if this function is successful.",
        "suggest": "请参见 [`send`]，以获取有关确保此函数成功后接收方是否已接收到数据的说明。",
        "translate": ""
    },
    {
        "source": "Attempts to return a pending value on this receiver without blocking.",
        "suggest": "尝试在不阻塞的情况下在此接收者上返回挂起的值。",
        "translate": ""
    },
    {
        "source": "This method will never block the caller in order to wait for data to become available.",
        "suggest": "此方法决不会阻塞调用方，以等待数据可用。",
        "translate": ""
    },
    {
        "source": "Instead, this will always return immediately with a possible option of pending data on the channel.",
        "suggest": "取而代之的是，它总是立即返回，并可能在通道上保留未决数据。",
        "translate": ""
    },
    {
        "source": "This is useful for a flavor of \"optimistic check\" before deciding to block on a receiver.",
        "suggest": "在决定阻塞接收者之前，这对于 \"optimistic check\" 很有用。",
        "translate": ""
    },
    {
        "source": "Compared with [`recv`], this function has two failure cases instead of one (one for disconnection, one for an empty buffer).",
        "suggest": "与 [`recv`] 相比，此函数有两种故障情况，而不是一种情况 (一种情况是断开连接，一种情况是空缓冲区)。",
        "translate": ""
    },
    {
        "source": "Attempts to wait for a value on this receiver, returning an error if the corresponding channel has hung up.",
        "suggest": "尝试等待此接收者上的值，如果相应的通道已挂起，则返回错误。",
        "translate": ""
    },
    {
        "source": "This function will always block the current thread if there is no data available and it's possible for more data to be sent.",
        "suggest": "如果没有可用数据，并且有可能发送更多数据，则此函数将始终阻止当前线程。",
        "translate": ""
    },
    {
        "source": "Once a message is sent to the corresponding [`Sender`] (or [`SyncSender`]), then this receiver will wake up and return that message.",
        "suggest": "将消息发送到相应的 [`Sender`] (或 [`SyncSender`]) 后，此接收者将唤醒并返回该消息。",
        "translate": ""
    },
    {
        "source": "If the corresponding [`Sender`] has disconnected, or it disconnects while this call is blocking, this call will wake up and return [`Err`] to indicate that no more messages can ever be received on this channel.",
        "suggest": "如果相应的 [`Sender`] 断开连接，或者在此调用阻塞时断开连接，则此调用将唤醒并返回 [`Err`]，以指示该通道上再也不会收到任何消息。",
        "translate": ""
    },
    {
        "source": "However, since channels are buffered, messages sent before the disconnect will still be properly received.",
        "suggest": "但是，由于缓冲了通道，因此在断开连接之前发送的消息仍将被正确接收。",
        "translate": ""
    },
    {
        "source": "Buffering behavior:",
        "suggest": "缓冲行为:",
        "translate": ""
    },
    {
        "source": "Attempts to wait for a value on this receiver, returning an error if the corresponding channel has hung up, or if it waits more than `timeout`.",
        "suggest": "尝试等待此接收器上的值，如果相应的通道已挂起，或者等待的时间超过 `timeout`，则返回错误。",
        "translate": ""
    },
    {
        "source": "Known Issues",
        "suggest": "已知的问题",
        "translate": ""
    },
    {
        "source": "There is currently a known issue (see [`#39364`]) that causes `recv_timeout` to panic unexpectedly with the following example:",
        "suggest": "当前存在一个已知问题 (请参见 [`#39364`])，以下示例导致 `recv_timeout` 意外变为 panic:",
        "translate": ""
    },
    {
        "source": "Successfully receiving value before encountering timeout:",
        "suggest": "在遇到超时之前成功获得值:",
        "translate": ""
    },
    {
        "source": "Receiving an error upon reaching timeout:",
        "suggest": "到达超时时收到错误:",
        "translate": ""
    },
    {
        "source": "Do an optimistic try_recv to avoid the performance impact of Instant::now() in the full-channel case.",
        "suggest": "进行乐观的 try_recv 以避免全通道情况下 Instant::now () 的性能影响。",
        "translate": ""
    },
    {
        "source": "So far in the future that it's practically the same as waiting indefinitely.",
        "suggest": "到目前为止，在 future 中，它实际上与无限期等待相同。",
        "translate": ""
    },
    {
        "source": "Attempts to wait for a value on this receiver, returning an error if the corresponding channel has hung up, or if `deadline` is reached.",
        "suggest": "尝试等待此接收器上的值，如果相应的通道已挂起，或者到达 `deadline`，则返回错误。",
        "translate": ""
    },
    {
        "source": "Successfully receiving value before reaching deadline:",
        "suggest": "在截止日期之前成功获得值:",
        "translate": ""
    },
    {
        "source": "Receiving an error upon reaching deadline:",
        "suggest": "在截止日期前收到错误:",
        "translate": ""
    },
    {
        "source": "If we're already passed the deadline, and we're here without data, return a timeout, else try again.",
        "suggest": "如果我们已经超过了最后期限，并且我们没有数据，请返回超时，否则重试。",
        "translate": ""
    },
    {
        "source": "Returns an iterator that will block waiting for messages, but never [`panic!`].",
        "suggest": "返回一个迭代器，该迭代器将阻止等待消息，但不会阻止 [`panic!`]。",
        "translate": ""
    },
    {
        "source": "It will return [`None`] when the channel has hung up.",
        "suggest": "通道挂起时，它将返回 [`None`]。",
        "translate": ""
    },
    {
        "source": "Returns an iterator that will attempt to yield all pending values.",
        "suggest": "返回一个迭代器，它将尝试产生所有挂起的值。",
        "translate": ""
    },
    {
        "source": "It will return `None` if there are no more pending values or if the channel has hung up.",
        "suggest": "如果没有其他未决值或通道已挂断，它将返回 `None`。",
        "translate": ""
    },
    {
        "source": "The iterator will never [`panic!`] or block the user by waiting for values.",
        "suggest": "迭代器永远不会 [`panic!`] 或通过等待值来阻止用户。",
        "translate": ""
    },
    {
        "source": "Converts a `SendError<T>` into a `TrySendError<T>`.",
        "suggest": "将 `SendError<T>` 转换为 `TrySendError<T>`。",
        "translate": ""
    },
    {
        "source": "This conversion always returns a `TrySendError::Disconnected` containing the data in the `SendError<T>`.",
        "suggest": "这种转换总是返回一个包含 `SendError<T>` 中数据的 `TrySendError::Disconnected`。",
        "translate": ""
    },
    {
        "source": "No data is allocated on the heap.",
        "suggest": "没有在堆上分配数据。",
        "translate": ""
    },
    {
        "source": "Converts a `RecvError` into a `TryRecvError`.",
        "suggest": "将 `RecvError` 转换为 `TryRecvError`。",
        "translate": ""
    },
    {
        "source": "This conversion always returns `TryRecvError::Disconnected`.",
        "suggest": "此转换始终返回 `TryRecvError::Disconnected`。",
        "translate": ""
    },
    {
        "source": "Converts a `RecvError` into a `RecvTimeoutError`.",
        "suggest": "将 `RecvError` 转换为 `RecvTimeoutError`。",
        "translate": ""
    },
    {
        "source": "This conversion always returns `RecvTimeoutError::Disconnected`.",
        "suggest": "此转换始终返回 `RecvTimeoutError::Disconnected`。",
        "translate": ""
    },
    {
        "source": "A mostly lock-free multi-producer, single consumer queue.",
        "suggest": "几乎无锁的多生产者，单个消费者队列。",
        "translate": ""
    },
    {
        "source": "This module contains an implementation of a concurrent MPSC queue.",
        "suggest": "该模块包含一个并发 MPSC 队列的实现。",
        "translate": ""
    },
    {
        "source": "This queue can be used to share data between threads, and is also used as the building block of channels in rust.",
        "suggest": "此队列可用于在线程之间共享数据，也可用作 rust 中通道的构造块。",
        "translate": ""
    },
    {
        "source": "Note that the current implementation of this queue has a caveat of the `pop` method, and see the method for more information about it.",
        "suggest": "请注意，此队列的当前实现具有 `pop` 方法的警告，有关该信息的更多信息，请参见该方法。",
        "translate": ""
    },
    {
        "source": "Due to this caveat, this queue may not be appropriate for all use-cases.",
        "suggest": "由于此警告，此队列可能不适用于所有用例。",
        "translate": ""
    },
    {
        "source": "A result of the `pop` function.",
        "suggest": "`pop` 函数的结果。",
        "translate": ""
    },
    {
        "source": "Some data has been popped",
        "suggest": "一些数据已经弹出",
        "translate": ""
    },
    {
        "source": "The queue is empty",
        "suggest": "队列为空",
        "translate": ""
    },
    {
        "source": "The queue is in an inconsistent state.",
        "suggest": "队列处于不一致状态。",
        "translate": ""
    },
    {
        "source": "Popping data should succeed, but some pushers have yet to make enough progress in order allow a pop to succeed.",
        "suggest": "弹出数据应该会成功，但是为了使弹出操作成功，某些推动程序尚未取得足够的进展。",
        "translate": ""
    },
    {
        "source": "It is recommended that a pop() occur \"in the near future\" in order to see if the sender has made progress or not",
        "suggest": "建议查看 pop()，以查看发送者是否已取得进展",
        "translate": ""
    },
    {
        "source": "The multi-producer single-consumer structure.",
        "suggest": "多生产者单一消费者的结构体。",
        "translate": ""
    },
    {
        "source": "This is not cloneable, but it may be safely shared so long as it is guaranteed that there is only one popper at a time (many pushers are allowed).",
        "suggest": "这是不可克隆的，但是可以确保安全地共享它，只要保证一次仅存在一个弹出器即可 (允许很多推动器)。",
        "translate": ""
    },
    {
        "source": "Creates a new queue that is safe to share among multiple producers and one consumer.",
        "suggest": "创建一个新的队列，可以在多个生产者和一个消费者之间共享。",
        "translate": ""
    },
    {
        "source": "Pushes a new value onto this queue.",
        "suggest": "将新值推送到此队列。",
        "translate": ""
    },
    {
        "source": "Pops some data from this queue.",
        "suggest": "从此队列中弹出一些数据。",
        "translate": ""
    },
    {
        "source": "Note that the current implementation means that this function cannot return `Option<T>`.",
        "suggest": "请注意，当前实现意味着此函数无法返回 `Option<T>`。",
        "translate": ""
    },
    {
        "source": "It is possible for this queue to be in an inconsistent state where many pushes have succeeded and completely finished, but pops cannot return `Some(t)`.",
        "suggest": "此队列可能处于不一致状态，在该状态下，许多推送已成功完成并完全完成，但是 pops 无法返回 `Some(t)`。",
        "translate": ""
    },
    {
        "source": "This inconsistent state happens when a pusher is pre-empted at an inopportune moment.",
        "suggest": "当推送器在不合时宜的时候被抢占时，就会发生这种不一致的状态。",
        "translate": ""
    },
    {
        "source": "This inconsistent state means that this queue does indeed have data, but it does not currently have access to it at this time.",
        "suggest": "这种不一致的状态意味着该队列确实有数据，但是目前无法访问该队列。",
        "translate": ""
    },
    {
        "source": "This is the initial flavor of channels/ports used for comm module.",
        "suggest": "这是用于通讯模块的 channels/ports 的初始风格。",
        "translate": ""
    },
    {
        "source": "This is an optimization for the one-use case of a channel.",
        "suggest": "这是针对通道的一次使用情况的优化。",
        "translate": ""
    },
    {
        "source": "The major optimization of this type is to have one and exactly one allocation when the chan/port pair is created.",
        "suggest": "这种类型的主要优化是在创建 chan/port 对时仅分配一个且仅分配一个。",
        "translate": ""
    },
    {
        "source": "Another possible optimization would be to not use an Arc box because in theory we know when the shared packet can be deallocated (no real need for the atomic reference counting), but I was having trouble how to destroy the data early in a drop of a Port.",
        "suggest": "另一个可能的优化是不使用 Arc box，因为从理论上讲我们知道何时可以重新分配共享数据包 (不需要真正的原子引用计数)，但我遇到了如何在一个端口丢弃的早期销毁数据的麻烦。",
        "translate": ""
    },
    {
        "source": "Oneshots are implemented around one atomic usize variable.",
        "suggest": "Oneshots 是围绕一个原子的 usize 变量实现的。",
        "translate": ""
    },
    {
        "source": "This variable indicates both the state of the port/chan but also contains any threads blocked on the port.",
        "suggest": "该变量不仅指示 port/chan 的状态，还包含端口上阻塞的所有线程。",
        "translate": ""
    },
    {
        "source": "All atomic operations happen on this one word.",
        "suggest": "所有的原子运算都发生在这个词上。",
        "translate": ""
    },
    {
        "source": "In order to upgrade a oneshot channel, an upgrade is considered a disconnect on behalf of the channel side of things (it can be mentally thought of as consuming the port).",
        "suggest": "为了升级 oneshot 通道，升级被视为代表事物在通道方面的断开连接 (在心理上可以认为是在占用端口)。",
        "translate": ""
    },
    {
        "source": "This upgrade is then also stored in the shared packet.",
        "suggest": "然后，此升级也存储在共享数据包中。",
        "translate": ""
    },
    {
        "source": "The one caveat to consider is that when a port sees a disconnected channel it must check for data because there is no \"data plus upgrade\" state.",
        "suggest": "需要考虑的一个警告是，当端口看到断开的通道时，它必须检查数据，因为没有 \"data plus upgrade\" 状态。",
        "translate": ""
    },
    {
        "source": "Various states you can find a port in.",
        "suggest": "您可以在各种状态下找到端口。",
        "translate": ""
    },
    {
        "source": "initial state: no data, no blocked receiver",
        "suggest": "初始状态: 无数据，无阻塞接收者",
        "translate": ""
    },
    {
        "source": "data ready for receiver to take",
        "suggest": "准备好供接收者接收的数据",
        "translate": ""
    },
    {
        "source": "channel is disconnected OR upgraded",
        "suggest": "通道已断开连接或已升级",
        "translate": ""
    },
    {
        "source": "Any other value represents a pointer to a SignalToken value.",
        "suggest": "任何其他值都表示一个指向 SignalToken 值的指针。",
        "translate": ""
    },
    {
        "source": "The protocol ensures that when the state moves *to* a pointer, ownership of the token is given to the packet, and when the state moves *from* a pointer, ownership of the token is transferred to whoever changed the state.",
        "suggest": "该协议确保当状态从 *移到指针时，将 token 的所有权提供给数据包，并且在状态从* 指针移向 * 时，token 的所有权将转移给更改状态的任何人。",
        "translate": ""
    },
    {
        "source": "Internal state of the chan/port pair (stores the blocked thread as well)",
        "suggest": "chan/port 对的内部状态 (也存储阻塞的线程)",
        "translate": ""
    },
    {
        "source": "One-shot data slot location",
        "suggest": "一键式数据插槽位置",
        "translate": ""
    },
    {
        "source": "when used for the second time, a oneshot channel must be upgraded, and this contains the slot for the upgrade",
        "suggest": "第二次使用时，必须升级 oneshot 通道，其中包含用于升级的插槽",
        "translate": ""
    },
    {
        "source": "Sanity check",
        "suggest": "完整性检查",
        "translate": ""
    },
    {
        "source": "Sent the data, no one was waiting",
        "suggest": "发送数据，没有人在等待",
        "translate": ""
    },
    {
        "source": "Couldn't send the data, the port hung up first.",
        "suggest": "无法发送数据，端口首先挂断。",
        "translate": ""
    },
    {
        "source": "Return the data back up the stack.",
        "suggest": "将数据返回栈。",
        "translate": ""
    },
    {
        "source": "Not possible, these are one-use channels",
        "suggest": "不可能，这些是一次性通道",
        "translate": ""
    },
    {
        "source": "There is a thread waiting on the other end.",
        "suggest": "另一端有一个线程在等待。",
        "translate": ""
    },
    {
        "source": "We leave the 'DATA' state inside so it'll pick it up on the other end.",
        "suggest": "我们将 'DATA' 状态留在内部，以便在另一端将其拾取。",
        "translate": ""
    },
    {
        "source": "Just tests whether this channel has been sent on or not, this is only safe to use from the sender.",
        "suggest": "只需测试此通道是否已发送，就可以从发送方安全地使用它。",
        "translate": ""
    },
    {
        "source": "Attempt to not block the thread (it's a little expensive).",
        "suggest": "尝试不阻塞线程 (这有点贵)。",
        "translate": ""
    },
    {
        "source": "If it looks like we're not empty, then immediately go through to `try_recv`.",
        "suggest": "如果看起来我们不是空的，那么请立即进行 `try_recv` 的操作。",
        "translate": ""
    },
    {
        "source": "race with senders to enter the blocking state",
        "suggest": "与发送者竞争进入阻止状态",
        "translate": ""
    },
    {
        "source": "Try to reset the state",
        "suggest": "尝试重置状态",
        "translate": ""
    },
    {
        "source": "drop the signal token, since we never blocked",
        "suggest": "丢弃信号 token，因为我们从未阻止",
        "translate": ""
    },
    {
        "source": "We saw some data on the channel, but the channel can be used again to send us an upgrade.",
        "suggest": "我们在通道上看到了一些数据，但是可以再次使用通道来向我们发送升级。",
        "translate": ""
    },
    {
        "source": "As a result, we need to re-insert into the channel that there's no data available (otherwise we'll just see DATA next time).",
        "suggest": "结果，我们需要重新插入没有可用数据的通道 (否则，下一次我们将只看到 DATA)。",
        "translate": ""
    },
    {
        "source": "This is done as a cmpxchg because if the state changes under our feet we'd rather just see that state change.",
        "suggest": "这是作为 cmpxchg 完成的，因为如果状态在我们的脚下改变，我们宁愿只看到状态改变。",
        "translate": ""
    },
    {
        "source": "There's no guarantee that we receive before an upgrade happens, and an upgrade flags the channel as disconnected, so when we see this we first need to check if there's data available and *then* we go through and process the upgrade.",
        "suggest": "无法保证在升级发生之前我们会收到，并且升级会将通道标记为断开连接，因此，当我们看到此消息时，我们首先需要检查是否有可用数据，然后 *然后* 进行升级。",
        "translate": ""
    },
    {
        "source": "We are the sole receiver;",
        "suggest": "我们是唯一的接收者;",
        "translate": ""
    },
    {
        "source": "there cannot be a blocking receiver already.",
        "suggest": "已经没有阻塞的接收者了。",
        "translate": ""
    },
    {
        "source": "Returns whether the upgrade was completed.",
        "suggest": "返回升级是否完成。",
        "translate": ""
    },
    {
        "source": "If the upgrade wasn't completed, then the port couldn't get sent to the other half (it will never receive it).",
        "suggest": "如果升级未完成，则无法将端口发送到另一半 (它将永远不会收到)。",
        "translate": ""
    },
    {
        "source": "If the channel is empty or has data on it, then we're good to go.",
        "suggest": "如果通道为空或上面有数据，那么我们很好。",
        "translate": ""
    },
    {
        "source": "Senders will check the data before the upgrade (in case we plastered over the DATA state).",
        "suggest": "发送者将在升级之前检查数据 (以防我们粘贴 DATA 状态)。",
        "translate": ""
    },
    {
        "source": "If the other end is already disconnected, then we failed the upgrade.",
        "suggest": "如果另一端已经断开连接，则升级失败。",
        "translate": ""
    },
    {
        "source": "Be sure to trash the port we were given.",
        "suggest": "请确保将我们给的端口丢掉。",
        "translate": ""
    },
    {
        "source": "If someone's waiting, we gotta wake them up",
        "suggest": "如果有人在等，我们得叫醒他们",
        "translate": ""
    },
    {
        "source": "An empty channel has nothing to do, and a remotely disconnected channel also has nothing to do b/c we're about to run the drop glue",
        "suggest": "空通道无关紧要，而远程断开连接的通道也无关紧要 b/c 我们将要运行 drop glue",
        "translate": ""
    },
    {
        "source": "There's data on the channel, so make sure we destroy it promptly.",
        "suggest": "通道上有数据，因此请确保我们立即销毁它。",
        "translate": ""
    },
    {
        "source": "This is why not using an arc is a little difficult (need the box to stay valid while we take the data).",
        "suggest": "这就是为什么不使用圆弧会有些困难的原因 (需要 box 才能在获取数据时保持有效)。",
        "translate": ""
    },
    {
        "source": "We're the only ones that can block on this port",
        "suggest": "我们是唯一可以阻止此端口的人",
        "translate": ""
    },
    {
        "source": "select implementation",
        "suggest": "选择实现",
        "translate": ""
    },
    {
        "source": "Remove a previous selecting thread from this port.",
        "suggest": "从该端口中删除先前的选择线程。",
        "translate": ""
    },
    {
        "source": "This ensures that the blocked thread will no longer be visible to any other threads.",
        "suggest": "这确保了被阻塞的线程将不再对任何其他线程可见。",
        "translate": ""
    },
    {
        "source": "The return value indicates whether there's data on this port.",
        "suggest": "返回值指示此端口上是否有数据。",
        "translate": ""
    },
    {
        "source": "Each of these states means that no further activity will happen with regard to abortion selection",
        "suggest": "这些状态中的每一个都意味着在堕胎选择方面不会发生进一步的活动",
        "translate": ""
    },
    {
        "source": "If we've got a blocked thread, then use an atomic to gain ownership of it (may fail)",
        "suggest": "如果我们有一个阻塞的线程，则使用原子来获得它的所有权 (可能会失败)",
        "translate": ""
    },
    {
        "source": "Now that we've got ownership of our state, figure out what to do about it.",
        "suggest": "既然我们已经拥有了国家的所有权，那么想出办法去做。",
        "translate": ""
    },
    {
        "source": "our thread used for select was stolen",
        "suggest": "用于选择的线程被盗",
        "translate": ""
    },
    {
        "source": "If the other end has hung up, then we have complete ownership of the port.",
        "suggest": "如果另一端挂断了，那么我们就拥有该端口的完全所有权。",
        "translate": ""
    },
    {
        "source": "First, check if there was data waiting for us.",
        "suggest": "首先，检查是否有数据在等待我们。",
        "translate": ""
    },
    {
        "source": "This is possible if the other end sent something and then hung up.",
        "suggest": "如果另一端发送了一些内容然后挂断，则可能发生这种情况。",
        "translate": ""
    },
    {
        "source": "We then need to check to see if there was an upgrade requested, and if so, the upgraded port needs to have its selection aborted.",
        "suggest": "然后，我们需要检查是否请求了升级，如果是，则升级后的端口需要中止选择。",
        "translate": ""
    },
    {
        "source": "We woke ourselves up from select.",
        "suggest": "我们从精选中唤醒了自己。",
        "translate": ""
    },
    {
        "source": "Shared channels.",
        "suggest": "共享通道。",
        "translate": ""
    },
    {
        "source": "This is the flavor of channels which are not necessarily optimized for any particular use case, but are the most general in how they are used.",
        "suggest": "这是通道的风格，不一定针对任何特定用例进行优化，但在使用方式上是最通用的。",
        "translate": ""
    },
    {
        "source": "Shared channels are cloneable allowing for multiple senders.",
        "suggest": "共享通道是可克隆的，允许多个发送者。",
        "translate": ""
    },
    {
        "source": "High level implementation details can be found in the comment of the parent module.",
        "suggest": "可以在父模块的注释中找到高级实现细节。",
        "translate": ""
    },
    {
        "source": "You'll also note that the implementation of the shared and stream channels are quite similar, and this is no coincidence!",
        "suggest": "您还将注意到，共享通道和流通道的实现非常相似，这绝非偶然!",
        "translate": ""
    },
    {
        "source": "How many items are on this channel",
        "suggest": "该通道上有多少项",
        "translate": ""
    },
    {
        "source": "How many times has a port received without blocking?",
        "suggest": "一个端口收到多少次无阻塞?",
        "translate": ""
    },
    {
        "source": "SignalToken for wake up",
        "suggest": "SignalToken 唤醒",
        "translate": ""
    },
    {
        "source": "The number of channels which are currently using this packet.",
        "suggest": "当前正在使用此数据包的通道数。",
        "translate": ""
    },
    {
        "source": "See the discussion in Port::drop and the channel send methods for what these are used for",
        "suggest": "有关这些功能的用途，请参见 Port::drop 中的讨论和通道发送方法。",
        "translate": ""
    },
    {
        "source": "this lock protects various portions of this implementation during",
        "suggest": "此锁在执行过程中保护此实现的各个部分",
        "translate": ""
    },
    {
        "source": "Creation of a packet *must* be followed by a call to postinit_lock and later by inherit_blocker",
        "suggest": "数据包的创建 (必须) 之后必须先调用 postinit_lock，然后再调用 Inherited_blocker",
        "translate": ""
    },
    {
        "source": "This function should be used after newly created Packet was wrapped with an Arc In other case mutex data will be duplicated while cloning and that could cause problems on platforms where it is represented by opaque data structure",
        "suggest": "这个函数应该在新创建的 Packet 用 Arc 包装后使用，否则在克隆时互斥锁数据将被复制，这可能会导致在它由不透明数据结构表示的平台上出现问题",
        "translate": ""
    },
    {
        "source": "This function is used at the creation of a shared packet to inherit a previously blocked thread.",
        "suggest": "在创建共享数据包时，可以使用此函数来继承以前阻塞的线程。",
        "translate": ""
    },
    {
        "source": "This is done to prevent spurious wakeups of threads in select().",
        "suggest": "这样做是为了防止 select() 中的线程被虚假唤醒。",
        "translate": ""
    },
    {
        "source": "This can only be called at channel-creation time",
        "suggest": "这只能在通道创建时调用",
        "translate": ""
    },
    {
        "source": "This store is a little sketchy.",
        "suggest": "这家商店有点简陋。",
        "translate": ""
    },
    {
        "source": "What's happening here is that we're transferring a blocker from a oneshot or stream channel to this shared channel.",
        "suggest": "这里发生的是我们正在将阻止程序从 oneshot 或流通道传输到此共享通道。",
        "translate": ""
    },
    {
        "source": "In doing so, we never spuriously wake them up and rather only wake them up at the appropriate time.",
        "suggest": "这样做时，我们绝不会虚假地唤醒它们，而只是在适当的时间唤醒它们。",
        "translate": ""
    },
    {
        "source": "This implementation of shared channels assumes that any blocking recv() will undo the increment of steals performed in try_recv() once the recv is complete.",
        "suggest": "共享通道的此实现假定，一旦接收完成，任何阻塞的 recv() 都将撤消 try_recv() 中执行的窃取增量。",
        "translate": ""
    },
    {
        "source": "This thread that we're inheriting, however, is not in the middle of recv. Hence, the first time we wake them up, they're going to wake up from their old port, move on to the upgraded port, and then call the block recv() function.",
        "suggest": "但是，我们正在继承的该线程不在 recv 的中间。因此，我们第一次唤醒它们时，它们将从原来的端口中唤醒，移至升级的端口，然后调用块 recv() 函数。",
        "translate": ""
    },
    {
        "source": "When calling this function, they'll find there's data immediately available, counting it as a steal.",
        "suggest": "调用此函数时，他们会发现立即有可用数据，将其算作窃取。",
        "translate": ""
    },
    {
        "source": "This in fact wasn't a steal because we appropriately blocked them waiting for data.",
        "suggest": "实际上，这并不是偷窃，因为我们适当地阻止了他们等待数据。",
        "translate": ""
    },
    {
        "source": "To offset this bad increment, we initially set the steal count to",
        "suggest": "为了弥补这一不良增长，我们最初将窃取计数设置为",
        "translate": ""
    },
    {
        "source": "You'll find some special code in abort_selection() as well to ensure that this -1 steal count doesn't escape too far.",
        "suggest": "您还将在 abort_selection() 中找到一些特殊的代码，以确保 -1 的盗用计数不会溢出太多。",
        "translate": ""
    },
    {
        "source": "When the shared packet is constructed, we grabbed this lock.",
        "suggest": "构建共享数据包后，我们抓住了这个锁。",
        "translate": ""
    },
    {
        "source": "The purpose of this lock is to ensure that abort_selection() doesn't interfere with this method.",
        "suggest": "此锁定的目的是确保 abort_selection() 不会干扰此方法。",
        "translate": ""
    },
    {
        "source": "After we unlock this lock, we're signifying that we're done modifying self.cnt and self.to_wake and the port is ready for the world to continue using it.",
        "suggest": "解锁此锁后，表示完成 self.cnt 和 self.to_wake 的修改，并且该端口已准备就绪，世界各地均可继续使用它。",
        "translate": ""
    },
    {
        "source": "See Port::drop for what's going on",
        "suggest": "请参见 Port::drop，了解发生了什么情况",
        "translate": ""
    },
    {
        "source": "Note that the multiple sender case is a little trickier semantically than the single sender case.",
        "suggest": "请注意，多发送者案例在语义上要比单发送者案例稍微复杂一些。",
        "translate": ""
    },
    {
        "source": "The logic for incrementing is \"add and if disconnected store disconnected\".",
        "suggest": "递增逻辑为 \"add and if disconnected store disconnected\"。",
        "translate": ""
    },
    {
        "source": "This could end up leading some senders to believe that there wasn't a disconnect if in fact there was a disconnect.",
        "suggest": "这可能最终导致某些发送者认为，即使实际上存在断开连接，也不会断开连接。",
        "translate": ""
    },
    {
        "source": "This means that while one thread is attempting to re-store the disconnected states, other threads could walk through merrily incrementing this very-negative disconnected count.",
        "suggest": "这意味着，当一个线程试图恢复断开连接状态时，其他线程可能会通过愉快地增加此非常负的断开连接计数来进行遍历。",
        "translate": ""
    },
    {
        "source": "To prevent senders from spuriously attempting to send when the channels is actually disconnected, the count has a ranged check here.",
        "suggest": "为了防止发送方在实际断开通道时虚假地尝试发送，此处对计数进行了范围检查。",
        "translate": ""
    },
    {
        "source": "This is also done for another reason.",
        "suggest": "这样做也是出于另一个原因。",
        "translate": ""
    },
    {
        "source": "Remember that the return value of this function is:",
        "suggest": "请记住，此函数的返回值为:",
        "translate": ""
    },
    {
        "source": "the data *may* be received, this essentially has no meaning `false` == the data will *never* be received, this has a lot of meaning",
        "suggest": "数据 *可能* 被接收，这实际上没有意义 `false` == 数据 * 将永远不会被接收，这具有很大的意义",
        "translate": ""
    },
    {
        "source": "In the SPSC case, we have a check of 'queue.is_empty()' to see whether the data was actually received, but this same condition means nothing in a multi-producer context.",
        "suggest": "在 SPSC 情况下，我们检查 'queue.is_empty()' 以查看是否实际接收到数据，但是在多生产者环境中，这种相同的条件没有任何意义。",
        "translate": ""
    },
    {
        "source": "As a result, this preflight check serves as the definitive \"this will never be received\".",
        "suggest": "结果，此预检检查将用作确定的 \"this will never be received\"。",
        "translate": ""
    },
    {
        "source": "Once we get beyond this check, we have permanently entered the realm of \"this may be received\"",
        "suggest": "一旦超出此检查范围，我们将永久进入 \"this may be received\" 领域",
        "translate": ""
    },
    {
        "source": "In this case, we have possibly failed to send our data, and we need to consider re-popping the data in order to fully destroy it.",
        "suggest": "在这种情况下，我们可能无法发送数据，我们需要考虑重新弹出数据以完全销毁它。",
        "translate": ""
    },
    {
        "source": "We must arbitrate among the multiple senders, however, because the queues that we're using are single-consumer queues.",
        "suggest": "但是，我们必须在多个发送者之间进行仲裁，因为我们使用的队列是单消费者队列。",
        "translate": ""
    },
    {
        "source": "In order to do this, all exiting pushers will use an atomic count in order to count those flowing through.",
        "suggest": "为了做到这一点，所有退出的推动器都将使用原子计数，以便对流经的推动器进行计数。",
        "translate": ""
    },
    {
        "source": "Pushers who see 0 are required to drain as much as possible, and then can only exit when they are the only pusher (otherwise they must try again).",
        "suggest": "看到 0 的推动器必须尽可能多地进入 drain，然后只有在它们是唯一推动器时才能退出 (否则必须再次尝试)。",
        "translate": ""
    },
    {
        "source": "see the comment in 'try' for a shared channel for why this window of \"not disconnected\" is ok.",
        "suggest": "请参见 'try' 中有关共享通道的文档，以了解 \"not disconnected\" 窗口正常的原因。",
        "translate": ""
    },
    {
        "source": "drain the queue, for info on the thread yield see the discussion in try_recv",
        "suggest": "drain 队列，有关线程产量的信息，请参见 try_recv 中的讨论",
        "translate": ""
    },
    {
        "source": "maybe we're done, if we're not the last ones here, then we need to go try again.",
        "suggest": "也许我们已经完成了，如果不是最后一个，那么我们需要再试一次。",
        "translate": ""
    },
    {
        "source": "At this point, there may still be data on the queue, but only if the count hasn't been incremented and some other sender hasn't finished pushing data just yet.",
        "suggest": "此时，队列上可能仍然有数据，但前提是计数没有增加，并且其他一些发送方尚未完成推送数据。",
        "translate": ""
    },
    {
        "source": "That sender in question will drain its own data.",
        "suggest": "该发送者将 drain 自己的数据。",
        "translate": ""
    },
    {
        "source": "Can't make any assumptions about this case like in the SPSC case.",
        "suggest": "不能像 SPSC 案例那样对此案例做出任何假设。",
        "translate": ""
    },
    {
        "source": "This code is essentially the exact same as that found in the stream case (see stream.rs)",
        "suggest": "该代码本质上与流情况下的代码完全相同 (请参见 stream.rs)",
        "translate": ""
    },
    {
        "source": "Essentially the exact same thing as the stream decrement function.",
        "suggest": "本质上与流递减函数完全相同。",
        "translate": ""
    },
    {
        "source": "Returns true if blocking should proceed.",
        "suggest": "如果应继续执行阻塞，则返回 true。",
        "translate": ""
    },
    {
        "source": "If we factor in our steals and notice that the channel has no data, we successfully sleep",
        "suggest": "如果我们将盗窃因素考虑在内，并且注意到该通道没有数据，那么我们就可以成功入睡",
        "translate": ""
    },
    {
        "source": "This is a bit of an interesting case.",
        "suggest": "这是一个有趣的案例。",
        "translate": ""
    },
    {
        "source": "The channel is reported as having data available, but our pop() has failed due to the queue being in an inconsistent state.",
        "suggest": "通道被报告为有可用数据，但是由于队列处于不一致状态，我们的 pop() 失败了。",
        "translate": ""
    },
    {
        "source": "This means that there is some pusher somewhere which has yet to complete, but we are guaranteed that a pop will eventually succeed.",
        "suggest": "这意味着某个地方还需要完成一些推动器，但是我们可以保证弹出操作最终会成功。",
        "translate": ""
    },
    {
        "source": "In this case, we spin in a yield loop because the remote sender should finish their enqueue operation \"very quickly\".",
        "suggest": "在这种情况下，我们旋转一个 yield 循环，因为远程发送者应该完成其入队操作 \"very quickly\"。",
        "translate": ""
    },
    {
        "source": "Avoiding this yield loop would require a different queue abstraction which provides the guarantee that after M pushes have succeeded, at least M pops will succeed.",
        "suggest": "避免这种良率循环将需要不同的队列抽象，这可以保证在成功完成 M 次推送之后，至少 M 次弹出会成功。",
        "translate": ""
    },
    {
        "source": "The current queues guarantee that if there are N active pushes, you can pop N times once all N have finished.",
        "suggest": "当前队列可确保如果有 N 次活动推送，则所有 N 完成后，您可以弹出 N 次。",
        "translate": ""
    },
    {
        "source": "See the discussion in the stream implementation for why we might decrement steals.",
        "suggest": "有关为什么我们可能减少盗窃的信息，请参见流实现中的讨论。",
        "translate": ""
    },
    {
        "source": "See the discussion in the stream implementation for why we try again.",
        "suggest": "有关为什么再次尝试的信息，请参见流实现中的讨论。",
        "translate": ""
    },
    {
        "source": "with no senders, an inconsistency is impossible.",
        "suggest": "没有发送者，不一致是不可能的。",
        "translate": ""
    },
    {
        "source": "Prepares this shared packet for a channel clone, essentially just bumping a refcount.",
        "suggest": "为通道克隆准备此共享数据包，实际上只是增加引用计数。",
        "translate": ""
    },
    {
        "source": "See comments on Arc::clone() on why we do this (for `mem::forget`).",
        "suggest": "请参见 Arc::clone () 上的注释，了解为什么要这样做 (对于 `mem::forget`)。",
        "translate": ""
    },
    {
        "source": "Decrement the reference count on a channel.",
        "suggest": "减少通道上的引用计数。",
        "translate": ""
    },
    {
        "source": "This is called whenever a Chan is dropped and may end up waking up a receiver.",
        "suggest": "每当 Chan 丢弃并可能最终唤醒接收者时，就会调用此方法。",
        "translate": ""
    },
    {
        "source": "It's the receiver's responsibility on the other end to figure out that we've disconnected.",
        "suggest": "另一端，接收者的责任是确定我们已断开连接。",
        "translate": ""
    },
    {
        "source": "See the long discussion inside of stream.rs for why the queue is drained, and why it is done in this fashion.",
        "suggest": "请参见 stream.rs 内部的冗长讨论，以了解为何耗尽队列以及为何以这种方式完成队列。",
        "translate": ""
    },
    {
        "source": "See the discussion in 'try_recv' for why we yield control of this thread.",
        "suggest": "请参见 'try_recv' 中的讨论，以了解为什么我们要对此线程进行控制。",
        "translate": ""
    },
    {
        "source": "Consumes ownership of the 'to_wake' field.",
        "suggest": "占用 'to_wake' 字段的所有权。",
        "translate": ""
    },
    {
        "source": "increment the count on the channel (used for selection)",
        "suggest": "增加通道上的计数 (用于选择)",
        "translate": ""
    },
    {
        "source": "Cancels a previous thread waiting on this port, returning whether there's data on the port.",
        "suggest": "取消先前在该端口上等待的线程，并返回该端口上是否有数据。",
        "translate": ""
    },
    {
        "source": "This is similar to the stream implementation (hence fewer comments), but uses a different value for the \"steals\" variable.",
        "suggest": "这与流实现类似 (因此，注释较少)，但对 \"steals\" 变量使用不同的值。",
        "translate": ""
    },
    {
        "source": "Before we do anything else, we bounce on this lock.",
        "suggest": "在我们做其他事情之前，我们先弹开这个锁。",
        "translate": ""
    },
    {
        "source": "The reason for doing this is to ensure that any upgrade-in-progress is gone and done with.",
        "suggest": "这样做的原因是为了确保进行中的所有升级都不会进行。",
        "translate": ""
    },
    {
        "source": "Without this bounce, we can race with inherit_blocker about looking at and dealing with to_wake.",
        "suggest": "没有这种反弹，我们就可以与 Inherited_blocker 竞争有关查看和处理 to_wake 的问题。",
        "translate": ""
    },
    {
        "source": "Once we have acquired the lock, we are guaranteed that inherit_blocker is done.",
        "suggest": "一旦获得了锁，我们就可以保证 Inherited_blocker 已完成。",
        "translate": ""
    },
    {
        "source": "Like the stream implementation, we want to make sure that the count on the channel goes non-negative.",
        "suggest": "像流实现一样，我们要确保通道上的计数变为非负数。",
        "translate": ""
    },
    {
        "source": "We don't know how negative the stream currently is, so instead of using a steal value of 1, we load the channel count and figure out what we should do to make it positive.",
        "suggest": "我们不知道当前流的负值如何，因此，我们不使用窃取值 1，而是加载通道计数并弄清楚应该如何使它变为正值。",
        "translate": ""
    },
    {
        "source": "if the number of steals is -1, it was the pre-emptive -1 steal count from when we inherited a blocker.",
        "suggest": "如果窃取次数为 -1，则它是从我们继承阻止程序起的先发制人的 -1 窃取次数。",
        "translate": ""
    },
    {
        "source": "This is fine because we're just going to overwrite it with a real value.",
        "suggest": "这很好，因为我们将使用实际值覆盖它。",
        "translate": ""
    },
    {
        "source": "Note that this load is not only an assert for correctness about disconnection, but also a proper fence before the read of `to_wake`, so this assert cannot be removed with also removing the `to_wake` assert.",
        "suggest": "请注意，此负载不仅是断开连接正确性的断言，而且还是读取 `to_wake` 之前的适当围栏，因此无法在删除 `to_wake` 断言的同时删除此断言。",
        "translate": ""
    },
    {
        "source": "Ensure the borrowchecker works",
        "suggest": "确保借用检查器正常工作",
        "translate": ""
    },
    {
        "source": "A single-producer single-consumer concurrent queue",
        "suggest": "单生产者单消费者并发队列",
        "translate": ""
    },
    {
        "source": "This module contains the implementation of an SPSC queue which can be used concurrently between two threads.",
        "suggest": "此模块包含 SPSC 队列的实现，该队列可在两个线程之间并发使用。",
        "translate": ""
    },
    {
        "source": "This data structure is safe to use and enforces the semantics that there is one pusher and one popper.",
        "suggest": "该数据结构体是安全使用的，并具有一个推送器和一个弹出器的语义。",
        "translate": ""
    },
    {
        "source": "Node within the linked list queue of messages to send",
        "suggest": "链表中要发送的消息队列中的节点",
        "translate": ""
    },
    {
        "source": "this could be an uninitialized T if we're careful enough, and that would reduce memory usage (and be a bit faster).",
        "suggest": "如果我们足够小心的话，这可能是未初始化的 T，这将减少内存使用量 (并且速度更快)。",
        "translate": ""
    },
    {
        "source": "is it worth it?",
        "suggest": "这值得么?",
        "translate": ""
    },
    {
        "source": "nullable for re-use of nodes",
        "suggest": "可为空，以重新使用节点",
        "translate": ""
    },
    {
        "source": "This node goes into the node cache",
        "suggest": "该节点进入节点缓存",
        "translate": ""
    },
    {
        "source": "next node in the queue",
        "suggest": "队列中的下一个节点",
        "translate": ""
    },
    {
        "source": "The single-producer single-consumer queue.",
        "suggest": "单生产者单消费者队列。",
        "translate": ""
    },
    {
        "source": "This structure is not cloneable, but it can be safely shared in an Arc if it is guaranteed that there is only one popper and one pusher touching the queue at any one point in time.",
        "suggest": "该结构体不可克隆，但是如果可以确保在任何时间点只有一个弹出器和一个推动器触摸队列，则可以在 Arc 中安全地共享该结构体。",
        "translate": ""
    },
    {
        "source": "consumer fields",
        "suggest": "consumer 字段",
        "translate": ""
    },
    {
        "source": "producer fields",
        "suggest": "producer 字段",
        "translate": ""
    },
    {
        "source": "where to pop from",
        "suggest": "从哪里弹出",
        "translate": ""
    },
    {
        "source": "maximum cache size",
        "suggest": "最大缓存大小",
        "translate": ""
    },
    {
        "source": "number of nodes marked as cacheable",
        "suggest": "标记为可缓存的节点数",
        "translate": ""
    },
    {
        "source": "where to push to",
        "suggest": "push 到哪里",
        "translate": ""
    },
    {
        "source": "where to get new nodes from",
        "suggest": "从哪里获得新节点",
        "translate": ""
    },
    {
        "source": "between first/tail",
        "suggest": "在 first/tail 之间",
        "translate": ""
    },
    {
        "source": "Creates a new queue.",
        "suggest": "创建一个新队列。",
        "translate": ""
    },
    {
        "source": "With given additional elements in the producer and consumer portions of the queue.",
        "suggest": "在队列的生产者和消费者部分中具有给定的其他元素。",
        "translate": ""
    },
    {
        "source": "Due to the performance implications of cache-contention, we wish to keep fields used mainly by the producer on a separate cache line than those used by the consumer.",
        "suggest": "由于缓存争用对性能的影响，我们希望将主要由生产者使用的字段与使用者所使用的字段保持在单独的缓存行上。",
        "translate": ""
    },
    {
        "source": "Since cache lines are usually 64 bytes, it is unreasonably expensive to allocate one for small fields, so we allow users to insert additional fields into the cache lines already allocated by this for the producer and consumer.",
        "suggest": "由于缓存行通常为 64 个字节，因此为小字段分配一个缓存区会不合理地昂贵，因此我们允许用户将其他字段插入为此已分配给生产者和使用者的缓存行中。",
        "translate": ""
    },
    {
        "source": "This is unsafe as the type system doesn't enforce a single consumer-producer relationship.",
        "suggest": "这是不安全的，因为类型系统不会强制执行单个消费者与生产者的关系。",
        "translate": ""
    },
    {
        "source": "It also allows the consumer to `pop` items while there is a `peek` active due to all methods having a non-mutable receiver.",
        "suggest": "由于所有方法都具有非可变接收者，因此它还允许使用者在有 `peek` 处于活动状态时使用 `pop` 项。",
        "translate": ""
    },
    {
        "source": "This queue implementation is implemented with a linked list, and this means that a push is always a malloc.",
        "suggest": "该队列实现是通过链表实现的，这意味着推送始终是 malloc。",
        "translate": ""
    },
    {
        "source": "In order to amortize this cost, an internal cache of nodes is maintained to prevent a malloc from always being necessary.",
        "suggest": "为了摊销此成本，维护了节点的内部缓存，以防止始终需要 malloc。",
        "translate": ""
    },
    {
        "source": "This bound is the limit on the size of the cache (if desired).",
        "suggest": "此限制是对高速缓存大小的限制 (如果需要)。",
        "translate": ""
    },
    {
        "source": "If the value is 0, then the cache has no bound.",
        "suggest": "如果值为 0，则高速缓存没有边界。",
        "translate": ""
    },
    {
        "source": "Otherwise, the cache will never grow larger than `bound` (although the queue itself could be much larger.",
        "suggest": "否则，缓存将永远不会超过 `bound` (尽管队列本身可能会更大)。",
        "translate": ""
    },
    {
        "source": "Note that to use this function safely, it must be externally guaranteed that there is only one pusher.",
        "suggest": "请注意，为了安全地使用此函数，必须从外部保证只有一个按钮。",
        "translate": ""
    },
    {
        "source": "Acquire a node (which either uses a cached one or allocates a new one), and then append this to the 'head' node.",
        "suggest": "获取一个节点 (使用缓存的节点或分配一个新的节点)，然后将其附加到 'head' 节点。",
        "translate": ""
    },
    {
        "source": "First try to see if we can consume the 'first' node for our uses.",
        "suggest": "首先尝试看看我们是否可以使用 'first' 节点供我们使用。",
        "translate": ""
    },
    {
        "source": "If the above fails, then update our copy of the tail and try again.",
        "suggest": "如果以上方法均失败，请更新我们的尾部副本，然后重试。",
        "translate": ""
    },
    {
        "source": "If all of that fails, then we have to allocate a new node (there's nothing in the node cache).",
        "suggest": "如果所有操作均失败，那么我们必须分配一个新节点 (节点缓存中没有任何内容)。",
        "translate": ""
    },
    {
        "source": "Attempts to pop a value from this queue.",
        "suggest": "尝试从此队列中弹出一个值。",
        "translate": ""
    },
    {
        "source": "Remember that to use this type safely you must ensure that there is only one popper at a time.",
        "suggest": "请记住，要安全使用此类型，必须确保一次仅弹出一个弹出窗口。",
        "translate": ""
    },
    {
        "source": "The `tail` node is not actually a used node, but rather a sentinel from where we should start popping from.",
        "suggest": "`tail` 节点实际上不是一个使用过的节点，而是一个应该从其开始弹出的标记。",
        "translate": ""
    },
    {
        "source": "Hence, look at tail's next field and see if we can use it.",
        "suggest": "因此，请查看 tail 的下一个字段，看看是否可以使用它。",
        "translate": ""
    },
    {
        "source": "If we do a pop, then the current tail node is a candidate for going into the cache.",
        "suggest": "如果我们弹出，则当前尾节点是进入缓存的候选对象。",
        "translate": ""
    },
    {
        "source": "We have successfully erased all references to 'tail', so now we can safely drop it.",
        "suggest": "我们已经成功擦除了所有对 'tail' 的引用，因此现在可以放心地丢弃它了。",
        "translate": ""
    },
    {
        "source": "Attempts to peek at the head of the queue, returning `None` if the queue has no data currently",
        "suggest": "尝试偷看队列的开头，如果队列当前没有数据，则返回 `None`",
        "translate": ""
    },
    {
        "source": "The reference returned is invalid if it is not used before the consumer pops the value off the queue.",
        "suggest": "如果在使用者将值从队列中弹出之前未使用返回的 quot，则该引用无效。",
        "translate": ""
    },
    {
        "source": "If the producer then pushes another value onto the queue, it will overwrite the value pointed to by the reference.",
        "suggest": "如果生产者然后将另一个值压入队列，它将覆盖引用所指向的值。",
        "translate": ""
    },
    {
        "source": "This is essentially the same as above with all the popping bits stripped out.",
        "suggest": "这与上面的基本相同，所有的弹出位都被去除了。",
        "translate": ""
    },
    {
        "source": "Stream channels",
        "suggest": "流通道",
        "translate": ""
    },
    {
        "source": "This is the flavor of channels which are optimized for one sender and one receiver.",
        "suggest": "这就是通道的风格，它针对一位发送者和一位接收者进行了优化。",
        "translate": ""
    },
    {
        "source": "The sender will be upgraded to a shared channel if the channel is cloned.",
        "suggest": "如果通道被克隆，则发送方将升级到共享通道。",
        "translate": ""
    },
    {
        "source": "internal queue for all messages",
        "suggest": "所有邮件的内部队列",
        "translate": ""
    },
    {
        "source": "SignalToken for the blocked thread to wake up",
        "suggest": "SignalToken 使被阻塞的线程唤醒",
        "translate": ""
    },
    {
        "source": "flag if the channel has been destroyed.",
        "suggest": "如果通道已被销毁，则进行标记。",
        "translate": ""
    },
    {
        "source": "Any message could contain an \"upgrade request\" to a new shared port, so the internal queue it's a queue of T, but rather Message<T>",
        "suggest": "任何消息都可以包含到新共享端口的 \"upgrade request\"，因此内部队列是 T 队列，而 Message<T>",
        "translate": ""
    },
    {
        "source": "If the other port has deterministically gone away, then definitely must return the data back up the stack.",
        "suggest": "如果另一个端口确定性地消失了，那么绝对必须将数据返回到栈中。",
        "translate": ""
    },
    {
        "source": "Otherwise, the data is considered as being sent.",
        "suggest": "否则，数据被视为已发送。",
        "translate": ""
    },
    {
        "source": "If the port has gone away, then there's no need to proceed any further.",
        "suggest": "如果端口已消失，则无需继续进行任何操作。",
        "translate": ""
    },
    {
        "source": "As described in the mod's doc comment, -1 == wakeup",
        "suggest": "如 mod 的文档注释中所述，-1 == 唤醒",
        "translate": ""
    },
    {
        "source": "As as described before, SPSC queues must be >= -2",
        "suggest": "如前所述，SPSC 队列必须 >= -2",
        "translate": ""
    },
    {
        "source": "Be sure to preserve the disconnected state, and the return value in this case is going to be whether our data was received or not.",
        "suggest": "确保保留断开连接状态，在这种情况下，返回值将取决于是否接收到我们的数据。",
        "translate": ""
    },
    {
        "source": "This manifests itself on whether we have an empty queue or not.",
        "suggest": "这表明我们是否有空队列。",
        "translate": ""
    },
    {
        "source": "Primarily, are required to drain the queue here because the port will never remove this data.",
        "suggest": "首先，需要 drain 此处的队列，因为端口将永远不会删除此数据。",
        "translate": ""
    },
    {
        "source": "We can only have at most one item to drain (the port drains the rest).",
        "suggest": "drain 最多只能有一个项 (端口将其余部分排出)。",
        "translate": ""
    },
    {
        "source": "we failed to send the data",
        "suggest": "我们无法发送数据",
        "translate": ""
    },
    {
        "source": "we successfully sent data",
        "suggest": "我们成功发送了数据",
        "translate": ""
    },
    {
        "source": "Otherwise we just sent some data on a non-waiting queue, so just make sure the world is sane and carry on!",
        "suggest": "否则，我们只是在非等待队列中发送了一些数据，因此只需确保世界保持理智并继续前进即可!",
        "translate": ""
    },
    {
        "source": "Decrements the count on the channel for a sleeper, returning the sleeper back if it shouldn't sleep.",
        "suggest": "减少睡眠者的通道上的计数，如果睡眠者不应该睡眠，则将其返回。",
        "translate": ""
    },
    {
        "source": "Note that this is the location where we take steals into account.",
        "suggest": "请注意，这是我们考虑盗窃的位置。",
        "translate": ""
    },
    {
        "source": "Optimistic preflight check (scheduling is expensive).",
        "suggest": "乐观的飞行前检查 (计划很昂贵)。",
        "translate": ""
    },
    {
        "source": "Welp, our channel has no data.",
        "suggest": "抱歉，我们的通道没有数据。",
        "translate": ""
    },
    {
        "source": "Deschedule the current thread and initiate the blocking protocol.",
        "suggest": "取消调度当前线程并启动阻止协议。",
        "translate": ""
    },
    {
        "source": "Messages which actually popped from the queue shouldn't count as a steal, so offset the decrement here (we already have our \"steal\" factored into the channel count above).",
        "suggest": "实际上从队列中弹出的消息不应算作窃取，因此请在此处抵消减少的费用 (我们已经将 \"steal\" 计入了上面的通道计数中)。",
        "translate": ""
    },
    {
        "source": "If we stole some data, record to that effect (this will be factored into cnt later on).",
        "suggest": "如果我们窃取了一些数据，请记录下来 (稍后将其计入 cnt)。",
        "translate": ""
    },
    {
        "source": "Note that we don't allow steals to grow without bound in order to prevent eventual overflow of either steals or cnt as an overflow would have catastrophic results.",
        "suggest": "请注意，我们不允许窃取行为无止境地增长，以防止窃取行为或 cnt 的最终溢出，因为溢出会带来灾难性的结果。",
        "translate": ""
    },
    {
        "source": "Sometimes, steals > cnt, but other times cnt > steals, so we don't know the relation between steals and cnt.",
        "suggest": "有时，窃取 > cnt，但是其他时候 > 窃取 > cnt，因此我们不知道窃取和 cnt 之间的关系。",
        "translate": ""
    },
    {
        "source": "This code path is executed only rarely, so we do a pretty slow operation, of swapping 0 into cnt, taking steals down as much as possible (without going negative), and then adding back in whatever we couldn't factor into steals.",
        "suggest": "此代码路径很少执行，因此我们执行了相当慢的操作，将 0 交换到 cnt，尽可能多地窃取 (不转为负数)，然后再加上我们无法算作窃取的内容。",
        "translate": ""
    },
    {
        "source": "This is a little bit of a tricky case.",
        "suggest": "这是一个棘手的情况。",
        "translate": ""
    },
    {
        "source": "We failed to pop data above, and then we have viewed that the channel is disconnected.",
        "suggest": "我们未能弹出上面的数据，然后我们查看了通道已断开连接。",
        "translate": ""
    },
    {
        "source": "In this window more data could have been sent on the channel.",
        "suggest": "在此窗口中，可能已经在通道上发送了更多数据。",
        "translate": ""
    },
    {
        "source": "It doesn't really make sense to return that the channel is disconnected when there's actually data on it, so be extra sure there's no data by popping one more time.",
        "suggest": "当通道上确实有数据时，返回断开的通道并没有多大意义，因此请再弹出一次以确保没有数据。",
        "translate": ""
    },
    {
        "source": "We can ignore steals because the other end is disconnected and we'll never need to really factor in our steals again.",
        "suggest": "我们可以忽略窃取，因为另一端断开了连接，我们再也不需要真正考虑我们的窃取了。",
        "translate": ""
    },
    {
        "source": "Dropping a channel is pretty simple, we just flag it as disconnected and then wakeup a blocker if there is one.",
        "suggest": "丢弃通道非常简单，我们只是将其标记为已断开连接，然后在存在阻塞器时唤醒它。",
        "translate": ""
    },
    {
        "source": "Dropping a port seems like a fairly trivial thing.",
        "suggest": "丢弃端口似乎是一件微不足道的事情。",
        "translate": ""
    },
    {
        "source": "In theory all we need to do is flag that we're disconnected and then everything else can take over (we don't have anyone to wake up).",
        "suggest": "从理论上讲，我们需要做的只是标记我们断开连接，然后其他所有事情都可以接管 (我们没有任何人可以唤醒)。",
        "translate": ""
    },
    {
        "source": "The catch for Ports is that we want to drop the entire contents of the queue.",
        "suggest": "Ports 的要点是我们要丢弃队列的全部内容。",
        "translate": ""
    },
    {
        "source": "There are multiple reasons for having this property, the largest of which is that if another chan is waiting in this channel (but not received yet), then waiting on that port will cause a deadlock.",
        "suggest": "拥有此属性有多个原因，其中最大的原因是，如果另一个通道在此通道中等待 (但尚未收到)，则在该端口上等待将导致死锁。",
        "translate": ""
    },
    {
        "source": "So if we accept that we must now destroy the entire contents of the queue, this code may make a bit more sense.",
        "suggest": "因此，如果我们接受必须立即销毁队列的全部内容的代码，那么这段代码可能会更有意义。",
        "translate": ""
    },
    {
        "source": "The tricky part is that we can't let any in-flight sends go un-dropped, we have to make sure *everything* is dropped and nothing new will come onto the channel.",
        "suggest": "棘手的是，我们不能让任何正在进行的发送都被丢弃，我们必须确保所有内容都已丢弃，并且没有新内容进入通道。",
        "translate": ""
    },
    {
        "source": "The first thing we do is set a flag saying that we're done for.",
        "suggest": "我们要做的第一件事是设置一个标志，说我们已经完成了。",
        "translate": ""
    },
    {
        "source": "All sends are gated on this flag, so we're immediately guaranteed that there are a bounded number of active sends that we'll have to deal with.",
        "suggest": "所有发送都在此标志上进行门控，因此我们立即保证有一定数量的活动发送必须处理。",
        "translate": ""
    },
    {
        "source": "Now that we're guaranteed to deal with a bounded number of senders, we need to drain the queue.",
        "suggest": "现在确保可以处理一定数量的发送者，我们需要将队列 drain 处理。",
        "translate": ""
    },
    {
        "source": "This draining process happens atomically with respect to the \"count\" of the channel.",
        "suggest": "draining 过程相对于通道的 \"count\" 是原子发生的。",
        "translate": ""
    },
    {
        "source": "If the count is nonzero (with steals taken into account), then there must be data on the channel.",
        "suggest": "如果计数为非零 (考虑到窃取)，则通道上必须有数据。",
        "translate": ""
    },
    {
        "source": "In this case we drain everything and then try again.",
        "suggest": "在这种情况下，我们一切都 drain，然后重试。",
        "translate": ""
    },
    {
        "source": "We will continue to fail while active senders send data while we're dropping data, but eventually we're guaranteed to break out of this loop (because there is a bounded number of senders).",
        "suggest": "当主动发送方在丢弃数据的同时发送数据时，我们将继续失败，但最终我们肯定会打破这个循环 (因为发送方的数量是有限的)。",
        "translate": ""
    },
    {
        "source": "At this point in time, we have gated all future senders from sending, and we have flagged the channel as being disconnected.",
        "suggest": "此时，我们已禁止所有 future 发送者发送，并且已将通道标记为已断开连接。",
        "translate": ""
    },
    {
        "source": "The senders still have some responsibility, however, because some sends may not complete until after we flag the disconnection.",
        "suggest": "但是，发送者仍然要承担一些责任，因为有些发送可能要等到我们标记断开连接后才能完成。",
        "translate": ""
    },
    {
        "source": "There are more details in the sending methods that see DISCONNECTED",
        "suggest": "发送方法中有更多详细信息，请参见已断开连接",
        "translate": ""
    },
    {
        "source": "Removes a previous thread from being blocked in this port",
        "suggest": "删除先前的线程，使其不再被阻塞在该端口中",
        "translate": ""
    },
    {
        "source": "If we're aborting selection after upgrading from a oneshot, then we're guarantee that no one is waiting.",
        "suggest": "如果我们是从 oneshot 升级后终止选择，那么我们保证没有人在等待。",
        "translate": ""
    },
    {
        "source": "The only way that we could have seen the upgrade is if data was actually sent on the channel half again.",
        "suggest": "我们可以看到升级的唯一方法是，是否实际上又在通道上再次发送了数据。",
        "translate": ""
    },
    {
        "source": "For us, this means that there is guaranteed to be data on this channel.",
        "suggest": "对我们来说，这意味着该通道上肯定有数据。",
        "translate": ""
    },
    {
        "source": "Furthermore, we're guaranteed that there was no start_selection previously, so there's no need to modify `self.cnt` at all.",
        "suggest": "此外，我们保证以前没有 start_selection，因此根本不需要修改 `self.cnt`。",
        "translate": ""
    },
    {
        "source": "Hence, because of these invariants, we immediately return `Ok(true)`.",
        "suggest": "因此，由于这些不变性，我们立即返回 `Ok(true)`。",
        "translate": ""
    },
    {
        "source": "Note that the data may not actually be sent on the channel just yet.",
        "suggest": "请注意，数据可能尚未真正在通道上发送。",
        "translate": ""
    },
    {
        "source": "The other end could have flagged the upgrade but not sent data to this end.",
        "suggest": "另一端可能已经标记了升级，但没有向该端发送数据。",
        "translate": ""
    },
    {
        "source": "This is fine because we know it's a small bounded windows of time until the data is actually sent.",
        "suggest": "这很好，因为我们知道在实际发送数据之前，它的时间是有限的 windows。",
        "translate": ""
    },
    {
        "source": "We want to make sure that the count on the channel goes non-negative, and in the stream case we can have at most one steal, so just assume that we had one steal.",
        "suggest": "我们要确保通道上的计数为非负数，并且在流情况下，我们最多只能进行一次盗用，因此只需假设我们进行了一次盗用即可。",
        "translate": ""
    },
    {
        "source": "If we were previously disconnected, then we know for sure that there is no thread in to_wake, so just keep going",
        "suggest": "如果我们以前已经断开连接，那么我们可以肯定地知道 to_wake 中没有线程，因此只要继续",
        "translate": ""
    },
    {
        "source": "there is data, that data is that we're disconnected",
        "suggest": "有数据，就是我们断开了连接",
        "translate": ""
    },
    {
        "source": "If the previous count was negative, then we just made things go positive, hence we passed the -1 boundary and we're responsible for removing the to_wake() field and trashing it.",
        "suggest": "如果先前的计数为负，那么我们只是使结果为正，因此我们通过了 -1 边界，我们有责任删除 to_wake() 字段并将其丢弃。",
        "translate": ""
    },
    {
        "source": "If the previous count was positive then we're in a tougher situation.",
        "suggest": "如果以前的数字是正数，那么我们将处在更加艰难的境地。",
        "translate": ""
    },
    {
        "source": "A possible race is that a sender just incremented through -1 (meaning it's going to try to wake a thread up), but it hasn't yet read the to_wake.",
        "suggest": "一个可能的竞赛是发送方只是通过 -1 递增 (这意味着它将尝试唤醒线程)，但尚未读取 to_wake。",
        "translate": ""
    },
    {
        "source": "In order to prevent a future recv() from waking up too early (this sender picking up the plastered over to_wake), we spin loop here waiting for to_wake to be 0.",
        "suggest": "为了防止 future recv() 太早唤醒 (此发送者在 to_wake 上拾取了抹灰)，我们在此处旋转循环以等待 to_wake 为 0。",
        "translate": ""
    },
    {
        "source": "Note that this entire select() implementation needs an overhaul, and this is *not* the worst part of it, so this is not done as a final solution but rather out of necessity for now to get something working.",
        "suggest": "请注意，整个 select() 实现都需要大修，这并不是最坏的部分，因此，这并不是最终解决方案，而是出于使当前工作正常的需要。",
        "translate": ""
    },
    {
        "source": "if we were previously positive, then there's surely data to receive",
        "suggest": "如果我们以前是积极的，那么肯定会有数据要接收",
        "translate": ""
    },
    {
        "source": "Now that we've determined that this queue \"has data\", we peek at the queue to see if the data is an upgrade or not.",
        "suggest": "现在，我们确定该队列为 \"has data\"，我们将窥视该队列以查看数据是否为升级。",
        "translate": ""
    },
    {
        "source": "If it's an upgrade, then we need to destroy this port and abort selection on the upgraded port.",
        "suggest": "如果是升级，则需要销毁该端口并在升级的端口上终止选择。",
        "translate": ""
    },
    {
        "source": "Synchronous channels/ports",
        "suggest": "同步 channels/ports",
        "translate": ""
    },
    {
        "source": "This channel implementation differs significantly from the asynchronous implementations found next to it (oneshot/stream/share).",
        "suggest": "此通道实现与 (oneshot/stream/share) 旁边的异步实现有很大不同。",
        "translate": ""
    },
    {
        "source": "This is an implementation of a synchronous, bounded buffer channel.",
        "suggest": "这是同步有界缓冲区通道的实现。",
        "translate": ""
    },
    {
        "source": "Each channel is created with some amount of backing buffer, and sends will *block* until buffer space becomes available.",
        "suggest": "每个通道都创建有一定数量的后备缓冲区，并且发送将 *阻塞*，直到缓冲区空间可用为止。",
        "translate": ""
    },
    {
        "source": "A buffer size of 0 is valid, which means that every successful send is paired with a successful recv.",
        "suggest": "缓冲区大小为 0 是有效的，这意味着每个成功的发送都与一个成功的 recv 配对。",
        "translate": ""
    },
    {
        "source": "This flavor of channels defines a new `send_opt` method for channels which is the method by which a message is sent but the thread does not panic if it cannot be delivered.",
        "suggest": "这种通道风格为通道定义了一种新的 `send_opt` 方法，该方法用于发送消息，但是如果无法传递该消息，则该线程不会 panic。",
        "translate": ""
    },
    {
        "source": "Another major difference is that send() will *always* return back the data if it couldn't be sent.",
        "suggest": "另一个主要区别是，如果无法发送 send()，它将 *总是* 返回数据。",
        "translate": ""
    },
    {
        "source": "This is because it is deterministically known when the data is received and when it is not received.",
        "suggest": "这是因为确定性地知道何时接收数据以及何时不接收数据。",
        "translate": ""
    },
    {
        "source": "Implementation-wise, it can all be summed up with \"use a mutex plus some logic\".",
        "suggest": "在实现方面，可以全部用 \"use a mutex plus some logic\" 进行总结。",
        "translate": ""
    },
    {
        "source": "The mutex used here is an OS native mutex, meaning that no user code is run inside of the mutex (to prevent context switching).",
        "suggest": "此处使用的互斥锁是 OS 固有的互斥锁，这意味着互斥锁内部没有运行任何用户代码 (以防止上下文切换)。",
        "translate": ""
    },
    {
        "source": "This implementation shares almost all code for the buffered and unbuffered cases of a synchronous channel.",
        "suggest": "此实现几乎共享了同步通道的已缓冲和未缓冲情况的所有代码。",
        "translate": ""
    },
    {
        "source": "There are a few branches for the unbuffered case, but they're mostly just relevant to blocking senders.",
        "suggest": "对于无缓冲的情况，有一些分支，但它们大多与阻止发送者有关。",
        "translate": ""
    },
    {
        "source": "Only field outside of the mutex.",
        "suggest": "互斥锁之外的唯一字段。",
        "translate": ""
    },
    {
        "source": "Just done for kicks, but mainly because the other shared channel already had the code implemented",
        "suggest": "刚刚完成，但是主要是因为其他共享通道已经实现了代码",
        "translate": ""
    },
    {
        "source": "Is the channel disconnected yet?",
        "suggest": "通道是否断开连接?",
        "translate": ""
    },
    {
        "source": "queue of senders waiting to send data",
        "suggest": "等待发送数据的发送者队列",
        "translate": ""
    },
    {
        "source": "currently blocked thread on this channel",
        "suggest": "当前在此通道上被阻塞的线程",
        "translate": ""
    },
    {
        "source": "storage for buffered messages",
        "suggest": "缓冲消息的存储",
        "translate": ""
    },
    {
        "source": "capacity of this channel",
        "suggest": "该通道的容量",
        "translate": ""
    },
    {
        "source": "A curious flag used to indicate whether a sender failed or succeeded in blocking.",
        "suggest": "一个奇怪的标志，用于指示发送者是阻止还是成功阻止。",
        "translate": ""
    },
    {
        "source": "This is used to transmit information back to the thread that it must dequeue its message from the buffer because it was not received.",
        "suggest": "这用于将信息传输回线程，因为它没有被接收，因此它必须从缓冲区中将其消息出队。",
        "translate": ""
    },
    {
        "source": "This is only relevant in the 0-buffer case.",
        "suggest": "这仅在 0 缓冲区的情况下相关。",
        "translate": ""
    },
    {
        "source": "This obviously cannot be safely constructed, but it's guaranteed to always have a valid pointer value.",
        "suggest": "这显然不能安全地构造，但是可以保证始终具有有效的指针值。",
        "translate": ""
    },
    {
        "source": "Possible flavors of threads who can be blocked on this channel.",
        "suggest": "可能在此通道上被阻塞的线程的味道。",
        "translate": ""
    },
    {
        "source": "Simple queue for threading threads together.",
        "suggest": "将线程连接在一起的简单队列。",
        "translate": ""
    },
    {
        "source": "Nodes are stack-allocated, so this structure is not safe at all",
        "suggest": "节点是栈分配的，因此该结构体根本不安全",
        "translate": ""
    },
    {
        "source": "A simple ring-buffer",
        "suggest": "一个简单的环形缓冲区",
        "translate": ""
    },
    {
        "source": "Atomically blocks the current thread, placing it into `slot`, unlocking `lock` in the meantime.",
        "suggest": "以原子方式阻止当前线程，将其放入 `slot`，同时解锁 `lock`。",
        "translate": ""
    },
    {
        "source": "This re-locks the mutex upon returning.",
        "suggest": "返回时，重新锁定互斥锁。",
        "translate": ""
    },
    {
        "source": "Same as wait, but waiting at most until `deadline`.",
        "suggest": "与等待相同，但最多等到 `deadline`。",
        "translate": ""
    },
    {
        "source": "Wakes up a thread, dropping the lock at the correct time",
        "suggest": "唤醒线程，在正确的时间丢弃锁",
        "translate": ""
    },
    {
        "source": "We need to be careful to wake up the waiting thread *outside* of the mutex in case it incurs a context switch.",
        "suggest": "我们需要小心地唤醒互斥锁的等待线程 *外部*，以防其引起上下文切换。",
        "translate": ""
    },
    {
        "source": "wait until a send slot is available, returning locked access to the channel state.",
        "suggest": "等待发送槽可用，将锁定的访问返回到通道状态。",
        "translate": ""
    },
    {
        "source": "are we ready to go?",
        "suggest": "我们准备好出发了吗?",
        "translate": ""
    },
    {
        "source": "no room;",
        "suggest": "没地儿;",
        "translate": ""
    },
    {
        "source": "actually block",
        "suggest": "实际阻止",
        "translate": ""
    },
    {
        "source": "if our capacity is 0, then we need to wait for a receiver to be available to take our data.",
        "suggest": "如果我们的容量为 0，那么我们需要等待接收者可用以获取我们的数据。",
        "translate": ""
    },
    {
        "source": "After waiting, we check again to make sure the port didn't go away in the meantime.",
        "suggest": "等待之后，我们再次检查以确保在此期间端口没有消失。",
        "translate": ""
    },
    {
        "source": "If it did, we need to hand back our data.",
        "suggest": "如果确实如此，我们需要交出我们的数据。",
        "translate": ""
    },
    {
        "source": "success, we buffered some data",
        "suggest": "成功，我们缓冲了一些数据",
        "translate": ""
    },
    {
        "source": "success, someone's about to receive our buffered data.",
        "suggest": "成功，有人将要接收我们的缓冲数据。",
        "translate": ""
    },
    {
        "source": "With capacity 0, even though we have buffer space we can't transfer the data unless there's a receiver waiting.",
        "suggest": "容量为 0 时，即使我们有缓冲区空间，我们也无法传输数据，除非有接收者在等待。",
        "translate": ""
    },
    {
        "source": "If the buffer has some space and the capacity isn't 0, then we just enqueue the data for later retrieval, ensuring to wake up any blocked receiver if there is one.",
        "suggest": "如果缓冲区有一些空间并且容量不为 0，则我们只是将数据放入队列以供以后检索，以确保在有阻塞的接收者的情况下将其唤醒。",
        "translate": ""
    },
    {
        "source": "Receives a message from this channel",
        "suggest": "接收来自此通道的消息",
        "translate": ""
    },
    {
        "source": "When reading this, remember that there can only ever be one receiver at time.",
        "suggest": "阅读本文时，请记住，一次只能有一个接收者。",
        "translate": ""
    },
    {
        "source": "Wait for the buffer to have something in it.",
        "suggest": "等待缓冲区中有东西。",
        "translate": ""
    },
    {
        "source": "No need for a while loop because we're the only receiver.",
        "suggest": "不需要 while 循环，因为我们是唯一的接收者。",
        "translate": ""
    },
    {
        "source": "N.B., channel could be disconnected while waiting, so the order of these conditionals is important.",
        "suggest": "注意，通道在等待时可能会断开连接，因此这些条件的顺序很重要。",
        "translate": ""
    },
    {
        "source": "Pick up the data, wake up our neighbors, and carry on",
        "suggest": "收集数据，唤醒我们的邻居，然后继续",
        "translate": ""
    },
    {
        "source": "Easy cases first",
        "suggest": "简单的案例优先",
        "translate": ""
    },
    {
        "source": "Be sure to wake up neighbors",
        "suggest": "一定要叫醒邻居",
        "translate": ""
    },
    {
        "source": "Wake up pending senders after some data has been received",
        "suggest": "收到一些数据后唤醒未决的发送者",
        "translate": ""
    },
    {
        "source": "flag if the receiver blocked to receive some data, or if it just picked up some data on the way out",
        "suggest": "如果接收者被阻止接收某些数据，或者在出路时刚刚拾取了一些数据，则进行标记",
        "translate": ""
    },
    {
        "source": "the lock guard that is held over this channel's lock",
        "suggest": "保留在此通道的锁上的锁卫",
        "translate": ""
    },
    {
        "source": "If this is a no-buffer channel (cap == 0), then if we didn't wait we need to ACK the sender.",
        "suggest": "如果这是一个无缓冲区的通道 (cap == 0)，则如果我们不等待，则需要对发送方进行 ACK。",
        "translate": ""
    },
    {
        "source": "If we waited, then the sender waking us up was already the ACK.",
        "suggest": "如果我们等待，则唤醒我们的发送者已经是 ACK。",
        "translate": ""
    },
    {
        "source": "only outside of the lock do we wake up the pending threads",
        "suggest": "只有在锁之外，我们才能唤醒挂起的线程",
        "translate": ""
    },
    {
        "source": "Only flag the channel as disconnected if we're the last channel",
        "suggest": "如果我们是最后一个通道，则仅将通道标记为已断开连接",
        "translate": ""
    },
    {
        "source": "Not much to do other than wake up a receiver if one's there",
        "suggest": "除了可以唤醒接收者以外，别无他法",
        "translate": ""
    },
    {
        "source": "If the capacity is 0, then the sender may want its data back after we're disconnected.",
        "suggest": "如果容量为 0，则在我们断开连接后，发送方可能希望返回其数据。",
        "translate": ""
    },
    {
        "source": "Otherwise it's now our responsibility to destroy the buffered data.",
        "suggest": "否则，现在我们有责任销毁缓冲的数据。",
        "translate": ""
    },
    {
        "source": "As with many other portions of this code, this needs to be careful to destroy the data *outside* of the lock to prevent deadlock.",
        "suggest": "与该代码的许多其他部分一样，需要小心地销毁锁外部的数据，以防止死锁。",
        "translate": ""
    },
    {
        "source": "Buffer, a simple ring buffer backed by Vec<T>",
        "suggest": "缓冲区，由 Vec<T> 支持的简单环形缓冲区",
        "translate": ""
    },
    {
        "source": "Queue, a simple queue to enqueue threads with (stack-allocated nodes)",
        "suggest": "队列，一个简单的队列，用于使线程排队 (栈分配的节点)",
        "translate": ""
    },
    {
        "source": "Simple test of closing without sending",
        "suggest": "简单的关闭测试，无需发送",
        "translate": ""
    },
    {
        "source": "Testing that the sender cleans up the payload if receiver is closed",
        "suggest": "如果接收方关闭，则测试发送方清除有效载荷",
        "translate": ""
    },
    {
        "source": "Receiving on a closed chan will panic",
        "suggest": "panic 在一个封闭的通道上接收",
        "translate": ""
    },
    {
        "source": "What is our res?",
        "suggest": "我们的资源是什么?",
        "translate": ""
    },
    {
        "source": "Regression test that we don't run out of stack in scheduler context",
        "suggest": "在调度程序上下文中我们不会耗尽栈的回归测试",
        "translate": ""
    },
    {
        "source": "This bug used to end up in a livelock inside of the Receiver destructor because the internal state of the Shared packet was corrupted",
        "suggest": "由于共享数据包的内部状态已损坏，该错误曾经以接收者析构函数内部的活动锁结束",
        "translate": ""
    },
    {
        "source": "wait on a oneshot",
        "suggest": "等待一个人",
        "translate": ""
    },
    {
        "source": "destroy a shared",
        "suggest": "销毁共享",
        "translate": ""
    },
    {
        "source": "make sure the other thread has gone to sleep",
        "suggest": "确保其他线程已经进入睡眠状态",
        "translate": ""
    },
    {
        "source": "upgrade to a shared chan and send a message",
        "suggest": "升级到共享频道并发送消息",
        "translate": ""
    },
    {
        "source": "wait for the child thread to exit before we exit",
        "suggest": "等待子线程退出，然后再退出",
        "translate": ""
    },
    {
        "source": "Request `x`s until we have `6`.",
        "suggest": "请求 `x` 直到我们拥有 `6`。",
        "translate": ""
    },
    {
        "source": "wait until parent gets in",
        "suggest": "等到 parent 进来",
        "translate": ""
    },
    {
        "source": "Parent should fail when it wakes up.",
        "suggest": "parent 醒来后应该会失败。",
        "translate": ""
    },
    {
        "source": "Tests nested mutexes and access to underlying data.",
        "suggest": "测试嵌套的互斥锁和对基础数据的访问。",
        "translate": ""
    },
    {
        "source": "Spawn a few threads to increment a shared variable (non-atomically), and let the main thread know once all increments are done.",
        "suggest": "Spawn 几个线程用于递增共享变量 (non-atomically)，并在完成所有递增操作后让主线程知道。",
        "translate": ""
    },
    {
        "source": "Here we're using an Arc to share memory among threads, and the data inside the Arc is protected with a mutex.",
        "suggest": "在这里，我们使用 Arc 在线程之间共享内存，并且 Arc 中的数据受到互斥锁的保护。",
        "translate": ""
    },
    {
        "source": "The shared state can only be accessed once the lock is held.",
        "suggest": "只有持有锁后，才能访问共享状态。",
        "translate": ""
    },
    {
        "source": "Our non-atomic increment is safe because we're the only thread which can access the shared state when the lock is held.",
        "suggest": "我们的非原子增量是安全的，因为当持有锁时，我们是唯一可以访问共享状态的线程。",
        "translate": ""
    },
    {
        "source": "We unwrap() the return value to assert that we are not expecting threads to ever fail while holding the lock.",
        "suggest": "我们用 unwrap() 的返回值来断言，我们不希望线程在持有锁的同时失败。",
        "translate": ""
    },
    {
        "source": "the lock is unlocked here when `data` goes out of scope.",
        "suggest": "`data` 离开作用域时，此处的锁已解锁。",
        "translate": ""
    },
    {
        "source": "This thread will acquire the mutex first, unwrapping the result of `lock` because the lock has not been poisoned.",
        "suggest": "该线程将首先获取互斥锁，因为该锁尚未中毒，所以将解开 `lock` 的结果。",
        "translate": ""
    },
    {
        "source": "This panic while holding the lock (`_guard` is in scope) will poison the mutex.",
        "suggest": "按住锁 (`_guard` 在作用域中) 时，此 panic 将中毒互斥锁。",
        "translate": ""
    },
    {
        "source": "The lock is poisoned by this point, but the returned result can be pattern matched on to return the underlying guard on both branches.",
        "suggest": "到此为止，锁定都会中毒，但是可以对返回的结果进行模式匹配，以返回两个分支上的基础防护。",
        "translate": ""
    },
    {
        "source": "This is the result of some important and long-ish work.",
        "suggest": "这是一些重要而长期的工作的结果。",
        "translate": ""
    },
    {
        "source": "We drop the `data` explicitly because it's not necessary anymore and the thread still has work to do.",
        "suggest": "我们明确丢弃 `data`，因为不再需要 `data`，并且线程仍然有工作要做。",
        "translate": ""
    },
    {
        "source": "This allow other threads to start working on the data immediately, without waiting for the rest of the unrelated work to be done here.",
        "suggest": "这允许其他线程立即开始处理数据，而无需等待其余无关工作在这里完成。",
        "translate": ""
    },
    {
        "source": "It's even more important here than in the threads because we `.join` the threads after that.",
        "suggest": "它在这里比在线程中更重要，因为在此之后我们对线程进行 `.join` 处理。",
        "translate": ""
    },
    {
        "source": "If we had not dropped the mutex guard, a thread could be waiting forever for it, causing a deadlock.",
        "suggest": "如果我们没有丢弃互斥锁守卫，则线程可能会永远等待它，从而导致死锁。",
        "translate": ""
    },
    {
        "source": "Here the mutex guard is not assigned to a variable and so, even if the scope does not end after this line, the mutex is still released: there is no deadlock.",
        "suggest": "这里互斥锁防护未分配给变量，因此，即使作用域在此行之后没有结束，互斥锁仍被释放: 没有死锁。",
        "translate": ""
    },
    {
        "source": "the mutex gets poisoned",
        "suggest": "互斥锁中毒",
        "translate": ""
    },
    {
        "source": "A mutual exclusion primitive useful for protecting shared data",
        "suggest": "互斥原语可用于保护共享数据",
        "translate": ""
    },
    {
        "source": "This mutex will block threads waiting for the lock to become available.",
        "suggest": "此互斥锁将阻止等待锁可用的线程。",
        "translate": ""
    },
    {
        "source": "The mutex can also be statically initialized or created via a [`new`] constructor.",
        "suggest": "互斥锁也可以通过 [`new`] 构造函数进行静态初始化或创建。",
        "translate": ""
    },
    {
        "source": "Each mutex has a type parameter which represents the data that it is protecting.",
        "suggest": "每个互斥锁都有一个类型参数，表示它正在保护的数据。",
        "translate": ""
    },
    {
        "source": "The data can only be accessed through the RAII guards returned from [`lock`] and [`try_lock`], which guarantees that the data is only ever accessed when the mutex is locked.",
        "suggest": "只能通过从 [`lock`] 和 [`try_lock`] 返回的 RAII 保护来访问数据，这保证了只有在互斥锁被锁定时才可以访问数据。",
        "translate": ""
    },
    {
        "source": "The mutexes in this module implement a strategy called \"poisoning\" where a mutex is considered poisoned whenever a thread panics while holding the mutex.",
        "suggest": "此模块中的互斥锁实现了一种称为 \"poisoning\" 的策略，只要线程 panics 按住互斥锁，互斥锁就会被视为中毒。",
        "translate": ""
    },
    {
        "source": "Once a mutex is poisoned, all other threads are unable to access the data by default as it is likely tainted (some invariant is not being upheld).",
        "suggest": "一旦互斥锁中毒，默认情况下，所有其他线程都无法访问数据，因为它很可能已被污染 (某些不变性未得到维护)。",
        "translate": ""
    },
    {
        "source": "For a mutex, this means that the [`lock`] and [`try_lock`] methods return a [`Result`] which indicates whether a mutex has been poisoned or not.",
        "suggest": "对于互斥锁，这意味着 [`lock`] 和 [`try_lock`] 方法返回一个 [`Result`]，该 [`Result`] 指示互斥锁是否已中毒。",
        "translate": ""
    },
    {
        "source": "Most usage of a mutex will simply [`unwrap()`] these results, propagating panics among threads to ensure that a possibly invalid invariant is not witnessed.",
        "suggest": "互斥锁的大多数用法将只是 [`unwrap()`] 这些结果，从而在线程之间传播 panics 以确保不会看到可能无效的不变式。",
        "translate": ""
    },
    {
        "source": "A poisoned mutex, however, does not prevent all access to the underlying data.",
        "suggest": "但是，中毒的互斥锁不会阻止对底层数据的所有访问。",
        "translate": ""
    },
    {
        "source": "The [`PoisonError`] type has an [`into_inner`] method which will return the guard that would have otherwise been returned on a successful lock.",
        "suggest": "[`PoisonError`] 类型具有 [`into_inner`] 方法，该方法将返回保护，否则将在成功锁定后返回该保护。",
        "translate": ""
    },
    {
        "source": "This allows access to the data, despite the lock being poisoned.",
        "suggest": "尽管锁被中毒，这仍允许访问数据。",
        "translate": ""
    },
    {
        "source": "To recover from a poisoned mutex:",
        "suggest": "要从中毒的互斥锁中恢复:",
        "translate": ""
    },
    {
        "source": "It is sometimes necessary to manually drop the mutex guard to unlock it sooner than the end of the enclosing scope.",
        "suggest": "时需要手动丢弃互斥锁守卫，以便在封闭作用域结束之前将其解锁。",
        "translate": ""
    },
    {
        "source": "these are the only places where `T: Send` matters;",
        "suggest": "这些是 `T: Send` 唯一重要的地方;",
        "translate": ""
    },
    {
        "source": "all other functionality works fine on a single thread.",
        "suggest": "所有其他功能都可以在单个线程上正常运行。",
        "translate": ""
    },
    {
        "source": "An RAII implementation of a \"scoped lock\" of a mutex.",
        "suggest": "互斥锁的 \"scoped lock\" 的 RAII 实现。",
        "translate": ""
    },
    {
        "source": "When this structure is dropped (falls out of scope), the lock will be unlocked.",
        "suggest": "当此结构体被丢弃 (离开作用域) 时，这个锁将被解锁。",
        "translate": ""
    },
    {
        "source": "The data protected by the mutex can be accessed through this guard via its [`Deref`] and [`DerefMut`] implementations.",
        "suggest": "可以通过此防护程序通过其 [`Deref`] 和 [`DerefMut`] 实现来访问受互斥锁保护的数据。",
        "translate": ""
    },
    {
        "source": "This structure is created by the [`lock`] and [`try_lock`] methods on [`Mutex`].",
        "suggest": "该结构体由 [`Mutex`] 上的 [`lock`] 和 [`try_lock`] 方法创建。",
        "translate": ""
    },
    {
        "source": "Creates a new mutex in an unlocked state ready for use.",
        "suggest": "在解锁状态下创建一个新的互斥锁，以备使用。",
        "translate": ""
    },
    {
        "source": "Immediately drops the guard, and consequently unlocks the mutex.",
        "suggest": "立即丢弃这个守卫，从而解锁互斥锁。",
        "translate": ""
    },
    {
        "source": "This function is equivalent to calling [`drop`] on the guard but is more self-documenting.",
        "suggest": "此函数等效于在守卫上调用 [`drop`]，但更具自记录性。",
        "translate": ""
    },
    {
        "source": "Alternately, the guard will be automatically dropped when it goes out of scope.",
        "suggest": "或者，守卫离开作用域时将自动丢弃。",
        "translate": ""
    },
    {
        "source": "Acquires a mutex, blocking the current thread until it is able to do so.",
        "suggest": "获取一个互斥锁，阻塞当前线程，直到能够这样做为止。",
        "translate": ""
    },
    {
        "source": "This function will block the local thread until it is available to acquire the mutex.",
        "suggest": "该函数将阻塞本地线程，直到可用于获取互斥锁为止。",
        "translate": ""
    },
    {
        "source": "Upon returning, the thread is the only thread with the lock held.",
        "suggest": "返回时，该线程是唯一持有锁的线程。",
        "translate": ""
    },
    {
        "source": "An RAII guard is returned to allow scoped unlock of the lock.",
        "suggest": "返回了 RAII 守卫，以允许对锁进行一定范围的解锁。",
        "translate": ""
    },
    {
        "source": "When the guard goes out of scope, the mutex will be unlocked.",
        "suggest": "当守卫离开作用域时，互斥锁将被解锁。",
        "translate": ""
    },
    {
        "source": "The exact behavior on locking a mutex in the thread which already holds the lock is left unspecified.",
        "suggest": "未指定将互斥锁锁定在已经持有该锁的线程中的确切行为。",
        "translate": ""
    },
    {
        "source": "However, this function will not return on the second call (it might panic or deadlock, for example).",
        "suggest": "但是，该函数不会在第二次调用时返回 (例如，可能为 panic 或死锁)。",
        "translate": ""
    },
    {
        "source": "If another user of this mutex panicked while holding the mutex, then this call will return an error once the mutex is acquired.",
        "suggest": "如果互斥锁的另一个用户在握住互斥锁时恐慌，则一旦获取互斥锁，此调用将返回错误。",
        "translate": ""
    },
    {
        "source": "This function might panic when called if the lock is already held by the current thread.",
        "suggest": "如果当前线程已锁定，则调用此函数时可能为 panic。",
        "translate": ""
    },
    {
        "source": "Attempts to acquire this lock.",
        "suggest": "尝试获取此锁。",
        "translate": ""
    },
    {
        "source": "If the lock could not be acquired at this time, then [`Err`] is returned.",
        "suggest": "如果此时无法获取锁，则返回 [`Err`]。",
        "translate": ""
    },
    {
        "source": "Otherwise, an RAII guard is returned.",
        "suggest": "否则，将返回 RAII 守卫。",
        "translate": ""
    },
    {
        "source": "The lock will be unlocked when the guard is dropped.",
        "suggest": "当守卫被丢弃时，锁将被解锁。",
        "translate": ""
    },
    {
        "source": "This function does not block.",
        "suggest": "该函数不会阻止。",
        "translate": ""
    },
    {
        "source": "If another user of this mutex panicked while holding the mutex, then this call will return an error if the mutex would otherwise be acquired.",
        "suggest": "如果此互斥锁的另一个用户在握住互斥锁时恐慌，那么如果以其他方式获取互斥锁，则此调用将返回错误。",
        "translate": ""
    },
    {
        "source": "Determines whether the mutex is poisoned.",
        "suggest": "确定互斥锁是否中毒。",
        "translate": ""
    },
    {
        "source": "If another thread is active, the mutex can still become poisoned at any time.",
        "suggest": "如果另一个线程处于活动状态，则互斥锁仍可随时中毒。",
        "translate": ""
    },
    {
        "source": "You should not trust a `false` value for program correctness without additional synchronization.",
        "suggest": "如果没有其他同步，则不应信任 `false` 值来确保程序正确性。",
        "translate": ""
    },
    {
        "source": "Consumes this mutex, returning the underlying data.",
        "suggest": "使用此互斥锁，返回基础数据。",
        "translate": ""
    },
    {
        "source": "If another user of this mutex panicked while holding the mutex, then this call will return an error instead.",
        "suggest": "如果此互斥锁的另一个用户在按住互斥锁时恐慌，则此调用将返回错误。",
        "translate": ""
    },
    {
        "source": "We know statically that there are no outstanding references to `self` so there's no need to lock the inner mutex.",
        "suggest": "我们静态地知道 `self` 没有未完成引用，因此不需要锁定内部的互斥锁。",
        "translate": ""
    },
    {
        "source": "To get the inner value, we'd like to call `data.into_inner()`, but because `Mutex` impl-s `Drop`, we can't move out of it, so we'll have to destructure it manually instead.",
        "suggest": "为了获得内部值，我们想调用 `data.into_inner()`，但是由于 `Mutex` impl-s `Drop`，我们不能将其移出，因此我们必须手动解构它。",
        "translate": ""
    },
    {
        "source": "Like `let Mutex { inner, poison, data } = self`.",
        "suggest": "像 `let Mutex { inner, poison, data } = self`。",
        "translate": ""
    },
    {
        "source": "Since this call borrows the `Mutex` mutably, no actual locking needs to take place -- the mutable borrow statically guarantees no locks exist.",
        "suggest": "由于此调用借用 `Mutex` 是可变的，因此不需要进行实际的锁定 - 可变借用可以静态地保证不存在任何锁定。",
        "translate": ""
    },
    {
        "source": "This is equivalent to [`Mutex::new`].",
        "suggest": "这等效于 [`Mutex::new`]。",
        "translate": ""
    },
    {
        "source": "Creates a `Mutex<T>`, with the `Default` value for T.",
        "suggest": "创建一个 `Mutex<T>`，其 T 值为 `Default`。",
        "translate": ""
    },
    {
        "source": "poison the once",
        "suggest": "中毒一次",
        "translate": ""
    },
    {
        "source": "poisoning propagates",
        "suggest": "中毒传播",
        "translate": ""
    },
    {
        "source": "we can subvert poisoning, however",
        "suggest": "我们可以颠覆中毒，但是",
        "translate": ""
    },
    {
        "source": "once any success happens, we stop propagating the poison",
        "suggest": "一旦成功，我们就停止传播毒药",
        "translate": ""
    },
    {
        "source": "make sure someone's waiting inside the once via a force",
        "suggest": "确保有人通过武力一次在里面等待",
        "translate": ""
    },
    {
        "source": "put another waiter on the once",
        "suggest": "让另一个等待者来一次",
        "translate": ""
    },
    {
        "source": "run initialization here",
        "suggest": "在这里运行初始化",
        "translate": ""
    },
    {
        "source": "Accessing a `static mut` is unsafe much of the time, but if we do so in a synchronized fashion (e.g., write once or read all) then we're good to go!",
        "suggest": "在很多情况下，访问 `static mut` 是不安全的，但是如果我们以同步方式进行操作 (例如，一次写入或全部读取)，那么我们就可以开始了!",
        "translate": ""
    },
    {
        "source": "This function will only call `expensive_computation` once, and will otherwise always return the value returned from the first invocation.",
        "suggest": "此函数将只调用一次 `expensive_computation`，否则将始终返回从第一次调用返回的值。",
        "translate": ""
    },
    {
        "source": "call_once_force will still run and reset the poisoned state",
        "suggest": "call_once_force 仍将运行并重置中毒状态",
        "translate": ""
    },
    {
        "source": "A \"once initialization\" primitive",
        "suggest": "\"一次初始化\" 原语",
        "translate": ""
    },
    {
        "source": "This primitive is meant to be used to run one-time initialization.",
        "suggest": "该原语旨在用于运行一次性初始化。",
        "translate": ""
    },
    {
        "source": "An example use case would be for initializing an FFI library.",
        "suggest": "一个示例用例将是初始化 FFI 库。",
        "translate": ""
    },
    {
        "source": "A \"once\" is a relatively simple primitive, and it's also typically provided by the OS as well (see `pthread_once` or `InitOnceExecuteOnce`).",
        "suggest": "\"once\" 是一个相对简单的原语，通常也由操作系统提供 (请参见 `pthread_once` 或 `InitOnceExecuteOnce`)。",
        "translate": ""
    },
    {
        "source": "The OS primitives, however, tend to have surprising restrictions, such as the Unix one doesn't allow an argument to be passed to the function.",
        "suggest": "但是，操作系统原语往往具有令人惊讶的限制，例如 Unix 不允许将参数传递给函数。",
        "translate": ""
    },
    {
        "source": "As a result, we end up implementing it ourselves in the standard library.",
        "suggest": "结果，我们最终在标准库中自己实现了它。",
        "translate": ""
    },
    {
        "source": "This also gives us the opportunity to optimize the implementation a bit which should help the fast path on call sites.",
        "suggest": "这也为我们提供了优化实现的机会，这将有助于在调用站点上实现快速路径。",
        "translate": ""
    },
    {
        "source": "Consequently, let's explain how this primitive works now!",
        "suggest": "因此，让我们解释一下该原语现在是如何工作的!",
        "translate": ""
    },
    {
        "source": "So to recap, the guarantees of a Once are that it will call the initialization closure at most once, and it will never return until the one that's running has finished running.",
        "suggest": "因此，回顾一下，一次的保证是它将最多调用一次初始化闭包，并且直到运行的那个完成运行后它才会返回。",
        "translate": ""
    },
    {
        "source": "This means that we need some form of blocking here while the custom callback is running at the very least.",
        "suggest": "这意味着，至少在自定义回调运行时，我们需要在此处进行某种形式的阻塞。",
        "translate": ""
    },
    {
        "source": "Additionally, we add on the restriction of **poisoning**.",
        "suggest": "此外，我们增加了中毒的限制。",
        "translate": ""
    },
    {
        "source": "Whenever an initialization closure panics, the Once enters a \"poisoned\" state which means that all future calls will immediately panic as well.",
        "suggest": "每当初始化闭包 panics 时，`Once` 都会进入 \"poisoned\" 状态，这意味着所有 future 调用也将立即变为 panic。",
        "translate": ""
    },
    {
        "source": "So to implement this, one might first reach for a `Mutex`, but those cannot be put into a `static`.",
        "suggest": "因此，要实现此目的，可能首先需要购买 `Mutex`，但不能将其放入 `static`。",
        "translate": ""
    },
    {
        "source": "It also gets a lot harder with poisoning to figure out when the mutex needs to be deallocated because it's not after the closure finishes, but after the first successful closure finishes.",
        "suggest": "通过中毒来确定何时需要释放互斥锁也会变得更加困难，因为它不是在闭包结束之后，而是在第一个成功的闭包结束之后。",
        "translate": ""
    },
    {
        "source": "All in all, this is instead implemented with atomics and lock-free operations!",
        "suggest": "总而言之，这是通过原子和无锁操作实现的!",
        "translate": ""
    },
    {
        "source": "Whee! Each `Once` has one word of atomic state, and this state is CAS'd on to determine what to do.",
        "suggest": "呜! 每个 `Once` 都有一个原子状态的字，此状态已通过 CAS 确定要做什么。",
        "translate": ""
    },
    {
        "source": "There are four possible state of a `Once`:",
        "suggest": "`Once` 有四种可能的状态:",
        "translate": ""
    },
    {
        "source": "Incomplete - no initialization has run yet, and no thread is currently using the Once.",
        "suggest": "未完成 - 尚未运行任何初始化，并且当前没有线程在使用 `Once`。",
        "translate": ""
    },
    {
        "source": "Poisoned - some thread has previously attempted to initialize the Once, but it panicked, so the Once is now poisoned.",
        "suggest": "中毒 - 一些线程之前尝试初始化 `Once`，但是它 panic 了，所以 `Once` 现在是中毒的。",
        "translate": ""
    },
    {
        "source": "There are no other threads currently accessing this Once.",
        "suggest": "当前没有其他线程访问此一次。",
        "translate": ""
    },
    {
        "source": "Running - some thread is currently attempting to run initialization.",
        "suggest": "正在运行 - 某些线程当前正在尝试运行初始化。",
        "translate": ""
    },
    {
        "source": "It may succeed, so all future threads need to wait for it to finish.",
        "suggest": "它可能会成功，因此所有 future 线程都需要等待它完成。",
        "translate": ""
    },
    {
        "source": "Note that this state is accompanied with a payload, described below.",
        "suggest": "注意，该状态伴随有有效载荷，如下所述。",
        "translate": ""
    },
    {
        "source": "Complete - initialization has completed and all future calls should finish immediately.",
        "suggest": "完成 - 初始化已完成，所有 future 调用应立即完成。",
        "translate": ""
    },
    {
        "source": "With 4 states we need 2 bits to encode this, and we use the remaining bits in the word we have allocated as a queue of threads waiting for the thread responsible for entering the RUNNING state.",
        "suggest": "对于 4 种状态，我们需要 2 位来对此进行编码，并且我们将已分配的字中的其余位用作线程队列，等待负责进入 RUNNING 状态的线程。",
        "translate": ""
    },
    {
        "source": "This queue is just a linked list of Waiter nodes which is monotonically increasing in size.",
        "suggest": "该队列只是一个 Waiter 节点的链表，其大小单调增加。",
        "translate": ""
    },
    {
        "source": "Each node is allocated on the stack, and whenever the running closure finishes it will consume the entire queue and notify all waiters they should try again.",
        "suggest": "每个节点都分配在栈上，并且每当运行的闭包完成时，它将消耗整个队列，并通知所有等待者他们应再次尝试。",
        "translate": ""
    },
    {
        "source": "You'll find a few more details in the implementation, but that's the gist of it!",
        "suggest": "您会在实现中找到更多细节，但这就是要点!",
        "translate": ""
    },
    {
        "source": "Atomic orderings:",
        "suggest": "原子顺序:",
        "translate": ""
    },
    {
        "source": "When running `Once` we deal with multiple atomics:",
        "suggest": "当运行 `Once` 时，我们处理多个原子:",
        "translate": ""
    },
    {
        "source": "and an unknown number of `Waiter.signaled`.",
        "suggest": "和未知数量的 `Waiter.signaled`。",
        "translate": ""
    },
    {
        "source": "is used (1) as a state flag, (2) for synchronizing the result of the `Once`, and (3) for synchronizing `Waiter` nodes.",
        "suggest": "使用 (1) 作为状态标志，使用 (2) 同步 `Once` 的结果，使用 (3) 同步 `Waiter` 节点。",
        "translate": ""
    },
    {
        "source": "At the end of the `call_inner` function we have to make sure the result of the `Once` is acquired.",
        "suggest": "在 `call_inner` 函数的末尾，我们必须确保已获取 `Once` 的结果。",
        "translate": ""
    },
    {
        "source": "So every load which can be the only one to load COMPLETED must have at least Acquire ordering, which means all three of them.",
        "suggest": "因此，可能是唯一要加载完成的负载，每个负载都必须至少具有获取顺序，这意味着它们全部都是三个。",
        "translate": ""
    },
    {
        "source": "is the only place that may store COMPLETED, and must do so with Release ordering to make the result available.",
        "suggest": "是唯一可以存储 COMPLETED 的位置，并且必须使用 Release 排序来存储结果，以使结果可用。",
        "translate": ""
    },
    {
        "source": "inserts `Waiter` nodes as a pointer in `state_and_queue`, and needs to make the nodes available with Release ordering.",
        "suggest": "在 `state_and_queue` 中插入 `Waiter` 节点作为指针，并且需要使节点可用 Release 排序。",
        "translate": ""
    },
    {
        "source": "The load in its `compare_exchange` can be Relaxed because it only has to compare the atomic, not to read other data.",
        "suggest": "`compare_exchange` 中的负载可以放宽，因为它只需要比较原子，而不必读取其他数据。",
        "translate": ""
    },
    {
        "source": "must see the `Waiter` nodes, so it must load `state_and_queue` with Acquire ordering.",
        "suggest": "必须看到 `Waiter` 节点，因此它必须以 Acquire 顺序加载 `state_and_queue`。",
        "translate": ""
    },
    {
        "source": "There is just one store where `state_and_queue` is used only as a state flag, without having to synchronize data: switching the state from INCOMPLETE to RUNNING in `call_inner`.",
        "suggest": "只有一个存储区，其中 `state_and_queue` 仅用作状态标志，而不必同步数据: 在 `call_inner` 中将状态从 INCOMPLETE 切换为 RUNNING。",
        "translate": ""
    },
    {
        "source": "This store can be Relaxed, but the read has to be Acquire because of the requirements mentioned above.",
        "suggest": "这个 store 可以是 Relaxed，但是 read 必须是 Acquire，因为上面提到的要求。",
        "translate": ""
    },
    {
        "source": "is both used as a flag, and to protect a field with interior mutability in `Waiter`.",
        "suggest": "既用作标志，又用于保护 `Waiter` 中具有内部可变性的字段。",
        "translate": ""
    },
    {
        "source": "is changed in `WaiterQueue::Drop` which then sets `signaled` with Release ordering.",
        "suggest": "在 `WaiterQueue::Drop` 中进行更改，然后使用发布顺序设置 `signaled`。",
        "translate": ""
    },
    {
        "source": "After `wait` loads `signaled` with Acquire and sees it is true, it needs to see the changes to drop the `Waiter` struct correctly.",
        "suggest": "`wait` 用 Acquire 加载 `signaled` 后，如果发现它是正确的，则需要查看更改以正确放置 `Waiter` 结构体。",
        "translate": ""
    },
    {
        "source": "There is one place where the two atomics `Once.state_and_queue` and `Waiter.signaled` come together, and might be reordered by the compiler or processor.",
        "suggest": "在一个地方，两个原子 `Once.state_and_queue` 和 `Waiter.signaled` 在一起，并且可能由编译器或处理器重新排序。",
        "translate": ""
    },
    {
        "source": "Because both use Acquire ordering such a reordering is not allowed, so no need for SeqCst.",
        "suggest": "因为两者都使用 Acquire 排序，所以不允许这样的重新排序，因此不需要 SeqCst。",
        "translate": ""
    },
    {
        "source": "A synchronization primitive which can be used to run a one-time global initialization.",
        "suggest": "同步原语，可用于运行一次性初始化。",
        "translate": ""
    },
    {
        "source": "Useful for one-time initialization for FFI or related functionality.",
        "suggest": "对于 FFI 或相关功能的一次性初始化很有用。",
        "translate": ""
    },
    {
        "source": "This type can only be constructed with [`Once::new()`].",
        "suggest": "该类型只能用 [`Once::new()`] 构造。",
        "translate": ""
    },
    {
        "source": "is actually a pointer to a `Waiter` with extra state bits, so we add the `PhantomData` appropriately.",
        "suggest": "实际上是指向带有额外状态位的 `Waiter` 的指针，因此我们适当地添加了 `PhantomData`。",
        "translate": ""
    },
    {
        "source": "The `PhantomData` of a raw pointer removes these two auto traits, but we enforce both below in the implementation so this should be safe to add.",
        "suggest": "裸指针的 `PhantomData` 删除了这两个自动 traits，但是我们在实现中强制执行以下两项，因此添加起来应该很安全。",
        "translate": ""
    },
    {
        "source": "State yielded to [`Once::call_once_force()`]’s closure parameter.",
        "suggest": "状态产生于 [`Once::call_once_force () `] 的闭包参数。",
        "translate": ""
    },
    {
        "source": "The state can be used to query the poison status of the [`Once`].",
        "suggest": "该状态可用于查询 [`Once`] 的中毒状态。",
        "translate": ""
    },
    {
        "source": "Initialization value for static [`Once`] values.",
        "suggest": "静态 [`Once`] 值的初始化值。",
        "translate": ""
    },
    {
        "source": "Four states that a Once can be in, encoded into the lower bits of `state_and_queue` in the Once structure.",
        "suggest": "一次可以进入的四个状态，被编码为一次结构体中 `state_and_queue` 的低位。",
        "translate": ""
    },
    {
        "source": "Mask to learn about the state.",
        "suggest": "隐含的了解状态。",
        "translate": ""
    },
    {
        "source": "All other bits are the queue of waiters if this is in the RUNNING state.",
        "suggest": "如果其他所有位都处于 RUNNING 状态，则它们都是等待者的队列。",
        "translate": ""
    },
    {
        "source": "Representation of a node in the linked list of waiters, used while in the RUNNING state.",
        "suggest": "处于 RUNNING 状态时使用的等待者的链表中的节点表示。",
        "translate": ""
    },
    {
        "source": "`Waiter` can't hold a mutable pointer to the next thread, because then `wait` would both hand out a mutable reference to its `Waiter` node, and keep a shared reference to check `signaled`.",
        "suggest": "`Waiter` 不能持有指向下一个线程的可变指针，因为 `wait` 会同时向其 `Waiter` 节点发出变量引用，并保留共享的引用以检查 `signaled`。",
        "translate": ""
    },
    {
        "source": "Instead we hold shared references and use interior mutability.",
        "suggest": "相反，我们使用共享引用，并使用内部可变性。",
        "translate": ""
    },
    {
        "source": "Ensure the two lower bits are free to use as state bits.",
        "suggest": "确保两个低位可以自由用作状态位。",
        "translate": ""
    },
    {
        "source": "Head of a linked list of waiters.",
        "suggest": "等待者链表的头。",
        "translate": ""
    },
    {
        "source": "Every node is a struct on the stack of a waiting thread.",
        "suggest": "每个节点都是等待线程栈上的结构体。",
        "translate": ""
    },
    {
        "source": "Will wake up the waiters when it gets dropped, i.e. also on panic.",
        "suggest": "丢弃时将唤醒等待者，例如在 panic 上。",
        "translate": ""
    },
    {
        "source": "Creates a new `Once` value.",
        "suggest": "创建一个新的 `Once` 值。",
        "translate": ""
    },
    {
        "source": "Performs an initialization routine once and only once.",
        "suggest": "仅执行一次初始化例程。",
        "translate": ""
    },
    {
        "source": "The given closure will be executed if this is the first time `call_once` has been called, and otherwise the routine will *not* be invoked.",
        "suggest": "如果这是第一次调用 `call_once`，则将执行给定的闭包，否则将 *不* 调用例程。",
        "translate": ""
    },
    {
        "source": "This method will block the calling thread if another initialization routine is currently running.",
        "suggest": "如果当前正在运行另一个初始化例程，则此方法将阻止调用线程。",
        "translate": ""
    },
    {
        "source": "When this function returns, it is guaranteed that some initialization has run and completed (it may not be the closure specified).",
        "suggest": "当此函数返回时，可以确保某些初始化已运行并完成 (它可能不是指定的闭包)。",
        "translate": ""
    },
    {
        "source": "It is also guaranteed that any memory writes performed by the executed closure can be reliably observed by other threads at this point (there is a happens-before relation between the closure and code executing after the return).",
        "suggest": "还可以确保此时其他线程可以可靠地观察到由执行的闭包执行的任何内存写操作 (闭包与返回之后执行的代码之间存在先于发生的关系)。",
        "translate": ""
    },
    {
        "source": "If the given closure recursively invokes `call_once` on the same [`Once`] instance the exact behavior is not specified, allowed outcomes are a panic or a deadlock.",
        "suggest": "如果给定的闭包在同一 [`Once`] 实例上递归调用 `call_once`，则未指定确切的行为，则允许的结果为 panic 或死锁。",
        "translate": ""
    },
    {
        "source": "The closure `f` will only be executed once if this is called concurrently amongst many threads.",
        "suggest": "如果在多个线程中同时调用闭包 `f`，则将仅执行一次。",
        "translate": ""
    },
    {
        "source": "If that closure panics, however, then it will *poison* this [`Once`] instance, causing all future invocations of `call_once` to also panic.",
        "suggest": "但是，如果该闭包 panics 将会毒化该 [`Once`] 实例，从而导致 `call_once` 的所有 future 调用也变为 panic。",
        "translate": ""
    },
    {
        "source": "This is similar to [poisoning with mutexes][poison].",
        "suggest": "这类似于 [poisoning with mutexes][poison]。",
        "translate": ""
    },
    {
        "source": "Performs the same function as [`call_once()`] except ignores poisoning.",
        "suggest": "执行与 [`call_once()`] 相同的函数，只是忽略中毒。",
        "translate": ""
    },
    {
        "source": "Unlike [`call_once()`], if this [`Once`] has been poisoned (i.e., a previous call to [`call_once()`] or [`call_once_force()`] caused a panic), calling [`call_once_force()`] will still invoke the closure `f` and will _not_ result in an immediate panic.",
        "suggest": "与 [`call_once()`] 不同，如果此 [`Once`] 已中毒 (例如，先前对 [`call_once()`] 或 [`call_once_force()`] 的调用导致 panic)，则调用 [`call_once_force()`] 仍将调用闭包 `f`，并且 _not_ 会立即导致 panic。",
        "translate": ""
    },
    {
        "source": "If `f` panics, the [`Once`] will remain in a poison state.",
        "suggest": "如果 `f` panics，则 [`Once`] 将保持中毒状态。",
        "translate": ""
    },
    {
        "source": "If `f` does _not_ panic, the [`Once`] will no longer be in a poison state and all future calls to [`call_once()`] or [`call_once_force()`] will be no-ops.",
        "suggest": "如果 `f` 执行 _not_ panic，则 [`Once`] 将不再处于中毒状态，并且所有对 [`call_once()`] 或 [`call_once_force()`] 的 future 调用都将变为无操作。",
        "translate": ""
    },
    {
        "source": "The closure `f` is yielded a [`OnceState`] structure which can be used to query the poison status of the [`Once`].",
        "suggest": "闭包 `f` 产生 [`OnceState`] 结构体，可用于查询 [`Once`] 的中毒状态。",
        "translate": ""
    },
    {
        "source": "Returns `true` if some [`call_once()`] call has completed successfully.",
        "suggest": "如果某些 [`call_once()`] 调用已成功完成，则返回 `true`。",
        "translate": ""
    },
    {
        "source": "Specifically, `is_completed` will return false in the following situations:",
        "suggest": "具体而言，在以下情况下，`is_completed` 将返回 false:",
        "translate": ""
    },
    {
        "source": "was not called at all,",
        "suggest": "根本没有被呼唤，",
        "translate": ""
    },
    {
        "source": "was called, but has not yet completed,",
        "suggest": "被称为，但尚未完成，",
        "translate": ""
    },
    {
        "source": "the [`Once`] instance is poisoned",
        "suggest": "[`Once`] 实例中毒",
        "translate": ""
    },
    {
        "source": "This function returning `false` does not mean that [`Once`] has not been executed.",
        "suggest": "此函数返回 `false` 并不意味着 [`Once`] 尚未执行。",
        "translate": ""
    },
    {
        "source": "For example, it may have been executed in the time between when `is_completed` starts executing and when it returns, in which case the `false` return value would be stale (but still permissible).",
        "suggest": "例如，它可能是在 `is_completed` 开始执行到返回之间的时间执行的，在这种情况下，`false` 的返回值将是陈旧的 (但仍然是允许的)。",
        "translate": ""
    },
    {
        "source": "An `Acquire` load is enough because that makes all the initialization operations visible to us, and, this being a fast path, weaker ordering helps with performance.",
        "suggest": "`Acquire` 负载就足够了，因为这使我们可以看到所有初始化操作，并且这是一条捷径，较弱的排序有助于提高性能。",
        "translate": ""
    },
    {
        "source": "This `Acquire` synchronizes with `Release` operations on the slow path.",
        "suggest": "该 `Acquire` 与慢速路径上的 `Release` 操作同步。",
        "translate": ""
    },
    {
        "source": "This is a non-generic function to reduce the monomorphization cost of using `call_once` (this isn't exactly a trivial or small implementation).",
        "suggest": "这是一个非通用类型的函数，可以减少使用 `call_once` 的单态化成本 (这并非微不足道或很小的实现)。",
        "translate": ""
    },
    {
        "source": "Additionally, this is tagged with `#[cold]` as it should indeed be cold and it helps let LLVM know that calls to this function should be off the fast path.",
        "suggest": "另外，它用 `#[cold]` 标记，因为它确实应该是冷的，它有助于让 LLVM 知道对该函数的调用应该不在快速路径之内。",
        "translate": ""
    },
    {
        "source": "Essentially, this should help generate more straight line code in LLVM.",
        "suggest": "从本质上讲，这应该有助于在 LLVM 中生成更多直线代码。",
        "translate": ""
    },
    {
        "source": "Finally, this takes an `FnMut` instead of a `FnOnce` because there's currently no way to take an `FnOnce` and call it via virtual dispatch without some allocation overhead.",
        "suggest": "最后，这需要 `FnMut` 而不是 `FnOnce`，因为当前没有办法通过虚拟调度来获取 `FnOnce` 并调用它，而没有一些分配开销。",
        "translate": ""
    },
    {
        "source": "Panic to propagate the poison.",
        "suggest": "Panic 传播毒药。",
        "translate": ""
    },
    {
        "source": "Try to register this thread as the one RUNNING.",
        "suggest": "尝试将该线程注册为一个正在运行的线程。",
        "translate": ""
    },
    {
        "source": "will manage other waiting threads, and wake them up on drop.",
        "suggest": "将管理其他等待的线程，并在丢弃时唤醒它们。",
        "translate": ""
    },
    {
        "source": "Run the initialization function, letting it know if we're poisoned or not.",
        "suggest": "运行初始化函数，让它知道我们是否中毒。",
        "translate": ""
    },
    {
        "source": "All other values must be RUNNING with possibly a pointer to the waiter queue in the more significant bits.",
        "suggest": "所有其他值都必须为 RUNNING，并且可能有一个指向更高有效位的侍者队列的指针。",
        "translate": ""
    },
    {
        "source": "the following code was carefully written to avoid creating a mutable reference to `node` that gets aliased.",
        "suggest": "以下代码经过精心编写，以避免对 `node` 创建别名。",
        "translate": ""
    },
    {
        "source": "Don't queue this thread if the status is no longer running, otherwise we will not be woken up.",
        "suggest": "如果状态不再运行，请不要将此线程排队，否则我们不会被唤醒。",
        "translate": ""
    },
    {
        "source": "Create the node for our current thread.",
        "suggest": "为我们当前的线程创建节点。",
        "translate": ""
    },
    {
        "source": "Try to slide in the node at the head of the linked list, making sure that another thread didn't just replace the head of the linked list.",
        "suggest": "尝试在链表顶部的节点中滑动，确保其他线程不只是替换链表的头部。",
        "translate": ""
    },
    {
        "source": "We have enqueued ourselves, now lets wait.",
        "suggest": "我们已经入队，现在让我们等待。",
        "translate": ""
    },
    {
        "source": "It is important not to return before being signaled, otherwise we would drop our `Waiter` node and leave a hole in the linked list (and a dangling reference).",
        "suggest": "重要的是不要在收到信号之前返回，否则我们将丢弃 `Waiter` 节点，并将 hole 留在链表中 (并悬垂引用)。",
        "translate": ""
    },
    {
        "source": "Guard against spurious wakeups by reparking ourselves until we are signaled.",
        "suggest": "提醒自己，直到收到信号为止，以防虚假唤醒。",
        "translate": ""
    },
    {
        "source": "If the managing thread happens to signal and unpark us before we can park ourselves, the result could be this thread never gets unparked.",
        "suggest": "如果管理线程恰好在我们可以停泊自己之前发出信号并释放了我们，则结果可能是该线程永远不会停泊。",
        "translate": ""
    },
    {
        "source": "Luckily `park` comes with the guarantee that if it got an `unpark` just before on an unparked thread is does not park.",
        "suggest": "幸运的是，`park` 附带保证，如果在未驻留线程上获得 `unpark` 之前，它也不会驻留。",
        "translate": ""
    },
    {
        "source": "Swap out our state with however we finished.",
        "suggest": "与我们交换状态，但是我们完成了。",
        "translate": ""
    },
    {
        "source": "We should only ever see an old state which was RUNNING.",
        "suggest": "我们应该只看到一个正在运行的旧状态。",
        "translate": ""
    },
    {
        "source": "Walk the entire linked list of waiters and wake them up (in lifo order, last to register is first to wake up).",
        "suggest": "遍历整个 waiters 的链表并唤醒他们 (按照 lifo 顺序，最后注册要首先唤醒)。",
        "translate": ""
    },
    {
        "source": "Right after setting `node.signaled = true` the other thread may free `node` if there happens to be has a spurious wakeup.",
        "suggest": "设置 `node.signaled = true` 之后，如果恰好有虚假唤醒，其他线程可能会释放 `node`。",
        "translate": ""
    },
    {
        "source": "So we have to take out the `thread` field and copy the pointer to `next` first.",
        "suggest": "因此，我们必须取出 `thread` 字段，然后首先将指针复制到 `next`。",
        "translate": ""
    },
    {
        "source": "FIXME (maybe): This is another case of issue #55005 `store()` has a potentially dangling ref to `signaled`.",
        "suggest": "FIXME (maybe): 这是 issue #55005 的另一种情况 `store()` 潜在地悬挂了对 `signaled` 的引用。",
        "translate": ""
    },
    {
        "source": "Returns `true` if the associated [`Once`] was poisoned prior to the invocation of the closure passed to [`Once::call_once_force()`].",
        "suggest": "如果关联的 [`Once`] 在调用传递给 [`Once::call_once_force()`] 的闭包之前中毒，则返回 `true`。",
        "translate": ""
    },
    {
        "source": "A poisoned [`Once`]:",
        "suggest": "中毒的 [`Once`]:",
        "translate": ""
    },
    {
        "source": "An unpoisoned [`Once`]:",
        "suggest": "无毒的 [`Once`]:",
        "translate": ""
    },
    {
        "source": "static INIT: Once = Once::new();",
        "suggest": "静态 INIT: 一次 = 一次: : new () ;",
        "translate": ""
    },
    {
        "source": "INIT.call_once_force(|state| {",
        "suggest": "INIT.call_once_force (| state | {",
        "translate": ""
    },
    {
        "source": "Poison the associated [`Once`] without explicitly panicking.",
        "suggest": "中毒关联的 [`Once`]，而不会显着恐慌。",
        "translate": ""
    },
    {
        "source": "This is currently only exposed for the `lazy` module",
        "suggest": "当前仅针对 `lazy` 模块公开",
        "translate": ""
    },
    {
        "source": "Readers try to catch the writer in the act",
        "suggest": "Readers 尝试在行为中捕获 writer",
        "translate": ""
    },
    {
        "source": "Wait for children to pass their asserts",
        "suggest": "等待子节点们通过他们的断言",
        "translate": ""
    },
    {
        "source": "Wait for writer to finish",
        "suggest": "等待 writer 完成",
        "translate": ""
    },
    {
        "source": "many reader locks can be held at once",
        "suggest": "可以一次持有许多 reader 锁",
        "translate": ""
    },
    {
        "source": "read locks are dropped at this point",
        "suggest": "此时将丢弃读锁",
        "translate": ""
    },
    {
        "source": "only one write lock may be held, however",
        "suggest": "只能持有一个写锁，但是",
        "translate": ""
    },
    {
        "source": "write lock is dropped here",
        "suggest": "写锁在这里被丢弃",
        "translate": ""
    },
    {
        "source": "the lock gets poisoned",
        "suggest": "锁被毒死了",
        "translate": ""
    },
    {
        "source": "A reader-writer lock",
        "suggest": "reader-writer 锁",
        "translate": ""
    },
    {
        "source": "This type of lock allows a number of readers or at most one writer at any point in time.",
        "suggest": "这种类型的锁定在任何时间点都允许多个 readers 或最多一个 writer。",
        "translate": ""
    },
    {
        "source": "The write portion of this lock typically allows modification of the underlying data (exclusive access) and the read portion of this lock typically allows for read-only access (shared access).",
        "suggest": "此锁的写入部分通常允许修改基础数据 (独占访问)，而此锁的读取部分通常允许进行只读访问 (共享访问)。",
        "translate": ""
    },
    {
        "source": "In comparison, a [`Mutex`] does not distinguish between readers or writers that acquire the lock, therefore blocking any threads waiting for the lock to become available.",
        "suggest": "相比之下，[`Mutex`] 不会区分获取锁定的 readers 或 writers，因此会阻塞等待锁定变为可用的所有线程。",
        "translate": ""
    },
    {
        "source": "An `RwLock` will allow any number of readers to acquire the lock as long as a writer is not holding the lock.",
        "suggest": "`RwLock` 将允许任意数量的 readers 获取锁，只要 writer 不持有该锁即可。",
        "translate": ""
    },
    {
        "source": "The priority policy of the lock is dependent on the underlying operating system's implementation, and this type does not guarantee that any particular policy will be used.",
        "suggest": "锁定的优先级策略取决于基础操作系统的实现，并且这种类型不能保证将使用任何特定的策略。",
        "translate": ""
    },
    {
        "source": "In particular, a writer which is waiting to acquire the lock in `write` might or might not block concurrent calls to `read`.",
        "suggest": "特别是，正在等待获取 `write` 中的锁的 writer 可能会或可能不会阻止对 `read` 的并发调用。",
        "translate": ""
    },
    {
        "source": "The type parameter `T` represents the data that this lock protects.",
        "suggest": "类型参数 `T` 表示此锁保护的数据。",
        "translate": ""
    },
    {
        "source": "It is required that `T` satisfies [`Send`] to be shared across threads and [`Sync`] to allow concurrent access through readers.",
        "suggest": "要求 `T` 满足 [`Send`] 在线程之间共享，并且 [`Sync`] 允许通过 readers 进行并发访问。",
        "translate": ""
    },
    {
        "source": "The RAII guards returned from the locking methods implement [`Deref`] (and [`DerefMut`] for the `write` methods) to allow access to the content of the lock.",
        "suggest": "从锁定方法返回的 RAII 防护实现 [`Deref`] (对于 `write` 方法为 [`DerefMut`]) 以允许访问锁的内容。",
        "translate": ""
    },
    {
        "source": "An `RwLock`, like [`Mutex`], will become poisoned on a panic.",
        "suggest": "`RwLock` 和 [`Mutex`] 一样，将在 panic 上中毒。",
        "translate": ""
    },
    {
        "source": "Note, however, that an `RwLock` may only be poisoned if a panic occurs while it is locked exclusively (write mode).",
        "suggest": "但是请注意，仅当 0panic 处于独占锁定状态 (写模式) 时，`RwLock` 才可能中毒。",
        "translate": ""
    },
    {
        "source": "If a panic occurs in any reader, then the lock will not be poisoned.",
        "suggest": "如果在任何 reader 中出现 panic，则锁不会中毒。",
        "translate": ""
    },
    {
        "source": "RAII structure used to release the shared read access of a lock when dropped.",
        "suggest": "RAII 结构，用于在丢弃锁时释放锁的共享读取访问。",
        "translate": ""
    },
    {
        "source": "This structure is created by the [`read`] and [`try_read`] methods on [`RwLock`].",
        "suggest": "该结构体由 [`RwLock`] 上的 [`read`] 和 [`try_read`] 方法创建。",
        "translate": ""
    },
    {
        "source": "RAII structure used to release the exclusive write access of a lock when dropped.",
        "suggest": "RAII 结构，用于在锁被丢弃时释放对锁的独占写访问。",
        "translate": ""
    },
    {
        "source": "This structure is created by the [`write`] and [`try_write`] methods on [`RwLock`].",
        "suggest": "该结构体由 [`RwLock`] 上的 [`write`] 和 [`try_write`] 方法创建。",
        "translate": ""
    },
    {
        "source": "Creates a new instance of an `RwLock<T>` which is unlocked.",
        "suggest": "创建一个已解锁的 `RwLock<T>` 的新实例。",
        "translate": ""
    },
    {
        "source": "Locks this rwlock with shared read access, blocking the current thread until it can be acquired.",
        "suggest": "使用共享的读取访问权限锁定此 rwlock，阻塞当前线程，直到可以获取它为止。",
        "translate": ""
    },
    {
        "source": "The calling thread will be blocked until there are no more writers which hold the lock.",
        "suggest": "调用线程将被阻塞，直到没有其他持有该锁的 writers 为止。",
        "translate": ""
    },
    {
        "source": "There may be other readers currently inside the lock when this method returns.",
        "suggest": "当此方法返回时，锁中可能当前存在其他 readers。",
        "translate": ""
    },
    {
        "source": "This method does not provide any guarantees with respect to the ordering of whether contentious readers or writers will acquire the lock first.",
        "suggest": "对于有争议的 readers 或 writers 将首先获取锁的顺序，此方法不提供任何保证。",
        "translate": ""
    },
    {
        "source": "Returns an RAII guard which will release this thread's shared access once it is dropped.",
        "suggest": "返回 RAII 保护，一旦该线程被丢弃，它将释放该线程的共享访问。",
        "translate": ""
    },
    {
        "source": "This function will return an error if the RwLock is poisoned.",
        "suggest": "如果 RwLock 中毒，则此函数将返回错误。",
        "translate": ""
    },
    {
        "source": "An RwLock is poisoned whenever a writer panics while holding an exclusive lock.",
        "suggest": "当 writer panics 持有排他锁时，RwLock 会中毒。",
        "translate": ""
    },
    {
        "source": "The failure will occur immediately after the lock has been acquired.",
        "suggest": "获取锁定后，将立即发生故障。",
        "translate": ""
    },
    {
        "source": "Attempts to acquire this rwlock with shared read access.",
        "suggest": "尝试使用共享的读取访问权限来获取此 rwlock。",
        "translate": ""
    },
    {
        "source": "If the access could not be granted at this time, then `Err` is returned.",
        "suggest": "如果此时不能授予访问权限，则返回 `Err`。",
        "translate": ""
    },
    {
        "source": "Otherwise, an RAII guard is returned which will release the shared access when it is dropped.",
        "suggest": "否则，将返回 RAII 保护，当该保护被丢弃时，该保护将释放共享访问。",
        "translate": ""
    },
    {
        "source": "This function does not provide any guarantees with respect to the ordering of whether contentious readers or writers will acquire the lock first.",
        "suggest": "对于有争议的 readers 或 writers 将首先获取锁的顺序，此函数不提供任何保证。",
        "translate": ""
    },
    {
        "source": "An error will only be returned if the lock would have otherwise been acquired.",
        "suggest": "仅当以其他方式获取锁时，才会返回错误。",
        "translate": ""
    },
    {
        "source": "Locks this rwlock with exclusive write access, blocking the current thread until it can be acquired.",
        "suggest": "用独占式写访问锁定该 rwlock，阻塞当前线程，直到可以获取它为止。",
        "translate": ""
    },
    {
        "source": "This function will not return while other writers or other readers currently have access to the lock.",
        "suggest": "当前其他 writers 或其他 readers 可以访问该锁时，此函数将不会返回。",
        "translate": ""
    },
    {
        "source": "Returns an RAII guard which will drop the write access of this rwlock when dropped.",
        "suggest": "返回一个 RAII 保护，当该保护被丢弃时，它将丢弃该读写锁的写访问。",
        "translate": ""
    },
    {
        "source": "An error will be returned when the lock is acquired.",
        "suggest": "获取锁时将返回错误。",
        "translate": ""
    },
    {
        "source": "Attempts to lock this rwlock with exclusive write access.",
        "suggest": "尝试使用互斥写访问权限锁定此 rwlock。",
        "translate": ""
    },
    {
        "source": "If the lock could not be acquired at this time, then `Err` is returned.",
        "suggest": "如果此时无法获取锁，则返回 `Err`。",
        "translate": ""
    },
    {
        "source": "Otherwise, an RAII guard is returned which will release the lock when it is dropped.",
        "suggest": "否则，将返回 RAII 守卫，它将在锁被丢弃时释放锁。",
        "translate": ""
    },
    {
        "source": "Determines whether the lock is poisoned.",
        "suggest": "确定锁是否中毒。",
        "translate": ""
    },
    {
        "source": "If another thread is active, the lock can still become poisoned at any time.",
        "suggest": "如果另一个线程处于活动状态，则锁定仍可能随时中毒。",
        "translate": ""
    },
    {
        "source": "Consumes this `RwLock`, returning the underlying data.",
        "suggest": "消耗此 `RwLock`，返回基础数据。",
        "translate": ""
    },
    {
        "source": "We know statically that there are no outstanding references to `self` so there's no need to lock the inner lock.",
        "suggest": "我们静态地知道 `self` 没有引用，因此不需要锁定内部锁。",
        "translate": ""
    },
    {
        "source": "To get the inner value, we'd like to call `data.into_inner()`, but because `RwLock` impl-s `Drop`, we can't move out of it, so we'll have to destructure it manually instead.",
        "suggest": "为了获得内部值，我们想调用 `data.into_inner()`，但是由于 `RwLock` impl-s `Drop`，我们不能将其移出，因此我们必须手动解构它。",
        "translate": ""
    },
    {
        "source": "Like `let RwLock { inner, poison, data } = self`.",
        "suggest": "像 `let RwLock { inner, poison, data } = self`。",
        "translate": ""
    },
    {
        "source": "Keep in sync with the `Drop` impl.",
        "suggest": "与 `Drop` impl 保持同步。",
        "translate": ""
    },
    {
        "source": "Since this call borrows the `RwLock` mutably, no actual locking needs to take place -- the mutable borrow statically guarantees no locks exist.",
        "suggest": "由于此调用借用 `RwLock` 是可变的，因此不需要进行实际的锁定 - 可变借用可以静态地保证不存在任何锁定。",
        "translate": ""
    },
    {
        "source": "This code needs to be kept in sync with `RwLock::into_inner`.",
        "suggest": "该代码需要与 `RwLock::into_inner` 保持同步。",
        "translate": ""
    },
    {
        "source": "Creates a new `RwLock<T>`, with the `Default` value for T.",
        "suggest": "用 T 的 `Default` 值创建一个新的 `RwLock<T>`。",
        "translate": ""
    },
    {
        "source": "This is equivalent to [`RwLock::new`].",
        "suggest": "这等效于 [`RwLock::new`]。",
        "translate": ""
    },
    {
        "source": "One-time global initialization.",
        "suggest": "一次性初始化。",
        "translate": ""
    },
    {
        "source": "One-time global cleanup.",
        "suggest": "一次性清理一次。",
        "translate": ""
    },
    {
        "source": "Returns the command line arguments",
        "suggest": "返回命令行参数",
        "translate": ""
    },
    {
        "source": "These symbols are all defined in `compiler-builtins`",
        "suggest": "这些符号都在 `compiler-builtins` 中定义",
        "translate": ""
    },
    {
        "source": "The implementation is inspired by Andrew D.",
        "suggest": "该实现受到 Andrew D 的启发。",
        "translate": ""
    },
    {
        "source": "Birrell's paper",
        "suggest": "Birrell's 的论文",
        "translate": ""
    },
    {
        "source": "HermitCore-specific extension to the primitives in the `std::ffi` module",
        "suggest": "HermitCore 特定于 `std::ffi` 模块中原语的扩展",
        "translate": ""
    },
    {
        "source": "A prelude for conveniently writing platform-specific code.",
        "suggest": "prelude，用于方便地编写平台特定的代码。",
        "translate": ""
    },
    {
        "source": "Includes all extension traits, and some important type definitions.",
        "suggest": "包括所有扩展名 traits 和一些重要的类型定义。",
        "translate": ""
    },
    {
        "source": "Extracts the actual file descriptor without closing it.",
        "suggest": "提取实际文件描述符而不关闭它。",
        "translate": ""
    },
    {
        "source": "Note that errors are ignored when closing a file descriptor.",
        "suggest": "请注意，关闭文件描述符时将忽略错误。",
        "translate": ""
    },
    {
        "source": "The reason for this is that if an error occurs we don't actually know if the file descriptor was closed or not, and if we retried (for something like EINTR), we might close another valid file descriptor (opened after we closed ours.",
        "suggest": "这样做的原因是，如果发生错误，我们实际上不知道文件描述符是否已关闭，并且如果我们重试 (针对 EINTR 之类的东西)，我们可能会关闭另一个有效的文件描述符 (在关闭文件描述符后打开)。",
        "translate": ""
    },
    {
        "source": "System bindings for HermitCore",
        "suggest": "HermitCore 的系统绑定",
        "translate": ""
    },
    {
        "source": "This module contains the facade (aka platform-specific) implementations of OS level functionality for HermitCore.",
        "suggest": "该模块包含 HermitCore 的 OS 级功能的外观 (又名平台特定) 实现。",
        "translate": ""
    },
    {
        "source": "This is all super highly experimental and not actually intended for wide/production use yet, it's still all in the experimental category.",
        "suggest": "这都是超级实验性的，实际上还不适合 wide/production 使用，它仍然属于实验类别。",
        "translate": ""
    },
    {
        "source": "This will likely change over time.",
        "suggest": "随着时间的流逝，这可能会改变。",
        "translate": ""
    },
    {
        "source": "Currently all functions here are basically stubs that immediately return errors.",
        "suggest": "当前，这里的所有函数基本上都是立即返回错误的存根。",
        "translate": ""
    },
    {
        "source": "The hope is that with a portability lint we can turn actually just remove all this and just omit parts of the standard library if we're compiling for wasm.",
        "suggest": "希望是，有了可移植性 lint，如果我们要为 wasm 进行编译，我们实际上可以删除所有这些内容并忽略标准库的某些部分。",
        "translate": ""
    },
    {
        "source": "That way it's a compile time error for something that's guaranteed to be a runtime error!",
        "suggest": "这样一来，就可以保证它是运行时错误，这是一个编译时错误!",
        "translate": ""
    },
    {
        "source": "This enum is used as the storage for a bunch of types which can't actually exist.",
        "suggest": "该枚举用作一堆实际上不存在的类型的存储。",
        "translate": ""
    },
    {
        "source": "just a workaround to test the system",
        "suggest": "只是测试系统的一种解决方法",
        "translate": ""
    },
    {
        "source": "This function is needed by the panic runtime.",
        "suggest": "panic 运行时需要此函数。",
        "translate": ""
    },
    {
        "source": "The symbol is named in pre-link args for the target specification, so keep that in sync.",
        "suggest": "该符号在目标规范的预链接 args 中命名，因此请使其保持同步。",
        "translate": ""
    },
    {
        "source": "NB. used by both libunwind and libpanic_abort",
        "suggest": "NB. 由 libunwind 和 libpanic_abort 都使用",
        "translate": ""
    },
    {
        "source": "initialize environment",
        "suggest": "初始化环境",
        "translate": ""
    },
    {
        "source": "This type provides a lock based on busy waiting to realize mutual exclusion",
        "suggest": "该类型提供基于忙于等待以实现互斥的锁",
        "translate": ""
    },
    {
        "source": "This structure behaves a lot like a common mutex.",
        "suggest": "这种结构体的行为很像普通的互斥锁。",
        "translate": ""
    },
    {
        "source": "There are some differences:",
        "suggest": "有一些区别:",
        "translate": ""
    },
    {
        "source": "By using busy waiting, it can be used outside the runtime.",
        "suggest": "通过使用繁忙等待，可以在运行时之外使用它。",
        "translate": ""
    },
    {
        "source": "It is a so called ticket lock and is completly fair.",
        "suggest": "这是所谓的票证锁，完全是公平的。",
        "translate": ""
    },
    {
        "source": "A guard to which the protected data can be accessed",
        "suggest": "可以访问受保护数据的防护",
        "translate": ""
    },
    {
        "source": "When the guard falls out of scope it will release the lock.",
        "suggest": "当守卫跌落离开作用域时，它将释放锁。",
        "translate": ""
    },
    {
        "source": "The dropping of the SpinlockGuard will release the lock it was created from.",
        "suggest": "丢弃自旋锁守护程序将会释放创建它的锁。",
        "translate": ""
    },
    {
        "source": "Realize a priority queue for tasks",
        "suggest": "实现任务的优先级队列",
        "translate": ""
    },
    {
        "source": "Add a task id by its priority to the queue",
        "suggest": "将任务 ID 按其优先级添加到队列中",
        "translate": ""
    },
    {
        "source": "Pop the task handle with the highest priority from the queue",
        "suggest": "从队列中弹出具有最高优先级的任务句柄",
        "translate": ""
    },
    {
        "source": "Checks whether the HermitCore's socket interface has been started already, and if not, starts it.",
        "suggest": "检查 HermitCore 的套接字接口是否已经启动，如果没有，则启动它。",
        "translate": ""
    },
    {
        "source": "Arc is used to count the number of used sockets.",
        "suggest": "Arc 用于计算已用套接字的数量。",
        "translate": ""
    },
    {
        "source": "Only if all sockets are released, the drop method will close the socket.",
        "suggest": "只有释放了所有套接字，丢弃方法才会关闭该套接字。",
        "translate": ""
    },
    {
        "source": "Strategy (copied from glibc): Variable name and value are separated by an ASCII equals sign '='.",
        "suggest": "策略 (从 glibc 复制) : 变量名称和值由 ASCII 等于 '=' 的 ASCII 字符分隔。",
        "translate": ""
    },
    {
        "source": "Since a variable name must not be empty, allow variable names starting with an equals sign.",
        "suggest": "由于变量名不能为空，因此请允许变量名以等号开头。",
        "translate": ""
    },
    {
        "source": "Skip all malformed lines.",
        "suggest": "跳过所有格式错误的行。",
        "translate": ""
    },
    {
        "source": "Returns a vector of (variable, value) byte-vector pairs for all the environment variables of the current process.",
        "suggest": "返回当前进程的所有环境变量的 vector (变量，值) 字节 - vector 对。",
        "translate": ""
    },
    {
        "source": "This rwlock implementation is a relatively simple implementation which has a condition variable for readers/writers as well as a mutex protecting the internal state of the lock.",
        "suggest": "该 rwlock 实现是一个相对简单的实现，它具有 readers/writers 的条件变量以及保护该锁内部状态的互斥锁。",
        "translate": ""
    },
    {
        "source": "A current downside of the implementation is that unlocking the lock will notify *all* waiters rather than just readers or just writers.",
        "suggest": "该实现的当前缺点是，解锁锁将通知 *所有* 等待者，而不只是 readers 或 writers。",
        "translate": ""
    },
    {
        "source": "This can cause lots of \"thundering stampede\" problems.",
        "suggest": "这会导致很多 \"thundering stampede\" 问题。",
        "translate": ""
    },
    {
        "source": "While hopefully correct this implementation is very likely to want to be changed in the future.",
        "suggest": "虽然希望正确无误，但很可能需要在 future 中对其进行更改。",
        "translate": ""
    },
    {
        "source": "should only wake up one of these some of the time",
        "suggest": "某些时候应该只唤醒其中之一",
        "translate": ""
    },
    {
        "source": "The thread failed to start and as a result p was not consumed.",
        "suggest": "线程无法启动，结果 p 没有被使用。",
        "translate": ""
    },
    {
        "source": "Therefore, it is safe to reconstruct the box so that it gets deallocated.",
        "suggest": "因此，重建 box 使其被释放是安全的。",
        "translate": ""
    },
    {
        "source": "Finally, let's run some code.",
        "suggest": "最后，让我们运行一些代码。",
        "translate": ""
    },
    {
        "source": "run all destructors",
        "suggest": "运行所有析构函数",
        "translate": ""
    },
    {
        "source": "Simplify dtor registration by using a list of destructors.",
        "suggest": "通过使用析构函数列表来简化 dtor 注册。",
        "translate": ""
    },
    {
        "source": "The this solution works like the implementation of macOS and doesn't additional OS support",
        "suggest": "此解决方案的工作方式类似于 macOS 的实现，并且不需要其他操作系统支持",
        "translate": ""
    },
    {
        "source": "every thread call this function to run through all possible destructors",
        "suggest": "每个线程调用此函数以运行所有可能的析构函数",
        "translate": ""
    },
    {
        "source": "target type would be `libc::time_t`",
        "suggest": "目标类型为 `libc::time_t`",
        "translate": ""
    },
    {
        "source": "Nano calculations can't overflow because nanos are <1B which fit in a u32.",
        "suggest": "纳米计算不会溢出，因为纳米数小于 1B，适合 u32。",
        "translate": ""
    },
    {
        "source": "Similar to above, nanos can't overflow.",
        "suggest": "与上述类似，nano 不会溢出。",
        "translate": ""
    },
    {
        "source": "Platform-dependent platform abstraction.",
        "suggest": "平台相关的平台抽象。",
        "translate": ""
    },
    {
        "source": "The `std::sys` module is the abstracted interface through which `std` talks to the underlying operating system.",
        "suggest": "`std::sys` 模块是抽象接口，`std` 通过该接口与基础操作系统进行对话。",
        "translate": ""
    },
    {
        "source": "It has different implementations for different operating system families, today just Unix and Windows, and initial support for Redox.",
        "suggest": "对于不同的操作系统系列，它具有不同的实现方式，今天只有 Unix 和 Windows，并且最初支持 Redox。",
        "translate": ""
    },
    {
        "source": "The centralization of platform-specific code in this module is enforced by the \"platform abstraction layer\" tidy script in `tools/tidy/src/pal.rs`.",
        "suggest": "该模块中特定于平台的代码的集中由 `tools/tidy/src/pal.rs` 中的 \"platform abstraction layer\" 整洁脚本强制执行。",
        "translate": ""
    },
    {
        "source": "This module is closely related to the platform-independent system integration code in `std::sys_common`.",
        "suggest": "该模块与 `std::sys_common` 中与平台无关的系统集成代码紧密相关。",
        "translate": ""
    },
    {
        "source": "See that module's documentation for details.",
        "suggest": "有关详细信息，请参见该模块的文档。",
        "translate": ""
    },
    {
        "source": "In the future it would be desirable for the independent implementations of this module to be extracted to their own crates that `std` can link to, thus enabling their implementation out-of-tree via crate replacement.",
        "suggest": "在 future 中，希望将此模块的独立实现提取到 `std` 可以链接到其自己的 crates，从而通过 crate 替换使其实现树外。",
        "translate": ""
    },
    {
        "source": "Though due to the complex inter-dependencies within `std` that will be a challenging goal to achieve.",
        "suggest": "尽管由于 `std` 中复杂的相互依赖关系，这将是一个具有挑战性的目标。",
        "translate": ""
    },
    {
        "source": "Import essential modules from both platforms when documenting.",
        "suggest": "记录时从两个平台导入基本模块。",
        "translate": ""
    },
    {
        "source": "These are then later used in the `std::os` module when documenting, for example, Windows when we're compiling for Linux.",
        "suggest": "然后在记录文档时在 `std::os` 模块中使用它们，例如，当我们为 Linux 编译时使用 Windows。",
        "translate": ""
    },
    {
        "source": "On unix we'll document what's already available",
        "suggest": "在 unix 上，我们将记录已经可用的内容",
        "translate": ""
    },
    {
        "source": "On non-WASI wasm right now the module below doesn't compile (missing things in `libc` which is empty) so just omit everything with an empty module",
        "suggest": "在非 WASI wasm 上，现在下面的模块无法编译 (缺少 `libc` 中为空的内容)，因此只需使用空模块忽略所有内容",
        "translate": ""
    },
    {
        "source": "On other platforms like Windows document the bare bones of unix",
        "suggest": "在其他平台 (如 Windows) 上记录 unix 的基本内容",
        "translate": ""
    },
    {
        "source": "On windows we'll just be documenting what's already available",
        "suggest": "在 windows 上，我们将仅记录已经可用的内容",
        "translate": ""
    },
    {
        "source": "On non-WASI wasm right now the shim below doesn't compile, so just omit it",
        "suggest": "在非 WASI wasm 上，现在以下填充程序无法编译，因此只需将其忽略即可",
        "translate": ""
    },
    {
        "source": "On all other platforms (aka linux/osx/etc) then pull in a \"minimal\" amount of windows goop which ends up compiling",
        "suggest": "在所有其他平台 (也称为 linux/osx/etc) 上，然后拉入 \"minimal\" 数量的 windows 框架，最终将其编译",
        "translate": ""
    },
    {
        "source": "On WASI we'll document what's already available",
        "suggest": "在 WASI 上，我们将记录已经可用的内容",
        "translate": ""
    },
    {
        "source": "On other platforms like Windows document the bare bones of WASI",
        "suggest": "在 Windows 等其他平台上，WASI 的基本内容也记录在案",
        "translate": ""
    }
]
