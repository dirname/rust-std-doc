[
    {
        "source": "Attribute macro applied to a static to register it as a global allocator.",
        "suggest": "将属性宏应用于静态以将其注册为分配器。",
        "translate": ""
    },
    {
        "source": "See also [`std::alloc::GlobalAlloc`](../std/alloc/trait.GlobalAlloc.html).",
        "suggest": "另请参见 [`std::alloc::GlobalAlloc`](../std/alloc/trait.GlobalAlloc.html)。",
        "translate": ""
    },
    {
        "source": "Keeps the item it's applied to if the passed path is accessible, and removes it otherwise.",
        "suggest": "如果可以访问传递的路径，则保留适用于它的项，否则将其删除。",
        "translate": ""
    },
    {
        "source": "Expands all `#[cfg]` and `#[cfg_attr]` attributes in the code fragment it's applied to.",
        "suggest": "扩展其所应用的代码片段中的所有 `#[cfg]` 和 `#[cfg_attr]` 属性。",
        "translate": ""
    },
    {
        "source": "Unstable implementation detail of the `rustc` compiler, do not use.",
        "suggest": "`rustc` 编译器的不稳定实现细节，请勿使用。",
        "translate": ""
    },
    {
        "source": "Panics the current thread.",
        "suggest": "Panics 当前线程。",
        "translate": ""
    },
    {
        "source": "This allows a program to terminate immediately and provide feedback to the caller of the program.",
        "suggest": "这允许程序立即终止并向程序的调用者提供反馈。",
        "translate": ""
    },
    {
        "source": "should be used when a program reaches an unrecoverable state.",
        "suggest": "当程序达到不可恢复的状态时应使用。",
        "translate": ""
    },
    {
        "source": "This macro is the perfect way to assert conditions in example code and in tests.",
        "suggest": "此宏是在示例代码和测试中声明条件的理想方法。",
        "translate": ""
    },
    {
        "source": "is closely tied with the `unwrap` method of both [`Option`][ounwrap] and [`Result`][runwrap] enums.",
        "suggest": "与 [`Option`][ounwrap] 和 [`Result`][runwrap] 枚举的 `unwrap` 方法紧密相关。",
        "translate": ""
    },
    {
        "source": "Both implementations call `panic!` when they are set to [`None`] or [`Err`] variants.",
        "suggest": "两种实现都将 `panic!` 设置为 [`None`] 或 [`Err`] 成员时。",
        "translate": ""
    },
    {
        "source": "When using `panic!()` you can specify a string payload, that is built using the [`format!`] syntax.",
        "suggest": "使用 `panic!()` 时，可以指定使用 [`format!`] 语法构建的字符串有效负载。",
        "translate": ""
    },
    {
        "source": "That payload is used when injecting the panic into the calling Rust thread, causing the thread to panic entirely.",
        "suggest": "当将 panic 注入到调用的 Rust 线程中时，将使用该有效负载，从而导致该线程完全变为 panic。",
        "translate": ""
    },
    {
        "source": "The behavior of the default `std` hook, i.e.",
        "suggest": "默认 `std` hook 的行为，即",
        "translate": ""
    },
    {
        "source": "the code that runs directly after the panic is invoked, is to print the message payload to `stderr` along with the file/line/column information of the `panic!()` call.",
        "suggest": "在调用 panic 之后直接运行的代码是将消息有效负载以及 `panic!()` 调用的 file/line/column 信息打印到 `stderr`。",
        "translate": ""
    },
    {
        "source": "You can override the panic hook using [`std::panic::set_hook()`].",
        "suggest": "您可以使用 [`std::panic::set_hook()`] 覆盖 panic hook。",
        "translate": ""
    },
    {
        "source": "Inside the hook a panic can be accessed as a `&dyn Any + Send`, which contains either a `&str` or `String` for regular `panic!()` invocations.",
        "suggest": "在 hook 内部，可以将 X0panic0Z 作为 `&dyn Any + Send` 进行访问，其中包含用于常规 `panic!()` 调用的 `&str` 或 `String`。",
        "translate": ""
    },
    {
        "source": "To panic with a value of another other type, [`panic_any`] can be used.",
        "suggest": "对于具有其他类型值的 panic，可以使用 [`panic_any`]。",
        "translate": ""
    },
    {
        "source": "enum is often a better solution for recovering from errors than using the `panic!` macro.",
        "suggest": "与使用 `panic!` 宏相比，枚举通常是从错误中恢复的更好解决方案。",
        "translate": ""
    },
    {
        "source": "This macro should be used to avoid proceeding using incorrect values, such as from external sources.",
        "suggest": "应该使用此宏来避免继续使用不正确的值，例如来自外部来源的值。",
        "translate": ""
    },
    {
        "source": "Detailed information about error handling is found in the [book].",
        "suggest": "有关错误处理的详细信息，请参见 [book]。",
        "translate": ""
    },
    {
        "source": "See also the macro [`compile_error!`], for raising errors during compilation.",
        "suggest": "另请参见宏 [`compile_error!`]，以获取编译期间的错误。",
        "translate": ""
    },
    {
        "source": "If the main thread panics it will terminate all your threads and end your program with code `101`.",
        "suggest": "如果主线程为 panics，它将终止您的所有线程并以代码 `101` 结束您的程序。",
        "translate": ""
    },
    {
        "source": "// error: Sized is not implemented for [i32]",
        "suggest": "// 错误: 没有为 [i32] 实现大小调整",
        "translate": ""
    },
    {
        "source": "// error: the trait `Bar` cannot be made into an object",
        "suggest": "// 错误: 无法将 trait `Bar` 创建成对象",
        "translate": ""
    },
    {
        "source": "has moved into `y`, and so cannot be used",
        "suggest": "已移至 `y`，因此无法使用",
        "translate": ""
    },
    {
        "source": "We can derive a `Copy` implementation.",
        "suggest": "我们可以派生一个 `Copy` 实现。",
        "translate": ""
    },
    {
        "source": "is also required, as it's a supertrait of `Copy`.",
        "suggest": "也是必需的，因为它是 `Copy` 的特征。",
        "translate": ""
    },
    {
        "source": "is a copy of `x`",
        "suggest": "是 `x` 的副本",
        "translate": ""
    },
    {
        "source": "We need a mutable reference to call `mem::replace`.",
        "suggest": "我们需要一个可变引用来调用 `mem::replace`。",
        "translate": ""
    },
    {
        "source": "We can obtain such a reference by (implicitly) invoking `Pin::deref_mut`, but that is only possible because `String` implements `Unpin`.",
        "suggest": "我们可以通过 (implicitly) 调用 `Pin::deref_mut` 来获得这样的引用，但这仅是可能的，因为 `String` 实现了 `Unpin`。",
        "translate": ""
    },
    {
        "source": "Primitive traits and types representing basic properties of types.",
        "suggest": "原始 traits 和类型表示类型的基本属性。",
        "translate": ""
    },
    {
        "source": "Rust types can be classified in various useful ways according to their intrinsic properties.",
        "suggest": "Rust 类型可以根据其固有属性以各种有用的方式进行分类。",
        "translate": ""
    },
    {
        "source": "These classifications are represented as traits.",
        "suggest": "这些分类表示为 traits。",
        "translate": ""
    },
    {
        "source": "Types that can be transferred across thread boundaries.",
        "suggest": "可以跨线程边界传输的类型。",
        "translate": ""
    },
    {
        "source": "This trait is automatically implemented when the compiler determines it's appropriate.",
        "suggest": "当编译器确定适当时，会自动实现此 trait。",
        "translate": ""
    },
    {
        "source": "An example of a non-`Send` type is the reference-counting pointer [`rc::Rc`][`Rc`].",
        "suggest": "非 `Send` 类型的一个示例是引用计数指针 [`rc::Rc`][`Rc`]。",
        "translate": ""
    },
    {
        "source": "If two threads attempt to clone [`Rc`]s that point to the same reference-counted value, they might try to update the reference count at the same time, which is [undefined behavior][ub] because [`Rc`] doesn't use atomic operations.",
        "suggest": "如果两个线程试图克隆指向相同引用计数值的 [`Rc`]，它们可能会同时尝试更新引用计数，这是 [未定义行为][ub] 因为 [`Rc`] 不使用原子操作。",
        "translate": ""
    },
    {
        "source": "Its cousin [`sync::Arc`][arc] does use atomic operations (incurring some overhead) and thus is `Send`.",
        "suggest": "它的表亲 [`sync::Arc`][arc] 确实使用原子操作 (产生一些开销)，因此它是 `Send`。",
        "translate": ""
    },
    {
        "source": "See [the Nomicon](../../nomicon/send-and-sync.html) for more details.",
        "suggest": "有关更多详细信息，请参见 [the Nomicon](../../nomicon/send-and-sync.html)。",
        "translate": ""
    },
    {
        "source": "Types with a constant size known at compile time.",
        "suggest": "在编译时已知常量大小的类型。",
        "translate": ""
    },
    {
        "source": "All type parameters have an implicit bound of `Sized`.",
        "suggest": "所有类型参数的隐含边界均为 `Sized`。",
        "translate": ""
    },
    {
        "source": "The special syntax `?Sized` can be used to remove this bound if it's not appropriate.",
        "suggest": "如果不合适，可以使用特殊语法 `?Sized` 删除此绑定。",
        "translate": ""
    },
    {
        "source": "The one exception is the implicit `Self` type of a trait.",
        "suggest": "一个例外是 trait 的隐式 `Self` 类型。",
        "translate": ""
    },
    {
        "source": "A trait does not have an implicit `Sized` bound as this is incompatible with [trait object]s where, by definition, the trait needs to work with all possible implementors, and thus could be any size.",
        "suggest": "trait 没有隐式 `Sized` 绑定，因为它与 [trait 对象][trait object] 不兼容，根据定义，trait 需要与所有可能的实现者一起使用，因此可以为任意大小。",
        "translate": ""
    },
    {
        "source": "Although Rust will let you bind `Sized` to a trait, you won't be able to use it to form a trait object later:",
        "suggest": "尽管 Rust 允许您将 `Sized` 绑定到 trait，但是以后您将无法使用它来形成 trait 对象:",
        "translate": ""
    },
    {
        "source": "for Default, for example, which requires that `[T]: !Default` be evaluatable",
        "suggest": "例如，对于 Default，它要求 `[T]: !Default` 必须是可评估的",
        "translate": ""
    },
    {
        "source": "Types that can be \"unsized\" to a dynamically-sized type.",
        "suggest": "可以是未定义大小的类型也可以是动态大小的类型。",
        "translate": ""
    },
    {
        "source": "For example, the sized array type `[i8; 2]` implements `Unsize<[i8]>` and `Unsize<dyn fmt::Debug>`.",
        "suggest": "例如，按大小排列的数组类型 `[i8; 2]` 实现 `Unsize<[i8]>` 和 `Unsize<dyn fmt::Debug>`。",
        "translate": ""
    },
    {
        "source": "All implementations of `Unsize` are provided automatically by the compiler.",
        "suggest": "`Unsize` 的所有实现均由编译器自动提供。",
        "translate": ""
    },
    {
        "source": "is implemented for:",
        "suggest": "为以下目的实现:",
        "translate": ""
    },
    {
        "source": "is `Unsize<[T]>`",
        "suggest": "是 `Unsize<[T]>`",
        "translate": ""
    },
    {
        "source": "is `Unsize<dyn Trait>` when `T: Trait`",
        "suggest": "`T: Trait` 时为 `Unsize<dyn Trait>`",
        "translate": ""
    },
    {
        "source": "is `Unsize<Foo<..., U, ...>>` if:",
        "suggest": "如果是，则为 `Unsize<Foo<..., U, ...>>`:",
        "translate": ""
    },
    {
        "source": "Foo is a struct",
        "suggest": "Foo 是一个结构体",
        "translate": ""
    },
    {
        "source": "Only the last field of `Foo` has a type involving `T`",
        "suggest": "仅 `Foo` 的最后一个字段具有涉及 `T` 的类型",
        "translate": ""
    },
    {
        "source": "is not part of the type of any other fields",
        "suggest": "不属于任何其他字段的类型",
        "translate": ""
    },
    {
        "source": "if the last field of `Foo` has type `Bar<T>`",
        "suggest": "如果 `Foo` 的最后一个字段的类型为 `Bar<T>`",
        "translate": ""
    },
    {
        "source": "is used along with [`ops::CoerceUnsized`] to allow \"user-defined\" containers such as [`Rc`] to contain dynamically-sized types.",
        "suggest": "与 [`ops::CoerceUnsized`] 一起使用可允许 \"user-defined\" 容器 (例如 [`Rc`]) 包含动态大小的类型。",
        "translate": ""
    },
    {
        "source": "See the [DST coercion RFC][RFC982] and [the nomicon entry on coercion][nomicon-coerce] for more details.",
        "suggest": "有关更多详细信息，请参见 [DST coercion RFC][RFC982] 和 [the nomicon entry on coercion][nomicon-coerce]。",
        "translate": ""
    },
    {
        "source": "Required trait for constants used in pattern matches.",
        "suggest": "模式匹配中使用的常量需要 trait。",
        "translate": ""
    },
    {
        "source": "Any type that derives `PartialEq` automatically implements this trait, *regardless* of whether its type-parameters implement `Eq`.",
        "suggest": "不管其类型参数是否实现 `Eq`，任何派生 `PartialEq` 的类型都会自动实现此 trait。",
        "translate": ""
    },
    {
        "source": "If a `const` item contains some type that does not implement this trait, then that type either (1.) does not implement `PartialEq` (which means the constant will not provide that comparison method, which code generation assumes is available), or (2.) it implements *its own* version of `PartialEq` (which we assume does not conform to a structural-equality comparison).",
        "suggest": "如果 `const` 项包含某种不实现此 trait 的类型，则该类型要么 (1.) 不实现 `PartialEq` (这意味着常量将不提供该比较方法 (代码生成假定可用) )，要么 (2.) 自身实现 *its*`PartialEq` 的版本 (我们认为不符合结构相等性比较)。",
        "translate": ""
    },
    {
        "source": "In either of the two scenarios above, we reject usage of such a constant in a pattern match.",
        "suggest": "在以上两种情况中的任何一种情况下，我们都拒绝在模式匹配中使用此类常量。",
        "translate": ""
    },
    {
        "source": "See also the [structural match RFC][RFC1445], and [issue 63438] which motivated migrating from attribute-based design to this trait.",
        "suggest": "另请参见 [structural match RFC][RFC1445] 和 [issue 63438]，它们促使从基于属性的设计迁移到此 trait。",
        "translate": ""
    },
    {
        "source": "Any type that derives `Eq` automatically implements this trait, *regardless* of whether its type parameters implement `Eq`.",
        "suggest": "派生 `Eq` 的任何类型都会自动实现此 trait，无论其类型参数是否实现 `Eq`。",
        "translate": ""
    },
    {
        "source": "This is a hack to work around a limitation in our type system.",
        "suggest": "这是一种解决我们类型系统限制的技巧。",
        "translate": ""
    },
    {
        "source": "We want to require that types of consts used in pattern matches have the attribute `#[derive(PartialEq, Eq)]`.",
        "suggest": "我们要要求模式匹配中使用的 const 类型具有属性 `#[derive(PartialEq, Eq)]`。",
        "translate": ""
    },
    {
        "source": "In a more ideal world, we could check that requirement by just checking that the given type implements both the `StructuralPartialEq` trait *and* the `Eq` trait.",
        "suggest": "在更理想的世界中，我们可以通过仅检查给定类型是否同时实现 `StructuralPartialEq` trait 和 `Eq` trait 来检查该要求。",
        "translate": ""
    },
    {
        "source": "However, you can have ADTs that *do* `derive(PartialEq, Eq)`, and be a case that we want the compiler to accept, and yet the constant's type fails to implement `Eq`.",
        "suggest": "但是，您可能拥有 *do*`derive(PartialEq, Eq)` 的 ADT，这是我们希望编译器接受的情况，但是 const 的类型无法实现 `Eq`。",
        "translate": ""
    },
    {
        "source": "Namely, a case like this:",
        "suggest": "即，这样的情况:",
        "translate": ""
    },
    {
        "source": "(The problem in the above code is that `Wrap<fn(&())>` does not implement `PartialEq`, nor `Eq`, because `for<'a> fn(&'a _)` does not implement those traits.)",
        "suggest": "(以上代码中的问题是 `Wrap<fn(&())>` 既不实现 `PartialEq` 也不实现 `Eq`，因为 `for <'a> fn(&'a _)` does not implement those traits.)",
        "translate": ""
    },
    {
        "source": "Therefore, we cannot rely on naive check for `StructuralPartialEq` and mere `Eq`.",
        "suggest": "因此，我们不能仅仅依靠 `StructuralPartialEq` 和 `Eq` 的幼稚检查。",
        "translate": ""
    },
    {
        "source": "As a hack to work around this, we use two separate traits injected by each of the two derives (`#[derive(PartialEq)]` and `#[derive(Eq)]`) and check that both of them are present as part of structural-match checking.",
        "suggest": "要解决此问题，我们使用两个派生对象 (`#[derive(PartialEq)]` 和 `#[derive(Eq)]`) 中的每个派生注入的两个单独的 traits，并检查它们是否都作为结构匹配检查的一部分出现。",
        "translate": ""
    },
    {
        "source": "Types whose values can be duplicated simply by copying bits.",
        "suggest": "只需复制位即可复制其值的类型。",
        "translate": ""
    },
    {
        "source": "By default, variable bindings have 'move semantics.' In other words:",
        "suggest": "默认情况下，变量绑定具有移动语义。换句话说:",
        "translate": ""
    },
    {
        "source": "However, if a type implements `Copy`, it instead has 'copy semantics':",
        "suggest": "但是，如果类型实现 `Copy`，则它具有复制语义:",
        "translate": ""
    },
    {
        "source": "It's important to note that in these two examples, the only difference is whether you are allowed to access `x` after the assignment.",
        "suggest": "重要的是要注意，在这两个示例中，唯一的区别是分配后是否允许您访问 `x`。",
        "translate": ""
    },
    {
        "source": "Under the hood, both a copy and a move can result in bits being copied in memory, although this is sometimes optimized away.",
        "suggest": "在后台，复制和移动都可能导致将位复制到内存中，尽管有时会对其进行优化。",
        "translate": ""
    },
    {
        "source": "How can I implement `Copy`?",
        "suggest": "如何实现 `Copy`?",
        "translate": ""
    },
    {
        "source": "There are two ways to implement `Copy` on your type.",
        "suggest": "有两种方法可以在您的类型上实现 `Copy`。",
        "translate": ""
    },
    {
        "source": "The simplest is to use `derive`:",
        "suggest": "最简单的是使用 `derive`:",
        "translate": ""
    },
    {
        "source": "You can also implement `Copy` and `Clone` manually:",
        "suggest": "您还可以手动实现 `Copy` 和 `Clone`:",
        "translate": ""
    },
    {
        "source": "There is a small difference between the two: the `derive` strategy will also place a `Copy` bound on type parameters, which isn't always desired.",
        "suggest": "两者之间的区别很小: `derive` 策略还将 `Copy` 绑定在类型参数上，这并不总是需要的。",
        "translate": ""
    },
    {
        "source": "What's the difference between `Copy` and `Clone`?",
        "suggest": "`Copy` 和 `Clone` 有什么区别?",
        "translate": ""
    },
    {
        "source": "Copies happen implicitly, for example as part of an assignment `y = x`.",
        "suggest": "复制是隐式发生的，例如作为工作 `y = x` 的一部分。",
        "translate": ""
    },
    {
        "source": "The behavior of `Copy` is not overloadable;",
        "suggest": "`Copy` 的行为不可重载;",
        "translate": ""
    },
    {
        "source": "it is always a simple bit-wise copy.",
        "suggest": "它始终是简单的按位复制。",
        "translate": ""
    },
    {
        "source": "Cloning is an explicit action, `x.clone()`.",
        "suggest": "克隆是一个明确的动作 `x.clone()`。",
        "translate": ""
    },
    {
        "source": "The implementation of [`Clone`] can provide any type-specific behavior necessary to duplicate values safely.",
        "suggest": "[`Clone`] 的实现可以提供安全复制值所需的任何特定于类型的行为。",
        "translate": ""
    },
    {
        "source": "For example, the implementation of [`Clone`] for [`String`] needs to copy the pointed-to string buffer in the heap.",
        "suggest": "例如，用于 [`String`] 的 [`Clone`] 的实现需要在堆中复制指向字符串的缓冲区。",
        "translate": ""
    },
    {
        "source": "A simple bitwise copy of [`String`] values would merely copy the pointer, leading to a double free down the line.",
        "suggest": "[`String`] 值的简单按位副本将仅复制指针，从而导致该行向下双重释放。",
        "translate": ""
    },
    {
        "source": "For this reason, [`String`] is [`Clone`] but not `Copy`.",
        "suggest": "因此，[`String`] 是 [`Clone`]，但不是 `Copy`。",
        "translate": ""
    },
    {
        "source": "is a supertrait of `Copy`, so everything which is `Copy` must also implement [`Clone`].",
        "suggest": "是 `Copy` 的特征，因此 `Copy` 的所有内容也必须实现 [`Clone`]。",
        "translate": ""
    },
    {
        "source": "If a type is `Copy` then its [`Clone`] implementation only needs to return `*self` (see the example above).",
        "suggest": "如果类型为 `Copy`，则其 [`Clone`] 实现仅需要返回 `*self` (请参见上面的示例)。",
        "translate": ""
    },
    {
        "source": "When can my type be `Copy`?",
        "suggest": "什么时候可以输入 `Copy`?",
        "translate": ""
    },
    {
        "source": "A type can implement `Copy` if all of its components implement `Copy`.",
        "suggest": "如果类型的所有组件都实现 `Copy`，则它可以实现 `Copy`。",
        "translate": ""
    },
    {
        "source": "For example, this struct can be `Copy`:",
        "suggest": "例如，此结构体可以是 `Copy`:",
        "translate": ""
    },
    {
        "source": "A struct can be `Copy`, and [`i32`] is `Copy`, therefore `Point` is eligible to be `Copy`.",
        "suggest": "一个结构体可以是 `Copy`，而 [`i32`] 是 `Copy`，因此 `Point` 有资格成为 `Copy`。",
        "translate": ""
    },
    {
        "source": "By contrast, consider",
        "suggest": "相比之下，考虑",
        "translate": ""
    },
    {
        "source": "The struct `PointList` cannot implement `Copy`, because [`Vec<T>`] is not `Copy`.",
        "suggest": "结构体 `PointList` 无法实现 `Copy`，因为 [`Vec<T>`] 不是 `Copy`。",
        "translate": ""
    },
    {
        "source": "If we attempt to derive a `Copy` implementation, we'll get an error:",
        "suggest": "如果尝试派生 `Copy` 实现，则会收到错误消息:",
        "translate": ""
    },
    {
        "source": "Shared references (`&T`) are also `Copy`, so a type can be `Copy`, even when it holds shared references of types `T` that are *not* `Copy`.",
        "suggest": "共享引用 (`&T`) 也是 `Copy`，因此，即使类型中包含 *04* 不是*`Copy` 类型的共享引用 `T`，也可以是 `Copy`。",
        "translate": ""
    },
    {
        "source": "Consider the following struct, which can implement `Copy`, because it only holds a *shared reference* to our non-`Copy` type `PointList` from above:",
        "suggest": "考虑下面的结构体，它可以实现 `Copy`，因为它从上方仅对我们的非 Copy 类型 `PointList` 持有一个 *shared 引用*:",
        "translate": ""
    },
    {
        "source": "When *can't* my type be `Copy`?",
        "suggest": "什么时候我的类型不能为 `Copy`?",
        "translate": ""
    },
    {
        "source": "Some types can't be copied safely.",
        "suggest": "某些类型无法安全复制。",
        "translate": ""
    },
    {
        "source": "For example, copying `&mut T` would create an aliased mutable reference.",
        "suggest": "例如，复制 `&mut T` 将创建一个别名可变引用。",
        "translate": ""
    },
    {
        "source": "Copying [`String`] would duplicate responsibility for managing the [`String`]'s buffer, leading to a double free.",
        "suggest": "复制 [`String`] 将重复管理 [`String`] 缓冲区，从而导致双重释放。",
        "translate": ""
    },
    {
        "source": "Generalizing the latter case, any type implementing [`Drop`] can't be `Copy`, because it's managing some resource besides its own [`size_of::<T>`] bytes.",
        "suggest": "概括后一种情况，任何实现 [`Drop`] 的类型都不能是 `Copy`，因为它除了管理自己的 [`size_of::<T>`] 字节外还管理一些资源。",
        "translate": ""
    },
    {
        "source": "If you try to implement `Copy` on a struct or enum containing non-`Copy` data, you will get the error [E0204].",
        "suggest": "果您尝试在包含非 `Copy` 数据的结构或枚举上实现 `Copy`，则会收到 [E0204] 错误。",
        "translate": ""
    },
    {
        "source": "When *should* my type be `Copy`?",
        "suggest": "什么时候我的类型应该是 `Copy`?",
        "translate": ""
    },
    {
        "source": "Generally speaking, if your type _can_ implement `Copy`, it should.",
        "suggest": "一般来说，如果您的类型可以实现 `Copy`，则应该这样做。",
        "translate": ""
    },
    {
        "source": "Keep in mind, though, that implementing `Copy` is part of the public API of your type.",
        "suggest": "但是请记住，实现 `Copy` 是您类型的公共 API 的一部分。",
        "translate": ""
    },
    {
        "source": "If the type might become non-`Copy` in the future, it could be prudent to omit the `Copy` implementation now, to avoid a breaking API change.",
        "suggest": "如果该类型将来可能变为非 `Copy`，则最好现在省略 `Copy` 实现，以避免 API 发生重大更改。",
        "translate": ""
    },
    {
        "source": "In addition to the [implementors listed below][impls], the following types also implement `Copy`:",
        "suggest": "除 [下面列出的实现者][impls] 之外，以下类型还实现 `Copy`:",
        "translate": ""
    },
    {
        "source": "Array types, for all sizes, if the item type also implements `Copy` (e.g., `[i32; 123456]`)",
        "suggest": "如果项类型也实现 `Copy` (例如 `[i32; 123456]`)，则所有大小的数组类型",
        "translate": ""
    },
    {
        "source": "Tuple types, if each component also implements `Copy` (e.g., `()`, `(i32, bool)`)",
        "suggest": "如果每个组件还实现 `Copy` (例如 `()`，`(i32, bool)`)，则为元组类型",
        "translate": ""
    },
    {
        "source": "Closure types, if they capture no value from the environment or if all such captured values implement `Copy` themselves.",
        "suggest": "闭包类型，如果它们没有从环境中捕获任何值，或者所有此类捕获的值本身都实现了 `Copy`。",
        "translate": ""
    },
    {
        "source": "Note that variables captured by shared reference always implement `Copy` (even if the referent doesn't), while variables captured by mutable reference never implement `Copy`.",
        "suggest": "请注意，由共享引用捕获的变量始终实现 `Copy` (即使引用对象没有实现)，而由变量引用捕获的变量从不实现 `Copy`。",
        "translate": ""
    },
    {
        "source": "This allows copying a type that doesn't implement `Copy` because of unsatisfied lifetime bounds (copying `A<'_>` when only `A<'static>: Copy` and `A<'_>: Clone`).",
        "suggest": "这允许复制由于生命周期界限不令人满意而无法实现 `Copy` 的类型 (仅 `A<'static>: Copy` 和 `A<'_>: Clone` 时复制 `A<'_>`)。",
        "translate": ""
    },
    {
        "source": "We have this attribute here for now only because there are quite a few existing specializations on `Copy` that already exist in the standard library, and there's no way to safely have this behavior right now.",
        "suggest": "我们现在在这里具有此属性的原因仅是因为标准库中已经存在 `Copy` 上的许多现有专长，并且目前尚无办法安全地具有此行为。",
        "translate": ""
    },
    {
        "source": "Derive macro generating an impl of the trait `Copy`.",
        "suggest": "派生宏，生成 `Copy` trait 的 impl。",
        "translate": ""
    },
    {
        "source": "Types for which it is safe to share references between threads.",
        "suggest": "可以在线程之间安全共享引用的类型。",
        "translate": ""
    },
    {
        "source": "The precise definition is: a type `T` is [`Sync`] if and only if `&T` is [`Send`].",
        "suggest": "精确的定义是: 当且仅当 `&T` 是 [`Send`] 时，类型 `T` 才是 [`Sync`]。",
        "translate": ""
    },
    {
        "source": "In other words, if there is no possibility of [undefined behavior][ub] (including data races) when passing `&T` references between threads.",
        "suggest": "换句话说，如果在线程之间传递 `&T` 引用时没有 [未定义的行为][ub] (包括数据竞争) 的可能性。",
        "translate": ""
    },
    {
        "source": "As one would expect, primitive types like [`u8`] and [`f64`] are all [`Sync`], and so are simple aggregate types containing them, like tuples, structs and enums.",
        "suggest": "正如人们所期望的那样，原始类型 (如 [`u8`] 和 [`f64`]) 都是 [`Sync`]，包含它们的简单聚合类型 (如元组，结构体和枚举) 也是如此。",
        "translate": ""
    },
    {
        "source": "More examples of basic [`Sync`] types include \"immutable\" types like `&T`, and those with simple inherited mutability, such as [`Box<T>`][box], [`Vec<T>`][vec] and most other collection types.",
        "suggest": "基本 [`Sync`] 类型的更多示例包括不可变类型 (例如 `&T`) 以及具有简单继承的可变性的类型，例如 [`Box<T>`][box]，[`Vec<T>`][vec] 和大多数其他集合类型。",
        "translate": ""
    },
    {
        "source": "(Generic parameters need to be [`Sync`] for their container to be [`Sync`].)",
        "suggest": "(泛型参数必须为 [`Sync`]，容器才能 [[Sync]]。)",
        "translate": ""
    },
    {
        "source": "A somewhat surprising consequence of the definition is that `&mut T` is `Sync` (if `T` is `Sync`) even though it seems like that might provide unsynchronized mutation.",
        "suggest": "该定义的一个令人惊讶的结果是 `&mut T` 是 `Sync` (如果 `T` 是 `Sync`)，即使看起来可能提供了不同步的可变的。",
        "translate": ""
    },
    {
        "source": "The trick is that a mutable reference behind a shared reference (that is, `& &mut T`) becomes read-only, as if it were a `& &T`.",
        "suggest": "诀窍是，共享引用 (即 `& &mut T`) 后面的可变引用将变为只读，就好像它是 `& &T` 一样。",
        "translate": ""
    },
    {
        "source": "Hence there is no risk of a data race.",
        "suggest": "因此，没有数据竞争的风险。",
        "translate": ""
    },
    {
        "source": "Types that are not `Sync` are those that have \"interior mutability\" in a non-thread-safe form, such as [`Cell`][cell] and [`RefCell`][refcell].",
        "suggest": "不是 `Sync` 的类型是具有非线程安全形式的 \"interior mutability\" 的类型，例如 [`Cell`][cell] 和 [`RefCell`][refcell]。",
        "translate": ""
    },
    {
        "source": "These types allow for mutation of their contents even through an immutable, shared reference.",
        "suggest": "这些类型甚至允许通过不可变，共享引用来更改其内容。",
        "translate": ""
    },
    {
        "source": "For example the `set` method on [`Cell<T>`][cell] takes `&self`, so it requires only a shared reference [`&Cell<T>`][cell].",
        "suggest": "例如，[`Cell<T>`][cell] 上的 `set` 方法采用 `&self`，因此它仅需要共享的引用 [`&Cell<T>`][cell]。",
        "translate": ""
    },
    {
        "source": "The method performs no synchronization, thus [`Cell`][cell] cannot be `Sync`.",
        "suggest": "该方法不执行同步，因此 [`Cell`][cell] 不能为 `Sync`。",
        "translate": ""
    },
    {
        "source": "Another example of a non-`Sync` type is the reference-counting pointer [`Rc`][rc].",
        "suggest": "另一个非 `Sync` 类型的例子是引用计数指针 [`Rc`][rc]。",
        "translate": ""
    },
    {
        "source": "Given any reference [`&Rc<T>`][rc], you can clone a new [`Rc<T>`][rc], modifying the reference counts in a non-atomic way.",
        "suggest": "给定任何引用 [`&Rc<T>`][rc]，您可以克隆新的 [`Rc<T>`][rc]，以非原子方式修改引用计数。",
        "translate": ""
    },
    {
        "source": "For cases when one does need thread-safe interior mutability, Rust provides [atomic data types], as well as explicit locking via [`sync::Mutex`][mutex] and [`sync::RwLock`][rwlock].",
        "suggest": "对于确实需要线程安全的内部可变性的情况，Rust 提供 [atomic data types] 以及通过 [`sync::Mutex`][mutex] 和 [`sync::RwLock`][rwlock] 进行的显式锁定。",
        "translate": ""
    },
    {
        "source": "These types ensure that any mutation cannot cause data races, hence the types are `Sync`.",
        "suggest": "这些类型可确保任何可变的都不会引起数据竞争，因此类型为 `Sync`。",
        "translate": ""
    },
    {
        "source": "Likewise, [`sync::Arc`][arc] provides a thread-safe analogue of [`Rc`][rc].",
        "suggest": "同样，[`sync::Arc`][arc] 提供了 [`Rc`][rc] 的线程安全模拟。",
        "translate": ""
    },
    {
        "source": "Any types with interior mutability must also use the [`cell::UnsafeCell`][unsafecell] wrapper around the value(s) which can be mutated through a shared reference.",
        "suggest": "任何具有内部可变性的类型还必须在 value(s) 周围使用 [`cell::UnsafeCell`][unsafecell] 包装器，该包装器可以通过共享的引用进行更改。",
        "translate": ""
    },
    {
        "source": "Failing to doing this is [undefined behavior][ub].",
        "suggest": "[未定义的行为][ub] 无法做到这一点。",
        "translate": ""
    },
    {
        "source": "For example, [`transmute`][transmute]-ing from `&T` to `&mut T` is invalid.",
        "suggest": "例如，从 `&T` 到 `&mut T` 的 [`transmute`][transmute] 无效。",
        "translate": ""
    },
    {
        "source": "See [the Nomicon][nomicon-send-and-sync] for more details about `Sync`.",
        "suggest": "有关 `Sync` 的更多详细信息，请参见 [the Nomicon][nomicon-send-and-sync]。",
        "translate": ""
    },
    {
        "source": "once support to add notes in `rustc_on_unimplemented` lands in beta, and it has been extended to check whether a closure is anywhere in the requirement chain, extend it as such (#48534):",
        "suggest": "一旦在 `rustc_on_unimplemented` 中添加 note 的支持进入 beta 版本，并且已经扩展到检查闭包是否在需求链中的任何地方，就这样扩展它 (#48534):",
        "translate": ""
    },
    {
        "source": "Zero-sized type used to mark things that \"act like\" they own a `T`.",
        "suggest": "零大小的类型用来标记那些行为像它们拥有一个 `T` 的东西。",
        "translate": ""
    },
    {
        "source": "Adding a `PhantomData<T>` field to your type tells the compiler that your type acts as though it stores a value of type `T`, even though it doesn't really.",
        "suggest": "向您的类型添加 `PhantomData<T>` 字段将告诉编译器，您的类型的行为就像它存储了 `T` 类型的值一样，即使实际上并非如此。",
        "translate": ""
    },
    {
        "source": "This information is used when computing certain safety properties.",
        "suggest": "在计算某些安全属性时会使用此信息。",
        "translate": ""
    },
    {
        "source": "For a more in-depth explanation of how to use `PhantomData<T>`, please see [the Nomicon](../../nomicon/phantom-data.html).",
        "suggest": "有关如何使用 `PhantomData<T>` 的更深入的说明，请参见 [the Nomicon](../../nomicon/phantom-data.html)。",
        "translate": ""
    },
    {
        "source": "A ghastly note 👻👻👻",
        "suggest": "一个可怕的笔记 👻👻👻",
        "translate": ""
    },
    {
        "source": "Though they both have scary names, `PhantomData` and 'phantom types' are related, but not identical.",
        "suggest": "尽管它们都有可怕的名称，但 `PhantomData` 和 phantom 类型是相关的，但并不完全相同。",
        "translate": ""
    },
    {
        "source": "A phantom type parameter is simply a type parameter which is never used.",
        "suggest": "phantom 类型参数只是从未使用过的类型参数。",
        "translate": ""
    },
    {
        "source": "In Rust, this often causes the compiler to complain, and the solution is to add a \"dummy\" use by way of `PhantomData`.",
        "suggest": "在 Rust 中，这通常会导致编译器抱怨，而解决方案是通过 `PhantomData` 添加 \"dummy\" 用途。",
        "translate": ""
    },
    {
        "source": "Unused lifetime parameters",
        "suggest": "未使用的生命周期参数",
        "translate": ""
    },
    {
        "source": "Perhaps the most common use case for `PhantomData` is a struct that has an unused lifetime parameter, typically as part of some unsafe code.",
        "suggest": "`PhantomData` 的最常见用例也许是具有未使用的生命周期参数的结构体，通常将其用作某些不安全代码的一部分。",
        "translate": ""
    },
    {
        "source": "For example, here is a struct `Slice` that has two pointers of type `*const T`, presumably pointing into an array somewhere:",
        "suggest": "例如，这是一个结构体 `Slice`，它具有两个 `*const T` 类型的指针，大概指向某个地方的数组:",
        "translate": ""
    },
    {
        "source": "The intention is that the underlying data is only valid for the lifetime `'a`, so `Slice` should not outlive `'a`.",
        "suggest": "目的是基础数据仅对生命周期 `'a` 有效，因此 `Slice` 不应超过 `'a`。",
        "translate": ""
    },
    {
        "source": "However, this intent is not expressed in the code, since there are no uses of the lifetime `'a` and hence it is not clear what data it applies to.",
        "suggest": "但是，此意图未在代码中表达，因为没有使用生命周期 `'a`，因此尚不清楚它适用于什么数据。",
        "translate": ""
    },
    {
        "source": "We can correct this by telling the compiler to act *as if* the `Slice` struct contained a reference `&'a T`:",
        "suggest": "我们可以通过告诉编译器如果 `Slice` 结构体包含引用 `&'a T` 来执行 *as 来纠正此问题:",
        "translate": ""
    },
    {
        "source": "This also in turn requires the annotation `T: 'a`, indicating that any references in `T` are valid over the lifetime `'a`.",
        "suggest": "这也需要注解 `T: 'a`，以指示 `T` 中的所有引用在生命周期 `'a` 上均有效。",
        "translate": ""
    },
    {
        "source": "When initializing a `Slice` you simply provide the value `PhantomData` for the field `phantom`:",
        "suggest": "初始化 `Slice` 时，只需为字段 `phantom` 提供值 `PhantomData`:",
        "translate": ""
    },
    {
        "source": "Unused type parameters",
        "suggest": "未使用的类型参数",
        "translate": ""
    },
    {
        "source": "It sometimes happens that you have unused type parameters which indicate what type of data a struct is \"tied\" to, even though that data is not actually found in the struct itself.",
        "suggest": "有时可能会发生未使用的类型参数，这些参数指示 \"tied\" 将结构体数据类型化的数据，即使该数据实际上不是在结构体本身中找到的也是如此。",
        "translate": ""
    },
    {
        "source": "Here is an example where this arises with [FFI].",
        "suggest": "这是 [FFI] 出现此情况的示例。",
        "translate": ""
    },
    {
        "source": "The foreign interface uses handles of type `*mut ()` to refer to Rust values of different types.",
        "suggest": "外部接口使用 `*mut ()` 类型的句柄来引用不同类型的 Rust 值。",
        "translate": ""
    },
    {
        "source": "We track the Rust type using a phantom type parameter on the struct `ExternalResource` which wraps a handle.",
        "suggest": "我们使用包裹句柄的结构体 `ExternalResource` 上的 `phantom` 类型参数来跟踪 Rust 类型。",
        "translate": ""
    },
    {
        "source": "Ownership and the drop check",
        "suggest": "所有权和 drop 检测",
        "translate": ""
    },
    {
        "source": "Adding a field of type `PhantomData<T>` indicates that your type owns data of type `T`.",
        "suggest": "添加 `PhantomData<T>` 类型的字段表示您的类型拥有 `T` 类型的数据。",
        "translate": ""
    },
    {
        "source": "This in turn implies that when your type is dropped, it may drop one or more instances of the type `T`.",
        "suggest": "反过来，这意味着丢弃您的类型时，它可能会丢弃一个或多个 `T` 类型的实例。",
        "translate": ""
    },
    {
        "source": "This has bearing on the Rust compiler's [drop check] analysis.",
        "suggest": "这与 Rust 编译器的 [drop check] 分析有关。",
        "translate": ""
    },
    {
        "source": "If your struct does not in fact *own* the data of type `T`, it is better to use a reference type, like `PhantomData<&'a T>` (ideally) or `PhantomData<*const T>` (if no lifetime applies), so as not to indicate ownership.",
        "suggest": "如果您的结构体实际上并不 *拥有*`T` 类型的数据，则最好使用引用类型，例如 `PhantomData<&'a T>` (ideally) 或 `PhantomData<*const T>` (如果没有生命周期适用)，以免表示所有权。",
        "translate": ""
    },
    {
        "source": "Compiler-internal trait used to indicate the type of enum discriminants.",
        "suggest": "编译器内部的 trait 用于指示枚举判别式的类型。",
        "translate": ""
    },
    {
        "source": "This trait is automatically implemented for every type and does not add any guarantees to [`mem::Discriminant`].",
        "suggest": "trait 会自动为每种类型实现，并且不会为 [`mem::Discriminant`] 添加任何保证。",
        "translate": ""
    },
    {
        "source": "It is **undefined behavior** to transmute between `DiscriminantKind::Discriminant` and `mem::Discriminant`.",
        "suggest": "在 `DiscriminantKind::Discriminant` 和 `mem::Discriminant` 之间转换是未定义的行为。",
        "translate": ""
    },
    {
        "source": "The type of the discriminant, which must satisfy the trait bounds required by `mem::Discriminant`.",
        "suggest": "判别类型，必须满足 `mem::Discriminant` 要求的 trait bounds。",
        "translate": ""
    },
    {
        "source": "Compiler-internal trait used to determine whether a type contains any `UnsafeCell` internally, but not through an indirection.",
        "suggest": "编译器内部的 trait 用于确定类型是否在内部包含任何 `UnsafeCell`，但不是通过间接寻址。",
        "translate": ""
    },
    {
        "source": "This affects, for example, whether a `static` of that type is placed in read-only static memory or writable static memory.",
        "suggest": "例如，这会影响该类型的 `static` 是否放置在只读静态存储器或可写静态存储器中。",
        "translate": ""
    },
    {
        "source": "Types that can be safely moved after being pinned.",
        "suggest": "固定后可以安全移动的类型。",
        "translate": ""
    },
    {
        "source": "Rust itself has no notion of immovable types, and considers moves (e.g., through assignment or [`mem::replace`]) to always be safe.",
        "suggest": "Rust 本身没有固定类型的概念，并认为移动 (例如，通过赋值或 [`mem::replace`]) 始终是安全的。",
        "translate": ""
    },
    {
        "source": "The [`Pin`][Pin] type is used instead to prevent moves through the type system.",
        "suggest": "[`Pin`][Pin] 类型代替使用，以防止在类型系统中移动。",
        "translate": ""
    },
    {
        "source": "Pointers `P<T>` wrapped in the [`Pin<P<T>>`][Pin] wrapper can't be moved out of.",
        "suggest": "[`Pin<P<T>>`][Pin] 包装器中包裹的指针 `P<T>` 不能移出。",
        "translate": ""
    },
    {
        "source": "See the [`pin` module] documentation for more information on pinning.",
        "suggest": "有关固定的更多信息，请参见 [`pin` module] 文档。",
        "translate": ""
    },
    {
        "source": "Implementing the `Unpin` trait for `T` lifts the restrictions of pinning off the type, which then allows moving `T` out of [`Pin<P<T>>`][Pin] with functions such as [`mem::replace`].",
        "suggest": "为 `T` 实现 `Unpin` trait 消除了固定该类型的限制，然后允许使用诸如 [`mem::replace`] 之类的功能将 `T` 从 [`Pin<P<T>>`][Pin] 中移出。",
        "translate": ""
    },
    {
        "source": "has no consequence at all for non-pinned data.",
        "suggest": "对于非固定数据完全没有影响。",
        "translate": ""
    },
    {
        "source": "In particular, [`mem::replace`] happily moves `!Unpin` data (it works for any `&mut T`, not just when `T: Unpin`).",
        "suggest": "特别是，[`mem::replace`] 可以愉快地移动 `!Unpin` 数据 (它适用于任何 `&mut T`，而不仅限于 `T: Unpin`)。",
        "translate": ""
    },
    {
        "source": "However, you cannot use [`mem::replace`] on data wrapped inside a [`Pin<P<T>>`][Pin] because you cannot get the `&mut T` you need for that, and *that* is what makes this system work.",
        "suggest": "但是，您不能对包装在 [`Pin<P<T>>`][Pin] 内的数据使用 [`mem::replace`]，因为您无法获得所需的 `&mut T`，并且 *that* 是使此系统正常工作的原因。",
        "translate": ""
    },
    {
        "source": "So this, for example, can only be done on types implementing `Unpin`:",
        "suggest": "因此，例如，这只能在实现 `Unpin` 的类型上完成:",
        "translate": ""
    },
    {
        "source": "This trait is automatically implemented for almost every type.",
        "suggest": "trait 几乎针对每种类型自动实现。",
        "translate": ""
    },
    {
        "source": "A marker type which does not implement `Unpin`.",
        "suggest": "没有实现 `Unpin` 的标记类型。",
        "translate": ""
    },
    {
        "source": "If a type contains a `PhantomPinned`, it will not implement `Unpin` by default.",
        "suggest": "如果类型包含 `PhantomPinned`，则默认情况下将不实现 `Unpin`。",
        "translate": ""
    },
    {
        "source": "Implementations of `Copy` for primitive types.",
        "suggest": "`Copy` 的基本类型的实现。",
        "translate": ""
    },
    {
        "source": "Shared references can be copied, but mutable references *cannot*!",
        "suggest": "共享的引用可以复制，但是可变引用 *不能*!",
        "translate": ""
    },
    {
        "source": "will be dropped after `children`.",
        "suggest": "将在 `children` 之后被丢弃。",
        "translate": ""
    },
    {
        "source": "Rust guarantees that fields are dropped in the order of declaration.",
        "suggest": "Rust 保证按声明顺序丢弃字段。",
        "translate": ""
    },
    {
        "source": "You can still safely operate on the value",
        "suggest": "您仍然可以安全地操作值",
        "translate": ""
    },
    {
        "source": "But `Drop` will not be run here",
        "suggest": "但是 `Drop` 不会在这里运行",
        "translate": ""
    },
    {
        "source": "This drops the `Box`.",
        "suggest": "这将使 `Box` 丢弃。",
        "translate": ""
    },
    {
        "source": "A wrapper to inhibit compiler from automatically calling `T`’s destructor.",
        "suggest": "包装器，用于禁止编译器自动调用 T 的析构函数。",
        "translate": ""
    },
    {
        "source": "This wrapper is 0-cost.",
        "suggest": "该包装器的成本为 0。",
        "translate": ""
    },
    {
        "source": "is subject to the same layout optimizations as `T`.",
        "suggest": "与 `T` 进行相同的布局优化。",
        "translate": ""
    },
    {
        "source": "As a consequence, it has *no effect* on the assumptions that the compiler makes about its contents.",
        "suggest": "因此，它在编译器对其内容进行假设的前提下具有 *no 效果*。",
        "translate": ""
    },
    {
        "source": "For example, initializing a `ManuallyDrop<&mut T>` with [`mem::zeroed`] is undefined behavior.",
        "suggest": "例如，用 [`mem::zeroed`] 初始化 `ManuallyDrop<&mut T>` 是未定义的行为。",
        "translate": ""
    },
    {
        "source": "If you need to handle uninitialized data, use [`MaybeUninit<T>`] instead.",
        "suggest": "如果需要处理未初始化的数据，请改用 [`MaybeUninit<T>`]。",
        "translate": ""
    },
    {
        "source": "Note that accessing the value inside a `ManuallyDrop<T>` is safe.",
        "suggest": "请注意，访问 `ManuallyDrop<T>` 内部的值是安全的。",
        "translate": ""
    },
    {
        "source": "This means that a `ManuallyDrop<T>` whose content has been dropped must not be exposed through a public safe API.",
        "suggest": "这意味着其内容已被丢弃的 `ManuallyDrop<T>` 一定不能通过公共安全 API 公开。",
        "translate": ""
    },
    {
        "source": "Correspondingly, `ManuallyDrop::drop` is unsafe.",
        "suggest": "相应地，`ManuallyDrop::drop` 是不安全的。",
        "translate": ""
    },
    {
        "source": "and drop order.",
        "suggest": "和 drop 指令。",
        "translate": ""
    },
    {
        "source": "Rust has a well-defined [drop order] of values.",
        "suggest": "Rust 具有定义明确的 [drop order] 值。",
        "translate": ""
    },
    {
        "source": "To make sure that fields or locals are dropped in a specific order, reorder the declarations such that the implicit drop order is the correct one.",
        "suggest": "为确保按特定顺序丢弃字段或局部变量，请对声明重新排序，以使隐式丢弃顺序正确。",
        "translate": ""
    },
    {
        "source": "It is possible to use `ManuallyDrop` to control the drop order, but this requires unsafe code and is hard to do correctly in the presence of unwinding.",
        "suggest": "可以使用 `ManuallyDrop` 来控制丢弃顺序，但这需要不安全的代码，并且在展开状态下很难正确执行。",
        "translate": ""
    },
    {
        "source": "For example, if you want to make sure that a specific field is dropped after the others, make it the last field of a struct:",
        "suggest": " 例如，如果您想要确保一个特定的字段在其他字段之后被丢弃，将它作为结构的最后一个字段:",
        "translate": ""
    },
    {
        "source": "Wrap a value to be manually dropped.",
        "suggest": "包装一个要手动丢弃的值。",
        "translate": ""
    },
    {
        "source": "Extracts the value from the `ManuallyDrop` container.",
        "suggest": "从 `ManuallyDrop` 容器中提取值。",
        "translate": ""
    },
    {
        "source": "This allows the value to be dropped again.",
        "suggest": "这样可以再次丢弃该值。",
        "translate": ""
    },
    {
        "source": "Takes the value from the `ManuallyDrop<T>` container out.",
        "suggest": "从 `ManuallyDrop<T>` 容器中取出值。",
        "translate": ""
    },
    {
        "source": "This method is primarily intended for moving out values in drop.",
        "suggest": "此方法主要用于在 drop 中移出值。",
        "translate": ""
    },
    {
        "source": "Instead of using [`ManuallyDrop::drop`] to manually drop the value, you can use this method to take the value and use it however desired.",
        "suggest": "您可以使用此方法获取值并根据需要使用它，而不是使用 [`ManuallyDrop::drop`] 手动删除该值。",
        "translate": ""
    },
    {
        "source": "Whenever possible, it is preferable to use [`into_inner`][`ManuallyDrop::into_inner`] instead, which prevents duplicating the content of the `ManuallyDrop<T>`.",
        "suggest": "只要有可能，最好改用 [`into_inner`][`ManuallyDrop::into_inner`]，这样可以防止重复 `ManuallyDrop<T>` 的内容。",
        "translate": ""
    },
    {
        "source": "This function semantically moves out the contained value without preventing further usage, leaving the state of this container unchanged.",
        "suggest": "该函数从语义上移出所包含的值，而不会阻止进一步使用，从而使该容器的状态保持不变。",
        "translate": ""
    },
    {
        "source": "It is your responsibility to ensure that this `ManuallyDrop` is not used again.",
        "suggest": "您有责任确保不再使用此 `ManuallyDrop`。",
        "translate": ""
    },
    {
        "source": "we are reading from a reference, which is guaranteed to be valid for reads.",
        "suggest": "我们正在从引文中进行读取，该引文保证对读取有效。",
        "translate": ""
    },
    {
        "source": "Manually drops the contained value.",
        "suggest": "手动丢弃包含的值。",
        "translate": ""
    },
    {
        "source": "This is exactly equivalent to calling [`ptr::drop_in_place`] with a pointer to the contained value.",
        "suggest": "这完全等同于使用指向所包含值的指针来调用 [`ptr::drop_in_place`]。",
        "translate": ""
    },
    {
        "source": "As such, unless the contained value is a packed struct, the destructor will be called in-place without moving the value, and thus can be used to safely drop [pinned] data.",
        "suggest": "这样，除非所包含的值是包装的结构体，否则析构函数将在不移动值的情况下就地调用，因此可用于安全地丢弃 [pinned] 数据。",
        "translate": ""
    },
    {
        "source": "If you have ownership of the value, you can use [`ManuallyDrop::into_inner`] instead.",
        "suggest": "如果您拥有该值的所有权，则可以改用 [`ManuallyDrop::into_inner`]。",
        "translate": ""
    },
    {
        "source": "This function runs the destructor of the contained value.",
        "suggest": "此函数运行包含值的析构函数。",
        "translate": ""
    },
    {
        "source": "Other than changes made by the destructor itself, the memory is left unchanged, and so as far as the compiler is concerned still holds a bit-pattern which is valid for the type `T`.",
        "suggest": "除了析构函数本身所做的更改之外，内存保持不变，因此就编译器而言，仍然保留一种对于 `T` 类型有效的位模式。",
        "translate": ""
    },
    {
        "source": "However, this \"zombie\" value should not be exposed to safe code, and this function should not be called more than once.",
        "suggest": "但是，此 \"zombie\" 值不应暴露给安全代码，并且不应多次调用此函数。",
        "translate": ""
    },
    {
        "source": "To use a value after it's been dropped, or drop a value multiple times, can cause Undefined Behavior (depending on what `drop` does).",
        "suggest": "在丢弃值或多次丢弃值后使用该值可能会导致未定义行为 (取决于 `drop` 的作用)。",
        "translate": ""
    },
    {
        "source": "This is normally prevented by the type system, but users of `ManuallyDrop` must uphold those guarantees without assistance from the compiler.",
        "suggest": "类型系统通常会阻止这种情况，但是 `ManuallyDrop` 的用户必须坚持这些保证，而无需编译器的帮助。",
        "translate": ""
    },
    {
        "source": "we are dropping the value pointed to by a mutable reference which is guaranteed to be valid for writes.",
        "suggest": "我们将丢弃变量引用所指向的值，该值对于写操作是有效的。",
        "translate": ""
    },
    {
        "source": "It is up to the caller to make sure that `slot` isn't dropped again.",
        "suggest": "取决于调用者，以确保不会再次丢弃 `slot`。",
        "translate": ""
    },
    {
        "source": "undefined behavior!",
        "suggest": "未定义的行为!",
        "translate": ""
    },
    {
        "source": "The equivalent code with `MaybeUninit<&i32>`:",
        "suggest": "与 `MaybeUninit<&i32>` 等效的代码:",
        "translate": ""
    },
    {
        "source": "The equivalent code with `MaybeUninit<bool>`:",
        "suggest": "与 `MaybeUninit<bool>` 等效的代码:",
        "translate": ""
    },
    {
        "source": "The equivalent code with `MaybeUninit<i32>`:",
        "suggest": "与 `MaybeUninit<i32>` 等效的代码:",
        "translate": ""
    },
    {
        "source": "Create an explicitly uninitialized reference.",
        "suggest": "创建一个显式未初始化的引用。",
        "translate": ""
    },
    {
        "source": "The compiler knows that data inside a `MaybeUninit<T>` may be invalid, and hence this is not UB:",
        "suggest": "编译器知道 `MaybeUninit<T>` 内部的数据可能无效，因此不是 UB:",
        "translate": ""
    },
    {
        "source": "Set it to a valid value.",
        "suggest": "将其设置为有效值。",
        "translate": ""
    },
    {
        "source": "Extract the initialized data -- this is only allowed *after* properly initializing `x`!",
        "suggest": "提取已初始化的数据 - 仅在正确初始化 `x` 之后 * 才允许这样做!",
        "translate": ""
    },
    {
        "source": "does not drop the old contents, which is important.",
        "suggest": "不会丢弃老的内容，这一点很重要。",
        "translate": ""
    },
    {
        "source": "Now we know `v` is initialized!",
        "suggest": "现在我们知道 `v` 已初始化!",
        "translate": ""
    },
    {
        "source": "This also makes sure the vector gets properly dropped.",
        "suggest": "这也可以确保正确丢弃 vector。",
        "translate": ""
    },
    {
        "source": "Create an uninitialized array of `MaybeUninit`.",
        "suggest": "创建一个未初始化的 `MaybeUninit` 数组。",
        "translate": ""
    },
    {
        "source": "The `assume_init` is safe because the type we are claiming to have initialized here is a bunch of `MaybeUninit`s, which do not require initialization.",
        "suggest": "`assume_init` 是安全的，因为我们声称这里已经初始化的类型是一堆 `MaybeUninit`，不需要初始化。",
        "translate": ""
    },
    {
        "source": "Dropping a `MaybeUninit` does nothing.",
        "suggest": "丢弃 `MaybeUninit` 不会执行任何操作。",
        "translate": ""
    },
    {
        "source": "Thus using raw pointer assignment instead of `ptr::write` does not cause the old uninitialized value to be dropped.",
        "suggest": "因此，使用裸指针分配代替 `ptr::write` 不会导致旧的未初始化值被丢弃。",
        "translate": ""
    },
    {
        "source": "Also if there is a panic during this loop, we have a memory leak, but there is no memory safety issue.",
        "suggest": "此外，如果在此循环期间存在 panic，则可能会发生内存泄漏，但不会出现内存安全问题。",
        "translate": ""
    },
    {
        "source": "Everything is initialized.",
        "suggest": "一切都已初始化。",
        "translate": ""
    },
    {
        "source": "Transmute the array to the initialized type.",
        "suggest": "将数组转换为初始化的类型。",
        "translate": ""
    },
    {
        "source": "Count the number of elements we have assigned.",
        "suggest": "计算我们分配的元素数。",
        "translate": ""
    },
    {
        "source": "For each item in the array, drop if we allocated it.",
        "suggest": "对于数组中的每个项，如果我们分配了它，则将其丢弃。",
        "translate": ""
    },
    {
        "source": "Initializing the `name` field",
        "suggest": "初始化 `name` 字段",
        "translate": ""
    },
    {
        "source": "Initializing the `list` field If there is a panic here, then the `String` in the `name` field leaks.",
        "suggest": "初始化 `list` 字段如果此处存在 panic，则 `name` 字段中的 `String` 泄漏。",
        "translate": ""
    },
    {
        "source": "All the fields are initialized, so we call `assume_init` to get an initialized Foo.",
        "suggest": "所有字段都已初始化，因此我们调用 `assume_init` 来获取已初始化的 Foo。",
        "translate": ""
    },
    {
        "source": "Returns a (possibly smaller) slice of data that was actually read",
        "suggest": "返回实际读取的 (可能较小的) 数据切片",
        "translate": ""
    },
    {
        "source": "Inside a pair, we create a `NotZero` that does not have a valid discriminant.",
        "suggest": "在一个对中，我们创建一个没有有效判别式的 `NotZero`。",
        "translate": ""
    },
    {
        "source": "This is undefined behavior.",
        "suggest": "这是未定义的行为。",
        "translate": ""
    },
    {
        "source": "Create a reference into the `MaybeUninit<T>`.",
        "suggest": "在 `MaybeUninit<T>` 中创建引用。",
        "translate": ""
    },
    {
        "source": "This is okay because we initialized it.",
        "suggest": "可以，因为我们已将其初始化。",
        "translate": ""
    },
    {
        "source": "We have created a reference to an uninitialized vector!",
        "suggest": "我们创建了对未初始化的 vector 的引用!",
        "translate": ""
    },
    {
        "source": "Create a reference into the `MaybeUninit<Vec<u32>>`.",
        "suggest": "在 `MaybeUninit<Vec<u32>>` 中创建引用。",
        "translate": ""
    },
    {
        "source": "had not been initialized yet, so this last line caused undefined behavior.",
        "suggest": "尚未初始化，因此这最后一行导致未定义的行为。",
        "translate": ""
    },
    {
        "source": "is `Copy`, so we may read multiple times.",
        "suggest": "是 `Copy`，因此我们可能会多次读取。",
        "translate": ""
    },
    {
        "source": "Duplicating a `None` value is okay, so we may read multiple times.",
        "suggest": "复制 `None` 值是可以的，因此我们可能会多次读取。",
        "translate": ""
    },
    {
        "source": "We now created two copies of the same vector, leading to a double-free ⚠️ when they both get dropped!",
        "suggest": "现在，我们创建了同一 vector 的两个副本，当它们都被丢弃时，将导致双重释放!",
        "translate": ""
    },
    {
        "source": "Initialize `x`:",
        "suggest": "初始化 `x`:",
        "translate": ""
    },
    {
        "source": "Now that our `MaybeUninit<_>` is known to be initialized, it is okay to create a shared reference to it:",
        "suggest": "现在已知我们的 `MaybeUninit<_>` 已初始化，可以创建对其的共享引用:",
        "translate": ""
    },
    {
        "source": "`x` has been initialized.",
        "suggest": "`x` 已初始化。",
        "translate": ""
    },
    {
        "source": "Initialize the `MaybeUninit` using `Cell::set`:",
        "suggest": "使用 `Cell::set` 初始化 `MaybeUninit`:",
        "translate": ""
    },
    {
        "source": "Reference to an uninitialized `Cell<bool>`: UB!",
        "suggest": "引用未初始化的 `Cell<bool>`: UB!",
        "translate": ""
    },
    {
        "source": "Initializes *all* the bytes of the input buffer.",
        "suggest": "初始化所有输入缓冲区的字节。",
        "translate": ""
    },
    {
        "source": "Initialize `buf`:",
        "suggest": "初始化 `buf`:",
        "translate": ""
    },
    {
        "source": "Now we know that `buf` has been initialized, so we could `.assume_init()` it.",
        "suggest": "现在我们知道 `buf` 已被初始化，因此我们可以对其进行 `.assume_init()`。",
        "translate": ""
    },
    {
        "source": "However, using `.assume_init()` may trigger a `memcpy` of the 2048 bytes.",
        "suggest": "但是，使用 `.assume_init()` 可能会触发 2048 字节的 `memcpy`。",
        "translate": ""
    },
    {
        "source": "To assert our buffer has been initialized without copying it, we upgrade the `&mut MaybeUninit<[u8; 2048]>` to a `&mut [u8; 2048]`:",
        "suggest": "要断言我们的缓冲区已被初始化而不复制它，我们将 `&mut MaybeUninit<[u8; 2048]>` 升级到 `&mut [u8; 2048]`:",
        "translate": ""
    },
    {
        "source": "`buf` has been initialized.",
        "suggest": "`buf` 已初始化。",
        "translate": ""
    },
    {
        "source": "Now we can use `buf` as a normal slice:",
        "suggest": "现在我们可以将 `buf` 用作普通切片:",
        "translate": ""
    },
    {
        "source": "We have created a (mutable) reference to an uninitialized `bool`!",
        "suggest": "我们已经创建了 (mutable) 引用未初始化的 `bool`!",
        "translate": ""
    },
    {
        "source": "reference to uninitialized memory!",
        "suggest": "引用未初始化的内存!",
        "translate": ""
    },
    {
        "source": "Now safe as we initialised all elements",
        "suggest": "现在安全了，因为我们初始化了所有元素",
        "translate": ""
    },
    {
        "source": "we have just copied all the elements of len into the spare capacity the first src.len() elements of the vec are valid now.",
        "suggest": "我们刚刚将 len 的所有元素复制到了备用容量中，vec 的第一个 src.len() 元素现在有效。",
        "translate": ""
    },
    {
        "source": "we have just cloned all the elements of len into the spare capacity the first src.len() elements of the vec are valid now.",
        "suggest": "我们刚刚将 len 的所有元素克隆到了备用容量中，vec 的第一个 src.len() 元素现在有效。",
        "translate": ""
    },
    {
        "source": "A wrapper type to construct uninitialized instances of `T`.",
        "suggest": "包装器类型，用于创建 `T` 的未初始化实例。",
        "translate": ""
    },
    {
        "source": "Initialization invariant",
        "suggest": "初始化不变式",
        "translate": ""
    },
    {
        "source": "The compiler, in general, assumes that a variable is properly initialized according to the requirements of the variable's type.",
        "suggest": "通常，编译器假定已根据变量类型的要求正确初始化了变量。",
        "translate": ""
    },
    {
        "source": "For example, a variable of reference type must be aligned and non-NULL.",
        "suggest": "例如，引用类型的变量必须对齐并且不能为 NULL。",
        "translate": ""
    },
    {
        "source": "This is an invariant that must *always* be upheld, even in unsafe code.",
        "suggest": "即使在不安全的代码中，这也必须始终保持不变。",
        "translate": ""
    },
    {
        "source": "As a consequence, zero-initializing a variable of reference type causes instantaneous [undefined behavior][ub], no matter whether that reference ever gets used to access memory:",
        "suggest": "结果，将引用类型的变量初始化为零会导致瞬时 [undefined behavior][ub]，无论引用是否曾经被用来访问内存:",
        "translate": ""
    },
    {
        "source": "This is exploited by the compiler for various optimizations, such as eliding run-time checks and optimizing `enum` layout.",
        "suggest": "编译器将其用于各种优化，例如消除运行时检查和优化 `enum` 布局。",
        "translate": ""
    },
    {
        "source": "Similarly, entirely uninitialized memory may have any content, while a `bool` must always be `true` or `false`.",
        "suggest": "同样，完全未初始化的存储器可以包含任何内容，而 `bool` 必须始终为 `true` 或 `false`。",
        "translate": ""
    },
    {
        "source": "Hence, creating an uninitialized `bool` is undefined behavior:",
        "suggest": "因此，创建未初始化的 `bool` 是未定义的行为:",
        "translate": ""
    },
    {
        "source": "Moreover, uninitialized memory is special in that it does not have a fixed value (\"fixed\" meaning \"it won't change without being written to\").",
        "suggest": "此外，未初始化的存储器的特殊之处在于它没有固定的值 (\"fixed\" 表示 \"it won't change without being written to\")。",
        "translate": ""
    },
    {
        "source": "Reading the same uninitialized byte multiple times can give different results.",
        "suggest": "多次读取相同的未初始化字节会产生不同的结果。",
        "translate": ""
    },
    {
        "source": "This makes it undefined behavior to have uninitialized data in a variable even if that variable has an integer type, which otherwise can hold any *fixed* bit pattern:",
        "suggest": "这使得在变量中具有未初始化的数据成为未定义的行为，即使该变量具有整数类型也可以保留任何固定位模式",
        "translate": ""
    },
    {
        "source": "(Notice that the rules around uninitialized integers are not finalized yet, but until they are, it is advisable to avoid them.)",
        "suggest": "(请注意，关于未初始化整数的规则尚未最终确定，但是除非被确定，否则建议避免使用它们。)",
        "translate": ""
    },
    {
        "source": "On top of that, remember that most types have additional invariants beyond merely being considered initialized at the type level.",
        "suggest": "最重要的是，请记住，大多数类型具有其他不变式，而不仅仅是在类型级别被初始化。",
        "translate": ""
    },
    {
        "source": "For example, a `1`-initialized [`Vec<T>`] is considered initialized (under the current implementation; this does not constitute a stable guarantee) because the only requirement the compiler knows about it is that the data pointer must be non-null.",
        "suggest": "例如，将 `1` 初始化的 [`Vec<T>`] 视为已初始化 (在当前实现下; 这并不构成稳定的保证)，因为编译器知道的唯一要求是数据指针必须为非空值。",
        "translate": ""
    },
    {
        "source": "Creating such a `Vec<T>` does not cause *immediate* undefined behavior, but will cause undefined behavior with most safe operations (including dropping it).",
        "suggest": "创建这样的 `Vec<T>` 不会立即导致未定义的行为，但是在大多数安全操作 (包括丢弃操作) 中都将导致未定义的行为。",
        "translate": ""
    },
    {
        "source": "serves to enable unsafe code to deal with uninitialized data.",
        "suggest": "用于使不安全的代码能够处理未初始化的数据。",
        "translate": ""
    },
    {
        "source": "It is a signal to the compiler indicating that the data here might *not* be initialized:",
        "suggest": "这是向编译器发出的信号，指示此处的数据可能不被初始化:",
        "translate": ""
    },
    {
        "source": "The compiler then knows to not make any incorrect assumptions or optimizations on this code.",
        "suggest": "然后，编译器知道不会对此代码进行任何错误的假设或优化。",
        "translate": ""
    },
    {
        "source": "You can think of `MaybeUninit<T>` as being a bit like `Option<T>` but without any of the run-time tracking and without any of the safety checks.",
        "suggest": "您可以认为 `MaybeUninit<T>` 有点像 `Option<T>`，但是没有任何运行时跟踪且没有任何安全检查。",
        "translate": ""
    },
    {
        "source": "You can use `MaybeUninit<T>` to implement \"out-pointers\": instead of returning data from a function, pass it a pointer to some (uninitialized) memory to put the result into.",
        "suggest": "您可以使用 `MaybeUninit<T>` 来实现 \"out-pointers\": 与其从函数中返回数据，还不如将其传递给某个 (uninitialized) 内存的指针以将结果放入其中。",
        "translate": ""
    },
    {
        "source": "This can be useful when it is important for the caller to control how the memory the result is stored in gets allocated, and you want to avoid unnecessary moves.",
        "suggest": "当对调用方来说，控制结果存储在内存中的分配方式很重要并且您希望避免不必要的移动时，这很有用。",
        "translate": ""
    },
    {
        "source": "Initializing an array element-by-element",
        "suggest": "逐元素初始化数组",
        "translate": ""
    },
    {
        "source": "can be used to initialize a large array element-by-element:",
        "suggest": "可用于按元素初始化大型数组:",
        "translate": ""
    },
    {
        "source": "You can also work with partially initialized arrays, which could be found in low-level datastructures.",
        "suggest": "您也可以使用部分初始化的数组，这些数组可以在不稳定的数据结构中找到。",
        "translate": ""
    },
    {
        "source": "Initializing a struct field-by-field",
        "suggest": "逐场初始化结构体",
        "translate": ""
    },
    {
        "source": "You can use `MaybeUninit<T>`, and the [`std::ptr::addr_of_mut`] macro, to initialize structs field by field:",
        "suggest": "您可以使用 `MaybeUninit<T>` 和 [`std::ptr::addr_of_mut`] 宏来逐字段初始化结构体:",
        "translate": ""
    },
    {
        "source": "is guaranteed to have the same size, alignment, and ABI as `T`:",
        "suggest": "保证具有与 `T` 相同的大小，对齐方式和 ABI:",
        "translate": ""
    },
    {
        "source": "However remember that a type *containing* a `MaybeUninit<T>` is not necessarily the same layout;",
        "suggest": "但是请记住，*包含*`MaybeUninit<T>` 的类型不一定是相同的布局。",
        "translate": ""
    },
    {
        "source": "Rust does not in general guarantee that the fields of a `Foo<T>` have the same order as a `Foo<U>` even if `T` and `U` have the same size and alignment.",
        "suggest": "Rust 通常不保证 `Foo<T>` 的字段具有与 `Foo<U>` 相同的顺序，即使 `T` 和 `U` 具有相同的大小和对齐方式。",
        "translate": ""
    },
    {
        "source": "Furthermore because any bit value is valid for a `MaybeUninit<T>` the compiler can't apply non-zero/niche-filling optimizations, potentially resulting in a larger size:",
        "suggest": "此外，由于任何位值对于 `MaybeUninit<T>` 都是有效的，因此编译器无法应用 non-zero/niche-filling 优化，从而可能导致更大的大小:",
        "translate": ""
    },
    {
        "source": "If `T` is FFI-safe, then so is `MaybeUninit<T>`.",
        "suggest": "如果 `T` 是 FFI 安全的，则 `MaybeUninit<T>` 也是如此。",
        "translate": ""
    },
    {
        "source": "While `MaybeUninit` is `#[repr(transparent)]` (indicating it guarantees the same size, alignment, and ABI as `T`), this does *not* change any of the previous caveats.",
        "suggest": "虽然 `MaybeUninit` 是 `#[repr(transparent)]` (表示它保证与 `T` 相同的大小，对齐方式和 ABI)，但是这 *不会* 更改任何先前的警告。",
        "translate": ""
    },
    {
        "source": "and `Option<MaybeUninit<T>>` may still have different sizes, and types containing a field of type `T` may be laid out (and sized) differently than if that field were `MaybeUninit<T>`.",
        "suggest": "和 `Option<MaybeUninit<T>>` 可能仍具有不同的大小，并且包含 `T` 类型的字段的类型的布局 (和大小) 可能与该字段为 `MaybeUninit<T>` 的情况不同。",
        "translate": ""
    },
    {
        "source": "is a union type, and `#[repr(transparent)]` on unions is unstable (see [the tracking issue](https://github.com/rust-lang/rust/issues/60405)).",
        "suggest": "是一个是联合类型，并且 union 上的 `#[repr(transparent)]` 是不稳定的 (请参见 [跟踪问题](https://github.com/rust-lang/rust/issues/60405))。",
        "translate": ""
    },
    {
        "source": "Over time, the exact guarantees of `#[repr(transparent)]` on unions may evolve, and `MaybeUninit` may or may not remain `#[repr(transparent)]`.",
        "suggest": "随着时间的推移，对 union 的 `#[repr(transparent)]` 的确切保证可能会发生变化，并且 `MaybeUninit` 可能会或可能不会保留 `#[repr(transparent)]`。",
        "translate": ""
    },
    {
        "source": "That said, `MaybeUninit<T>` will *always* guarantee that it has the same size, alignment, and ABI as `T`;",
        "suggest": "就是说，`MaybeUninit<T>` 将总是保证它具有与 `T` 有相同的大小、对齐方式和 ABI;",
        "translate": ""
    },
    {
        "source": "it's just that the way `MaybeUninit` implements that guarantee may evolve.",
        "suggest": "只是 `MaybeUninit` 实现保证的方式可能会演变。",
        "translate": ""
    },
    {
        "source": "Lang item so we can wrap other types in it.",
        "suggest": "Lang 项，因此我们可以在其中包装其他类型。",
        "translate": ""
    },
    {
        "source": "This is useful for generators.",
        "suggest": "这对于生成器很有用。",
        "translate": ""
    },
    {
        "source": "Not calling `T::clone()`, we cannot know if we are initialized enough for that.",
        "suggest": "不调用 `T::clone()`，我们不知道我们是否已足够初始化。",
        "translate": ""
    },
    {
        "source": "Creates a new `MaybeUninit<T>` initialized with the given value.",
        "suggest": "创建一个使用给定值初始化的新 `MaybeUninit<T>`。",
        "translate": ""
    },
    {
        "source": "It is safe to call [`assume_init`] on the return value of this function.",
        "suggest": "在此函数的返回值上调用 [`assume_init`] 是安全的。",
        "translate": ""
    },
    {
        "source": "Note that dropping a `MaybeUninit<T>` will never call `T`'s drop code.",
        "suggest": "注意，丢弃 `MaybeUninit<T>` 永远不会调用 T 的丢弃代码。",
        "translate": ""
    },
    {
        "source": "It is your responsibility to make sure `T` gets dropped if it got initialized.",
        "suggest": "确保 `T` 在初始化时被丢弃是您的责任。",
        "translate": ""
    },
    {
        "source": "Creates a new `MaybeUninit<T>` in an uninitialized state.",
        "suggest": "以未初始化的状态创建一个新的 `MaybeUninit<T>`。",
        "translate": ""
    },
    {
        "source": "See the [type-level documentation][MaybeUninit] for some examples.",
        "suggest": "有关一些示例，请参见 [类型级文档][MaybeUninit]。",
        "translate": ""
    },
    {
        "source": "Create a new array of `MaybeUninit<T>` items, in an uninitialized state.",
        "suggest": "在未初始化状态下创建 `MaybeUninit<T>` 项的新数组。",
        "translate": ""
    },
    {
        "source": "in a future Rust version this method may become unnecessary when array literal syntax allows [repeating const expressions](https://github.com/rust-lang/rust/issues/49147).",
        "suggest": "在 future Rust 版本中，当数组字面量语法允许 [重复常量表达式](https://github.com/rust-lang/rust/issues/49147) 时，此方法可能变得不必要。",
        "translate": ""
    },
    {
        "source": "The example below could then use `let mut buf = [MaybeUninit::<u8>::uninit(); 32];`.",
        "suggest": "然后，下面的示例可以使用 `let mut buf = [MaybeUninit::<u8>::uninit(); 32];`。",
        "translate": ""
    },
    {
        "source": "An uninitialized `[MaybeUninit<_>; LEN]` is valid.",
        "suggest": "未初始化的 `[MaybeUninit<_>; LEN]` 有效。",
        "translate": ""
    },
    {
        "source": "Creates a new `MaybeUninit<T>` in an uninitialized state, with the memory being filled with `0` bytes.",
        "suggest": "在未初始化状态下创建新的 `MaybeUninit<T>`，并用 `0` 字节填充内存。",
        "translate": ""
    },
    {
        "source": "It depends on `T` whether that already makes for proper initialization.",
        "suggest": "取决于 `T` 是否已经进行了正确的初始化。",
        "translate": ""
    },
    {
        "source": "For example, `MaybeUninit<usize>::zeroed()` is initialized, but `MaybeUninit<&'static i32>::zeroed()` is not because references must not be null.",
        "suggest": "例如，初始化 `MaybeUninit<usize>::zeroed()`，但不初始化 `MaybeUninit<&'static i32>::zeroed()`，因为引用不能为空。",
        "translate": ""
    },
    {
        "source": "Correct usage of this function: initializing a struct with zero, where all fields of the struct can hold the bit-pattern 0 as a valid value.",
        "suggest": "此函数的正确用法: 用零初始化结构体，其中结构体的所有字段都可以将位模式 0 保留为有效值。",
        "translate": ""
    },
    {
        "source": "*Incorrect* usage of this function: calling `x.zeroed().assume_init()` when `0` is not a valid bit-pattern for the type:",
        "suggest": "该函数的 *错误* 用法: 当 `0` 不是该类型的有效位模式时，调用 `x.zeroed().assume_init()`:",
        "translate": ""
    },
    {
        "source": "`u.as_mut_ptr()` points to allocated memory.",
        "suggest": "`u.as_mut_ptr()` 指向分配的内存。",
        "translate": ""
    },
    {
        "source": "Sets the value of the `MaybeUninit<T>`.",
        "suggest": "设置 `MaybeUninit<T>` 的值。",
        "translate": ""
    },
    {
        "source": "This overwrites any previous value without dropping it, so be careful not to use this twice unless you want to skip running the destructor.",
        "suggest": "这将覆盖任何先前的值而不将其丢弃，因此请注意不要重复使用此两次，除非您要跳过运行析构函数。",
        "translate": ""
    },
    {
        "source": "For your convenience, this also returns a mutable reference to the (now safely initialized) contents of `self`.",
        "suggest": "为了您的方便，这也将 `self` 的内容 (现在已安全初始化) 返回变量引用。",
        "translate": ""
    },
    {
        "source": "We just initialized this value.",
        "suggest": "我们只是初始化了这个值。",
        "translate": ""
    },
    {
        "source": "Gets a pointer to the contained value.",
        "suggest": "获取指向包含值的指针。",
        "translate": ""
    },
    {
        "source": "Reading from this pointer or turning it into a reference is undefined behavior unless the `MaybeUninit<T>` is initialized.",
        "suggest": "除非初始化 `MaybeUninit<T>`，否则从该指针读取或将其转换为 quot 是未定义的行为。",
        "translate": ""
    },
    {
        "source": "Writing to memory that this pointer (non-transitively) points to is undefined behavior (except inside an `UnsafeCell<T>`).",
        "suggest": "写入该指针 (non-transitively) 指向的内存是未定义的行为 (`UnsafeCell<T>` 内部除外)。",
        "translate": ""
    },
    {
        "source": "Correct usage of this method:",
        "suggest": "正确使用此方法:",
        "translate": ""
    },
    {
        "source": "*Incorrect* usage of this method:",
        "suggest": "这个方法的错误用法:",
        "translate": ""
    },
    {
        "source": "(Notice that the rules around references to uninitialized data are not finalized yet, but until they are, it is advisable to avoid them.)",
        "suggest": "(请注意，围绕未初始化数据引用的规则尚未最终确定，但是除非被确定，否则建议避免使用它们。)",
        "translate": ""
    },
    {
        "source": "and `ManuallyDrop` are both `repr(transparent)` so we can cast the pointer.",
        "suggest": "和 `ManuallyDrop` 都是 `repr(transparent)`，因此我们可以强制转换指针。",
        "translate": ""
    },
    {
        "source": "Gets a mutable pointer to the contained value.",
        "suggest": "获取指向包含值的可变指针。",
        "translate": ""
    },
    {
        "source": "Extracts the value from the `MaybeUninit<T>` container.",
        "suggest": "从 `MaybeUninit<T>` 容器中提取值。",
        "translate": ""
    },
    {
        "source": "This is a great way to ensure that the data will get dropped, because the resulting `T` is subject to the usual drop handling.",
        "suggest": "这是确保数据将被丢弃的好方法，因为生成的 `T` 受到通常的丢弃处理。",
        "translate": ""
    },
    {
        "source": "It is up to the caller to guarantee that the `MaybeUninit<T>` really is in an initialized state.",
        "suggest": "取决于调用方，以确保 `MaybeUninit<T>` 确实处于初始化状态。",
        "translate": ""
    },
    {
        "source": "The [type-level documentation][inv] contains more information about this initialization invariant.",
        "suggest": "[类型级文档][inv] 中包含了有关此初始化不可变变量的更多信息。",
        "translate": ""
    },
    {
        "source": "the caller must guarantee that `self` is initialized.",
        "suggest": "调用者必须保证 `self` 已初始化。",
        "translate": ""
    },
    {
        "source": "This also means that `self` must be a `value` variant.",
        "suggest": "这也意味着 `self` 必须是 `value` 成员。",
        "translate": ""
    },
    {
        "source": "Reads the value from the `MaybeUninit<T>` container.",
        "suggest": "从 `MaybeUninit<T>` 容器中读取值。",
        "translate": ""
    },
    {
        "source": "The resulting `T` is subject to the usual drop handling.",
        "suggest": "结果 `T` 受通常的 drop 处理影响。",
        "translate": ""
    },
    {
        "source": "Whenever possible, it is preferable to use [`assume_init`] instead, which prevents duplicating the content of the `MaybeUninit<T>`.",
        "suggest": "只要有可能，最好改用 [`assume_init`]，这样可以防止重复 `MaybeUninit<T>` 的内容。",
        "translate": ""
    },
    {
        "source": "Moreover, this leaves a copy of the same data behind in the `MaybeUninit<T>`.",
        "suggest": "而且，这会将相同数据的副本留在 `MaybeUninit<T>` 中。",
        "translate": ""
    },
    {
        "source": "When using multiple copies of the data (by calling `assume_init_read` multiple times, or first calling `assume_init_read` and then [`assume_init`]), it is your responsibility to ensure that that data may indeed be duplicated.",
        "suggest": "使用数据的多个副本时 (通过多次调用 `assume_init_read`，或先调用 `assume_init_read`，然后再调用 [`assume_init`])，您有责任确保确实可以复制数据。",
        "translate": ""
    },
    {
        "source": "Reading from `self.as_ptr()` is safe since `self` should be initialized.",
        "suggest": "从 `self.as_ptr()` 读取数据是安全的，因为应该初始化 `self`。",
        "translate": ""
    },
    {
        "source": "Drops the contained value in place.",
        "suggest": "将包含的值放置到位。",
        "translate": ""
    },
    {
        "source": "If you have ownership of the `MaybeUninit`, you can use [`assume_init`] instead.",
        "suggest": "如果您拥有 `MaybeUninit` 的所有权，则可以改用 [`assume_init`]。",
        "translate": ""
    },
    {
        "source": "On top of that, all additional invariants of the type `T` must be satisfied, as the `Drop` implementation of `T` (or its members) may rely on this.",
        "suggest": "最重要的是，必须满足类型 `T` 的所有其他不可变变量，因为 `T` (或其成员) 的 `Drop` 实现可能依赖于此。",
        "translate": ""
    },
    {
        "source": "Dropping such a `Vec<T>` however will cause undefined behaviour.",
        "suggest": "但是，丢弃这样的 `Vec<T>` 会导致不确定的行为。",
        "translate": ""
    },
    {
        "source": "the caller must guarantee that `self` is initialized and satisfies all invariants of `T`.",
        "suggest": "调用者必须保证 `self` 已初始化并且满足 `T` 的所有不可变变量。",
        "translate": ""
    },
    {
        "source": "Dropping the value in place is safe if that is the case.",
        "suggest": "在这种情况下，将值放到适当的位置是安全的。",
        "translate": ""
    },
    {
        "source": "Gets a shared reference to the contained value.",
        "suggest": "获取对包含值的共享引用。",
        "translate": ""
    },
    {
        "source": "This can be useful when we want to access a `MaybeUninit` that has been initialized but don't have ownership of the `MaybeUninit` (preventing the use of `.assume_init()`).",
        "suggest": "当我们要访问已初始化但没有 `MaybeUninit` 所有权 (防止使用 `.assume_init()`) 的 `MaybeUninit` 时，这很有用。",
        "translate": ""
    },
    {
        "source": "Calling this when the content is not yet fully initialized causes undefined behavior: it is up to the caller to guarantee that the `MaybeUninit<T>` really is in an initialized state.",
        "suggest": "在内容尚未完全初始化时调用此方法会导致未定义的行为: 取决于调用方，以确保 `MaybeUninit<T>` 确实处于初始化状态。",
        "translate": ""
    },
    {
        "source": "*Incorrect* usages of this method:",
        "suggest": "这个方法的错误用法:",
        "translate": ""
    },
    {
        "source": "Gets a mutable (unique) reference to the contained value.",
        "suggest": "获取所包含值的可变 (unique) 引用。",
        "translate": ""
    },
    {
        "source": "For instance, `.assume_init_mut()` cannot be used to initialize a `MaybeUninit`.",
        "suggest": "例如，`.assume_init_mut()` 不能用于初始化 `MaybeUninit`。",
        "translate": ""
    },
    {
        "source": "You cannot use `.assume_init_mut()` to initialize a value:",
        "suggest": "您不能使用 `.assume_init_mut()` 初始化值:",
        "translate": ""
    },
    {
        "source": "For instance, you cannot [`Read`] into an uninitialized buffer:",
        "suggest": "例如，您不能 [`Read`] 进入未初始化的缓冲区:",
        "translate": ""
    },
    {
        "source": "Nor can you use direct field access to do field-by-field gradual initialization:",
        "suggest": "也不能使用直接字段访问来进行逐字段逐步初始化:",
        "translate": ""
    },
    {
        "source": "We currently rely on the above being incorrect, i.e., we have references to uninitialized data (e.g., in `libcore/fmt/float.rs`).",
        "suggest": "当前，我们依赖于上述错误信息，即，我们对未初始化的数据 (例如，在 `libcore/fmt/float.rs` 中) 进行了引用。",
        "translate": ""
    },
    {
        "source": "We should make a final decision about the rules before stabilization.",
        "suggest": "在稳定之前，我们应该对规则做出最后决定。",
        "translate": ""
    },
    {
        "source": "Extracts the values from an array of `MaybeUninit` containers.",
        "suggest": "从 `MaybeUninit` 容器数组中提取值。",
        "translate": ""
    },
    {
        "source": "It is up to the caller to guarantee that all elements of the array are in an initialized state.",
        "suggest": "调用方有责任保证数组的所有元素都处于初始化状态。",
        "translate": ""
    },
    {
        "source": "The caller guarantees that all elements of the array are initialized",
        "suggest": "调用者保证数组的所有元素都已初始化",
        "translate": ""
    },
    {
        "source": "and T are guaranteed to have the same layout",
        "suggest": "和 T 保证具有相同的布局",
        "translate": ""
    },
    {
        "source": "MaybeUnint does not drop, so there are no double-frees And thus the conversion is safe",
        "suggest": "也许 Unint 不会丢弃，所以没有双重释放，因此转换是安全的",
        "translate": ""
    },
    {
        "source": "Assuming all the elements are initialized, get a slice to them.",
        "suggest": "假设所有元素都已初始化，请对其进行切片。",
        "translate": ""
    },
    {
        "source": "It is up to the caller to guarantee that the `MaybeUninit<T>` elements really are in an initialized state.",
        "suggest": "取决于调用方，以确保 `MaybeUninit<T>` 元素确实处于初始化状态。",
        "translate": ""
    },
    {
        "source": "Calling this when the content is not yet fully initialized causes undefined behavior.",
        "suggest": "在内容尚未完全初始化时调用此方法会导致未定义的行为。",
        "translate": ""
    },
    {
        "source": "See [`assume_init_ref`] for more details and examples.",
        "suggest": "有关更多详细信息和示例，请参见 [`assume_init_ref`]。",
        "translate": ""
    },
    {
        "source": "casting slice to a `*const [T]` is safe since the caller guarantees that `slice` is initialized, and`MaybeUninit` is guaranteed to have the same layout as `T`.",
        "suggest": "将切片转换为 `*const [T]` 是安全的，因为调用方保证已初始化 `slice`，并保证 `MaybeUninit` 具有与 `T` 相同的布局。",
        "translate": ""
    },
    {
        "source": "The pointer obtained is valid since it refers to memory owned by `slice` which is a reference and thus guaranteed to be valid for reads.",
        "suggest": "所获得的指针是有效的，因为它引用 `slice` 拥有的内存，该内存是一个引用，因此可以保证对读取有效。",
        "translate": ""
    },
    {
        "source": "Assuming all the elements are initialized, get a mutable slice to them.",
        "suggest": "假设所有元素都已初始化，请为其获取可变切片。",
        "translate": ""
    },
    {
        "source": "See [`assume_init_mut`] for more details and examples.",
        "suggest": "有关更多详细信息和示例，请参见 [`assume_init_mut`]。",
        "translate": ""
    },
    {
        "source": "similar to safety notes for `slice_get_ref`, but we have a mutable reference which is also guaranteed to be valid for writes.",
        "suggest": "类似于 `slice_get_ref` 的安全说明，但我们有一个可变引用，也保证对写操作有效。",
        "translate": ""
    },
    {
        "source": "Gets a pointer to the first element of the array.",
        "suggest": "获取一个指向数组第一个元素的指针。",
        "translate": ""
    },
    {
        "source": "Gets a mutable pointer to the first element of the array.",
        "suggest": "获取指向数组第一个元素的可变指针。",
        "translate": ""
    },
    {
        "source": "Copies the elements from `src` to `this`, returning a mutable reference to the now initalized contents of `this`.",
        "suggest": "将元素从 `src` 复制到 `this`，并将变量引用返回到 `this` 的现在初始化的内容。",
        "translate": ""
    },
    {
        "source": "If `T` does not implement `Copy`, use [`write_slice_cloned`]",
        "suggest": "如果 `T` 未实现 `Copy`，请使用 [`write_slice_cloned`]",
        "translate": ""
    },
    {
        "source": "This is similar to [`slice::copy_from_slice`].",
        "suggest": "这类似于 [`slice::copy_from_slice`]。",
        "translate": ""
    },
    {
        "source": "This function will panic if the two slices have different lengths.",
        "suggest": "如果两个切片的长度不同，则此函数将为 panic。",
        "translate": ""
    },
    {
        "source": "&[T] and &[MaybeUninit<T>] have the same layout",
        "suggest": "&[T] and &[MaybeUninit<T>] 具有相同的布局",
        "translate": ""
    },
    {
        "source": "Valid elements have just been copied into `this` so it is initalized",
        "suggest": "有效元素刚刚被复制到 `this` 中，因此被初始化",
        "translate": ""
    },
    {
        "source": "Clones the elements from `src` to `this`, returning a mutable reference to the now initalized contents of `this`.",
        "suggest": "将元素从 `src` 克隆到 `this`，将变量引用返回到 `this` 的现在初始化的内容。",
        "translate": ""
    },
    {
        "source": "Any already initalized elements will not be dropped.",
        "suggest": "任何已经初始化的元素都不会被丢弃。",
        "translate": ""
    },
    {
        "source": "If `T` implements `Copy`, use [`write_slice`]",
        "suggest": "如果 `T` 实现 `Copy`，请使用 [`write_slice`]",
        "translate": ""
    },
    {
        "source": "This is similar to [`slice::clone_from_slice`] but does not drop existing elements.",
        "suggest": "这类似于 [`slice::clone_from_slice`]，但不会丢弃现有元素。",
        "translate": ""
    },
    {
        "source": "This function will panic if the two slices have different lengths, or if the implementation of `Clone` panics.",
        "suggest": "如果两个切片的长度不同，或者 `Clone` panics 的实现，则此函数将为 panic。",
        "translate": ""
    },
    {
        "source": "If there is a panic, the already cloned elements will be dropped.",
        "suggest": "如果存在 panic，将丢弃已经克隆的元素。",
        "translate": ""
    },
    {
        "source": "unlike copy_from_slice this does not call clone_from_slice on the slice this is because `MaybeUninit<T: Clone>` does not implement Clone.",
        "suggest": "与 copy_from_slice 不同，这不会在切片上调用 clone_from_slice，这是因为 `MaybeUninit<T: Clone>` 没有实现 Clone。",
        "translate": ""
    },
    {
        "source": "this raw slice will contain only initialized objects that's why, it is allowed to drop it.",
        "suggest": "此原始切片将仅包含初始化的对象，这就是为什么允许将其丢弃。",
        "translate": ""
    },
    {
        "source": "We need to explicitly slice them to the same length for bounds checking to be elided, and the optimizer will generate memcpy for simple cases (for example T = u8).",
        "suggest": "我们需要显式地将它们切成相同的长度，以消除边界检查，优化器将为简单情况生成 memcpy (例如 T= u8)。",
        "translate": ""
    },
    {
        "source": "guard is needed b/c panic might happen during a clone",
        "suggest": "需要保护 b/c 在克隆过程中可能会发生 panic",
        "translate": ""
    },
    {
        "source": "Valid elements have just been written into `this` so it is initalized",
        "suggest": "有效元素刚刚被写入 `this`，所以它是初始化的",
        "translate": ""
    },
    {
        "source": "Build a `String` using the contents of `v`",
        "suggest": "使用 `v` 的内容构建 `String`",
        "translate": ""
    },
    {
        "source": "leak `v` because its memory is now managed by `s`",
        "suggest": "泄漏 `v`，因为它的内存现在由 `s` 管理",
        "translate": ""
    },
    {
        "source": "ERROR - v is invalid and must not be passed to a function",
        "suggest": "错误 - v 无效，不得将其传递给函数",
        "translate": ""
    },
    {
        "source": "is implicitly dropped and its memory deallocated.",
        "suggest": "被隐式丢弃，并且其内存被释放。",
        "translate": ""
    },
    {
        "source": "Before we disassemble `v` into its raw parts, make sure it does not get dropped!",
        "suggest": "在将 `v` 拆解为原始零件之前，请确保它不会丢弃掉!",
        "translate": ""
    },
    {
        "source": "Now disassemble `v`.",
        "suggest": "现在拆卸 `v`。",
        "translate": ""
    },
    {
        "source": "These operations cannot panic, so there cannot be a leak.",
        "suggest": "这些操作不能 panic，因此不会有泄漏。",
        "translate": ""
    },
    {
        "source": "Finally, build a `String`.",
        "suggest": "最后，构建一个 `String`。",
        "translate": ""
    },
    {
        "source": "Some primitives",
        "suggest": "一些原语",
        "translate": ""
    },
    {
        "source": "Some arrays",
        "suggest": "一些数组",
        "translate": ""
    },
    {
        "source": "Pointer size equality",
        "suggest": "指针大小相等",
        "translate": ""
    },
    {
        "source": "The size of the first field is 1, so add 1 to the size.",
        "suggest": "第一个字段的大小为 1，因此请在大小上加 1。",
        "translate": ""
    },
    {
        "source": "Size is 1.",
        "suggest": "大小为 1。",
        "translate": ""
    },
    {
        "source": "The alignment of the second field is 2, so add 1 to the size for padding.",
        "suggest": "第二个字段的对齐方式为 2，因此在填充大小上加 1。",
        "translate": ""
    },
    {
        "source": "Size is 2.",
        "suggest": "大小为 2。",
        "translate": ""
    },
    {
        "source": "The size of the second field is 2, so add 2 to the size.",
        "suggest": "第二个字段的大小为 2，因此将大小加 2。",
        "translate": ""
    },
    {
        "source": "Size is 4.",
        "suggest": "大小为 4。",
        "translate": ""
    },
    {
        "source": "The alignment of the third field is 1, so add 0 to the size for padding.",
        "suggest": "第三个字段的对齐方式为 1，因此请在填充大小上加上 0。",
        "translate": ""
    },
    {
        "source": "The size of the third field is 1, so add 1 to the size.",
        "suggest": "第三个字段的大小为 1，因此请在大小上加 1。",
        "translate": ""
    },
    {
        "source": "Size is 5.",
        "suggest": "大小为 5。",
        "translate": ""
    },
    {
        "source": "Finally, the alignment of the struct is 2 (because the largest alignment amongst its fields is 2), so add 1 to the size for padding.",
        "suggest": "最后，结构体的对齐方式为 2 (因为其字段之间的最大对齐方式为 2)，所以在填充的大小上加 1。",
        "translate": ""
    },
    {
        "source": "Size is 6.",
        "suggest": "大小为 6。",
        "translate": ""
    },
    {
        "source": "Tuple structs follow the same rules.",
        "suggest": "元组结构体遵循相同的规则。",
        "translate": ""
    },
    {
        "source": "Note that reordering the fields can lower the size.",
        "suggest": "请注意，对字段重新排序可以减小大小。",
        "translate": ""
    },
    {
        "source": "We can remove both padding bytes by putting `third` before `second`.",
        "suggest": "我们可以通过将 `third` 放在 `second` 之前删除两个填充字节。",
        "translate": ""
    },
    {
        "source": "Union size is the size of the largest field.",
        "suggest": "union 的大小是最大字段的大小。",
        "translate": ""
    },
    {
        "source": "drop the data",
        "suggest": "丢弃数据",
        "translate": ""
    },
    {
        "source": "Undefined behavior!",
        "suggest": "未定义的行为!",
        "translate": ""
    },
    {
        "source": "And again!",
        "suggest": "然后再次!",
        "translate": ""
    },
    {
        "source": "error: cannot move out of dereference of `&mut`-pointer",
        "suggest": "错误: 无法移出 & mut-pointer 指针的解引用",
        "translate": ""
    },
    {
        "source": "explicitly drop the vector",
        "suggest": "显式丢弃 vector",
        "translate": ""
    },
    {
        "source": "relinquish the mutable borrow on this slot",
        "suggest": "放弃该插槽上的可变借用",
        "translate": ""
    },
    {
        "source": "a copy of `x` is moved and dropped",
        "suggest": "`x` 的副本已移动并丢弃",
        "translate": ""
    },
    {
        "source": "a copy of `y` is moved and dropped",
        "suggest": "`y` 的副本已移动并丢弃",
        "translate": ""
    },
    {
        "source": "still available",
        "suggest": "仍然可用",
        "translate": ""
    },
    {
        "source": "Copy the data from 'foo_array' and treat it as a 'Foo'",
        "suggest": "从 'foo_array' 复制数据并将其视为 'Foo'",
        "translate": ""
    },
    {
        "source": "Modify the copied data",
        "suggest": "修改复制的数据",
        "translate": ""
    },
    {
        "source": "The contents of 'foo_array' should not have changed",
        "suggest": "'foo_array' 的内容不应更改",
        "translate": ""
    },
    {
        "source": "Basic functions for dealing with memory.",
        "suggest": "处理内存的基本函数。",
        "translate": ""
    },
    {
        "source": "This module contains functions for querying the size and alignment of types, initializing and manipulating memory.",
        "suggest": "该模块包含用于查询类型的大小和对齐，初始化和操作内存的函数。",
        "translate": ""
    },
    {
        "source": "Takes ownership and \"forgets\" about the value **without running its destructor**.",
        "suggest": "在不运行其析构函数 **的情况下，获取所有权和 \"forgets\" 值**。",
        "translate": ""
    },
    {
        "source": "Any resources the value manages, such as heap memory or a file handle, will linger forever in an unreachable state.",
        "suggest": "该值管理的任何资源 (例如堆内存或文件句柄) 将永远处于无法访问的状态。",
        "translate": ""
    },
    {
        "source": "However, it does not guarantee that pointers to this memory will remain valid.",
        "suggest": "但是，它不能保证指向该内存的指针将保持有效。",
        "translate": ""
    },
    {
        "source": "If you want to leak memory, see [`Box::leak`].",
        "suggest": "如果要泄漏内存，请参见 [`Box::leak`]。",
        "translate": ""
    },
    {
        "source": "If you want to obtain a raw pointer to the memory, see [`Box::into_raw`].",
        "suggest": "如果要获取内存的裸指针，请参见 [`Box::into_raw`]。",
        "translate": ""
    },
    {
        "source": "If you want to dispose of a value properly, running its destructor, see [`mem::drop`].",
        "suggest": "如果要正确处理某个值，请运行其析构函数，请参见 [`mem::drop`]。",
        "translate": ""
    },
    {
        "source": "is not marked as `unsafe`, because Rust's safety guarantees do not include a guarantee that destructors will always run.",
        "suggest": "未将其标记为 `unsafe`，因为 Rust 的安全保证不包括析构函数将始终运行的保证。",
        "translate": ""
    },
    {
        "source": "For example, a program can create a reference cycle using [`Rc`][rc], or call [`process::exit`][exit] to exit without running destructors.",
        "suggest": "例如，程序可以使用 [`Rc`][rc] 创建引用循环，或调用 [`process::exit`][exit] 退出而不运行析构函数。",
        "translate": ""
    },
    {
        "source": "Thus, allowing `mem::forget` from safe code does not fundamentally change Rust's safety guarantees.",
        "suggest": "因此，从安全代码允许 `mem::forget` 不会从根本上改变 Rust 的安全保证。",
        "translate": ""
    },
    {
        "source": "That said, leaking resources such as memory or I/O objects is usually undesirable.",
        "suggest": "也就是说，通常不希望泄漏诸如内存或 I/O 对象之类的资源。",
        "translate": ""
    },
    {
        "source": "The need comes up in some specialized use cases for FFI or unsafe code, but even then, [`ManuallyDrop`] is typically preferred.",
        "suggest": "在某些特殊的用例中，对于 FFI 或不安全代码提出了需求，但即使这样，通常还是首选 [`ManuallyDrop`]。",
        "translate": ""
    },
    {
        "source": "Because forgetting a value is allowed, any `unsafe` code you write must allow for this possibility.",
        "suggest": "因为允许忘记一个值，所以您编写的任何 `unsafe` 代码都必须允许这种可能性。",
        "translate": ""
    },
    {
        "source": "You cannot return a value and expect that the caller will necessarily run the value's destructor.",
        "suggest": "您不能返回值，并且期望调用者一定会运行该值的析构函数。",
        "translate": ""
    },
    {
        "source": "The canonical safe use of `mem::forget` is to circumvent a value's destructor implemented by the `Drop` trait.",
        "suggest": "`mem::forget` 的规范安全使用是为了避免 `Drop` trait 实现的值的析构函数。",
        "translate": ""
    },
    {
        "source": "For example, this will leak a `File`, i.e.",
        "suggest": "例如，这将泄漏 `File`，即",
        "translate": ""
    },
    {
        "source": "reclaim the space taken by the variable but never close the underlying system resource:",
        "suggest": "回收变量占用的空间，但不要关闭基础系统资源:",
        "translate": ""
    },
    {
        "source": "This is useful when the ownership of the underlying resource was previously transferred to code outside of Rust, for example by transmitting the raw file descriptor to C code.",
        "suggest": "当基础资源的所有权先前已转移到 Rust 之外的代码时 (例如，通过将原始文件描述符传输到 C 代码)，这很有用。",
        "translate": ""
    },
    {
        "source": "Relationship with `ManuallyDrop`",
        "suggest": "与 `ManuallyDrop` 的关系",
        "translate": ""
    },
    {
        "source": "While `mem::forget` can also be used to transfer *memory* ownership, doing so is error-prone.",
        "suggest": "虽然 `mem::forget` 也可以用于转移 *内存* 所有权，但是这样做很容易出错。",
        "translate": ""
    },
    {
        "source": "should be used instead.",
        "suggest": "应该改用。",
        "translate": ""
    },
    {
        "source": "Consider, for example, this code:",
        "suggest": "例如，考虑以下代码:",
        "translate": ""
    },
    {
        "source": "There are two issues with the above example:",
        "suggest": "上面的示例有两个问题:",
        "translate": ""
    },
    {
        "source": "If more code were added between the construction of `String` and the invocation of `mem::forget()`, a panic within it would cause a double free because the same memory is handled by both `v` and `s`.",
        "suggest": "如果在 `String` 的构造与 `mem::forget()` 的调用之间添加了更多代码，则其中的 panic 将导致双重释放，因为 `v` 和 `s` 均处理同一内存。",
        "translate": ""
    },
    {
        "source": "After calling `v.as_mut_ptr()` and transmitting the ownership of the data to `s`, the `v` value is invalid.",
        "suggest": "调用 `v.as_mut_ptr()` 并将数据所有权传输到 `s` 之后，`v` 值无效。",
        "translate": ""
    },
    {
        "source": "Even when a value is just moved to `mem::forget` (which won't inspect it), some types have strict requirements on their values that make them invalid when dangling or no longer owned.",
        "suggest": "即使将值仅移动到 `mem::forget` (不会检查它)，某些类型对其值也有严格的要求，以使它们在悬空或不再拥有时无效。",
        "translate": ""
    },
    {
        "source": "Using invalid values in any way, including passing them to or returning them from functions, constitutes undefined behavior and may break the assumptions made by the compiler.",
        "suggest": "以任何方式使用无效值，包括将它们传递给函数或从函数中返回它们，都构成未定义的行为，并且可能会破坏编译器所做的假设。",
        "translate": ""
    },
    {
        "source": "Switching to `ManuallyDrop` avoids both issues:",
        "suggest": "切换到 `ManuallyDrop` 可以避免两个问题:",
        "translate": ""
    },
    {
        "source": "robustly prevents double-free because we disable `v`'s destructor before doing anything else.",
        "suggest": "强有力地防止了双重释放，因为在执行其他任何操作之前，我们先禁用了 v 的析构函数。",
        "translate": ""
    },
    {
        "source": "doesn't allow this because it consumes its argument, forcing us to call it only after extracting anything we need from `v`.",
        "suggest": "不允许这样做，因为它消耗了其参数，仅在从 `v` 中提取了我们需要的所有内容后，才迫使我们调用它。",
        "translate": ""
    },
    {
        "source": "Even if a panic were introduced between construction of `ManuallyDrop` and building the string (which cannot happen in the code as shown), it would result in a leak and not a double free.",
        "suggest": "即使在 `ManuallyDrop` 的构建与字符串的构建之间引入了 panic (这在所示的代码中不能发生)，也将导致泄漏，而不是双重释放。",
        "translate": ""
    },
    {
        "source": "In other words, `ManuallyDrop` errs on the side of leaking instead of erring on the side of (double-)dropping.",
        "suggest": "换句话说，`ManuallyDrop` 在泄漏的一侧发生错误，而不是在 (两次) 丢弃的一侧发生错误。",
        "translate": ""
    },
    {
        "source": "Also, `ManuallyDrop` prevents us from having to \"touch\" `v` after transferring the ownership to `s` — the final step of interacting with `v` to dispose of it without running its destructor is entirely avoided.",
        "suggest": "同样，`ManuallyDrop` 避免了在将所有权转让给 `s` 之后必须使用 \"touch\" `v` 的情况-完全避免了与 `v` 交互以处置它而不运行其析构函数的最后一步。",
        "translate": ""
    },
    {
        "source": "Like [`forget`], but also accepts unsized values.",
        "suggest": "与 [`forget`] 一样，但也接受未定义大小的值。",
        "translate": ""
    },
    {
        "source": "This function is just a shim intended to be removed when the `unsized_locals` feature gets stabilized.",
        "suggest": "该函数只是 `unsized_locals` 功能稳定后要删除的垫片。",
        "translate": ""
    },
    {
        "source": "Returns the size of a type in bytes.",
        "suggest": "返回类型的大小 (以字节为单位)。",
        "translate": ""
    },
    {
        "source": "More specifically, this is the offset in bytes between successive elements in an array with that item type including alignment padding.",
        "suggest": "更具体地说，这是具有该项类型 (包括对齐填充) 的数组中连续元素之间的字节偏移量。",
        "translate": ""
    },
    {
        "source": "Thus, for any type `T` and length `n`, `[T; n]` has a size of `n * size_of::<T>()`.",
        "suggest": "因此，对于任何类型的 `T` 和长度 `n`，`[T; n]` 的大小都是 `n * size_of::<T>()`。",
        "translate": ""
    },
    {
        "source": "In general, the size of a type is not stable across compilations, but specific types such as primitives are.",
        "suggest": "通常，类型的大小在整个编译过程中不稳定，但是特定类型 (例如基元) 是稳定的。",
        "translate": ""
    },
    {
        "source": "The following table gives the size for primitives.",
        "suggest": "下表提供了基元的大小。",
        "translate": ""
    },
    {
        "source": "Furthermore, `usize` and `isize` have the same size.",
        "suggest": "此外，`usize` 和 `isize` 具有相同的大小。",
        "translate": ""
    },
    {
        "source": "The types `*const T`, `&T`, `Box<T>`, `Option<&T>`, and `Option<Box<T>>` all have the same size.",
        "suggest": "`*const T`，`&T`，`Box<T>`，`Option<&T>` 和 `Option<Box<T>>` 类型均具有相同的大小。",
        "translate": ""
    },
    {
        "source": "If `T` is Sized, all of those types have the same size as `usize`.",
        "suggest": "如果将 `T` 调整为大小，则所有这些类型的大小均与 `usize` 相同。",
        "translate": ""
    },
    {
        "source": "The mutability of a pointer does not change its size.",
        "suggest": "指针的可变性不会改变其大小。",
        "translate": ""
    },
    {
        "source": "As such, `&T` and `&mut T` have the same size.",
        "suggest": "这样，`&T` 和 `&mut T` 具有相同的大小。",
        "translate": ""
    },
    {
        "source": "Likewise for `*const T` and `*mut T`.",
        "suggest": "对于 `*const T` 和 `* mut T` 同样。",
        "translate": ""
    },
    {
        "source": "Size of `#[repr(C)]` items",
        "suggest": "`#[repr(C)]` 项的大小",
        "translate": ""
    },
    {
        "source": "The `C` representation for items has a defined layout.",
        "suggest": "项的 `C` 表示具有已定义的布局。",
        "translate": ""
    },
    {
        "source": "With this layout, the size of items is also stable as long as all fields have a stable size.",
        "suggest": "使用此布局，只要所有字段的大小都稳定，则项的大小也将保持稳定。",
        "translate": ""
    },
    {
        "source": "Size of Structs",
        "suggest": "结构体的大小",
        "translate": ""
    },
    {
        "source": "For `structs`, the size is determined by the following algorithm.",
        "suggest": "对于 `structs`，大小由以下算法确定。",
        "translate": ""
    },
    {
        "source": "For each field in the struct ordered by declaration order:",
        "suggest": "对于结构体中按声明顺序排序的每个字段:",
        "translate": ""
    },
    {
        "source": "Add the size of the field.",
        "suggest": "添加字段的大小。",
        "translate": ""
    },
    {
        "source": "Round up the current size to the nearest multiple of the next field's [alignment].",
        "suggest": "将当前大小四舍五入到下一个字段的 [alignment] 的最接近倍数。",
        "translate": ""
    },
    {
        "source": "Finally, round the size of the struct to the nearest multiple of its [alignment].",
        "suggest": "最后，将结构体的大小四舍五入到其 [alignment] 的最接近倍数。",
        "translate": ""
    },
    {
        "source": "The alignment of the struct is usually the largest alignment of all its fields;",
        "suggest": "结构体的排列通常是其所有字段中最大的排列;",
        "translate": ""
    },
    {
        "source": "this can be changed with the use of `repr(align(N))`.",
        "suggest": "这可以通过使用 `repr(align(N))` 进行更改。",
        "translate": ""
    },
    {
        "source": "Unlike `C`, zero sized structs are not rounded up to one byte in size.",
        "suggest": "与 `C` 不同，零大小的结构体不会四舍五入为一个字节。",
        "translate": ""
    },
    {
        "source": "Size of Enums",
        "suggest": "枚举的大小",
        "translate": ""
    },
    {
        "source": "Enums that carry no data other than the discriminant have the same size as C enums on the platform they are compiled for.",
        "suggest": "除判别式外不包含任何数据的枚举的大小与为其编译的平台上的 C 枚举的大小相同。",
        "translate": ""
    },
    {
        "source": "Size of Unions",
        "suggest": "union 的大小",
        "translate": ""
    },
    {
        "source": "The size of a union is the size of its largest field.",
        "suggest": "union 的大小是其最大字段的大小。",
        "translate": ""
    },
    {
        "source": "Unlike `C`, zero sized unions are not rounded up to one byte in size.",
        "suggest": "与 `C` 不同，零大小的 union 不会被四舍五入到一个字节的大小。",
        "translate": ""
    },
    {
        "source": "Using `#[repr(C)]`.",
        "suggest": "使用 `#[repr(C)]`。",
        "translate": ""
    },
    {
        "source": "Returns the size of the pointed-to value in bytes.",
        "suggest": "返回所指向的值的大小 (以字节为单位)。",
        "translate": ""
    },
    {
        "source": "This is usually the same as `size_of::<T>()`.",
        "suggest": "这通常与 `size_of::<T>()` 相同。",
        "translate": ""
    },
    {
        "source": "However, when `T` *has* no statically-known size, e.g., a slice [`[T]`][slice] or a [trait object], then `size_of_val` can be used to get the dynamically-known size.",
        "suggest": "但是，当 `T` 没有静态已知的大小 (例如，切片 [`[T]`][slice] 或 [trait object]) 时，可以使用 `size_of_val` 获得动态已知的大小。",
        "translate": ""
    },
    {
        "source": "`val` is a reference, so it's a valid raw pointer",
        "suggest": "`val` 是引用，因此它是有效的裸指针",
        "translate": ""
    },
    {
        "source": "a [slice], then the length of the slice tail must be an initialized integer, and the size of the *entire value* (dynamic tail length + statically sized prefix) must fit in `isize`.",
        "suggest": "[slice]，则切片尾部的长度必须是初始化的整数，并且 *entire 值*(动态尾部长度 + 静态大小的前缀) 的大小必须适合 `isize`。",
        "translate": ""
    },
    {
        "source": "a [trait object], then the vtable part of the pointer must point to a valid vtable acquired by an unsizing coercion, and the size of the *entire value* (dynamic tail length + statically sized prefix) must fit in `isize`.",
        "suggest": "[trait object]，则指针的 vtable 部分必须指向通过取消大小调整强制获取的有效 vtable，并且 *entire 值*(动态尾部长度 + 静态大小的前缀) 的大小必须适合 `isize`。",
        "translate": ""
    },
    {
        "source": "This is the same behavior as [`size_of_val`] on a reference to a type with an extern type tail.",
        "suggest": "这与带有外部类型尾部的类型的引用上的 [`size_of_val`] 行为相同。",
        "translate": ""
    },
    {
        "source": "the caller must provide a valid raw pointer",
        "suggest": "调用者必须提供有效的裸指针",
        "translate": ""
    },
    {
        "source": "Returns the [ABI]-required minimum alignment of a type.",
        "suggest": "返回 [ABI] 要求的类型的最小对齐方式。",
        "translate": ""
    },
    {
        "source": "Every reference to a value of the type `T` must be a multiple of this number.",
        "suggest": "`T` 类型的值的每个引用必须是该数字的倍数。",
        "translate": ""
    },
    {
        "source": "This is the alignment used for struct fields.",
        "suggest": "这是用于结构字段的对齐方式。",
        "translate": ""
    },
    {
        "source": "It may be smaller than the preferred alignment.",
        "suggest": "它可能小于首选的对齐方式。",
        "translate": ""
    },
    {
        "source": "Returns the [ABI]-required minimum alignment of the type of the value that `val` points to.",
        "suggest": "返回 [ABI] 所需的 `val` 指向的值的类型的最小对齐方式。",
        "translate": ""
    },
    {
        "source": "val is a reference, so it's a valid raw pointer",
        "suggest": "val 是一个引用，因此它是有效的裸指针",
        "translate": ""
    },
    {
        "source": "This is the same behavior as [`align_of_val`] on a reference to a type with an extern type tail.",
        "suggest": "这与带有外部类型尾部的类型的引用上的 [`align_of_val`] 行为相同。",
        "translate": ""
    },
    {
        "source": "Returns `true` if dropping values of type `T` matters.",
        "suggest": "如果丢弃类型为 `T` 的值很重要，则返回 `true`。",
        "translate": ""
    },
    {
        "source": "This is purely an optimization hint, and may be implemented conservatively:",
        "suggest": "这纯粹是一个优化提示，可以保守地实现:",
        "translate": ""
    },
    {
        "source": "it may return `true` for types that don't actually need to be dropped.",
        "suggest": "对于实际上不需要丢弃的类型，它可能返回 `true`。",
        "translate": ""
    },
    {
        "source": "As such always returning `true` would be a valid implementation of this function.",
        "suggest": "因此，始终返回 `true` 将是此函数的有效实现。",
        "translate": ""
    },
    {
        "source": "However if this function actually returns `false`, then you can be certain dropping `T` has no side effect.",
        "suggest": "但是，如果此函数实际返回 `false`，则可以确定丢弃 `T` 没有副作用。",
        "translate": ""
    },
    {
        "source": "Low level implementations of things like collections, which need to manually drop their data, should use this function to avoid unnecessarily trying to drop all their contents when they are destroyed.",
        "suggest": "需要手动丢弃其数据的诸如集合之类的底层实现，应使用此函数来避免在销毁它们时不必要地丢弃其所有内容。",
        "translate": ""
    },
    {
        "source": "This might not make a difference in release builds (where a loop that has no side-effects is easily detected and eliminated), but is often a big win for debug builds.",
        "suggest": "这可能不会对发行版本产生影响 (可以轻松检测并消除没有副作用的循环)，但是对于调试版本而言，这通常是一个大胜利。",
        "translate": ""
    },
    {
        "source": "Note that [`drop_in_place`] already performs this check, so if your workload can be reduced to some small number of [`drop_in_place`] calls, using this is unnecessary.",
        "suggest": "请注意，[`drop_in_place`] 已经执行了此检查，因此，如果您的工作量可以减少到少量的 [`drop_in_place`] 调用，则无需使用此功能。",
        "translate": ""
    },
    {
        "source": "In particular note that you can [`drop_in_place`] a slice, and that will do a single needs_drop check for all the values.",
        "suggest": "特别要注意的是，您可以 [`drop_in_place`] 一个切片，这将对所有值进行一次 needs_drop 检查。",
        "translate": ""
    },
    {
        "source": "Types like Vec therefore just `drop_in_place(&mut self[..])` without using `needs_drop` explicitly.",
        "suggest": "因此，像 Vec 这样的类型只是 `drop_in_place(&mut self[..])`，而没有显式使用 `needs_drop`。",
        "translate": ""
    },
    {
        "source": "Types like [`HashMap`], on the other hand, have to drop values one at a time and should use this API.",
        "suggest": "另一方面，像 [`HashMap`] 这样的类型必须一次丢弃一个值，并且应使用此 API。",
        "translate": ""
    },
    {
        "source": "Here's an example of how a collection might make use of `needs_drop`:",
        "suggest": "这是一个集合如何利用 `needs_drop` 的示例:",
        "translate": ""
    },
    {
        "source": "Returns the value of type `T` represented by the all-zero byte-pattern.",
        "suggest": "返回由全零字节模式表示的 `T` 类型的值。",
        "translate": ""
    },
    {
        "source": "This means that, for example, the padding byte in `(u8, u16)` is not necessarily zeroed.",
        "suggest": "这意味着，例如，`(u8, u16)` 中的填充字节不必为零。",
        "translate": ""
    },
    {
        "source": "There is no guarantee that an all-zero byte-pattern represents a valid value of some type `T`.",
        "suggest": "不能保证全零字节模式代表某种 `T` 类型的有效值。",
        "translate": ""
    },
    {
        "source": "For example, the all-zero byte-pattern is not a valid value for reference types (`&T`, `&mut T`) and functions pointers.",
        "suggest": "例如，对于引用类型 (`&T`，`&mut T`) 和函数指针，全零字节模式不是有效值。",
        "translate": ""
    },
    {
        "source": "Using `zeroed` on such types causes immediate [undefined behavior][ub] because [the Rust compiler assumes][inv] that there always is a valid value in a variable it considers initialized.",
        "suggest": "在此类类型上使用 `zeroed` 会立即导致 [未定义的行为][ub]，因为 [Rust 编译器][inv] 假设在它认为已初始化的变量中始终存在有效值。",
        "translate": ""
    },
    {
        "source": "This has the same effect as [`MaybeUninit::zeroed().assume_init()`][zeroed].",
        "suggest": "与 [`MaybeUninit::zeroed().assume_init()`][zeroed] 具有相同的作用。",
        "translate": ""
    },
    {
        "source": "It is useful for FFI sometimes, but should generally be avoided.",
        "suggest": "有时对 FFI 很有用，但通常应避免使用。",
        "translate": ""
    },
    {
        "source": "Correct usage of this function: initializing an integer with zero.",
        "suggest": "此函数的正确用法: 用零初始化一个整数。",
        "translate": ""
    },
    {
        "source": "*Incorrect* usage of this function: initializing a reference with zero.",
        "suggest": "该函数的 *错误* 用法: 用零初始化引用。",
        "translate": ""
    },
    {
        "source": "the caller must guarantee that an all-zero value is valid for `T`.",
        "suggest": "调用者必须保证全零值对 `T` 有效。",
        "translate": ""
    },
    {
        "source": "Bypasses Rust's normal memory-initialization checks by pretending to produce a value of type `T`, while doing nothing at all.",
        "suggest": "假装产生 `T` 类型的值，而实际上什么也不做，从而绕过 Rust 的常规内存初始化检查。",
        "translate": ""
    },
    {
        "source": "**This function is deprecated.** Use [`MaybeUninit<T>`] instead.",
        "suggest": "**不推荐使用此函数。** 请改用 [`MaybeUninit<T>`]。",
        "translate": ""
    },
    {
        "source": "The reason for deprecation is that the function basically cannot be used correctly: it has the same effect as [`MaybeUninit::uninit().assume_init()`][uninit].",
        "suggest": "弃用的原因是该函数基本上不能正确使用: 它具有与 [`MaybeUninit::uninit().assume_init()`][uninit] 相同的作用。",
        "translate": ""
    },
    {
        "source": "As the [`assume_init` documentation][assume_init] explains, [the Rust compiler assumes][inv] that values are properly initialized.",
        "suggest": "正如 [`assume_init` 文档][assume_init] 所解释的那样，[Rust 编译器][inv] 假设值已正确初始化。",
        "translate": ""
    },
    {
        "source": "As a consequence, calling e.g.",
        "suggest": "因此，调用例如",
        "translate": ""
    },
    {
        "source": "causes immediate undefined behavior for returning a `bool` that is not definitely either `true` or `false`.",
        "suggest": "导致立即返回返回的 `bool` 的不确定行为，该 `bool` 不一定是 `true` 或 `false`。",
        "translate": ""
    },
    {
        "source": "Worse, truly uninitialized memory like what gets returned here is special in that the compiler knows that it does not have a fixed value.",
        "suggest": "更糟糕的是，真正的未初始化内存 (如此处返回的内存) 的特殊之处在于，编译器知道它没有固定的值。",
        "translate": ""
    },
    {
        "source": "This makes it undefined behavior to have uninitialized data in a variable even if that variable has an integer type.",
        "suggest": "这使得在变量中具有未初始化的数据成为不确定的行为，即使该变量具有整数类型也是如此。",
        "translate": ""
    },
    {
        "source": "the caller must guarantee that an unitialized value is valid for `T`.",
        "suggest": "调用者必须保证对 `T` 有效的单位化值。",
        "translate": ""
    },
    {
        "source": "Swaps the values at two mutable locations, without deinitializing either one.",
        "suggest": "在两个可变位置交换值，而无需对其中一个进行初始化。",
        "translate": ""
    },
    {
        "source": "If you want to swap with a default or dummy value, see [`take`].",
        "suggest": "如果要交换默认值或虚拟值，请参见 [`take`]。",
        "translate": ""
    },
    {
        "source": "If you want to swap with a passed value, returning the old value, see [`replace`].",
        "suggest": "如果要与传递的值交换，返回旧值，请参见 [`replace`]。",
        "translate": ""
    },
    {
        "source": "the raw pointers have been created from safe mutable references satisfying all the constraints on `ptr::swap_nonoverlapping_one`",
        "suggest": "裸指针是根据安全可变引用创建的，满足 `ptr::swap_nonoverlapping_one` 上的所有约束",
        "translate": ""
    },
    {
        "source": "Replaces `dest` with the default value of `T`, returning the previous `dest` value.",
        "suggest": "用默认值 `T` 替换 `dest`，并返回以前的 `dest` 值。",
        "translate": ""
    },
    {
        "source": "If you want to replace the values of two variables, see [`swap`].",
        "suggest": "如果要替换两个变量的值，请参见 [`swap`]。",
        "translate": ""
    },
    {
        "source": "If you want to replace with a passed value instead of the default value, see [`replace`].",
        "suggest": "如果要替换为传递的值而不是默认值，请参见 [`replace`]。",
        "translate": ""
    },
    {
        "source": "A simple example:",
        "suggest": "一个简单的例子:",
        "translate": ""
    },
    {
        "source": "allows taking ownership of a struct field by replacing it with an \"empty\" value.",
        "suggest": "允许通过将结构体字段替换为 \"empty\" 值来获得结构体字段的所有权。",
        "translate": ""
    },
    {
        "source": "Without `take` you can run into issues like these:",
        "suggest": "没有 `take`，您可能会遇到以下问题:",
        "translate": ""
    },
    {
        "source": "Note that `T` does not necessarily implement [`Clone`], so it can't even clone and reset `self.buf`.",
        "suggest": "请注意，`T` 不一定实现 [`Clone`]，因此它甚至无法克隆和重置 `self.buf`。",
        "translate": ""
    },
    {
        "source": "But `take` can be used to disassociate the original value of `self.buf` from `self`, allowing it to be returned:",
        "suggest": "但是 `take` 可以用于取消 `self.buf` 的原始值与 `self` 的关联，从而可以将其返回:",
        "translate": ""
    },
    {
        "source": "Moves `src` into the referenced `dest`, returning the previous `dest` value.",
        "suggest": "将 `src` 移至引用的 `dest`，返回先前的 `dest` 值。",
        "translate": ""
    },
    {
        "source": "Neither value is dropped.",
        "suggest": "这两个值都不会被丢弃。",
        "translate": ""
    },
    {
        "source": "If you want to replace with a default value, see [`take`].",
        "suggest": "如果要替换为默认值，请参见 [`take`]。",
        "translate": ""
    },
    {
        "source": "allows consumption of a struct field by replacing it with another value.",
        "suggest": "允许通过用另一个值替换结构体字段来使用它。",
        "translate": ""
    },
    {
        "source": "Without `replace` you can run into issues like these:",
        "suggest": "没有 `replace`，您可能会遇到以下问题:",
        "translate": ""
    },
    {
        "source": "Note that `T` does not necessarily implement [`Clone`], so we can't even clone `self.buf[i]` to avoid the move.",
        "suggest": "请注意，`T` 不一定实现 [`Clone`]，因此我们甚至无法克隆 `self.buf[i]` 以避免此举。",
        "translate": ""
    },
    {
        "source": "But `replace` can be used to disassociate the original value at that index from `self`, allowing it to be returned:",
        "suggest": "但是 `replace` 可以用于取消该索引处的原始值与 `self` 的关联，从而可以将其返回:",
        "translate": ""
    },
    {
        "source": "We read from `dest` but directly write `src` into it afterwards, such that the old value is not duplicated.",
        "suggest": "我们从 `dest` 读取，但之后直接将 `src` 写入其中，这样就不会重复旧值。",
        "translate": ""
    },
    {
        "source": "Nothing is dropped and nothing here can panic.",
        "suggest": "什么都不会被丢弃掉，也什么都不会 panic。",
        "translate": ""
    },
    {
        "source": "Disposes of a value.",
        "suggest": "处理一个值。",
        "translate": ""
    },
    {
        "source": "This does so by calling the argument's implementation of [`Drop`][drop].",
        "suggest": "通过调用 [`Drop`][drop] 的参数实现来实现。",
        "translate": ""
    },
    {
        "source": "This effectively does nothing for types which implement `Copy`, e.g.",
        "suggest": "这对于实现 `Copy` 的类型实际上不起作用，例如",
        "translate": ""
    },
    {
        "source": "Such values are copied and _then_ moved into the function, so the value persists after this function call.",
        "suggest": "这样的值被复制并将 _then_ 移到函数中，因此该值在此函数调用之后仍然存在。",
        "translate": ""
    },
    {
        "source": "This function is not magic;",
        "suggest": "这个功能并不神奇。",
        "translate": ""
    },
    {
        "source": "it is literally defined as",
        "suggest": "它的字面定义为",
        "translate": ""
    },
    {
        "source": "Because `_x` is moved into the function, it is automatically dropped before the function returns.",
        "suggest": "由于 `_x` 已移入函数，因此它会在函数返回之前自动丢弃。",
        "translate": ""
    },
    {
        "source": "Since [`RefCell`] enforces the borrow rules at runtime, `drop` can release a [`RefCell`] borrow:",
        "suggest": "由于 [`RefCell`] 在运行时强制执行借用规则，因此 `drop` 可以发布 [`RefCell`] 借用:",
        "translate": ""
    },
    {
        "source": "Integers and other types implementing [`Copy`] are unaffected by `drop`.",
        "suggest": "实现 [`Copy`] 的整数和其他类型不受 `drop` 的影响。",
        "translate": ""
    },
    {
        "source": "Interprets `src` as having type `&U`, and then reads `src` without moving the contained value.",
        "suggest": "将 `src` 解释为具有 `&U` 类型，然后在不移动所包含的值的情况下读取 `src`。",
        "translate": ""
    },
    {
        "source": "This function will unsafely assume the pointer `src` is valid for [`size_of::<U>`][size_of] bytes by transmuting `&T` to `&U` and then reading the `&U` (except that this is done in a way that is correct even when `&U` makes stricter alignment requirements than `&T`).",
        "suggest": "通过将 `&T` 转换为 `&U`，然后读取 `&U`，此函数将不安全地假定指针 `src` 对 [`size_of::<U>`][size_of] 字节有效 (除非这样做的正确方式是，即使 `&U` 的对齐要求比 `&T` 严格)。",
        "translate": ""
    },
    {
        "source": "It will also unsafely create a copy of the contained value instead of moving out of `src`.",
        "suggest": "它还将不安全地创建所包含值的副本，而不是移出 `src`。",
        "translate": ""
    },
    {
        "source": "It is not a compile-time error if `T` and `U` have different sizes, but it is highly encouraged to only invoke this function where `T` and `U` have the same size.",
        "suggest": "如果 `T` 和 `U` 具有不同的大小，则不是编译时错误，但是强烈建议仅在 `T` 和 `U` 具有相同的大小时调用此函数。",
        "translate": ""
    },
    {
        "source": "This function triggers [undefined behavior][ub] if `U` is larger than `T`.",
        "suggest": "如果 `U` 大于 `T`，则此函数将触发 [未定义的行为][ub]。",
        "translate": ""
    },
    {
        "source": "If U has a higher alignment requirement, src may not be suitably aligned.",
        "suggest": "如果 U 具有更高的对齐要求，则 src 可能无法适当对齐。",
        "translate": ""
    },
    {
        "source": "`src` is a reference which is guaranteed to be valid for reads.",
        "suggest": "`src` 是一个引用，它保证对读取有效。",
        "translate": ""
    },
    {
        "source": "The caller must guarantee that the actual transmutation is safe.",
        "suggest": "调用者必须保证实际的转换是安全的。",
        "translate": ""
    },
    {
        "source": "We just checked that `src as *const U` was properly aligned.",
        "suggest": "我们只是检查 `src as *const U` 是否正确对齐。",
        "translate": ""
    },
    {
        "source": "Opaque type representing the discriminant of an enum.",
        "suggest": "代表枚举的不透明类型。",
        "translate": ""
    },
    {
        "source": "See the [`discriminant`] function in this module for more information.",
        "suggest": "有关更多信息，请参见此模块中的 [`discriminant`] 函数。",
        "translate": ""
    },
    {
        "source": "These trait implementations cannot be derived because we don't want any bounds on T.",
        "suggest": "无法导出这些 trait 实现，因为我们不需要 T 的任何界限。",
        "translate": ""
    },
    {
        "source": "Returns a value uniquely identifying the enum variant in `v`.",
        "suggest": "返回唯一标识 `v` 中的枚举成员的值。",
        "translate": ""
    },
    {
        "source": "If `T` is not an enum, calling this function will not result in undefined behavior, but the return value is unspecified.",
        "suggest": "如果 `T` 不是枚举，则调用此函数不会导致未定义的行为，但返回值是未指定的。",
        "translate": ""
    },
    {
        "source": "The discriminant of an enum variant may change if the enum definition changes.",
        "suggest": "如果枚举定义更改，则枚举成员的判别式可能会更改。",
        "translate": ""
    },
    {
        "source": "A discriminant of some variant will not change between compilations with the same compiler.",
        "suggest": "在具有相同编译器的编译之间，对某些成员的判别将不会发生变化。",
        "translate": ""
    },
    {
        "source": "This can be used to compare enums that carry data, while disregarding the actual data:",
        "suggest": "这可以用来比较携带数据的枚举，而忽略实际数据:",
        "translate": ""
    },
    {
        "source": "Returns the number of variants in the enum type `T`.",
        "suggest": "返回枚举类型 `T` 中的成员数。",
        "translate": ""
    },
    {
        "source": "Equally, if `T` is an enum with more variants than `usize::MAX` the return value is unspecified.",
        "suggest": "同样，如果 `T` 是成员数大于 `usize::MAX` 的枚举，则未指定返回值。",
        "translate": ""
    },
    {
        "source": "Custom arbitrary-precision number (bignum) implementation.",
        "suggest": "自定义任意精度数字 (bignum) 的实现。",
        "translate": ""
    },
    {
        "source": "This is designed to avoid the heap allocation at expense of stack memory.",
        "suggest": "这样做是为了避免以分配堆内存为代价来避免堆分配。",
        "translate": ""
    },
    {
        "source": "The most used bignum type, `Big32x40`, is limited by 32 × 40 = 1,280 bits and will take at most 160 bytes of stack memory.",
        "suggest": "最常用的 bignum 类型 `Big32x40` 受 32×40=1,280 位的限制，最多占用 160 个字节的栈内存。",
        "translate": ""
    },
    {
        "source": "This is more than enough for round-tripping all possible finite `f64` values.",
        "suggest": "对于往返所有可能的有限 `f64` 值而言，这绰绰有余。",
        "translate": ""
    },
    {
        "source": "In principle it is possible to have multiple bignum types for different inputs, but we don't do so to avoid the code bloat.",
        "suggest": "原则上，可以为不同的输入使用多个 bignum 类型，但是我们这样做并不是为了避免代码膨胀。",
        "translate": ""
    },
    {
        "source": "Each bignum is still tracked for the actual usages, so it normally doesn't matter.",
        "suggest": "仍然会跟踪每个 bignum 的实际用法，因此通常没有关系。",
        "translate": ""
    },
    {
        "source": "This module is only for dec2flt and flt2dec, and only public because of coretests.",
        "suggest": "该模块仅用于 dec2flt 和 flt2dec，并且由于 coretests 而仅用于公共模块。",
        "translate": ""
    },
    {
        "source": "It is not intended to ever be stabilized.",
        "suggest": "它永远都不会稳定下来。",
        "translate": ""
    },
    {
        "source": "Arithmetic operations required by bignums.",
        "suggest": "bignums 需要的算术运算。",
        "translate": ""
    },
    {
        "source": "Returns `(carry', v')` such that `carry' * 2^W + v' = self + other + carry`, where `W` is the number of bits in `Self`.",
        "suggest": "返回 `(carry', v')`，使得 `carry' * 2^W + v' = self + other + carry`，其中 `W` 是 `Self` 中的位数。",
        "translate": ""
    },
    {
        "source": "Returns `(carry', v')` such that `carry' * 2^W + v' = self * other + carry`, where `W` is the number of bits in `Self`.",
        "suggest": "返回 `(carry', v')`，使得 `carry'*2^W + v' = self* other + carry`，其中 `W` 是 `Self` 中的位数。",
        "translate": ""
    },
    {
        "source": "Returns `(carry', v')` such that `carry' * 2^W + v' = self * other + other2 + carry`, where `W` is the number of bits in `Self`.",
        "suggest": "返回 `(carry', v')`，使得 `carry'*2^W + v' = self* other + other2 + carry`，其中 `W` 是 `Self` 中的位数。",
        "translate": ""
    },
    {
        "source": "Returns `(quo, rem)` such that `borrow * 2^W + self = quo * other + rem` and `0 <= rem < other`, where `W` is the number of bits in `Self`.",
        "suggest": "返回 `(quo, rem)`，使得 `borrow *2^W + self = quo* other + rem` 和 `0 <= rem < other`，其中 `W` 是 `Self` 中的位数。",
        "translate": ""
    },
    {
        "source": "This cannot overflow;",
        "suggest": "这不会溢出;",
        "translate": ""
    },
    {
        "source": "the output is between `0` and `2 * 2^nbits - 1`.",
        "suggest": "输出在 `0` 和 `2 * 2^nbits - 1` 之间。",
        "translate": ""
    },
    {
        "source": "will LLVM optimize this into ADC or similar?",
        "suggest": "LLVM 会将其优化到 ADC 或类似产品中吗?",
        "translate": ""
    },
    {
        "source": "the output is between `0` and `2^nbits * (2^nbits - 1)`.",
        "suggest": "输出在 `0` 和 `2^nbits * (2^nbits - 1)` 之间。",
        "translate": ""
    },
    {
        "source": "See RFC #521 for enabling this.",
        "suggest": "有关启用此功能的信息，请参见 RFC #521。",
        "translate": ""
    },
    {
        "source": "add(intrinsics::u64_add_with_overflow), mul/div(u128);",
        "suggest": "add(intrinsics::u64_add_with_overflow)，mul/div (u128) ;",
        "translate": ""
    },
    {
        "source": "Table of powers of 5 representable in digits.",
        "suggest": "5 的幂表可用数字表示。",
        "translate": ""
    },
    {
        "source": "Specifically, the largest {u8, u16, u32} value that's a power of five, plus the corresponding exponent.",
        "suggest": "具体来说，最大的 {u8, u16, u32} 值是 5 的幂，再加上相应的指数。",
        "translate": ""
    },
    {
        "source": "Used in `mul_pow5`.",
        "suggest": "在 `mul_pow5` 中使用。",
        "translate": ""
    },
    {
        "source": "Stack-allocated arbitrary-precision (up to certain limit) integer.",
        "suggest": "栈分配的任意精度 (达到一定限制) 整数。",
        "translate": ""
    },
    {
        "source": "This is backed by a fixed-size array of given type (\"digit\").",
        "suggest": "这由给定类型 (\"digit\") 的固定大小的数组支持。",
        "translate": ""
    },
    {
        "source": "While the array is not very large (normally some hundred bytes), copying it recklessly may result in the performance hit.",
        "suggest": "尽管数组不是很大 (通常为几百个字节)，但不计后果地复制它可能会导致性能下降。",
        "translate": ""
    },
    {
        "source": "Thus this is intentionally not `Copy`.",
        "suggest": "因此，这不是 `Copy`。",
        "translate": ""
    },
    {
        "source": "All operations available to bignums panic in the case of overflows.",
        "suggest": "发生溢出时，bignums panic 可以使用所有操作。",
        "translate": ""
    },
    {
        "source": "The caller is responsible to use large enough bignum types.",
        "suggest": "调用方负责使用足够大的 bignum 类型。",
        "translate": ""
    },
    {
        "source": "One plus the offset to the maximum \"digit\" in use.",
        "suggest": "一加偏移量到正在使用的最大 \"digit\"。",
        "translate": ""
    },
    {
        "source": "This does not decrease, so be aware of the computation order.",
        "suggest": "这不会减少，因此请注意计算顺序。",
        "translate": ""
    },
    {
        "source": "should be zero.",
        "suggest": "应该为零。",
        "translate": ""
    },
    {
        "source": "represents `a + b*2^W + c*2^(2W) + ...` where `W` is the number of bits in the digit type.",
        "suggest": "表示 `a + b *2^W + c* 2^(2W) + ...`，其中 `W` 是数字类型的位数。",
        "translate": ""
    },
    {
        "source": "Makes a bignum from one digit.",
        "suggest": "从一位数产生一个大数。",
        "translate": ""
    },
    {
        "source": "Makes a bignum from `u64` value.",
        "suggest": "从 `u64` 值得到一个大数。",
        "translate": ""
    },
    {
        "source": "Returns the internal digits as a slice `[a, b, c, ...]` such that the numeric value is `a + b * 2^W + c * 2^(2W) + ...` where `W` is the number of bits in the digit type.",
        "suggest": "返回内部数字作为切片 `[a, b, c, ...]`，以使数值为 `a + b *2^W + c* 2^(2W) + ...`，其中 `W` 是数字类型中的位数。",
        "translate": ""
    },
    {
        "source": "Returns the `i`-th bit where bit 0 is the least significant one.",
        "suggest": "返回第 i 位，其中位 0 是最低有效位。",
        "translate": ""
    },
    {
        "source": "In other words, the bit with weight `2^i`.",
        "suggest": "换句话说，钻头的重量为 `2^i`。",
        "translate": ""
    },
    {
        "source": "Returns `true` if the bignum is zero.",
        "suggest": "如果 bignum 为零，则返回 `true`。",
        "translate": ""
    },
    {
        "source": "Returns the number of bits necessary to represent this value.",
        "suggest": "返回表示此值所需的位数。",
        "translate": ""
    },
    {
        "source": "Note that zero is considered to need 0 bits.",
        "suggest": "注意，零被认为需要 0 位。",
        "translate": ""
    },
    {
        "source": "Skip over the most significant digits which are zero.",
        "suggest": "跳过最高有效数字零。",
        "translate": ""
    },
    {
        "source": "There are no non-zero digits, i.e., the number is zero.",
        "suggest": "没有非零数字，即数字为零。",
        "translate": ""
    },
    {
        "source": "This could be optimized with leading_zeros() and bit shifts, but that's probably not worth the hassle.",
        "suggest": "可以使用 leading_zeros() 和位移来优化它，但这可能不值得麻烦。",
        "translate": ""
    },
    {
        "source": "Adds `other` to itself and returns its own mutable reference.",
        "suggest": "向其自身添加 `other`，并返回其自己的可变引用。",
        "translate": ""
    },
    {
        "source": "Subtracts `other` from itself and returns its own mutable reference.",
        "suggest": "从自身中减去 `other`，并返回其自己的可变引用。",
        "translate": ""
    },
    {
        "source": "Multiplies itself by a digit-sized `other` and returns its own mutable reference.",
        "suggest": "将自身乘以数字大小的 `other` 并返回其自己的可变引用。",
        "translate": ""
    },
    {
        "source": "Multiplies itself by `2^bits` and returns its own mutable reference.",
        "suggest": "将自身乘以 `2^bits` 并返回自己的变量引用。",
        "translate": ""
    },
    {
        "source": "shift by `digits * digitbits` bits",
        "suggest": "移位 `digits * digitbits` 位",
        "translate": ""
    },
    {
        "source": "shift by `bits` bits",
        "suggest": "移位 `bits` 位",
        "translate": ""
    },
    {
        "source": "self.base[..digits] is zero, no need to shift",
        "suggest": "self.base [.. digits] 为零，无需移位",
        "translate": ""
    },
    {
        "source": "Multiplies itself by `5^e` and returns its own mutable reference.",
        "suggest": "将自身乘以 `5^e` 并返回自己的变量引用。",
        "translate": ""
    },
    {
        "source": "There are exactly n trailing zeros on 2^n, and the only relevant digit sizes are consecutive powers of two, so this is well suited index for the table.",
        "suggest": "在 2 ^ n 上正好有 n 个尾随零，并且唯一相关的数字大小是 2 的连续幂，因此这非常适合该表的索引。",
        "translate": ""
    },
    {
        "source": "Multiply with the largest single-digit power as long as possible ...",
        "suggest": "尽可能长地乘以最大的一位数功率...",
        "translate": ""
    },
    {
        "source": "then finish off the remainder.",
        "suggest": "然后结束剩余的部分。",
        "translate": ""
    },
    {
        "source": "Multiplies itself by a number described by `other[0] + other[1] * 2^W + other[2] * 2^(2W) + ...` (where `W` is the number of bits in the digit type) and returns its own mutable reference.",
        "suggest": "将自身乘以 `other[0] + other[1]*2^W + other[2]* 2^(2W) + ...` 描述的数字 (其中 `W` 是数字类型的位数)，并返回其自己的可变引用。",
        "translate": ""
    },
    {
        "source": "the internal routine.",
        "suggest": "内部例程。",
        "translate": ""
    },
    {
        "source": "works best when aa.len() <= bb.len().",
        "suggest": "当 aa.len() <= bb.len() 时，效果最佳。",
        "translate": ""
    },
    {
        "source": "Divides itself by a digit-sized `other` and returns its own mutable reference *and* the remainder.",
        "suggest": "用数字大小的 `other` 除以自身，并返回其自身的变量引用 *，其余为*。",
        "translate": ""
    },
    {
        "source": "Divide self by another bignum, overwriting `q` with the quotient and `r` with the remainder.",
        "suggest": "将自身除以另一个大数，用商覆盖 `q`，用余数覆盖 `r`。",
        "translate": ""
    },
    {
        "source": "Stupid slow base-2 long division taken from",
        "suggest": "愚蠢的慢 base-2 长除法取自",
        "translate": ""
    },
    {
        "source": "FIXME use a greater base ($ty) for the long division.",
        "suggest": "FIXME 对于长除法使用更大的基数 ($ty)。",
        "translate": ""
    },
    {
        "source": "Set bit `i` of q to 1.",
        "suggest": "将 q 的 `i` 位设置为 1。",
        "translate": ""
    },
    {
        "source": "The digit type for `Big32x40`.",
        "suggest": "`Big32x40` 的数字类型。",
        "translate": ""
    },
    {
        "source": "this one is used for testing only.",
        "suggest": "此仅用于测试。",
        "translate": ""
    },
    {
        "source": "The various algorithms from the paper.",
        "suggest": "本文中的各种算法。",
        "translate": ""
    },
    {
        "source": "Number of significand bits in Fp",
        "suggest": "Fp 中的有效位数",
        "translate": ""
    },
    {
        "source": "We simply store the best approximation for *all* exponents, so the variable \"h\" and the associated conditions can be omitted.",
        "suggest": "我们仅存储 *all* 指数的最佳近似值，因此可以省略变量 \"h\" 和相关条件。",
        "translate": ""
    },
    {
        "source": "This trades performance for a couple kilobytes of space.",
        "suggest": "这将性能换成几千字节的空间。",
        "translate": ""
    },
    {
        "source": "In most architectures, floating point operations have an explicit bit size, therefore the precision of the computation is determined on a per-operation basis.",
        "suggest": "在大多数体系结构中，浮点运算具有显式的位大小，因此计算的精度取决于每个运算。",
        "translate": ""
    },
    {
        "source": "On x86, the x87 FPU is used for float operations if the SSE/SSE2 extensions are not available.",
        "suggest": "在 x86 上，如果 SSE/SSE2 扩展不可用，则将 x87 FPU 用于浮动操作。",
        "translate": ""
    },
    {
        "source": "The x87 FPU operates with 80 bits of precision by default, which means that operations will round to 80 bits causing double rounding to happen when values are eventually represented as",
        "suggest": "x87 FPU 默认情况下以 80 位精度运行，这意味着运算将舍入到 80 位，从而在最终将值表示为时将发生双舍入",
        "translate": ""
    },
    {
        "source": "bit float values.",
        "suggest": "位浮点值。",
        "translate": ""
    },
    {
        "source": "To overcome this, the FPU control word can be set so that the computations are performed in the desired precision.",
        "suggest": "为了克服这个问题，可以设置 FPU 控制字，以便以所需的精度执行计算。",
        "translate": ""
    },
    {
        "source": "A structure used to preserve the original value of the FPU control word, so that it can be restored when the structure is dropped.",
        "suggest": "一种结构体，用于保留 FPU 控制字的原始值，以便在丢弃该结构体时可以将其恢复。",
        "translate": ""
    },
    {
        "source": "The x87 FPU is a 16-bits register whose fields are as follows:",
        "suggest": "x87 FPU 是一个 16 位寄存器，其字段如下:",
        "translate": ""
    },
    {
        "source": "The documentation for all of the fields is available in the IA-32 Architectures Software Developer's Manual (Volume 1).",
        "suggest": "IA-32 体系结构软件开发人员手册 (第 1 卷) 中提供了所有字段的文档。",
        "translate": ""
    },
    {
        "source": "The only field which is relevant for the following code is PC, Precision Control.",
        "suggest": "与以下代码相关的唯一字段是 PC，Precision Control。",
        "translate": ""
    },
    {
        "source": "This field determines the precision of the operations performed by the  FPU.",
        "suggest": "该字段确定 FPU 执行的操作的精度。",
        "translate": ""
    },
    {
        "source": "It can be set to:",
        "suggest": "可以设置为:",
        "translate": ""
    },
    {
        "source": "0b00, single precision i.e., 32-bits",
        "suggest": "0b00，单精度，即 32 位",
        "translate": ""
    },
    {
        "source": "0b10, double precision i.e., 64-bits",
        "suggest": "0b10，双精度，即 64 位",
        "translate": ""
    },
    {
        "source": "0b11, double extended precision i.e., 80-bits (default state) The 0b01 value is reserved and should not be used.",
        "suggest": "0b11，双精度扩展精度，即 80 位 (默认状态) 0b01 值是保留的，不应使用。",
        "translate": ""
    },
    {
        "source": "the `fldcw` instruction has been audited to be able to work correctly with any `u16`",
        "suggest": "`fldcw` 指令已通过审核，可以与任何 `u16` 一起正常使用",
        "translate": ""
    },
    {
        "source": "We are using ATT syntax to support LLVM 8 and LLVM 9.",
        "suggest": "我们正在使用 ATT 语法来支持 LLVM 8 和 LLVM 9。",
        "translate": ""
    },
    {
        "source": "Sets the precision field of the FPU to `T` and returns a `FPUControlWord`.",
        "suggest": "将 FPU 的 precision 字段设置为 `T` 并返回 `FPUControlWord`。",
        "translate": ""
    },
    {
        "source": "Compute the value for the Precision Control field that is appropriate for `T`.",
        "suggest": "计算适用于 `T` 的 Precision Control 字段的值。",
        "translate": ""
    },
    {
        "source": "32 bits",
        "suggest": "32 位",
        "translate": ""
    },
    {
        "source": "64 bits",
        "suggest": "64 位",
        "translate": ""
    },
    {
        "source": "default, 80 bits",
        "suggest": "默认为 80 位",
        "translate": ""
    },
    {
        "source": "Get the original value of the control word to restore it later, when the `FPUControlWord` structure is dropped",
        "suggest": "丢弃 `FPUControlWord` 结构体时，获取控制字的原始值以在以后还原它",
        "translate": ""
    },
    {
        "source": "the `fnstcw` instruction has been audited to be able to work correctly with any `u16`",
        "suggest": "`fnstcw` 指令已通过审核，可以与任何 `u16` 一起正常使用",
        "translate": ""
    },
    {
        "source": "Set the control word to the desired precision.",
        "suggest": "将控制字设置为所需的精度。",
        "translate": ""
    },
    {
        "source": "This is achieved by masking away the old precision (bits 8 and 9, 0x300) and replacing it with the precision flag computed above.",
        "suggest": "这可以通过掩盖旧的精度 (位 8 和 9，0x300) 并将其替换为上面计算的精度标志来实现。",
        "translate": ""
    },
    {
        "source": "The fast path of Bellerophon using machine-sized integers and floats.",
        "suggest": "Bellerophon 使用机器大小的整数和浮点数的快速路径。",
        "translate": ""
    },
    {
        "source": "This is extracted into a separate function so that it can be attempted before constructing a bignum.",
        "suggest": "将其提取到单独的函数中，以便可以在创建 bignum 之前尝试使用它。",
        "translate": ""
    },
    {
        "source": "~ 15.95.",
        "suggest": "〜15.95。",
        "translate": ""
    },
    {
        "source": "We compare the exact value to MAX_SIG near the end, this is just a quick, cheap rejection (and also frees the rest of the code from worrying about underflow).",
        "suggest": "我们将精确值与末尾的 MAX_SIG 进行比较，这只是一个快速，廉价的拒绝方法 (并且使其余代码免于担心下溢的麻烦)。",
        "translate": ""
    },
    {
        "source": "The fast path crucially depends on arithmetic being rounded to the correct number of bits without any intermediate rounding.",
        "suggest": "快速路径至关重要地取决于将算术四舍五入到正确的位数，而无需任何中间舍入。",
        "translate": ""
    },
    {
        "source": "On x86 (without SSE or SSE2) this requires the precision of the x87 FPU stack to be changed so that it directly rounds to 64/32 bit.",
        "suggest": "在 x86 (不带 SSE 或 SSE2) 上，这需要更改 x87 FPU 栈的精度，以便直接将其舍入为 64/32 位。",
        "translate": ""
    },
    {
        "source": "The `set_precision` function takes care of setting the precision on architectures which require setting it by changing the global state (like the control word of the x87 FPU).",
        "suggest": "`set_precision` 函数负责在需要通过更改 ^ 状态 (例如 x87 FPU 的控制字) 进行设置的体系结构上设置精度。",
        "translate": ""
    },
    {
        "source": "The case e < 0 cannot be folded into the other branch.",
        "suggest": "e <0 的情况不能折叠到另一个分支中。",
        "translate": ""
    },
    {
        "source": "Negative powers result in a repeating fractional part in binary, which are rounded, which causes real (and occasionally quite significant!) errors in the final result.",
        "suggest": "负幂会导致二进制中重复的小数部分四舍五入，这会在最终结果中引起实际的 (有时是相当大的! ) 错误。",
        "translate": ""
    },
    {
        "source": "Algorithm Bellerophon is trivial code justified by non-trivial numeric analysis.",
        "suggest": "算法 Bellerophon 是通过非平凡数值分析证明的平凡代码。",
        "translate": ""
    },
    {
        "source": "It rounds ``f`` to a float with 64 bit significand and multiplies it by the best approximation of `10^e` (in the same floating point format).",
        "suggest": "它将 ``f`` 四舍五入为有效位数为 64 位的浮点数，并将其乘以 `10^e` 的最佳近似值 (以相同的浮点格式)。",
        "translate": ""
    },
    {
        "source": "This is often enough to get the correct result.",
        "suggest": "通常这足以获得正确的结果。",
        "translate": ""
    },
    {
        "source": "However, when the result is close to halfway between two adjacent (ordinary) floats, the compound rounding error from multiplying two approximation means the result may be off by a few bits.",
        "suggest": "但是，当结果接近两个相邻 (ordinary) 浮点数之间的一半时，乘以两个近似值会产生复合舍入误差，这意味着结果可能会偏离几位。",
        "translate": ""
    },
    {
        "source": "When this happens, the iterative Algorithm R fixes things up.",
        "suggest": "发生这种情况时，迭代算法 R 会解决问题。",
        "translate": ""
    },
    {
        "source": "The hand-wavy \"close to halfway\" is made precise by the numeric analysis in the paper.",
        "suggest": "通过本文中的数值分析，可以使手工波浪 \"close to halfway\" 变得精确。",
        "translate": ""
    },
    {
        "source": "In the words of Clinger:",
        "suggest": "用 Clinger 的话来说:",
        "translate": ""
    },
    {
        "source": "Slop, expressed in units of the least significant bit, is an inclusive bound for the error",
        "suggest": "以最低有效位为单位表示的斜率是误差的包含范围",
        "translate": ""
    },
    {
        "source": "accumulated during the floating point calculation of the approximation to f * 10^e.",
        "suggest": "在对 f * 10 ^ e 进行近似的浮点计算过程中累积。",
        "translate": ""
    },
    {
        "source": "(Slop is",
        "suggest": "(斜率是",
        "translate": ""
    },
    {
        "source": "not a bound for the true error, but bounds the difference between the approximation z and",
        "suggest": "不是真正误差的界限，而是将近似值 z 与",
        "translate": ""
    },
    {
        "source": "the best possible approximation that uses p bits of significand.)",
        "suggest": "使用 p 个有效位数的最佳近似值。)",
        "translate": ""
    },
    {
        "source": "The cases abs(e) < log5(2^N) are in fast_path()",
        "suggest": "abs(e) <log5(2^N) 的情况在 fast_path() 中",
        "translate": ""
    },
    {
        "source": "Is the slop large enough to make a difference when rounding to n bits?",
        "suggest": "舍入到 n 位时，斜率是否足够大以产生影响?",
        "translate": ""
    },
    {
        "source": "An iterative algorithm that improves a floating point approximation of `f * 10^e`.",
        "suggest": "一种改进 `f * 10^e` 浮点近似的迭代算法。",
        "translate": ""
    },
    {
        "source": "Each iteration gets one unit in the last place closer, which of course takes terribly long to converge if `z0` is even mildly off.",
        "suggest": "每次迭代都会在最后一个位置获得一个单元，如果 `z0` 稍微关闭，则收敛当然会花费非常长的时间。",
        "translate": ""
    },
    {
        "source": "Luckily, when used as fallback for Bellerophon, the starting approximation is off by at most one ULP.",
        "suggest": "幸运的是，当用作 Bellerophon 的后备时，起始近似值最多可以有一个 ULP。",
        "translate": ""
    },
    {
        "source": "Find positive integers `x`, `y` such that `x / y` is exactly `(f * 10^e) / (m * 2^k)`.",
        "suggest": "找到正整数 `x`，`y`，使 `x / y` 恰好是 `(f *10^e) / (m* 2^k)`。",
        "translate": ""
    },
    {
        "source": "This not only avoids dealing with the signs of `e` and `k`, we also eliminate the power of two common to `10^e` and `2^k` to make the numbers smaller.",
        "suggest": "这不仅避免了处理 `e` 和 `k` 的符号，而且还消除了 `10^e` 和 `2^k` 的两个共同之处，以使数字更小。",
        "translate": ""
    },
    {
        "source": "This is written a bit awkwardly because our bignums don't support negative numbers, so we use the absolute value + sign information.",
        "suggest": "这样做有点尴尬，因为我们的 bignum 不支持负数，因此我们使用绝对值 + 符号信息。",
        "translate": ""
    },
    {
        "source": "The multiplication with m_digits can't overflow.",
        "suggest": "与 m_digits 的乘法不会溢出。",
        "translate": ""
    },
    {
        "source": "If `x` or `y` are large enough that we need to worry about overflow, then they are also large enough that `make_ratio` has reduced the fraction by a factor of 2^64 or more.",
        "suggest": "如果 `x` 或 `y` 足够大，我们需要担心溢出，那么它们也足够大，以至于 `make_ratio` 将分数减少了 2 ^ 64 或更多。",
        "translate": ""
    },
    {
        "source": "Don't need x any more, save a clone().",
        "suggest": "不再需要 x，保存 clone()。",
        "translate": ""
    },
    {
        "source": "Still need y - make a copy.",
        "suggest": "仍然需要 y - 进行复制。",
        "translate": ""
    },
    {
        "source": "Given `x = f` and `y = m` where `f` represent input decimal digits as usual and `m` is the significand of a floating point approximation, make the ratio `x / y` equal to `(f * 10^e) / (m * 2^k)`, possibly reduced by a power of two both have in common.",
        "suggest": "给定 `x = f` 和 `y = m`，其中 `f` 照常表示输入的十进制数字，而 `m` 是浮点近似值的有效数字，使比率 `x / y` 等于 `(f *10^e) / (m* 2^k)`，可能会减少两者的幂。",
        "translate": ""
    },
    {
        "source": "x = f * 10^e, y = m * 2^k, except that we reduce the fraction by some power of two.",
        "suggest": "x = f * 10^e, y = m * 2^k，除了我们将分数减小两倍。",
        "translate": ""
    },
    {
        "source": "x = f * 10^e * 2^abs(k), y = m This can't overflow because it requires positive `e` and negative `k`, which can only happen for values extremely close to 1, which means that `e` and `k` will be comparatively tiny.",
        "suggest": "x = f * 10^e * 2^abs(k)，y = m 这不会溢出，因为它需要正 `e` 和负 `k`，这仅在值非常接近 1 时才会发生，这意味着 `e` 和 `k` 将相对较小。",
        "translate": ""
    },
    {
        "source": "x = f, y = m * 10^abs(e) * 2^k This can't overflow either, see above.",
        "suggest": "x = f, y = m * 10^abs(e) * 2^k 这也不会溢出，请参见上文。",
        "translate": ""
    },
    {
        "source": "x = f * 2^abs(k), y = m * 10^abs(e), again reducing by a common power of two.",
        "suggest": "x = f * 2^abs(k), y = m * 10^abs(e)，再次减小为 2 的公方次幂。",
        "translate": ""
    },
    {
        "source": "Conceptually, Algorithm M is the simplest way to convert a decimal to a float.",
        "suggest": "从概念上讲，算法 M 是将小数转换为浮点数的最简单方法。",
        "translate": ""
    },
    {
        "source": "We form a ratio that is equal to `f * 10^e`, then throwing in powers of two until it gives a valid float significand.",
        "suggest": "我们形成一个等于 `f * 10^e` 的比率，然后将其乘以 2，直到给出有效的有效浮点数为止。",
        "translate": ""
    },
    {
        "source": "The binary exponent `k` is the number of times we multiplied numerator or denominator by two, i.e., at all times `f * 10^e` equals `(u / v) * 2^k`.",
        "suggest": "二进制指数 `k` 是分子或分母乘以 2 的次数，即 `f *10^e` 始终等于 `(u / v)* 2^k`。",
        "translate": ""
    },
    {
        "source": "When we have found out significand, we only need to round by inspecting the remainder of the division, which is done in helper functions further below.",
        "suggest": "当我们发现有效位数时，我们只需要检查除法的其余部分就可以进行四舍五入，这将在下面的辅助函数中完成。",
        "translate": ""
    },
    {
        "source": "This algorithm is super slow, even with the optimization described in `quick_start()`.",
        "suggest": "即使使用 `quick_start()` 中描述的优化方法，该算法也非常慢。",
        "translate": ""
    },
    {
        "source": "However, it's the simplest of the algorithms to adapt for overflow, underflow, and subnormal results.",
        "suggest": "但是，它是最适合于上溢，下溢和次正规结果的算法。",
        "translate": ""
    },
    {
        "source": "This implementation takes over when Bellerophon and Algorithm R are overwhelmed.",
        "suggest": "当 Bellerophon 和 Algorithm R 不堪重负时，此实现将接手。",
        "translate": ""
    },
    {
        "source": "Detecting underflow and overflow is easy: The ratio still isn't an in-range significand, yet the minimum/maximum exponent has been reached.",
        "suggest": "检测下溢和上溢很容易: 该比率仍然不是有效范围，但已达到 minimum/maximum 指数。",
        "translate": ""
    },
    {
        "source": "In the case of overflow, we simply return infinity.",
        "suggest": "在溢出的情况下，我们只是返回无穷大。",
        "translate": ""
    },
    {
        "source": "Handling underflow and subnormals is trickier.",
        "suggest": "处理下溢和次常态异常比较棘手。",
        "translate": ""
    },
    {
        "source": "One big problem is that, with the minimum exponent, the ratio might still be too large for a significand.",
        "suggest": "一个大问题是，如果使用最小指数，则该比率可能仍然太大而无法实现。",
        "translate": ""
    },
    {
        "source": "See underflow() for details.",
        "suggest": "有关详细信息，请参见 underflow()。",
        "translate": ""
    },
    {
        "source": "FIXME possible optimization: generalize big_to_fp so that we can do the equivalent of fp_to_float(big_to_fp(u)) here, only without the double rounding.",
        "suggest": "FIXME 可能的优化: 泛化 big_to_fp，以便我们可以在这里执行 fp_to_float(big_to_fp(u)) 的等效功能，而无需进行双取整。",
        "translate": ""
    },
    {
        "source": "We have to stop at the minimum exponent, if we wait until `k < T::MIN_EXP_INT`, then we'd be off by a factor of two.",
        "suggest": "我们必须在最小指数处停止，如果我们等到 `k < T::MIN_EXP_INT`，那么我们将相差 2 倍。",
        "translate": ""
    },
    {
        "source": "Unfortunately this means we have to special- case normal numbers with the minimum exponent.",
        "suggest": "不幸的是，这意味着我们必须对具有最小指数的正态数进行特殊处理。",
        "translate": ""
    },
    {
        "source": "FIXME find a more elegant formulation, but run the `tiny-pow10` test to make sure that it's actually correct!",
        "suggest": "FIXME 找到了一个更优雅的公式，但是运行 `tiny-pow10` 测试以确保它实际上是正确的!",
        "translate": ""
    },
    {
        "source": "Skips over most Algorithm M iterations by checking the bit length.",
        "suggest": "通过检查位长跳过大多数算法 M 迭代。",
        "translate": ""
    },
    {
        "source": "The bit length is an estimate of the base two logarithm, and log(u / v) = log(u) - log(v).",
        "suggest": "位长是以 2 为底的对数的估计值，并且 log(u / v) = log(u)-log(v)。",
        "translate": ""
    },
    {
        "source": "The estimate is off by at most 1, but always an under-estimate, so the error on log(u) and log(v) are of the same sign and cancel out (if both are large).",
        "suggest": "估计最多偏移 1，但始终被低估，因此 log(u) 和 log(v) 上的错误具有相同的符号并被抵消 (如果两者都很大)。",
        "translate": ""
    },
    {
        "source": "Therefore the error for log(u / v) is at most one as well.",
        "suggest": "因此，log(u / v) 的错误最多也为 1。",
        "translate": ""
    },
    {
        "source": "The target ratio is one where u/v is in an in-range significand.",
        "suggest": "目标比率是 u/v 在有效范围内的比率。",
        "translate": ""
    },
    {
        "source": "Thus our termination condition is log2(u / v) being the significand bits, plus/minus one.",
        "suggest": "因此，我们的终止条件是 log2(u / v) 为有效位，plus/minus 为 1。",
        "translate": ""
    },
    {
        "source": "FIXME Looking at the second bit could improve the estimate and avoid some more divisions.",
        "suggest": "FIXME 查看第二位可以改善估计并避免更多划分。",
        "translate": ""
    },
    {
        "source": "Underflow or subnormal.",
        "suggest": "下溢或低于正常水平。",
        "translate": ""
    },
    {
        "source": "Leave it to the main function.",
        "suggest": "留给主函数。",
        "translate": ""
    },
    {
        "source": "Overflow. Leave it to the main function.",
        "suggest": "溢出。留给主函数。",
        "translate": ""
    },
    {
        "source": "Ratio isn't an in-range significand with the minimum exponent, so we need to round off excess bits and adjust the exponent accordingly.",
        "suggest": "比率不是最小指数的有效范围，因此我们需要舍入多余的位并相应地调整指数。",
        "translate": ""
    },
    {
        "source": "The real value now looks like this:",
        "suggest": "现在，实际值如下所示:",
        "translate": ""
    },
    {
        "source": "Therefore, when the rounded-off bits are != 0.5 ULP, they decide the rounding on their own.",
        "suggest": "因此，当舍入位为! = 0.5 ULP 时，它们将自行决定舍入。",
        "translate": ""
    },
    {
        "source": "When they are equal and the remainder is non-zero, the value still needs to be rounded up.",
        "suggest": "当它们相等且余数不为零时，该值仍需要四舍五入。",
        "translate": ""
    },
    {
        "source": "Only when the rounded off bits are 1/2 and the remainder is zero, we have a half-to-even situation.",
        "suggest": "只有当四舍五入的位是 1/2 且其余部分为零时，我们才有一半到偶数的情况。",
        "translate": ""
    },
    {
        "source": "Ordinary round-to-even, obfuscated by having to round based on the remainder of a division.",
        "suggest": "普通的取整到偶数，由于必须除以除法的余数而取整。",
        "translate": ""
    },
    {
        "source": "Converting decimal strings into IEEE 754 binary floating point numbers.",
        "suggest": "将十进制字符串转换为 IEEE 754 二进制浮点数。",
        "translate": ""
    },
    {
        "source": "Problem statement",
        "suggest": "问题陈述",
        "translate": ""
    },
    {
        "source": "We are given a decimal string such as `12.34e56`.",
        "suggest": "我们给了一个十进制字符串，例如 `12.34e56`。",
        "translate": ""
    },
    {
        "source": "This string consists of integral (`12`), fractional (`34`), and exponent (`56`) parts.",
        "suggest": "该字符串由整数 (`12`)，小数 (`34`) 和指数 (`56`) 组成。",
        "translate": ""
    },
    {
        "source": "All parts are optional and interpreted as zero when missing.",
        "suggest": "所有部分都是可选的，缺少则解释为零。",
        "translate": ""
    },
    {
        "source": "We seek the IEEE 754 floating point number that is closest to the exact value of the decimal string.",
        "suggest": "我们寻求最接近十进制字符串确切值的 IEEE 754 浮点数。",
        "translate": ""
    },
    {
        "source": "It is well-known that many decimal strings do not have terminating representations in base two, so we round to 0.5 units in the last place (in other words, as well as possible).",
        "suggest": "众所周知，许多十进制字符串在基数 2 中都没有终止表示，因此我们将 0.5 单位最后舍入 (换句话说，尽可能)。",
        "translate": ""
    },
    {
        "source": "Ties, decimal values exactly half-way between two consecutive floats, are resolved with the half-to-even strategy, also known as banker's rounding.",
        "suggest": "领带 (精确到两个连续浮点之间的中间的十进制值) 通过半对偶策略 (也称为银行家舍入) 来解决。",
        "translate": ""
    },
    {
        "source": "Needless to say, this is quite hard, both in terms of implementation complexity and in terms of CPU cycles taken.",
        "suggest": "不用说，这在实现复杂性和所用的 CPU 周期方面都相当困难。",
        "translate": ""
    },
    {
        "source": "First, we ignore signs.",
        "suggest": "首先，我们忽略迹象。",
        "translate": ""
    },
    {
        "source": "Or rather, we remove it at the very beginning of the conversion process and re-apply it at the very end.",
        "suggest": "或者更确切地说，我们在转换过程的开始就将其删除，然后在结束时将其重新应用。",
        "translate": ""
    },
    {
        "source": "This is correct in all edge cases since IEEE floats are symmetric around zero, negating one simply flips the first bit.",
        "suggest": "这在所有 edge 情况下都是正确的，因为 IEEE 浮点数对称于零左右，取反则仅翻转第一位。",
        "translate": ""
    },
    {
        "source": "Then we remove the decimal point by adjusting the exponent: Conceptually, `12.34e56` turns into `1234e54`, which we describe with a positive integer `f = 1234` and an integer `e = 54`.",
        "suggest": "然后，我们通过调整指数来删除小数点: 从概念上讲，`12.34e56` 变为 `1234e54`，我们用正整数 `f = 1234` 和整数 `e = 54` 对其进行描述。",
        "translate": ""
    },
    {
        "source": "The `(f, e)` representation is used by almost all code past the parsing stage.",
        "suggest": "在解析阶段之后，几乎所有代码都使用 `(f, e)` 表示形式。",
        "translate": ""
    },
    {
        "source": "We then try a long chain of progressively more general and expensive special cases using machine-sized integers and small, fixed-sized floating point numbers (first `f32`/`f64`, then a type with 64 bit significand, `Fp`).",
        "suggest": "然后，我们尝试使用机器大小的整数和较小的，固定大小的浮点数 (首先是 `f32`/`f64`，然后是具有 64 位有效数字的类型 `Fp`)，尝试一长串越来越普通和昂贵的特殊情况。",
        "translate": ""
    },
    {
        "source": "When all these fail, we bite the bullet and resort to a simple but very slow algorithm that involved computing `f * 10^e` fully and doing an iterative search for the best approximation.",
        "suggest": "如果所有这些方法都失败了，我们会硬着头皮，诉诸于一种简单但非常缓慢的算法，该算法需要完全计算 `f * 10^e`，然后进行迭代搜索以寻求最佳近似值。",
        "translate": ""
    },
    {
        "source": "Primarily, this module and its children implement the algorithms described in:",
        "suggest": "首先，此模块及其子级实现以下算法:",
        "translate": ""
    },
    {
        "source": "In addition, there are numerous helper functions that are used in the paper but not available in Rust (or at least in core).",
        "suggest": "此外，本文中使用了许多辅助函数，但 Rust (或至少在内核中) 不可用。",
        "translate": ""
    },
    {
        "source": "Our version is additionally complicated by the need to handle overflow and underflow and the desire to handle subnormal numbers.",
        "suggest": "我们的版本由于需要处理上溢和下溢以及处理次正规数的需求而变得更加复杂。",
        "translate": ""
    },
    {
        "source": "Bellerophon and Algorithm R have trouble with overflow, subnormals, and underflow.",
        "suggest": "Bellerophon 和算法 R 在上溢，子正常和下溢方面存在问题。",
        "translate": ""
    },
    {
        "source": "We conservatively switch to Algorithm M (with the modifications described in section 8 of the paper) well before the inputs get into the critical region.",
        "suggest": "在输入进入关键区域之前，我们会保守地切换到算法 M (具有本文第 8 节中描述的修改)。",
        "translate": ""
    },
    {
        "source": "Another aspect that needs attention is the ``RawFloat`` trait by which almost all functions are parametrized.",
        "suggest": "需要注意的另一个方面是 ``RawFloat`` trait，几乎所有函数都通过 ``RawFloat`` trait 进行了参数化。",
        "translate": ""
    },
    {
        "source": "One might think that it's enough to parse to `f64` and cast the result to `f32`.",
        "suggest": "有人可能认为解析为 `f64` 并将结果转换为 `f32` 就足够了。",
        "translate": ""
    },
    {
        "source": "Unfortunately this is not the world we live in, and this has nothing to do with using base two or half-to-even rounding.",
        "suggest": "不幸的是，这不是我们生活的世界，这与使用基数二进位或半到四舍五入四舍五入无关。",
        "translate": ""
    },
    {
        "source": "Consider for example two types `d2` and `d4` representing a decimal type with two decimal digits and four decimal digits each and take \"0.01499\" as input.",
        "suggest": "例如，考虑两种类型的 `d2` 和 `d4`，它们代表具有两个十进制数字和四个十进制数字的十进制类型，并以 \"0.01499\" 作为输入。",
        "translate": ""
    },
    {
        "source": "Let's use half-up rounding.",
        "suggest": "让我们使用上半舍入。",
        "translate": ""
    },
    {
        "source": "Going directly to two decimal digits gives `0.01`, but if we round to four digits first, we get `0.0150`, which is then rounded up to `0.02`.",
        "suggest": "直接转到两位十进制数字将得到 `0.01`，但是如果我们首先四舍五入到四位数字，则会得到 `0.0150`，然后将其四舍五入为 `0.02`。",
        "translate": ""
    },
    {
        "source": "The same principle applies to other operations as well, if you want 0.5 ULP accuracy you need to do *everything* in full precision and round *exactly once, at the end*, by considering all truncated bits at once.",
        "suggest": "同样的原理也适用于其他操作，如果要获得 0.5 ULP 精度，则需要 *进行全精度的所有操作，并在末尾将* exactly once 舍入*，同时考虑所有截断的位。",
        "translate": ""
    },
    {
        "source": "Although some code duplication is necessary, perhaps parts of the code could be shuffled around such that less code is duplicated.",
        "suggest": "尽管某些代码重复是必要的，但也许可以对部分代码进行混洗，以便减少重复的代码。",
        "translate": ""
    },
    {
        "source": "Large parts of the algorithms are independent of the float type to output, or only needs access to a few constants, which could be passed in as parameters.",
        "suggest": "算法的大部分不依赖于 float 类型来输出，或者仅需要访问一些常量即可作为参数传递。",
        "translate": ""
    },
    {
        "source": "The conversion should *never* panic.",
        "suggest": "转换应 *从不* panic。",
        "translate": ""
    },
    {
        "source": "There are assertions and explicit panics in the code, but they should never be triggered and only serve as internal sanity checks.",
        "suggest": "在代码中有断言和显式的 panics，但是它们绝不应该被触发，而仅用作内部的健全性检查。",
        "translate": ""
    },
    {
        "source": "Any panics should be considered a bug.",
        "suggest": "任何 panics 都应视为错误。",
        "translate": ""
    },
    {
        "source": "There are unit tests but they are woefully inadequate at ensuring correctness, they only cover a small percentage of possible errors.",
        "suggest": "虽然有单元测试，但它们在确保正确性上还远远不够，它们只覆盖了很小一部分可能的错误。",
        "translate": ""
    },
    {
        "source": "Far more extensive tests are located in the directory `src/etc/test-float-parse` as a Python script.",
        "suggest": "更广泛的测试作为 Python 脚本位于目录 `src/etc/test-float-parse` 中。",
        "translate": ""
    },
    {
        "source": "A note on integer overflow: Many parts of this file perform arithmetic with the decimal exponent `e`.",
        "suggest": "关于整型溢出的注意事项: 该文件的许多部分都使用十进制指数 `e` 来执行算术运算。",
        "translate": ""
    },
    {
        "source": "Primarily, we shift the decimal point around: Before the first decimal digit, after the last decimal digit, and so on.",
        "suggest": "首先，我们将小数点移动: 在第一个十进制数字之前，在最后一个十进制数字之后，依此类推。",
        "translate": ""
    },
    {
        "source": "This could overflow if done carelessly.",
        "suggest": "如果不小心这样做可能会溢出。",
        "translate": ""
    },
    {
        "source": "We rely on the parsing submodule to only hand out sufficiently small exponents, where \"sufficient\" means \"such that the exponent +/- the number of decimal digits fits into a 64 bit integer\".",
        "suggest": "我们依靠解析子模块仅分发足够小的指数，其中 \"sufficient\" 表示 \"such that the exponent +/- the number of decimal digits fits into a 64 bit integer\"。",
        "translate": ""
    },
    {
        "source": "Larger exponents are accepted, but we don't do arithmetic with them, they are immediately turned into {positive,negative} {zero,infinity}.",
        "suggest": "较大的指数被接受，但是我们不对它们进行算术运算，它们立即变成 {positive,negative} {zero,infinity}。",
        "translate": ""
    },
    {
        "source": "These two have their own tests.",
        "suggest": "这两个有自己的测试。",
        "translate": ""
    },
    {
        "source": "Converts a string in base 10 to a float.",
        "suggest": "将以 10 为底的字符串转换为浮点数。",
        "translate": ""
    },
    {
        "source": "Accepts an optional decimal exponent.",
        "suggest": "接受可选的十进制指数。",
        "translate": ""
    },
    {
        "source": "This function accepts strings such as",
        "suggest": "该函数接受诸如以下的字符串",
        "translate": ""
    },
    {
        "source": "or equivalently,",
        "suggest": "或等效地，",
        "translate": ""
    },
    {
        "source": "or, equivalently,",
        "suggest": "或者，等效地，",
        "translate": ""
    },
    {
        "source": "Leading and trailing whitespace represent an error.",
        "suggest": "前导和尾随空格表示错误。",
        "translate": ""
    },
    {
        "source": "All strings that adhere to the following [EBNF] grammar will result in an [`Ok`] being returned:",
        "suggest": "遵循以下 [EBNF] 语法的所有字符串都将导致返回 [`Ok`]:",
        "translate": ""
    },
    {
        "source": "Known bugs",
        "suggest": "已知错误",
        "translate": ""
    },
    {
        "source": "In some situations, some strings that should create a valid float instead return an error.",
        "suggest": "在某些情况下，应该创建有效浮点数的某些字符串会返回错误。",
        "translate": ""
    },
    {
        "source": "See [issue #31407] for details.",
        "suggest": "有关详细信息，请参见 [issue #31407]。",
        "translate": ""
    },
    {
        "source": "src - A string",
        "suggest": "src - 字符串",
        "translate": ""
    },
    {
        "source": "if the string did not represent a valid number.",
        "suggest": "如果字符串不代表有效数字。",
        "translate": ""
    },
    {
        "source": "Otherwise, `Ok(n)` where `n` is the floating-point number represented by `src`.",
        "suggest": "否则，为 `Ok(n)`，其中 `n` 是 `src` 表示的浮点数。",
        "translate": ""
    },
    {
        "source": "An error which can be returned when parsing a float.",
        "suggest": "解析浮点数时可以返回的错误。",
        "translate": ""
    },
    {
        "source": "This error is used as the error type for the [`FromStr`] implementation for [`f32`] and [`f64`].",
        "suggest": "该错误用作 [`f32`] 和 [`f64`] 的 [`FromStr`] 实现的错误类型。",
        "translate": ""
    },
    {
        "source": "Splits a decimal string into sign and the rest, without inspecting or validating the rest.",
        "suggest": "将十进制字符串拆分为符号和剩余部分，而无需检查或验证其余部分。",
        "translate": ""
    },
    {
        "source": "If the string is invalid, we never use the sign, so we don't need to validate here.",
        "suggest": "如果字符串无效，则我们永远不会使用符号，因此我们无需在此处进行验证。",
        "translate": ""
    },
    {
        "source": "Converts a decimal string into a floating point number.",
        "suggest": "将十进制字符串转换为浮点数。",
        "translate": ""
    },
    {
        "source": "The main workhorse for the decimal-to-float conversion: Orchestrate all the preprocessing and figure out which algorithm should do the actual conversion.",
        "suggest": "十进制到浮点转换的主要动力: 统筹所有预处理并确定哪种算法应进行实际转换。",
        "translate": ""
    },
    {
        "source": "out the decimal point.",
        "suggest": "掉小数点",
        "translate": ""
    },
    {
        "source": "Big32x40 is limited to 1280 bits, which translates to about 385 decimal digits.",
        "suggest": "Big32x40 限制为 1280 位，即大约 385 个十进制数字。",
        "translate": ""
    },
    {
        "source": "If we exceed this, we'll crash, so we error out before getting too close (within 10^10).",
        "suggest": "如果超过此值，我们将崩溃，因此我们会在距离太近 (在 10 ^ 10 以内) 之前出错。",
        "translate": ""
    },
    {
        "source": "Now the exponent certainly fits in 16 bit, which is used throughout the main algorithms.",
        "suggest": "现在，指数肯定适合 16 位，整个主要算法都使用该位。",
        "translate": ""
    },
    {
        "source": "FIXME These bounds are rather conservative.",
        "suggest": "FIXME 这些界限相当保守。",
        "translate": ""
    },
    {
        "source": "A more careful analysis of the failure modes of Bellerophon could allow using it in more cases for a massive speed up.",
        "suggest": "对 Bellerophon 的故障模式进行更仔细的分析可能会允许在更多情况下使用它，从而大幅度提高速度。",
        "translate": ""
    },
    {
        "source": "As written, this optimizes badly (see #27130, though it refers to an old version of the code).",
        "suggest": "如所写，这会导致优化效果不佳 (请参见 #27130，尽管它引用的是旧版本的代码)。",
        "translate": ""
    },
    {
        "source": "is a workaround for that.",
        "suggest": "是一种解决方法。",
        "translate": ""
    },
    {
        "source": "There are only two call sites overall and it doesn't make code size worse.",
        "suggest": "总体上只有两个调用站点，并且不会使代码大小变糟。",
        "translate": ""
    },
    {
        "source": "Strip zeros where possible, even when this requires changing the exponent",
        "suggest": "即使可能需要去除指数，也应尽可能去除零",
        "translate": ""
    },
    {
        "source": "Trimming these zeros does not change anything but may enable the fast path (< 15 digits).",
        "suggest": "修剪这些零不会改变任何内容，但可以启用快速路径 (<15 位数字)。",
        "translate": ""
    },
    {
        "source": "Simplify numbers of the form 0.0...x and x...0.0, adjusting the exponent accordingly.",
        "suggest": "简化形式为 0.0...x 和 x...0.0 的数字，并相应地调整指数。",
        "translate": ""
    },
    {
        "source": "This may not always be a win (possibly pushes some numbers out of the fast path), but it simplifies other parts significantly (notably, approximating the magnitude of the value).",
        "suggest": "这可能并不总是一个胜利 (可能会将一些数字排除在快速路径之外)，但会显着简化其他部分 (尤其是近似值的大小)。",
        "translate": ""
    },
    {
        "source": "Returns a quick-an-dirty upper bound on the size (log10) of the largest value that Algorithm R and Algorithm M will compute while working on the given decimal.",
        "suggest": "返回算法 R 和算法 M 在处理给定小数时将计算的最大值的大小 (log10) 的快速脏上限。",
        "translate": ""
    },
    {
        "source": "We don't need to worry too much about overflow here thanks to trivial_cases() and the parser, which filter out the most extreme inputs for us.",
        "suggest": "由于 trivial_cases() 和解析器为我们筛选出了最极端的输入，因此我们不必担心这里的溢出。",
        "translate": ""
    },
    {
        "source": "In the case e >= 0, both algorithms compute about `f * 10^e`.",
        "suggest": "在 e >= 0 的情况下，两种算法都计算大约 `f * 10^e`。",
        "translate": ""
    },
    {
        "source": "Algorithm R proceeds to do some complicated calculations with this but we can ignore that for the upper bound because it also reduces the fraction beforehand, so we have plenty of buffer there.",
        "suggest": "算法 R 对此进行了一些复杂的计算，但是对于上限，我们可以忽略它，因为它还会预先减小分数，因此我们在那里有很多缓冲区。",
        "translate": ""
    },
    {
        "source": "If e < 0, Algorithm R does roughly the same thing, but Algorithm M differs:",
        "suggest": "如果 e < 0，则算法 R 做大致相同的事情，但是算法 M 不同:",
        "translate": ""
    },
    {
        "source": "It tries to find a positive number k such that `f << k / 10^e` is an in-range significand.",
        "suggest": "它试图找到一个正数 k，以使 `f << k / 10^e` 是有效范围内的有效数字。",
        "translate": ""
    },
    {
        "source": "This will result in about `2^53 * f * 10^e` < `10^17 * f * 10^e`.",
        "suggest": "这将导致大约 `2^53 *f* 10^e` <`10^17 *f* 10^e`。",
        "translate": ""
    },
    {
        "source": "One input that triggers this is 0.33...33 (375 x 3).",
        "suggest": "触发此操作的一个输入为 0.33 ... 33 (375 x 3)。",
        "translate": ""
    },
    {
        "source": "Detects obvious overflows and underflows without even looking at the decimal digits.",
        "suggest": "无需查看十进制数字即可检测到明显的上溢和下溢。",
        "translate": ""
    },
    {
        "source": "There were zeros but they were stripped by simplify()",
        "suggest": "有零，但它们被 simplify() 去掉了",
        "translate": ""
    },
    {
        "source": "This is a crude approximation of ceil(log10(the real value)).",
        "suggest": "这是 ceil(log10(the real value)) 的粗略近似值。",
        "translate": ""
    },
    {
        "source": "We don't need to worry too much about overflow here because the input length is tiny (at least compared to 2^64) and the parser already handles exponents whose absolute value is greater than 10^18 (which is still 10^19 short of 2^64).",
        "suggest": "我们在这里不必担心溢出问题，因为输入长度很小 (至少与 2 ^ 64 相比)，并且解析器已经处理了绝对值大于 10 ^ 18 (仍然短 10 ^ 19 的指数) 2 ^ 64)。",
        "translate": ""
    },
    {
        "source": "Utility functions for bignums that don't make too much sense to turn into methods.",
        "suggest": "用于 bignum 的实用程序函数，转换为方法没有太大意义。",
        "translate": ""
    },
    {
        "source": "FIXME This module's name is a bit unfortunate, since other modules also import `core::num`.",
        "suggest": "FIXME 这个模块的名称有点不幸，因为其他模块也导入 `core::num`。",
        "translate": ""
    },
    {
        "source": "Test whether truncating all bits less significant than `ones_place` introduces a relative error less, equal, or greater than 0.5 ULP.",
        "suggest": "测试是否将所有不重要于 `ones_place` 的位截断是否引入了小于，等于或大于 0.5 ULP 的相对误差。",
        "translate": ""
    },
    {
        "source": "If all remaining bits are zero, it's = 0.5 ULP, otherwise > 0.5 If there are no more bits (half_bit == 0), the below also correctly returns Equal.",
        "suggest": "如果所有剩余位均为零，则为 = 0.5 ULP，否则 > 0.5 如果没有更多位 (half_bit == 0)，则以下内容也将正确返回 Equal。",
        "translate": ""
    },
    {
        "source": "Converts an ASCII string containing only decimal digits to a `u64`.",
        "suggest": "将仅包含十进制数字的 ASCII 字符串转换为 `u64`。",
        "translate": ""
    },
    {
        "source": "Does not perform checks for overflow or invalid characters, so if the caller is not careful, the result is bogus and can panic (though it won't be `unsafe`).",
        "suggest": "不检查溢出或无效字符，因此，如果调用者不小心，结果将是虚假的，并且可能为 panic (尽管不会是 `unsafe`)。",
        "translate": ""
    },
    {
        "source": "Additionally, empty strings are treated as zero.",
        "suggest": "此外，空字符串被视为零。",
        "translate": ""
    },
    {
        "source": "This function exists because",
        "suggest": "之所以存在该函数，是因为",
        "translate": ""
    },
    {
        "source": "using `FromStr` on `&[u8]` requires `from_utf8_unchecked`, which is bad, and",
        "suggest": "在 `&[u8]` 上使用 `FromStr` 需要 `from_utf8_unchecked`，这很糟糕，并且",
        "translate": ""
    },
    {
        "source": "piecing together the results of `integral.parse()` and `fractional.parse()` is more complicated than this entire function.",
        "suggest": "将 `integral.parse()` 和 `fractional.parse()` 的结果组合在一起比整个函数要复杂得多。",
        "translate": ""
    },
    {
        "source": "Converts a string of ASCII digits into a bignum.",
        "suggest": "将 ASCII 数字字符串转换为 bignum。",
        "translate": ""
    },
    {
        "source": "Like `from_str_unchecked`, this function relies on the parser to weed out non-digits.",
        "suggest": "像 `from_str_unchecked` 一样，此函数依靠解析器清除非数字。",
        "translate": ""
    },
    {
        "source": "Unwraps a bignum into a 64 bit integer.",
        "suggest": "将 bignum 解包为 64 位整数。",
        "translate": ""
    },
    {
        "source": "Panics if the number is too large.",
        "suggest": "Panics 如果数字太大。",
        "translate": ""
    },
    {
        "source": "Extracts a range of bits.",
        "suggest": "提取一定范围的位。",
        "translate": ""
    },
    {
        "source": "Index 0 is the least significant bit and the range is half-open as usual.",
        "suggest": "索引 0 是最低有效位，并且该范围像往常一样是半开的。",
        "translate": ""
    },
    {
        "source": "Panics if asked to extract more bits than fit into the return type.",
        "suggest": "Panics，如果要求提取超出返回类型的位数。",
        "translate": ""
    },
    {
        "source": "Validating and decomposing a decimal string of the form:",
        "suggest": "验证并分解以下形式的十进制字符串:",
        "translate": ""
    },
    {
        "source": "In other words, standard floating-point syntax, with two exceptions: No sign, and no handling of \"inf\" and \"NaN\".",
        "suggest": "换句话说，是标准的浮点语法，但有两个例外: 无符号，并且不处理 \"inf\" 和 \"NaN\"。",
        "translate": ""
    },
    {
        "source": "These are handled by the driver function (super::dec2flt).",
        "suggest": "这些由驱动程序函数 (super::dec2flt) 处理。",
        "translate": ""
    },
    {
        "source": "Although recognizing valid inputs is relatively easy, this module also has to reject the countless invalid variations, never panic, and perform numerous checks that the other modules rely on to not panic (or overflow) in turn.",
        "suggest": "尽管识别有效输入相对容易，但该模块还必须拒绝无数无效变量，从不拒绝 panic，并执行其他模块不依赖于 panic 的大量检查 (或溢出)。",
        "translate": ""
    },
    {
        "source": "To make matters worse, all that happens in a single pass over the input.",
        "suggest": "更糟的是，所有这些都在输入上一次完成。",
        "translate": ""
    },
    {
        "source": "So, be careful when modifying anything, and double-check with the other modules.",
        "suggest": "因此，修改任何内容时都要小心，并仔细检查其他模块。",
        "translate": ""
    },
    {
        "source": "The interesting parts of a decimal string.",
        "suggest": "十进制字符串的有趣部分。",
        "translate": ""
    },
    {
        "source": "The decimal exponent, guaranteed to have fewer than 18 decimal digits.",
        "suggest": "十进制指数，保证少于 18 个十进制数字。",
        "translate": ""
    },
    {
        "source": "Checks if the input string is a valid floating point number and if so, locate the integral part, the fractional part, and the exponent in it.",
        "suggest": "检查输入字符串是否为有效的浮点数，如果是，则在其中找到整数部分，小数部分和指数。",
        "translate": ""
    },
    {
        "source": "Does not handle signs.",
        "suggest": "不处理标志。",
        "translate": ""
    },
    {
        "source": "No digits before 'e'",
        "suggest": "'e' 之前没有数字",
        "translate": ""
    },
    {
        "source": "We require at least a single digit before or after the point.",
        "suggest": "在该点之前或之后，我们至少需要一位数字。",
        "translate": ""
    },
    {
        "source": "Trailing junk after fractional part",
        "suggest": "小数部分后的尾随垃圾",
        "translate": ""
    },
    {
        "source": "Trailing junk after first digit string",
        "suggest": "第一个数字字符串后的结尾垃圾",
        "translate": ""
    },
    {
        "source": "Carves off decimal digits up to the first non-digit character.",
        "suggest": "分割十进制数字，直到第一个非数字字符。",
        "translate": ""
    },
    {
        "source": "Exponent extraction and error checking.",
        "suggest": "指数提取和错误检查。",
        "translate": ""
    },
    {
        "source": "Trailing junk after exponent",
        "suggest": "指数后的尾随垃圾",
        "translate": ""
    },
    {
        "source": "Empty exponent",
        "suggest": "空指数",
        "translate": ""
    },
    {
        "source": "At this point, we certainly have a valid string of digits.",
        "suggest": "在这一点上，我们当然有一个有效的数字字符串。",
        "translate": ""
    },
    {
        "source": "It may be too long to put into an `i64`, but if it's that huge, the input is certainly zero or infinity.",
        "suggest": "放入 `i64` 可能太长了，但如果太大，则输入肯定为零或无穷大。",
        "translate": ""
    },
    {
        "source": "Since each zero in the decimal digits only adjusts the exponent by +/- 1, at exp = 10^18 the input would have to be 17 exabyte (!) of zeros to get even remotely close to being finite.",
        "suggest": "由于十进制数字中的每个零仅将指数调整 +/-1，因此在 exp=10 ^ 18 时，输入必须为 17 exabyte (!) 零，才能几乎接近于有限值。",
        "translate": ""
    },
    {
        "source": "This is not exactly a use case we need to cater to.",
        "suggest": "这不是我们需要迎合的用例。",
        "translate": ""
    },
    {
        "source": "Bit fiddling on positive IEEE 754 floats.",
        "suggest": "正向 IEEE 754 浮点数的 fiddling。",
        "translate": ""
    },
    {
        "source": "Negative numbers aren't and needn't be handled.",
        "suggest": "负数不是，也不需要处理。",
        "translate": ""
    },
    {
        "source": "Normal floating point numbers have a canonical representation as (frac, exp) such that the value is 2<sup>exp</sup> * (1 + sum(frac[N-i] / 2<sup>i</sup>)) where N is the number of bits.",
        "suggest": "普通浮点数的规范表示为 (frac，exp)，因此值是 2 <sup>exp</sup> * (1 + sum(frac[N-i] / 2<sup>i</sup>))，其中 N 是位数。",
        "translate": ""
    },
    {
        "source": "Subnormals are slightly different and weird, but the same principle applies.",
        "suggest": "Subnormals 法则略有不同和奇怪，但适用相同的原理。",
        "translate": ""
    },
    {
        "source": "Here, however, we represent them as (sig, k) with f positive, such that the value is f *",
        "suggest": "但是，在这里，我们将它们表示为 (sig，k)，且 f 为正，因此值为 f *",
        "translate": ""
    },
    {
        "source": "2<sup>e</sup>. Besides making the \"hidden bit\" explicit, this changes the exponent by the so-called mantissa shift.",
        "suggest": "2 <sup>e</sup>。除了使 \"hidden bit\" 显式显示之外，这还通过所谓的尾数转换来更改指数。",
        "translate": ""
    },
    {
        "source": "Put another way, normally floats are written as (1) but here they are written as (2):",
        "suggest": "换句话说，通常将浮点数写为 (1)，但在这里将它们写为 (2):",
        "translate": ""
    },
    {
        "source": "We call (1) the **fractional representation** and (2) the **integral representation**.",
        "suggest": "我们将 (1) 称为分数表示，将 (2) 称为积分表示。",
        "translate": ""
    },
    {
        "source": "Many functions in this module only handle normal numbers.",
        "suggest": "此模块中的许多函数仅处理普通数。",
        "translate": ""
    },
    {
        "source": "The dec2flt routines conservatively take the universally-correct slow path (Algorithm M) for very small and very large numbers.",
        "suggest": "对于非常小的数字和非常大的数字，dec2flt 例程保守地采用通用正确的慢路径 (算法 M)。",
        "translate": ""
    },
    {
        "source": "That algorithm needs only next_float() which does handle subnormals and zeros.",
        "suggest": "该算法仅需要 next_float()，即可处理次态和零。",
        "translate": ""
    },
    {
        "source": "A helper trait to avoid duplicating basically all the conversion code for `f32` and `f64`.",
        "suggest": "一个帮助程序 trait，可以避免基本上复制 `f32` 和 `f64` 的所有转换代码。",
        "translate": ""
    },
    {
        "source": "See the parent module's doc comment for why this is necessary.",
        "suggest": "有关为什么这样做的必要信息，请参见父模块的文档注释。",
        "translate": ""
    },
    {
        "source": "Should **never ever** be implemented for other types or be used outside the dec2flt module.",
        "suggest": "**永远不要** 为其他类型实现或在 dec2flt 模块外部使用。",
        "translate": ""
    },
    {
        "source": "Type used by `to_bits` and `from_bits`.",
        "suggest": "`to_bits` 和 `from_bits` 使用的类型。",
        "translate": ""
    },
    {
        "source": "Performs a raw transmutation to an integer.",
        "suggest": "执行原始转换为整数。",
        "translate": ""
    },
    {
        "source": "Performs a raw transmutation from an integer.",
        "suggest": "从整数执行原始转换。",
        "translate": ""
    },
    {
        "source": "Returns the category that this number falls into.",
        "suggest": "返回此数字所属的类别。",
        "translate": ""
    },
    {
        "source": "Returns the mantissa, exponent and sign as integers.",
        "suggest": "以整数形式返回尾数，指数和符号。",
        "translate": ""
    },
    {
        "source": "Decodes the float.",
        "suggest": "解码浮点数。",
        "translate": ""
    },
    {
        "source": "Casts from a small integer that can be represented exactly.",
        "suggest": "从可以精确表示的小整数进行转换。",
        "translate": ""
    },
    {
        "source": "Panic if the integer can't be represented, the other code in this module makes sure to never let that happen.",
        "suggest": "Panic 如果无法表示整数，则此模块中的其他代码确保永不让这种情况发生。",
        "translate": ""
    },
    {
        "source": "Gets the value 10<sup>e</sup> from a pre-computed table.",
        "suggest": "从预先计算的表中获取值 10 <sup>e</sup>。",
        "translate": ""
    },
    {
        "source": "What the name says.",
        "suggest": "名字怎么说。",
        "translate": ""
    },
    {
        "source": "It's easier to hard code than juggling intrinsics and hoping LLVM constant folds it.",
        "suggest": "硬编码比杂凑内联函数和希望 LLVM 常量将其折叠起来容易。",
        "translate": ""
    },
    {
        "source": "A conservative bound on the decimal digits of inputs that can't produce overflow or zero or",
        "suggest": "输入的小数位数的保守界限，不会产生溢出或零或",
        "translate": ""
    },
    {
        "source": "subnormals. Probably the decimal exponent of the maximum normal value, hence the name.",
        "suggest": "subnormals。可能是最大值的十进制指数，因此得名。",
        "translate": ""
    },
    {
        "source": "When the most significant decimal digit has a place value greater than this, the number is certainly rounded to infinity.",
        "suggest": "当最高有效十进制数字的位数大于该数值时，该数字肯定会四舍五入为无穷大。",
        "translate": ""
    },
    {
        "source": "When the most significant decimal digit has a place value less than this, the number is certainly rounded to zero.",
        "suggest": "当最高有效十进制数字的位数小于此位数时，该数字肯定会四舍五入为零。",
        "translate": ""
    },
    {
        "source": "The number of bits in the exponent.",
        "suggest": "指数中的位数。",
        "translate": ""
    },
    {
        "source": "The number of bits in the significand, *including* the hidden bit.",
        "suggest": "有效位数的位数，*包括* 隐藏位数。",
        "translate": ""
    },
    {
        "source": "The number of bits in the significand, *excluding* the hidden bit.",
        "suggest": "有效位数的位数，*不包括* 隐藏位。",
        "translate": ""
    },
    {
        "source": "The maximum legal exponent in fractional representation.",
        "suggest": "小数表示形式中的最大合法指数。",
        "translate": ""
    },
    {
        "source": "The minimum legal exponent in fractional representation, excluding subnormals.",
        "suggest": "分数表示形式中的最小合法指数，不包括次正规数。",
        "translate": ""
    },
    {
        "source": "for integral representation, i.e., with the shift applied.",
        "suggest": "用于积分表示，即应用了移位。",
        "translate": ""
    },
    {
        "source": "encoded (i.e., with offset bias)",
        "suggest": "编码 (即具有偏移偏置)",
        "translate": ""
    },
    {
        "source": "The maximum normalized significand in integral representation.",
        "suggest": "整数表示形式中的最大归一化有效位数。",
        "translate": ""
    },
    {
        "source": "The minimal normalized significand in integral representation.",
        "suggest": "整数表示形式中的最小归一化有效位数。",
        "translate": ""
    },
    {
        "source": "Mostly a workaround for #34344.",
        "suggest": "通常是 #34344 的解决方法。",
        "translate": ""
    },
    {
        "source": "Exponent bias + mantissa shift",
        "suggest": "指数偏差 + 尾数偏移",
        "translate": ""
    },
    {
        "source": "rkruppe is uncertain whether `as` rounds correctly on all platforms.",
        "suggest": "rkruppe 不确定 `as` 是否在所有平台上都能正确取整。",
        "translate": ""
    },
    {
        "source": "Converts an `Fp` to the closest machine float type.",
        "suggest": "将 `Fp` 转换为最接近的机器浮点类型。",
        "translate": ""
    },
    {
        "source": "Does not handle subnormal results.",
        "suggest": "不处理不正常的结果。",
        "translate": ""
    },
    {
        "source": "is 64 bit, so x.e has a mantissa shift of 63",
        "suggest": "是 64 位，因此 x.e 的尾数偏移为 63",
        "translate": ""
    },
    {
        "source": "Round the 64-bit significand to T::SIG_BITS bits with half-to-even.",
        "suggest": "将 64 位有效位数四舍五入为 T::SIG_BITS 位。",
        "translate": ""
    },
    {
        "source": "Does not handle exponent overflow.",
        "suggest": "不处理指数溢出。",
        "translate": ""
    },
    {
        "source": "Adjust mantissa shift",
        "suggest": "调整尾数偏移",
        "translate": ""
    },
    {
        "source": "Inverse of `RawFloat::unpack()` for normalized numbers.",
        "suggest": "`RawFloat::unpack()` 的倒数，用于归一化的数字。",
        "translate": ""
    },
    {
        "source": "Panics if the significand or exponent are not valid for normalized numbers.",
        "suggest": "Panics (如果有效位数或指数对于标准化数字无效)。",
        "translate": ""
    },
    {
        "source": "Remove the hidden bit",
        "suggest": "删除隐藏的位",
        "translate": ""
    },
    {
        "source": "Adjust the exponent for exponent bias and mantissa shift",
        "suggest": "调整指数以实现指数偏差和尾数偏移",
        "translate": ""
    },
    {
        "source": "Leave sign bit at 0 (\"+\"), our numbers are all positive",
        "suggest": "在 0 (\"+\") 处保留符号位，我们的数字均为正",
        "translate": ""
    },
    {
        "source": "Construct a subnormal.",
        "suggest": "创建一个次正规的。",
        "translate": ""
    },
    {
        "source": "A mantissa of 0 is allowed and constructs zero.",
        "suggest": "允许尾数为 0，构造为 0。",
        "translate": ""
    },
    {
        "source": "Encoded exponent is 0, the sign bit is 0, so we just have to reinterpret the bits.",
        "suggest": "编码指数为 0，符号位为 0，因此我们只需要重新解释这些位即可。",
        "translate": ""
    },
    {
        "source": "Approximate a bignum with an Fp.",
        "suggest": "大约有 Fp 的 bignum。",
        "translate": ""
    },
    {
        "source": "Rounds within 0.5 ULP with half-to-even.",
        "suggest": "在 0.5 ULP 中四舍五入至半数。",
        "translate": ""
    },
    {
        "source": "We cut off all bits prior to the index `start`, i.e., we effectively right-shift by an amount of `start`, so this is also the exponent we need.",
        "suggest": "我们将索引 `start` 之前的所有位都切除，也就是说，我们实际上右移了 `start`，因此这也是我们需要的指数。",
        "translate": ""
    },
    {
        "source": "Round (half-to-even) depending on the truncated bits.",
        "suggest": "根据截断的位舍入 (half-to-even)。",
        "translate": ""
    },
    {
        "source": "Finds the largest floating point number strictly smaller than the argument.",
        "suggest": "查找严格小于参数的最大浮点数。",
        "translate": ""
    },
    {
        "source": "Does not handle subnormals, zero, or exponent underflow.",
        "suggest": "不处理次正规量，零或指数下溢。",
        "translate": ""
    },
    {
        "source": "Find the smallest floating point number strictly larger than the argument.",
        "suggest": "找到严格大于参数的最小浮点数。",
        "translate": ""
    },
    {
        "source": "This operation is saturating, i.e., next_float(inf) == inf.",
        "suggest": "此操作饱和，即 next_float(inf) == inf。",
        "translate": ""
    },
    {
        "source": "Unlike most code in this module, this function does handle zero, subnormals, and infinities.",
        "suggest": "与该模块中的大多数代码不同，此函数确实处理零，次正态和无穷大。",
        "translate": ""
    },
    {
        "source": "However, like all other code here, it does not deal with NaN and negative numbers.",
        "suggest": "但是，像这里的所有其他代码一样，它不处理 NaN 和负数。",
        "translate": ""
    },
    {
        "source": "This seems too good to be true, but it works.",
        "suggest": "这似乎太好了，难以置信，但它确实有效。",
        "translate": ""
    },
    {
        "source": "is encoded as the all-zero word.",
        "suggest": "被编码为全零字。",
        "translate": ""
    },
    {
        "source": "subnormals are 0x000m...m where m is the mantissa.",
        "suggest": "subnormals 为 0x000m...m，其中 m 为尾数。",
        "translate": ""
    },
    {
        "source": "In particular, the smallest subnormal is 0x0...01 and the largest is 0x000F...F.",
        "suggest": "特别是，最小的次正规值为 0x0...01，最大的为 0x000F...F。",
        "translate": ""
    },
    {
        "source": "The smallest normal number is 0x0010...0, so this corner case works as well.",
        "suggest": "最小的正常数字是 0x0010...0，所以这个极端情况也适用。",
        "translate": ""
    },
    {
        "source": "If the increment overflows the mantissa, the carry bit increments the exponent as we want, and the mantissa bits become zero.",
        "suggest": "如果增量使尾数溢出，则进位将根据需要递增指数，并且尾数位变为零。",
        "translate": ""
    },
    {
        "source": "Because of the hidden bit convention, this too is exactly what we want!",
        "suggest": "由于隐藏的位约定，这正是我们想要的!",
        "translate": ""
    },
    {
        "source": "Finally, f64::MAX + 1 = 7eff...f + 1 = 7ff0...0 = f64::INFINITY.",
        "suggest": "最后，`f64::MAX + 1 = 7eff...f + 1 = 7ff0...0 = f64::INFINITY`。",
        "translate": ""
    },
    {
        "source": "Tables of approximations of powers of ten.",
        "suggest": "十次幂的近似表。",
        "translate": ""
    },
    {
        "source": "DO NOT MODIFY: Generated by `src/etc/dec2flt_table.py`",
        "suggest": "不修改: 由 `src/etc/dec2flt_table.py` 生成",
        "translate": ""
    },
    {
        "source": "Extended precision \"soft float\", for internal use only.",
        "suggest": "扩展精度 \"soft float\"，仅供内部使用。",
        "translate": ""
    },
    {
        "source": "A custom 64-bit floating point type, representing `f * 2^e`.",
        "suggest": "自定义的 64 位浮点类型，表示 `f * 2^e`。",
        "translate": ""
    },
    {
        "source": "The integer mantissa.",
        "suggest": "整数尾数。",
        "translate": ""
    },
    {
        "source": "The exponent in base 2.",
        "suggest": "以 2 为底的指数。",
        "translate": ""
    },
    {
        "source": "Returns a correctly rounded product of itself and `other`.",
        "suggest": "返回其自身和 `other` 的正确舍入乘积。",
        "translate": ""
    },
    {
        "source": "Normalizes itself so that the resulting mantissa is at least `2^63`.",
        "suggest": "对其自身进行规范化，以使所得的尾数至少为 `2^63`。",
        "translate": ""
    },
    {
        "source": "Normalizes itself to have the shared exponent.",
        "suggest": "标准化自己以具有共享指数。",
        "translate": ""
    },
    {
        "source": "It can only decrease the exponent (and thus increase the mantissa).",
        "suggest": "它只能减少指数 (从而增加尾数)。",
        "translate": ""
    },
    {
        "source": "Error types for conversion to integral types.",
        "suggest": "转换为整数类型的错误类型。",
        "translate": ""
    },
    {
        "source": "The error type returned when a checked integral type conversion fails.",
        "suggest": "当检查的整数类型转换失败时，返回错误类型。",
        "translate": ""
    },
    {
        "source": "Match rather than coerce to make sure that code like `From<Infallible> for TryFromIntError` above will keep working when `Infallible` becomes an alias to `!`.",
        "suggest": "匹配而不是强制，以确保当 `Infallible` 成为 `!` 的别名时，上述 `From<Infallible> for TryFromIntError` 这样的代码将继续起作用。",
        "translate": ""
    },
    {
        "source": "An error which can be returned when parsing an integer.",
        "suggest": "解析整数时可以返回的错误。",
        "translate": ""
    },
    {
        "source": "This error is used as the error type for the `from_str_radix()` functions on the primitive integer types, such as [`i8::from_str_radix`].",
        "suggest": "此错误用作原始整数类型 (例如 [`i8::from_str_radix`]) 上 `from_str_radix()` 函数的错误类型。",
        "translate": ""
    },
    {
        "source": "Potential causes",
        "suggest": "潜在原因",
        "translate": ""
    },
    {
        "source": "Among other causes, `ParseIntError` can be thrown because of leading or trailing whitespace in the string e.g., when it is obtained from the standard input.",
        "suggest": "除其他原因外，例如，当从标准输入中获取 `ParseIntError` 时，可能会由于字符串中的前导或尾随空格而抛出 `ParseIntError`。",
        "translate": ""
    },
    {
        "source": "Using the [`str::trim()`] method ensures that no whitespace remains before parsing.",
        "suggest": "使用 [`str::trim()`] 方法可确保在解析之前不留空格。",
        "translate": ""
    },
    {
        "source": "Enum to store the various types of errors that can cause parsing an integer to fail.",
        "suggest": "枚举存储各种类型的错误，这些错误可能导致解析整数失败。",
        "translate": ""
    },
    {
        "source": "Value being parsed is empty.",
        "suggest": "被解析的值是空的。",
        "translate": ""
    },
    {
        "source": "Among other causes, this variant will be constructed when parsing an empty string.",
        "suggest": "除其他原因外，解析空字符串时会创建这个变量。",
        "translate": ""
    },
    {
        "source": "Contains an invalid digit in its context.",
        "suggest": "在其上下文中包含无效数字。",
        "translate": ""
    },
    {
        "source": "Among other causes, this variant will be constructed when parsing a string that contains a non-ASCII char.",
        "suggest": "除其他原因外，当解析包含非 ASCII 字符的字符串时，将创建这个变量。",
        "translate": ""
    },
    {
        "source": "This variant is also constructed when a `+` or `-` is misplaced within a string either on its own or in the middle of a number.",
        "suggest": "当 `+` 或 `-` 单独放置在字符串中或放置在数字中间时，也会创建此变量。",
        "translate": ""
    },
    {
        "source": "Integer is too large to store in target integer type.",
        "suggest": "整数太大，无法存储为目标整数类型。",
        "translate": ""
    },
    {
        "source": "Integer is too small to store in target integer type.",
        "suggest": "整数太小，无法存储为目标整数类型。",
        "translate": ""
    },
    {
        "source": "Value was Zero",
        "suggest": "值为零",
        "translate": ""
    },
    {
        "source": "This variant will be emitted when the parsing string has a value of zero, which would be illegal for non-zero types.",
        "suggest": "当解析字符串的值为零时将发出此成员，这对于非零类型是非法的。",
        "translate": ""
    }
]
