[
    {
        "source": "You may be most interested in [#40][vendor], implementing all vendor intrinsics on x86.",
        "suggest": "您可能对 [#40][vendor] 最感兴趣，并在 x86 上实现了所有供应商内联函数。",
        "translate": ""
    },
    {
        "source": "That issue's got some good pointers about where to get started!",
        "suggest": "这个问题对于从哪里开始有一些很好的指示!",
        "translate": ""
    },
    {
        "source": "If you've got general questions feel free to [join us on gitter][gitter] and ask around!",
        "suggest": "如果您有一般性问题，请随时向 [加入我们的 gitter][gitter] 询问!",
        "translate": ""
    },
    {
        "source": "Feel free to ping either @BurntSushi or @alexcrichton with questions.",
        "suggest": "如有问题，请随时 ping@BurntSushi 或 @alexcrichton。",
        "translate": ""
    },
    {
        "source": "How to write examples for stdarch intrinsics",
        "suggest": "如何为 stdarch 内联函数编写示例",
        "translate": ""
    },
    {
        "source": "There are a few features that must be enabled for the given intrinsic to work properly and the example must only be run by `cargo test --doc` when the feature is supported by the CPU.",
        "suggest": "为了使给定的内联函数正常工作，必须启用一些功能，并且该示例仅在 CPU 支持该功能时才可以由 `cargo test --doc` 运行。",
        "translate": ""
    },
    {
        "source": "As a result, the default `fn main` that is generated by `rustdoc` will not work (in most cases).",
        "suggest": "结果，`rustdoc` 生成的默认 `fn main` 将不起作用 (在大多数情况下)。",
        "translate": ""
    },
    {
        "source": "Consider using the following as a guide to ensure your example works as expected.",
        "suggest": "考虑使用以下内容作为指导，以确保您的示例按预期工作。",
        "translate": ""
    },
    {
        "source": "If some of the above syntax does not look familiar, the [Documentation as tests] section of the [Rust Book] describes the `rustdoc` syntax quite well.",
        "suggest": "如果上述某些语法看起来不太熟悉，则 [Rust Book] 的 [Documentation as tests] 部分将很好地描述 `rustdoc` 语法。",
        "translate": ""
    },
    {
        "source": "As always, feel free to [join us on gitter][gitter] and ask us if you hit any snags, and thank you for helping to improve the documentation of `stdarch`!",
        "suggest": "与往常一样，请随时使用 [加入我们的 gitter][gitter]，并询问我们是否遇到任何障碍，并感谢您帮助改善 `stdarch` 的文档!",
        "translate": ""
    },
    {
        "source": "Alternative Testing Instructions",
        "suggest": "替代测试说明",
        "translate": ""
    },
    {
        "source": "It is generally recommended that you use `ci/run.sh` to run the tests.",
        "suggest": "通常建议您使用 `ci/run.sh` 来运行测试。",
        "translate": ""
    },
    {
        "source": "However this might not work for you, e.g. if you are on Windows.",
        "suggest": "但是，这可能对您不起作用，例如，如果您使用的是 Windows。",
        "translate": ""
    },
    {
        "source": "In that case you can fall back to running `cargo +nightly test` and `cargo +nightly test --release -p core_arch` for testing the code generation.",
        "suggest": "在这种情况下，您可以回去运行 `cargo +nightly test` 和 `cargo +nightly test --release -p core_arch` 来测试代码生成。",
        "translate": ""
    },
    {
        "source": "Note that these require the nightly toolchain to be installed and for `rustc` to know about your target triple and its CPU.",
        "suggest": "请注意，这些要求每夜安装一次工具链，并且 `rustc` 才能了解目标三元组及其 CPU。",
        "translate": ""
    },
    {
        "source": "In particular you need to set the `TARGET` environment variable as you would for `ci/run.sh`.",
        "suggest": "特别是，您需要像设置 `ci/run.sh` 一样设置 `TARGET` 环境变量。",
        "translate": ""
    },
    {
        "source": "In addition you need to set `RUSTCFLAGS` (need the `C`) to indicate target features, e.g.",
        "suggest": "另外，您需要设置 `RUSTCFLAGS` (需要 `C`) 以指示目标功能，例如",
        "translate": ""
    },
    {
        "source": "You can also set `-C -target-cpu=native` if you're \"just\" developing against your current CPU.",
        "suggest": "如果您正在针对当前的 CPU 开发 \"just\"，也可以设置 `-C -target-cpu=native`。",
        "translate": ""
    },
    {
        "source": "Be warned that when you use these alternative instructions, [things may go less smoothly than they would with `ci/run.sh`][ci-run-good], e.g.",
        "suggest": "请注意，当您使用这些替代说明时，[事情可能不如使用 `ci/run.sh` 顺利][ci-run-good]，例如",
        "translate": ""
    },
    {
        "source": "instruction generation tests may fail because the disassembler named them differently, e.g.",
        "suggest": "指令生成测试可能会失败，因为反汇编程序对它们的命名不同，例如",
        "translate": ""
    },
    {
        "source": "it may generate `vaesenc` instead of `aesenc` instructions despite them behaving the same.",
        "suggest": "尽管它们的行为相同，但它可能会生成 `vaesenc` 而不是 `aesenc` 指令。",
        "translate": ""
    },
    {
        "source": "Also these instructions execute less tests than would normally be done, so don't be surprised that when you eventually pull-request some errors may show up for tests not covered here.",
        "suggest": "同样，这些指令执行的测试少于通常执行的测试，因此当您最终请求请求时，对于此处未涵盖的测试，可能会出现一些错误，请不要感到惊讶。",
        "translate": ""
    },
    {
        "source": "stdarch - Rust's standard library SIMD components",
        "suggest": "stdarch-Rust 的标准库 SIMD 组件",
        "translate": ""
    },
    {
        "source": "This repository contains two main crates:",
        "suggest": "该仓库包含两个主要的 crates:",
        "translate": ""
    },
    {
        "source": "implements `core::arch` - Rust's core library architecture-specific intrinsics, and",
        "suggest": "实现 `core::arch`-Rust 的核心库体系结构特定的内联函数，以及",
        "translate": ""
    },
    {
        "source": "implements `std::detect` - Rust's standard library run-time CPU feature detection.",
        "suggest": "实现 `std::detect`-Rust 的标准库运行时 CPU 功能检测。",
        "translate": ""
    },
    {
        "source": "The `std::simd` component now lives in the [`packed_simd`](https://github.com/rust-lang-nursery/packed_simd) crate.",
        "suggest": "`std::simd` 组件现在位于 [`packed_simd`](https://github.com/rust-lang-nursery/packed_simd) crate 中。",
        "translate": ""
    },
    {
        "source": "How to do a release",
        "suggest": "如何发布",
        "translate": ""
    },
    {
        "source": "To do a release of the `core_arch` and `std_detect` crates,",
        "suggest": "要发布 `core_arch` 和 `std_detect` crates，",
        "translate": ""
    },
    {
        "source": "bump up the version appropriately,",
        "suggest": "适当提高版本，",
        "translate": ""
    },
    {
        "source": "comment out the `dev-dependencies` in their `Cargo.toml` files (due to https://github.com/rust-lang/cargo/issues/4242),",
        "suggest": "在 `Cargo.toml` 文件中注释掉 `dev-dependencies` (因为 https://github.com/rust-lang/cargo/issues/4242)，",
        "translate": ""
    },
    {
        "source": "publish the crates.",
        "suggest": "发布 crates。",
        "translate": ""
    },
    {
        "source": "Terminal formatting library.",
        "suggest": "终端格式化库。",
        "translate": ""
    },
    {
        "source": "This crate provides the `Terminal` trait, which abstracts over an [ANSI Terminal][ansi] to provide color printing, among other things.",
        "suggest": "crate 提供了 `Terminal` trait，它在 [ANSI 终端][ansi] 上进行抽象以提供彩色打印。",
        "translate": ""
    },
    {
        "source": "There are two implementations, the `TerminfoTerminal`, which uses control characters from a [terminfo][ti] database, and `WinConsole`, which uses the [Win32 Console API][win].",
        "suggest": "有两种实现，一种是 `TerminfoTerminal`，它使用来自 [术语信息][ti] 数据库的控制字符，另一种是 `WinConsole`，它使用 [Win32 控制台 API][win]。",
        "translate": ""
    },
    {
        "source": "Alias for stdout terminals.",
        "suggest": "stdout 终端的别名。",
        "translate": ""
    },
    {
        "source": "Alias for stderr terminals.",
        "suggest": "stderr 终端的别名。",
        "translate": ""
    },
    {
        "source": "Returns a Terminal wrapping stdout, or None if a terminal couldn't be opened.",
        "suggest": "返回包装 stdout 的终端，如果无法打开终端，则返回 None。",
        "translate": ""
    },
    {
        "source": "Returns a Terminal wrapping stderr, or None if a terminal couldn't be opened.",
        "suggest": "返回终端包装的 stderr，如果无法打开终端，则返回 None。",
        "translate": ""
    },
    {
        "source": "Terminal color definitions",
        "suggest": "终端颜色定义",
        "translate": ""
    },
    {
        "source": "Number for a terminal color",
        "suggest": "终端颜色的编号",
        "translate": ""
    },
    {
        "source": "Terminal attributes for use with term.attr().",
        "suggest": "term.attr() 使用的终端属性。",
        "translate": ""
    },
    {
        "source": "Most attributes can only be turned on and must be turned off with term.reset().",
        "suggest": "大多数属性只能打开，并且必须使用 term.reset() 关闭。",
        "translate": ""
    },
    {
        "source": "The ones that can be turned off explicitly take a boolean value.",
        "suggest": "可以显式关闭的值具有布尔值。",
        "translate": ""
    },
    {
        "source": "Color is also represented as an attribute for convenience.",
        "suggest": "为了方便起见，颜色也表示为属性。",
        "translate": ""
    },
    {
        "source": "Bold (or possibly bright) mode",
        "suggest": "粗体 (或可能明亮) 模式",
        "translate": ""
    },
    {
        "source": "Dim mode, also called faint or half-bright.",
        "suggest": "昏暗模式，也称为微弱或半亮。",
        "translate": ""
    },
    {
        "source": "Often not supported",
        "suggest": "通常不支持",
        "translate": ""
    },
    {
        "source": "Italics mode.",
        "suggest": "斜体模式。",
        "translate": ""
    },
    {
        "source": "Underline mode",
        "suggest": "下划线模式",
        "translate": ""
    },
    {
        "source": "Blink mode",
        "suggest": "闪烁模式",
        "translate": ""
    },
    {
        "source": "Standout mode.",
        "suggest": "突出模式。",
        "translate": ""
    },
    {
        "source": "Often implemented as Reverse, sometimes coupled with Bold",
        "suggest": "通常实现为反向，有时加粗体",
        "translate": ""
    },
    {
        "source": "Reverse mode, inverts the foreground and background colors",
        "suggest": "反转模式，反转前景色和背景色",
        "translate": ""
    },
    {
        "source": "Secure mode, also called invis mode.",
        "suggest": "安全模式，也称为 invis 模式。",
        "translate": ""
    },
    {
        "source": "Hides the printed text",
        "suggest": "隐藏打印的文字",
        "translate": ""
    },
    {
        "source": "Convenience attribute to set the foreground color",
        "suggest": "便利属性可设置前景色",
        "translate": ""
    },
    {
        "source": "Convenience attribute to set the background color",
        "suggest": "便利属性可设置背景色",
        "translate": ""
    },
    {
        "source": "A terminal with similar capabilities to an ANSI Terminal (foreground/background colors etc).",
        "suggest": "具有与 ANSI 终端 (foreground/background 颜色等) 相似的功能的终端。",
        "translate": ""
    },
    {
        "source": "The terminal's output writer type.",
        "suggest": "终端的输出 writer 类型。",
        "translate": ""
    },
    {
        "source": "Sets the foreground color to the given color.",
        "suggest": "将前景色设置为给定的颜色。",
        "translate": ""
    },
    {
        "source": "If the color is a bright color, but the terminal only supports 8 colors, the corresponding normal color will be used instead.",
        "suggest": "如果颜色是亮色，但终端仅支持 8 种颜色，则将使用相应的常规颜色。",
        "translate": ""
    },
    {
        "source": "Returns `Ok(true)` if the color was set, `Ok(false)` otherwise, and `Err(e)` if there was an I/O error.",
        "suggest": "如果设置了颜色，则返回 `Ok(true)`，否则返回 `Ok(false)`，如果存在 I/O 错误，则返回 `Err(e)`。",
        "translate": ""
    },
    {
        "source": "Sets the background color to the given color.",
        "suggest": "将背景色设置为给定的颜色。",
        "translate": ""
    },
    {
        "source": "Sets the given terminal attribute, if supported.",
        "suggest": "设置给定的终端属性 (如果支持)。",
        "translate": ""
    },
    {
        "source": "Returns `Ok(true)` if the attribute was supported, `Ok(false)` otherwise, and `Err(e)` if there was an I/O error.",
        "suggest": "如果支持该属性，则返回 `Ok(true)`; 否则，返回 `Ok(false)`; 如果存在 I/O 错误，则返回 `Err(e)`。",
        "translate": ""
    },
    {
        "source": "Returns `true` if the given terminal attribute is supported.",
        "suggest": "如果支持给定的终端属性，则返回 `true`。",
        "translate": ""
    },
    {
        "source": "Resets all terminal attributes and colors to their defaults.",
        "suggest": "将所有终端属性和颜色重置为其默认值。",
        "translate": ""
    },
    {
        "source": "Returns `Ok(true)` if the terminal was reset, `Ok(false)` otherwise, and `Err(e)` if there was an I/O error.",
        "suggest": "如果重置了终端，则返回 `Ok(true)`; 否则，返回 `Ok(false)`; 如果发生 I/O 错误，则返回 `Err(e)`。",
        "translate": ""
    },
    {
        "source": "This does not flush.",
        "suggest": "这不会刷新。",
        "translate": ""
    },
    {
        "source": "That means the reset command may get buffered so, if you aren't planning on doing anything else that might flush stdout's buffer (e.g., writing a line of text), you should flush after calling reset.",
        "suggest": "这意味着 reset 命令可能会被缓冲，因此，如果您不打算做其他可能会刷新 stdout 缓冲区的事情 (例如，编写一行文本)，则应在调用 reset 之后刷新。",
        "translate": ""
    },
    {
        "source": "Gets an immutable reference to the stream inside",
        "suggest": "获取内部流的不可变引用",
        "translate": ""
    },
    {
        "source": "Gets a mutable reference to the stream inside",
        "suggest": "获取内部流的可变引用",
        "translate": ""
    },
    {
        "source": "Returns the contained stream, destroying the `Terminal`",
        "suggest": "返回包含的流，销毁 `Terminal`",
        "translate": ""
    },
    {
        "source": "Terminfo database interface.",
        "suggest": "Terminfo 数据库接口。",
        "translate": ""
    },
    {
        "source": "A parsed terminfo database entry.",
        "suggest": "解析的 terminfo 数据库条目。",
        "translate": ""
    },
    {
        "source": "Names for the terminal",
        "suggest": "终端名称",
        "translate": ""
    },
    {
        "source": "Map of capability name to boolean value",
        "suggest": "能力名称的 Map 到布尔值",
        "translate": ""
    },
    {
        "source": "Map of capability name to numeric value",
        "suggest": "能力名称的 Map 到数值",
        "translate": ""
    },
    {
        "source": "Map of capability name to raw (unexpanded) string",
        "suggest": "功能名称的 Map 到原始 (unexpanded) 字符串",
        "translate": ""
    },
    {
        "source": "A terminfo creation error.",
        "suggest": "terminfo 创建错误。",
        "translate": ""
    },
    {
        "source": "TermUnset Indicates that the environment doesn't include enough information to find the terminfo entry.",
        "suggest": "TermUnset 指示环境没有足够的信息来查找 terminfo 条目。",
        "translate": ""
    },
    {
        "source": "MalformedTerminfo indicates that parsing the terminfo entry failed.",
        "suggest": "MalformedTerminfo 指示解析 terminfo 条目失败。",
        "translate": ""
    },
    {
        "source": "forwards any io::Errors encountered when finding or reading the terminfo entry.",
        "suggest": "转发查找或读取 terminfo 条目时遇到的任何 io::Errors。",
        "translate": ""
    },
    {
        "source": "Creates a TermInfo based on current environment.",
        "suggest": "根据当前环境创建 TermInfo。",
        "translate": ""
    },
    {
        "source": "msys terminal",
        "suggest": "msys 终端",
        "translate": ""
    },
    {
        "source": "Creates a TermInfo for the named terminal.",
        "suggest": "为命名的终端创建 TermInfo。",
        "translate": ""
    },
    {
        "source": "Parse the given TermInfo.",
        "suggest": "解析给定的 TermInfo。",
        "translate": ""
    },
    {
        "source": "Keep the metadata small",
        "suggest": "保持元数据较小",
        "translate": ""
    },
    {
        "source": "TermInfo format parsing.",
        "suggest": "TermInfo 格式解析。",
        "translate": ""
    },
    {
        "source": "ncurses-compatible compiled terminfo format parsing (term(5))",
        "suggest": "解析 (term(5)) 的 ncurses 兼容的已编译 terminfo 格式",
        "translate": ""
    },
    {
        "source": "A Terminal that knows how many colors it supports, with a reference to its parsed Terminfo database record.",
        "suggest": "一个终端，知道它支持多少种颜色，并对其解析的 Terminfo 数据库记录进行引用。",
        "translate": ""
    },
    {
        "source": "are there any terminals that have color/attrs and not sgr0?",
        "suggest": "是否有带有 color/attrs 而不是 sgr0 的端子?",
        "translate": ""
    },
    {
        "source": "Try falling back to sgr, then op",
        "suggest": "尝试回退到 sgr，然后再操作",
        "translate": ""
    },
    {
        "source": "Creates a new TerminfoTerminal with the given TermInfo and Write.",
        "suggest": "使用给定的 TermInfo 和 Write 创建一个新的 TerminfoTerminal。",
        "translate": ""
    },
    {
        "source": "Creates a new TerminfoTerminal for the current environment with the given Write.",
        "suggest": "使用给定的 Write 为当前环境创建一个新的 TerminfoTerminal。",
        "translate": ""
    },
    {
        "source": "Returns `None` when the terminfo cannot be found or parsed.",
        "suggest": "找不到或解析 terminfo 时，返回 `None`。",
        "translate": ""
    },
    {
        "source": "Parameterized string expansion",
        "suggest": "参数化字符串扩展",
        "translate": ""
    },
    {
        "source": "Types of parameters a capability can use",
        "suggest": "功能可以使用的参数类型",
        "translate": ""
    },
    {
        "source": "Container for static and dynamic variable arrays",
        "suggest": "静态和动态变量数组的容器",
        "translate": ""
    },
    {
        "source": "Static variables A-Z",
        "suggest": "静态变量 A-Z",
        "translate": ""
    },
    {
        "source": "Dynamic variables a-z",
        "suggest": "动态变量 a-z",
        "translate": ""
    },
    {
        "source": "Returns a new zero-initialized Variables",
        "suggest": "返回一个新的零初始化变量",
        "translate": ""
    },
    {
        "source": "Expand a parameterized capability",
        "suggest": "扩展参数化功能",
        "translate": ""
    },
    {
        "source": "string to expand",
        "suggest": "扩展字符串",
        "translate": ""
    },
    {
        "source": "vector of params for %p1 etc",
        "suggest": "%p1 等的参数 vector",
        "translate": ""
    },
    {
        "source": "Variables struct for %Pa etc",
        "suggest": "%Pa 等的变量结构体",
        "translate": ""
    },
    {
        "source": "To be compatible with ncurses, `vars` should be the same between calls to `expand` for multiple capabilities for the same terminal.",
        "suggest": "为了与 ncurses 兼容，对于同一终端的多种功能，在 `expand` 的调用之间，`vars` 应该相同。",
        "translate": ""
    },
    {
        "source": "expanded cap will only rarely be larger than the cap itself",
        "suggest": "扩展的封顶很少会比封顶本身大",
        "translate": ""
    },
    {
        "source": "Copy parameters into a local vector for mutability",
        "suggest": "将参数复制到本地 vector 中以实现可变性",
        "translate": ""
    },
    {
        "source": "if c is 0, use 0200 (128) for ncurses compatibility",
        "suggest": "如果 c 为 0，则使用 0200 (128) 进行 ncurses 兼容性",
        "translate": ""
    },
    {
        "source": "Don't check bounds.",
        "suggest": "不要检查边界。",
        "translate": ""
    },
    {
        "source": "ncurses just casts and truncates.",
        "suggest": "ncurses 只是强制转换和截断。",
        "translate": ""
    },
    {
        "source": "printf-style support for %doxXs",
        "suggest": "%doxXs 的 printf 样式支持",
        "translate": ""
    },
    {
        "source": "params are 1-indexed",
        "suggest": "参数是 1 索引的",
        "translate": ""
    },
    {
        "source": "will cause state to go to Nothing",
        "suggest": "将导致状态变为 Nothing",
        "translate": ""
    },
    {
        "source": "C doesn't take sign into account in precision calculation.",
        "suggest": "C 在精度计算中不考虑符号。",
        "translate": ""
    },
    {
        "source": "Leading octal zero counts against precision.",
        "suggest": "前导八进制零会影响精度。",
        "translate": ""
    },
    {
        "source": "These are the orders ncurses uses in its compiled format (as of 5.9).",
        "suggest": "这些是 ncurses 以其编译格式使用的命令 (自 5.9 起)。",
        "translate": ""
    },
    {
        "source": "Not sure if portable.",
        "suggest": "不确定是否可移植。",
        "translate": ""
    },
    {
        "source": "Parse a compiled terminfo entry, using long capability names if `longnames` is true",
        "suggest": "如果 `longnames` 为 true，则使用长功能名称解析已编译的 terminfo 条目",
        "translate": ""
    },
    {
        "source": "Check magic number",
        "suggest": "检查 magic 数字",
        "translate": ""
    },
    {
        "source": "According to the spec, these fields must be >= -1 where -1 means that the feature is not supported.",
        "suggest": "根据规范，这些字段必须 >= -1，其中 -1 表示不支持该功能。",
        "translate": ""
    },
    {
        "source": "Using 0 instead of -1 works because we skip sections with length 0.",
        "suggest": "使用 0 代替 -1 是可行的，因为我们跳过了长度为 0 的部分。",
        "translate": ""
    },
    {
        "source": "don't read NUL",
        "suggest": "不要读 NUL",
        "translate": ""
    },
    {
        "source": "consume NUL",
        "suggest": "消耗 NUL",
        "translate": ""
    },
    {
        "source": "compensate for padding",
        "suggest": "补偿填充",
        "translate": ""
    },
    {
        "source": "undocumented: FFFE indicates cap@, which means the capability is not present unsure if the handling for this is correct",
        "suggest": "未记录: FFFE 表示 cap@，这表示该能力不存在，不确定处理是否正确",
        "translate": ""
    },
    {
        "source": "Find the offset of the NUL we want to go to",
        "suggest": "找到我们想去的 NUL 的偏移量",
        "translate": ""
    },
    {
        "source": "And that's all there is to it",
        "suggest": "这就是全部",
        "translate": ""
    },
    {
        "source": "Creates a dummy TermInfo struct for msys terminals",
        "suggest": "为 msys 终端创建虚拟 TermInfo 结构体",
        "translate": ""
    },
    {
        "source": "msys is a fork of an older cygwin version",
        "suggest": "msys 是较旧的 cygwin 版本的 fork",
        "translate": ""
    },
    {
        "source": "woefully inadequate test coverage",
        "suggest": "严重不足的测试覆盖率",
        "translate": ""
    },
    {
        "source": "current tests won't work with non-standard terminfo hierarchies (e.g., macOS's)",
        "suggest": "当前的测试不适用于非标准的 terminfo 层次结构 (例如 macOS)",
        "translate": ""
    },
    {
        "source": "FIXME (#9639): This needs to handle non-utf8 paths",
        "suggest": "FIXME (#9639): 这需要处理非 utf8 路径",
        "translate": ""
    },
    {
        "source": "ncurses-compatible database discovery.",
        "suggest": "ncurses 兼容的数据库发现。",
        "translate": ""
    },
    {
        "source": "Does not support hashed database, only filesystem!",
        "suggest": "不支持哈希数据库，仅支持文件系统!",
        "translate": ""
    },
    {
        "source": "Return path to database entry for `term`",
        "suggest": "`term` 的数据库条目的返回路径",
        "translate": ""
    },
    {
        "source": "Find search directory",
        "suggest": "查找搜索目录",
        "translate": ""
    },
    {
        "source": "Found nothing in TERMINFO_DIRS, use the default paths:",
        "suggest": "在 TERMINFO_DIRS 中一无所获，请使用默认路径:",
        "translate": ""
    },
    {
        "source": "According to  /etc/terminfo/README, after looking at ~/.terminfo, ncurses will search /etc/terminfo, then /lib/terminfo, and eventually /usr/share/terminfo.",
        "suggest": "根据 /etc/terminfo/README，在查看 ~/.terminfo 之后，ncurses 将搜索 /etc/terminfo，然后是 /lib/terminfo，最后是 /usr/share/terminfo。",
        "translate": ""
    },
    {
        "source": "On Haiku the database can be found at /boot/system/data/terminfo",
        "suggest": "在 Haiku 上，数据库位于 /boot/system/data/terminfo",
        "translate": ""
    },
    {
        "source": "Look for the terminal in all of the search directories",
        "suggest": "在所有搜索目录中查找终端",
        "translate": ""
    },
    {
        "source": "on some installations the dir is named after the hex of the char (e.g., macOS)",
        "suggest": "在某些安装中，该目录以 char 的十六进制命名 (例如 macOS)",
        "translate": ""
    },
    {
        "source": "console handling",
        "suggest": "控制台操作",
        "translate": ""
    },
    {
        "source": "FIXME (#13400): this is only a tiny fraction of the Windows console api",
        "suggest": "FIXME (#13400): 这只是 Windows 控制台 api 的一小部分",
        "translate": ""
    },
    {
        "source": "A Terminal implementation that uses the Win32 Console API.",
        "suggest": "使用 Win32 控制台 API 的终端实现。",
        "translate": ""
    },
    {
        "source": "magic numbers from mingw-w64's wincon.h",
        "suggest": "mingw-w64 的 wincon.h 的 magic 数字",
        "translate": ""
    },
    {
        "source": "copy the hi-intensity bit",
        "suggest": "复制高强度位",
        "translate": ""
    },
    {
        "source": "Magic -11 means stdout, from",
        "suggest": "Magic -11 表示 stdout，来自",
        "translate": ""
    },
    {
        "source": "You may be wondering, \"but what about stderr?\", and the answer to that is that setting terminal attributes on the stdout handle also sets them for stderr, since they go to the same terminal!",
        "suggest": "\"但是 stderr 呢?\"，您可能会想知道，答案是，在 stdout 句柄上设置终端属性也会将它们设置为 stderr，因为它们会到达同一终端!",
        "translate": ""
    },
    {
        "source": "Admittedly, this is fragile, since stderr could be redirected to a different console.",
        "suggest": "诚然，这很脆弱，因为可以将 stderr 重定向到其他控制台。",
        "translate": ""
    },
    {
        "source": "This is good enough for rustc though.",
        "suggest": "不过，这对于 rustc 已经足够了。",
        "translate": ""
    },
    {
        "source": "See #13400.",
        "suggest": "请参见 #13400。",
        "translate": ""
    },
    {
        "source": "Returns `None` whenever the terminal cannot be created for some reason.",
        "suggest": "每当由于某种原因无法创建终端时，返回 `None`。",
        "translate": ""
    },
    {
        "source": "it claims support for underscore and reverse video, but I can't get it to do anything -cmr",
        "suggest": "它声称支持下划线和反向视频，但我无法让它做任何事情 -cmr",
        "translate": ""
    },
    {
        "source": "not actually used but needed to always have proc_macro in the sysroot",
        "suggest": "并未实际使用，但需要始终在 sysroot 中拥有 proc_macro",
        "translate": ""
    },
    {
        "source": "Forward features to the `std` crate as necessary",
        "suggest": "根据需要将功能转发到 `std` crate",
        "translate": ""
    },
    {
        "source": "Benchmarking module.",
        "suggest": "基准测试模块。",
        "translate": ""
    },
    {
        "source": "Manager of the benchmarking runs.",
        "suggest": "基准测试管理。",
        "translate": ""
    },
    {
        "source": "This is fed into functions marked with `#[bench]` to allow for set-up & tear-down before running a piece of code repeatedly via a call to `iter`.",
        "suggest": "这被馈入标有 `#[bench]` 的函数中，以便在通过调用 `iter` 重复运行一段代码之前进行设置和拆除。",
        "translate": ""
    },
    {
        "source": "Callback for benchmark functions to run in their body.",
        "suggest": "基准函数在其体内运行的回调。",
        "translate": ""
    },
    {
        "source": "Format a number with thousands separators",
        "suggest": "用数千个分隔符设置数字格式",
        "translate": ""
    },
    {
        "source": "Initial bench run to get ballpark figure.",
        "suggest": "最初的替补席上跑来获得大致数字。",
        "translate": ""
    },
    {
        "source": "Try to estimate iter count for 1ms falling back to 1m iterations if first run took < 1ns.",
        "suggest": "如果第一次运行的时间小于 1ns，请尝试估计 1ms 的迭代次数，然后减少到 1m 迭代次数。",
        "translate": ""
    },
    {
        "source": "if the first run took more than 1ms we don't want to just be left doing 0 iterations on every loop.",
        "suggest": "如果第一次运行花费的时间超过 1 毫秒，我们不想在每个循环中仅进行 0 次迭代。",
        "translate": ""
    },
    {
        "source": "The unfortunate side effect of not being able to do as many runs is automatically handled by the statistical analysis below (i.e., larger error bars).",
        "suggest": "下面的统计分析自动处理了不能做那么多运行的不幸的副作用（即较大的错误条）。",
        "translate": ""
    },
    {
        "source": "If we've run for 100ms and seem to have converged to a stable median.",
        "suggest": "如果我们已经运行了 100 毫秒，并且似乎已经收敛到稳定的中值。",
        "translate": ""
    },
    {
        "source": "Longest we ever run for is 3s.",
        "suggest": "我们运行的最长时间是 3 秒。",
        "translate": ""
    },
    {
        "source": "If we overflow here just return the results so far.",
        "suggest": "如果我们在这里溢出，请返回到目前为止的结果。",
        "translate": ""
    },
    {
        "source": "We check a multiplier of 10 because we're about to multiply by 2 and the next iteration of the loop will also multiply by 5 (to calculate the summ5 result)",
        "suggest": "我们将乘数检查为 10，因为我们将乘以 2，并且循环的下一次迭代也将乘以 5 (以计算 summ5 结果)",
        "translate": ""
    },
    {
        "source": "iter not called, so no data.",
        "suggest": "它没有被调用，所以没有数据。",
        "translate": ""
    },
    {
        "source": "error in this case?",
        "suggest": "在这种情况下的错误?",
        "translate": ""
    },
    {
        "source": "Module converting command-line arguments into test configuration.",
        "suggest": "将命令行参数转换为测试配置的模块。",
        "translate": ""
    },
    {
        "source": "Result of parsing the options.",
        "suggest": "解析选项的结果。",
        "translate": ""
    },
    {
        "source": "Result of parsing the option part.",
        "suggest": "解析选项部分的结果。",
        "translate": ""
    },
    {
        "source": "Parses command line arguments into test options.",
        "suggest": "将命令行参数解析为测试选项。",
        "translate": ""
    },
    {
        "source": "Returns `None` if help was requested (since we only show help message and don't run tests), returns `Some(Err(..))` if provided arguments are incorrect, otherwise creates a `TestOpts` object and returns it.",
        "suggest": "如果请求了帮助，则返回 `None` (因为我们仅显示帮助消息并且不运行测试)，如果提供的参数不正确，则返回 `Some(Err(..))`，否则创建 `TestOpts` 对象并返回它。",
        "translate": ""
    },
    {
        "source": "Parse matches.",
        "suggest": "解析匹配。",
        "translate": ""
    },
    {
        "source": "Check if help was requested.",
        "suggest": "检查是否需要帮助。",
        "translate": ""
    },
    {
        "source": "Show help and do nothing more.",
        "suggest": "显示帮助，仅此而已。",
        "translate": ""
    },
    {
        "source": "Actually parse the opts.",
        "suggest": "实际解析选项。",
        "translate": ""
    },
    {
        "source": "Gets the option value and checks if unstable features are enabled.",
        "suggest": "获取选项值，并检查是否启用了可变的特性。",
        "translate": ""
    },
    {
        "source": "Implementation of `parse_opts` that doesn't care about help message and returns a `Result`.",
        "suggest": "`parse_opts` 的实现，它不关心帮助消息并返回 `Result`。",
        "translate": ""
    },
    {
        "source": "Unstable flags",
        "suggest": "不稳定的标志",
        "translate": ""
    },
    {
        "source": "Copied from librustc_ast until linkage errors are resolved.",
        "suggest": "从 librustc_ast 复制，直到解决链接错误。",
        "translate": ""
    },
    {
        "source": "Whether this is a feature-staged build, i.e., on the beta or stable channel",
        "suggest": "这是功能阶段构建，即基于 beta 还是稳定的通道",
        "translate": ""
    },
    {
        "source": "Whether we should enable unstable features for bootstrapping",
        "suggest": "我们是否应该为引导启用不稳定的功能",
        "translate": ""
    },
    {
        "source": "Gets the CLI options associated with `report-time` feature.",
        "suggest": "获取与 `report-time` 功能关联的 CLI 选项。",
        "translate": ""
    },
    {
        "source": "If `ensure-test-time` option is provided, time output is enforced, so user won't be confused if any of tests will silently fail.",
        "suggest": "如果提供了 `ensure-test-time` 选项，则将强制执行时间输出，因此如果任何测试都将以静默方式失败，则不会使用户感到困惑。",
        "translate": ""
    },
    {
        "source": "Module providing interface for running tests in the console.",
        "suggest": "提供在控制台中运行测试的接口的模块。",
        "translate": ""
    },
    {
        "source": "Generic wrapper over stdout.",
        "suggest": "stdout 上的通用包装器。",
        "translate": ""
    },
    {
        "source": "List the tests to console, and optionally to logfile.",
        "suggest": "列出要控制台进行的测试，还可以列出日志文件。",
        "translate": ""
    },
    {
        "source": "Filters are honored.",
        "suggest": "筛选器很荣幸。",
        "translate": ""
    },
    {
        "source": "Updates `ConsoleTestState` depending on result of the test execution.",
        "suggest": "根据测试执行的结果更新 `ConsoleTestState`。",
        "translate": ""
    },
    {
        "source": "Handler for events that occur during test execution.",
        "suggest": "处理在测试执行期间发生的事件的处理程序。",
        "translate": ""
    },
    {
        "source": "It is provided as a callback to the `run_tests` function.",
        "suggest": "它作为 `run_tests` 函数的回调提供。",
        "translate": ""
    },
    {
        "source": "A simple console test runner.",
        "suggest": "一个简单的控制台测试运行程序。",
        "translate": ""
    },
    {
        "source": "Runs provided tests reporting process and results to the stdout.",
        "suggest": "运行提供的测试报告过程并将结果发送到 stdout。",
        "translate": ""
    },
    {
        "source": "Prevent the usage of `Instant` in some cases:",
        "suggest": "在某些情况下，禁止使用 `Instant`:",
        "translate": ""
    },
    {
        "source": "It's currently not supported for wasm targets.",
        "suggest": "wasm 目标目前不支持此功能。",
        "translate": ""
    },
    {
        "source": "We disable it for miri because it's not available when isolation is enabled.",
        "suggest": "我们为 miri 禁用了此功能，因为启用隔离后该功能不可用。",
        "translate": ""
    },
    {
        "source": "Calculates padding for given test description.",
        "suggest": "计算给定测试说明的填充。",
        "translate": ""
    },
    {
        "source": "Module containing different events that can occur during tests execution process.",
        "suggest": "包含在测试执行过程中可能发生的不同事件的模块。",
        "translate": ""
    },
    {
        "source": "A doc test's name includes a filename which must be escaped for correct json.",
        "suggest": "doc 测试的名称包含一个文件名，对于正确的 json，必须对该文件名进行转义。",
        "translate": ""
    },
    {
        "source": "A formatting utility used to print strings with characters in need of escaping.",
        "suggest": "一种格式化实用程序，用于打印带有需要转义的字符的字符串。",
        "translate": ""
    },
    {
        "source": "Base code taken form `libserialize::json::escape_str`",
        "suggest": "基本代码形式为 `libserialize::json::escape_str`",
        "translate": ""
    },
    {
        "source": "Number of columns to fill when aligning names",
        "suggest": "对齐名称时要填充的列数",
        "translate": ""
    },
    {
        "source": "When running tests concurrently, we should not print the test's name as the result will be mis-aligned.",
        "suggest": "同时运行测试时，我们不应打印测试的名称，因为结果将不一致。",
        "translate": ""
    },
    {
        "source": "When running the tests serially, we print the name here so that the user can see which test hangs.",
        "suggest": "串行运行测试时，我们在此处打印名称，以便用户可以看到哪个测试挂起。",
        "translate": ""
    },
    {
        "source": "There's no parallelism at this point so it's safe to use color",
        "suggest": "此时没有并行性，因此使用颜色是安全的",
        "translate": ""
    },
    {
        "source": "insert a '\\n' after 100 tests in quiet mode",
        "suggest": "在安静模式下进行 100 次测试后插入 '\\n'",
        "translate": ""
    },
    {
        "source": "initialized later, when write_run_start is called",
        "suggest": "稍后在调用 write_run_start 时初始化",
        "translate": ""
    },
    {
        "source": "we insert a new line every 100 dots in order to flush the screen when dealing with line-buffered output (e.g., piping to `stamp` in the rust CI).",
        "suggest": "我们每隔 100 个点插入一条新行，以便在处理行缓冲输出时冲洗屏幕 (例如，通过管道传递到 rust CI 中的 `stamp`)。",
        "translate": ""
    },
    {
        "source": "Remnants from old libtest code that used the padding value in order to indicate benchmarks.",
        "suggest": "旧 libtest 代码的残余部分，这些代码使用填充值来指示基准。",
        "translate": ""
    },
    {
        "source": "When running benchmarks, terse-mode should still print their name as if it is the Pretty formatter.",
        "suggest": "在运行基准测试时，简洁模式仍应打印其名称，就像它是 Pretty 格式化程序一样。",
        "translate": ""
    },
    {
        "source": "Helper module which helps to determine amount of threads to be used during tests execution.",
        "suggest": "帮助程序模块，它有助于确定测试执行期间要使用的线程数量。",
        "translate": ""
    },
    {
        "source": "Helper module to detect subprocess exit code.",
        "suggest": "帮助程序模块，用于检测子进程退出代码。",
        "translate": ""
    },
    {
        "source": "Helper module which provides a function to test if stdout is a tty.",
        "suggest": "帮助程序模块，它提供一个函数来测试 stdout 是否为 tty。",
        "translate": ""
    },
    {
        "source": "Implement isatty on SGX",
        "suggest": "在新交所实现 isatty",
        "translate": ""
    },
    {
        "source": "Benchmark metrics.",
        "suggest": "基准指标。",
        "translate": ""
    },
    {
        "source": "Insert a named `value` (+/- `noise`) metric into the map.",
        "suggest": "将名为 `value` (+/-`noise`) 的度量标准插入 map。",
        "translate": ""
    },
    {
        "source": "The value must be non-negative.",
        "suggest": "该值必须为非负数。",
        "translate": ""
    },
    {
        "source": "The `noise` indicates the uncertainty of the metric, which doubles as the \"noise range\" of acceptable pairwise-regressions on this named value, when comparing from one metric to the next using `compare_to_old`.",
        "suggest": "`noise` 表示度量的不确定性，当使用 `compare_to_old` 从一个度量与下一个度量进行比较时，该命名值的可接受的成对回归的 \"noise range\" 会增加一倍。",
        "translate": ""
    },
    {
        "source": "If `noise` is positive, then it means this metric is of a value you want to see grow smaller, so a change larger than `noise` in the positive direction represents a regression.",
        "suggest": "如果 `noise` 为正，则表示您希望看到该度量值变小，因此在正方向上大于 `noise` 的更改表示回归。",
        "translate": ""
    },
    {
        "source": "If `noise` is negative, then it means this metric is of a value you want to see grow larger, so a change larger than `noise` in the negative direction represents a regression.",
        "suggest": "如果 `noise` 为负，则表示您希望看到该指标的值变大，因此在负方向上大于 `noise` 的更改表示回归。",
        "translate": ""
    },
    {
        "source": "Module with common helpers not directly related to tests but used in `libtest`.",
        "suggest": "带有普通帮助程序的模块与测试不直接相关，但已在 `libtest` 中使用。",
        "translate": ""
    },
    {
        "source": "Support code for rustc's built in unit-test and micro-benchmarking framework.",
        "suggest": "rustc 的内置单元测试和微基准测试框架的支持代码。",
        "translate": ""
    },
    {
        "source": "Almost all user code will only be interested in `Bencher` and `black_box`.",
        "suggest": "几乎所有用户代码都只对 `Bencher` 和 `black_box` 感兴趣。",
        "translate": ""
    },
    {
        "source": "All other interactions (such as writing tests and benchmarks themselves) should be done via the `#[test]` and `#[bench]` attributes.",
        "suggest": "所有其他交互 (例如编写测试和基准测试本身) 都应通过 `#[test]` 和 `#[bench]` 属性来完成。",
        "translate": ""
    },
    {
        "source": "See the [Testing Chapter](../book/ch11-00-testing.html) of the book for more details.",
        "suggest": "有关更多详细信息，请参见本书的 [测试章节](../book/ch11-00-testing.html)。",
        "translate": ""
    },
    {
        "source": "Currently, not much of this is meant for users.",
        "suggest": "当前，这对于用户而言意义不大。",
        "translate": ""
    },
    {
        "source": "It is intended to support the simplest interface possible for representing and running tests while providing a base that other test frameworks may build off of.",
        "suggest": "它旨在支持可能的最简单接口，以表示和运行测试，同时提供其他测试框架可以建立的基础。",
        "translate": ""
    },
    {
        "source": "N.B., this is also specified in this crate's Cargo.toml, but librustc_ast contains logic specific to this crate, which relies on this attribute (rather than the value of `--crate-name` passed by cargo) to detect this crate.",
        "suggest": "注意，这也在此 crate 的 Cargo.toml 中指定，但是 librustc_ast 包含特定于此 crate 的逻辑，该逻辑依赖于此属性 (而不是 cargo 传递的 `--crate-name` 的值) 来检测此 crate。",
        "translate": ""
    },
    {
        "source": "Public reexports",
        "suggest": "公开重导出",
        "translate": ""
    },
    {
        "source": "Module to be used by rustc to compile tests in libtest",
        "suggest": "rustc 用来在 libtest 中编译测试的模块",
        "translate": ""
    },
    {
        "source": "Process exit code to be used to indicate test failures.",
        "suggest": "用于指示测试失败的进程退出代码。",
        "translate": ""
    },
    {
        "source": "The default console test runner.",
        "suggest": "默认的控制台测试运行程序。",
        "translate": ""
    },
    {
        "source": "It accepts the command line arguments and a vector of test_descs.",
        "suggest": "它接受命令行参数和 test_descs 的 vector。",
        "translate": ""
    },
    {
        "source": "A variant optimized for invocation with a static test vector.",
        "suggest": "为使用静态测试 vector 进行调用而优化的成员。",
        "translate": ""
    },
    {
        "source": "This will panic (intentionally) when fed any dynamic tests.",
        "suggest": "进行任何动态测试时，这将为 panic (intentionally)。",
        "translate": ""
    },
    {
        "source": "This is the entry point for the main function generated by `rustc --test` when panic=unwind.",
        "suggest": "当 panic=unwind 时，这是由 `rustc --test` 生成的主函数的入口点。",
        "translate": ""
    },
    {
        "source": "Runs tests in panic=abort mode, which involves spawning subprocesses for tests.",
        "suggest": "以 panic=abort 模式运行测试，该模式涉及为测试生成子进程。",
        "translate": ""
    },
    {
        "source": "This is the entry point for the main function generated by `rustc --test` when panic=abort.",
        "suggest": "当 panic=abort 时，这是 `rustc --test` 生成的主函数的入口点。",
        "translate": ""
    },
    {
        "source": "If we're being run in SpawnedSecondary mode, run the test here.",
        "suggest": "如果我们以 SpawnedSecondary 模式运行，请在这里运行测试。",
        "translate": ""
    },
    {
        "source": "run_test will then exit the process.",
        "suggest": "然后 run_test 将退出该进程。",
        "translate": ""
    },
    {
        "source": "Clones static values for putting into a dynamic vector, which test_main() needs to hand out ownership of tests to parallel test runners.",
        "suggest": "克隆静态值以放入动态 vector，test_main() 需要将该静态值分发给并行测试运行程序。",
        "translate": ""
    },
    {
        "source": "This will panic when fed any dynamic tests, because they cannot be cloned.",
        "suggest": "进行任何动态测试时，这将为 panic，因为它们无法克隆。",
        "translate": ""
    },
    {
        "source": "Invoked when unit tests terminate.",
        "suggest": "单元测试终止时调用。",
        "translate": ""
    },
    {
        "source": "Should panic if the unit Tests is considered a failure.",
        "suggest": "如果将单元测试视为失败，则应该 panic。",
        "translate": ""
    },
    {
        "source": "By default, invokes `report()` and checks for a `0` result.",
        "suggest": "默认情况下，调用 `report()` 并检查 `0` 结果。",
        "translate": ""
    },
    {
        "source": "Use a deterministic hasher",
        "suggest": "使用确定性哈希",
        "translate": ""
    },
    {
        "source": "here no pad",
        "suggest": "这里没有填充",
        "translate": ""
    },
    {
        "source": "Result is not yet ready, continue waiting.",
        "suggest": "结果尚未准备好，请继续等待。",
        "translate": ""
    },
    {
        "source": "We've got a result, stop the loop.",
        "suggest": "我们得到了结果，请停止循环。",
        "translate": ""
    },
    {
        "source": "All benchmarks run at the end, in serial.",
        "suggest": "所有基准测试最终都以串行方式运行。",
        "translate": ""
    },
    {
        "source": "Remove tests that don't match the test filter",
        "suggest": "删除与测试过滤器不匹配的测试",
        "translate": ""
    },
    {
        "source": "Skip tests that match any of the skip filters",
        "suggest": "与任何跳过过滤器匹配的跳过测试",
        "translate": ""
    },
    {
        "source": "Excludes #[should_panic] tests",
        "suggest": "排除 #[should_panic] 个测试",
        "translate": ""
    },
    {
        "source": "maybe unignore tests",
        "suggest": "也许会忽略测试",
        "translate": ""
    },
    {
        "source": "Sort the tests alphabetically",
        "suggest": "按字母顺序对测试进行排序",
        "translate": ""
    },
    {
        "source": "convert benchmarks to tests, if we're not benchmarking them",
        "suggest": "如果我们不对基准进行基准测试，则将其转换为测试",
        "translate": ""
    },
    {
        "source": "Emscripten can catch panics but other wasm targets cannot",
        "suggest": "Emscripten 可以捕获 panics，但其他 wasm 目标无法捕获",
        "translate": ""
    },
    {
        "source": "If the platform is single-threaded we're just going to run the test synchronously, regardless of the concurrency level.",
        "suggest": "如果平台是单线程的，那么无论并发级别如何，我们都将同步运行测试。",
        "translate": ""
    },
    {
        "source": "means hitting the thread limit on some platforms, so run the test synchronously here instead.",
        "suggest": "表示在某些平台上达到了线程限制，因此请在此处同步运行测试。",
        "translate": ""
    },
    {
        "source": "Benchmarks aren't expected to panic, so we run them all in-process.",
        "suggest": "不应将基准设置为 panic，因此我们会在所有进程中运行它们。",
        "translate": ""
    },
    {
        "source": "Buffer for capturing standard I/O",
        "suggest": "用于捕获标准 I/O 的缓冲区",
        "translate": ""
    },
    {
        "source": "We don't support serializing TrFailedMsg, so just print the message out to stderr.",
        "suggest": "我们不支持序列化 TrFailedMsg，因此只需将消息打印到 stderr 即可。",
        "translate": ""
    },
    {
        "source": "Enums denoting options for test execution.",
        "suggest": "枚举，表示测试执行的选项。",
        "translate": ""
    },
    {
        "source": "Whether to execute tests concurrently or not",
        "suggest": "是否同时执行测试",
        "translate": ""
    },
    {
        "source": "Number of times to run a benchmarked function",
        "suggest": "运行基准函数的次数",
        "translate": ""
    },
    {
        "source": "Whether test is expected to panic or not",
        "suggest": "是否期望对 panic 进行测试",
        "translate": ""
    },
    {
        "source": "Whether should console output be colored or not",
        "suggest": "控制台输出是否应为彩色",
        "translate": ""
    },
    {
        "source": "Format of the test results output",
        "suggest": "测试结果输出格式",
        "translate": ""
    },
    {
        "source": "Verbose output",
        "suggest": "详细输出",
        "translate": ""
    },
    {
        "source": "Quiet output",
        "suggest": "安静的输出",
        "translate": ""
    },
    {
        "source": "JSON output",
        "suggest": "JSON 输出",
        "translate": ""
    },
    {
        "source": "Whether ignored test should be run or not",
        "suggest": "是否应该运行被忽略的测试",
        "translate": ""
    },
    {
        "source": "Run only ignored tests",
        "suggest": "仅运行忽略的测试",
        "translate": ""
    },
    {
        "source": "Runs the test in the current process, and sends the result back over the supplied channel.",
        "suggest": "在当前进程中运行测试，并将结果通过提供的通道发送回去。",
        "translate": ""
    },
    {
        "source": "Spawns a subprocess to run the test, and sends the result back over the supplied channel.",
        "suggest": "产生一个子进程来运行测试，并将结果通过提供的通道发送回去。",
        "translate": ""
    },
    {
        "source": "Requires `argv[0]` to exist and point to the binary that's currently running.",
        "suggest": "需要 `argv[0]` 存在并指向当前正在运行的二进制文件。",
        "translate": ""
    },
    {
        "source": "Options for the test run defined by the caller (instead of CLI arguments).",
        "suggest": "调用方定义的测试运行的选项 (而不是 CLI 参数)。",
        "translate": ""
    },
    {
        "source": "In case we want to add other options as well, just add them in this struct.",
        "suggest": "如果我们还想添加其他选项，只需将其添加到此结构体中即可。",
        "translate": ""
    },
    {
        "source": "Test vectors generated from R, using the script src/etc/stat-test-vectors.r.",
        "suggest": "使用脚本 src/etc/stat-test-vectors.r 测试从 R 生成的 vectors。",
        "translate": ""
    },
    {
        "source": "We needed a few more digits to get exact equality on these but they're within float epsilon, which is 1.0e-6.",
        "suggest": "我们还需要一些数字来获得精确的相等性，但是它们在 float epsilon 之内，即 1.0e-6。",
        "translate": ""
    },
    {
        "source": "Trait that provides simple descriptive statistics on a univariate set of numeric samples.",
        "suggest": "Trait，它提供关于单变量数字样本集的简单描述性统计信息。",
        "translate": ""
    },
    {
        "source": "Sum of the samples.",
        "suggest": "样本的总和。",
        "translate": ""
    },
    {
        "source": "this method sacrifices performance at the altar of accuracy Depends on IEEE-754 arithmetic guarantees.",
        "suggest": "这种方法牺牲了性能的准确性。取决于 IEEE-754 的算法保证。",
        "translate": ""
    },
    {
        "source": "See proof of correctness at:",
        "suggest": "请参见正确性证明:",
        "translate": ""
    },
    {
        "source": "Minimum value of the samples.",
        "suggest": "样品的最小值。",
        "translate": ""
    },
    {
        "source": "Maximum value of the samples.",
        "suggest": "样品的最大值。",
        "translate": ""
    },
    {
        "source": "Arithmetic mean (average) of the samples: sum divided by sample-count.",
        "suggest": "样本的算术平均值 (average): 总和除以样本数。",
        "translate": ""
    },
    {
        "source": "Median of the samples: value separating the lower half of the samples from the higher half.",
        "suggest": "样本中位数: 将样本下半部分与样本上半部分分开的值。",
        "translate": ""
    },
    {
        "source": "Equal to `self.percentile(50.0)`.",
        "suggest": "等于 `self.percentile(50.0)`。",
        "translate": ""
    },
    {
        "source": "Variance of the samples: bias-corrected mean of the squares of the differences of each sample from the sample mean.",
        "suggest": "样本方差: 每个样本与样本均值之差的平方的偏差校正后的平均值。",
        "translate": ""
    },
    {
        "source": "Note that this calculates the _sample variance_ rather than the population variance, which is assumed to be unknown.",
        "suggest": "请注意，这是计算 _sample variance_ 而不是总体方差 (假定该方差是未知的)。",
        "translate": ""
    },
    {
        "source": "It therefore corrects the `(n-1)/n` bias that would appear if we calculated a population variance, by dividing by `(n-1)` rather than `n`.",
        "suggest": "因此，通过除以 `(n-1)` 而不是 `n`，它可以纠正如果我们计算总体方差时出现的 `(n-1)/n` 偏差。",
        "translate": ""
    },
    {
        "source": "Standard deviation: the square root of the sample variance.",
        "suggest": "标准偏差: 样本方差的平方根。",
        "translate": ""
    },
    {
        "source": "this is not a robust statistic for non-normal distributions.",
        "suggest": "对于非正态分布，这不是一个可靠的统计数据。",
        "translate": ""
    },
    {
        "source": "Prefer the `median_abs_dev` for unknown distributions.",
        "suggest": "对于未知的发行版，最好使用 `median_abs_dev`。",
        "translate": ""
    },
    {
        "source": "Standard deviation as a percent of the mean value.",
        "suggest": "标准偏差，以平均值的百分比表示。",
        "translate": ""
    },
    {
        "source": "See `std_dev` and `mean`.",
        "suggest": "请参见 `std_dev` 和 `mean`。",
        "translate": ""
    },
    {
        "source": "Prefer the `median_abs_dev_pct` for unknown distributions.",
        "suggest": "对于未知的发行版，最好使用 `median_abs_dev_pct`。",
        "translate": ""
    },
    {
        "source": "Scaled median of the absolute deviations of each sample from the sample median.",
        "suggest": "每个样本与样本中位数的绝对偏差的标度中位数。",
        "translate": ""
    },
    {
        "source": "This is a robust (distribution-agnostic) estimator of sample variability.",
        "suggest": "这是样本可变性的可靠 (distribution-agnostic) 估计器。",
        "translate": ""
    },
    {
        "source": "Use this in preference to `std_dev` if you cannot assume your sample is normally distributed.",
        "suggest": "如果您不能假定样本是正态分布的，则优先使用 `std_dev`。",
        "translate": ""
    },
    {
        "source": "Note that this is scaled by the constant `1.4826` to allow its use as a consistent estimator for the standard deviation.",
        "suggest": "请注意，常量 `1.4826` 对它进行了缩放，以使其可用作标准偏差的一致估计量。",
        "translate": ""
    },
    {
        "source": "Median absolute deviation as a percent of the median.",
        "suggest": "中位数绝对偏差占中位数的百分比。",
        "translate": ""
    },
    {
        "source": "See `median_abs_dev` and `median`.",
        "suggest": "请参见 `median_abs_dev` 和 `median`。",
        "translate": ""
    },
    {
        "source": "Percentile: the value below which `pct` percent of the values in `self` fall.",
        "suggest": "百分位数: `self` 中的值所占的 `pct` 百分比以下的值。",
        "translate": ""
    },
    {
        "source": "For example, percentile(95.0) will return the value `v` such that 95% of the samples `s` in `self` satisfy `s <= v`.",
        "suggest": "例如，percentile(95.0) 将返回值 `v`，以使 `self` 中 95% 的样本 `s` 满足 `s <= v`。",
        "translate": ""
    },
    {
        "source": "Calculated by linear interpolation between closest ranks.",
        "suggest": "通过最接近等级之间的线性插值计算。",
        "translate": ""
    },
    {
        "source": "Quartiles of the sample: three values that divide the sample into four equal groups, each with 1/4 of the data.",
        "suggest": "样本四分位数: 将样本分为四个相等组的三个值，每个组的数据为 1/4。",
        "translate": ""
    },
    {
        "source": "The middle value is the median.",
        "suggest": "中间值为中间值。",
        "translate": ""
    },
    {
        "source": "See `median` and `percentile`.",
        "suggest": "请参见 `median` 和 `percentile`。",
        "translate": ""
    },
    {
        "source": "This function may calculate the 3 quartiles more efficiently than 3 calls to `percentile`, but is otherwise equivalent.",
        "suggest": "与对 `percentile` 的 3 个调用相比，此函数可以更有效地计算 3 个四分位数，但在其他方面等效。",
        "translate": ""
    },
    {
        "source": "Inter-quartile range: the difference between the 25th percentile (1st quartile) and the 75th percentile (3rd quartile).",
        "suggest": "四分位间距: 第 25 个百分位数 (第 1 个四分位数) 和第 75 个百分位数 (第 3 个四分位数) 之间的差。",
        "translate": ""
    },
    {
        "source": "See `quartiles`.",
        "suggest": "请参见 `quartiles`。",
        "translate": ""
    },
    {
        "source": "Extracted collection of all the summary statistics of a sample set.",
        "suggest": "样本集的所有汇总统计信息的提取集合。",
        "translate": ""
    },
    {
        "source": "Construct a new summary of a sample set.",
        "suggest": "创建一个新的样本集总结。",
        "translate": ""
    },
    {
        "source": "FIXME #11059 handle NaN, inf and overflow",
        "suggest": "FIXME #11059 处理 NaN，inf 和溢出",
        "translate": ""
    },
    {
        "source": "This inner loop applies `hi`/`lo` summation to each partial so that the list of partial sums remains exact.",
        "suggest": "此内部循环将 `hi`/`lo` 总和应用于每个部分，以使部分总和的列表保持准确。",
        "translate": ""
    },
    {
        "source": "Rounded `x+y` is stored in `hi` with round-off stored in `lo`.",
        "suggest": "四舍五入的 `x+y` 存储在 `hi` 中，四舍五入存储在 `lo` 中。",
        "translate": ""
    },
    {
        "source": "Together `hi+lo` are exactly equal to `x+y`.",
        "suggest": "`hi+lo` 等于 `x+y`。",
        "translate": ""
    },
    {
        "source": "N.B., this is _supposed to be_ len-1, not len.",
        "suggest": "注意，这 _应该是 _ len-1，而不是 len。",
        "translate": ""
    },
    {
        "source": "If you change it back to len, you will be calculating a population variance, not a sample variance.",
        "suggest": "如果将其更改回 len，则将计算总体方差，而不是样本方差。",
        "translate": ""
    },
    {
        "source": "This constant is derived by smarter statistics brains than me, but it is consistent with how R and other packages treat the MAD.",
        "suggest": "这个常量是由比我更聪明的统计头脑得出的，但它与 R 和其他软件包对 MAD 的处理方式一致。",
        "translate": ""
    },
    {
        "source": "Helper function: extract a value representing the `pct` percentile of a sorted sample-set, using linear interpolation.",
        "suggest": "Helper 函数: 使用线性插值提取代表排序后的样本集的 `pct` 百分位数的值。",
        "translate": ""
    },
    {
        "source": "If samples are not sorted, return nonsensical value.",
        "suggest": "如果样品未排序，则返回无意义的值。",
        "translate": ""
    },
    {
        "source": "Winsorize a set of samples, replacing values above the `100-pct` percentile and below the `pct` percentile with those percentiles themselves.",
        "suggest": "Winsorize 一组样本，用这些百分数本身替换 `100-pct` 百分数以上和 `pct` 百分数以下的值。",
        "translate": ""
    },
    {
        "source": "This is a way of minimizing the effect of outliers, at the cost of biasing the sample.",
        "suggest": "这是最小化离群值影响的方法，但要以使样本产生偏差为代价。",
        "translate": ""
    },
    {
        "source": "It differs from trimming in that it does not change the number of samples, just changes the values of those that are outliers.",
        "suggest": "它与修整的不同之处在于，它不会更改样本数，而只会更改异常值的值。",
        "translate": ""
    },
    {
        "source": "FIXME (introduced by #65251) ShouldPanic, StaticTestName, TestDesc, TestDescAndFn, TestOpts, TestTimeOptions, TestType, TrFailedMsg, TrIgnored, TrOk,",
        "suggest": "FIXME (由 #65251 引入) ShouldPanic，StaticTestName，TestDesc，TestDescAndFn，TestOpts，TestTimeOptions，TestType，TrFailedMsg，TrIgnored，TrOk，",
        "translate": ""
    },
    {
        "source": "Re-enable emscripten once it can catch panics again (introduced by #65251)",
        "suggest": "一旦可以再次捕获 panics，则重新启用 emscripten (由 #65251 引入)",
        "translate": ""
    },
    {
        "source": "will initialize all the thresholds to 0 milliseconds.",
        "suggest": "将所有阈值初始化为 0 毫秒。",
        "translate": ""
    },
    {
        "source": "Check that for unknown tests thresholds aren't applied.",
        "suggest": "检查是否未应用未知测试阈值。",
        "translate": ""
    },
    {
        "source": "When we run ignored tests the test filter should filter out all the unignored tests and flip the ignore flag on the rest to false",
        "suggest": "当我们运行忽略的测试时，测试过滤器应过滤掉所有未被忽略的测试，并将其余的忽略标志设置为 false",
        "translate": ""
    },
    {
        "source": "When we \"--include-ignored\" tests, the ignore flag should be set to false on all tests and no test filtered out",
        "suggest": "当我们进行 \"--include-ignored\" 测试时，应在所有测试中将 ignore 标志设置为 false，并且不会过滤掉任何测试",
        "translate": ""
    },
    {
        "source": "Return codes for secondary process.",
        "suggest": "二级处理的返回码。",
        "translate": ""
    },
    {
        "source": "Start somewhere other than 0 so we know the return code means what we think it means.",
        "suggest": "从 0 以外的地方开始，所以我们知道返回码意味着我们认为的含义。",
        "translate": ""
    },
    {
        "source": "Creates a `TestResult` depending on the raw result of test execution and associated data.",
        "suggest": "根据测试执行的原始结果和相关数据创建 `TestResult`。",
        "translate": ""
    },
    {
        "source": "If test is already failed (or allowed to fail), do not change the result.",
        "suggest": "如果测试已经失败 (或允许失败)，请不要更改结果。",
        "translate": ""
    },
    {
        "source": "Check if test is failed due to timeout.",
        "suggest": "检查测试是否由于超时而失败。",
        "translate": ""
    },
    {
        "source": "Creates a `TestResult` depending on the exit code of test subprocess.",
        "suggest": "根据测试子进程的退出代码创建 `TestResult`。",
        "translate": ""
    },
    {
        "source": "Module `time` contains everything related to the time measurement of unit tests execution.",
        "suggest": "模块 `time` 包含与单元测试执行的时间度量有关的所有内容。",
        "translate": ""
    },
    {
        "source": "The purposes of this module:",
        "suggest": "该模块的目的:",
        "translate": ""
    },
    {
        "source": "Check whether test is timed out.",
        "suggest": "检查测试是否超时。",
        "translate": ""
    },
    {
        "source": "Provide helpers for `report-time` and `measure-time` options.",
        "suggest": "为 `report-time` 和 `measure-time` 选项提供帮助。",
        "translate": ""
    },
    {
        "source": "Provide newtypes for executions times.",
        "suggest": "提供执行时间的新类型。",
        "translate": ""
    },
    {
        "source": "This small module contains constants used by `report-time` option.",
        "suggest": "这个小模块包含 `report-time` 选项使用的常量。",
        "translate": ""
    },
    {
        "source": "Those constants values will be used if corresponding environment variables are not set.",
        "suggest": "如果未设置相应的环境变量，则将使用这些常量值。",
        "translate": ""
    },
    {
        "source": "To override values for unit-tests, use a constant `RUST_TEST_TIME_UNIT`, To override values for integration tests, use a constant `RUST_TEST_TIME_INTEGRATION`, To override values for doctests, use a constant `RUST_TEST_TIME_DOCTEST`.",
        "suggest": "要覆盖单元测试的值，请使用常量 `RUST_TEST_TIME_UNIT`; 要覆盖集成测试的值，请使用常量 `RUST_TEST_TIME_INTEGRATION`; 要覆盖 doctests 的值，请使用常量 `RUST_TEST_TIME_DOCTEST`。",
        "translate": ""
    },
    {
        "source": "Example of the expected format is `RUST_TEST_TIME_xxx=100,200`, where 100 means warn time, and 200 means critical time.",
        "suggest": "预期格式的示例是 `RUST_TEST_TIME_xxx=100,200`，其中 100 表示警告时间，而 200 表示临界时间。",
        "translate": ""
    },
    {
        "source": "Environment variable for overriding default threshold for unit-tests.",
        "suggest": "用于覆盖单元测试的默认阈值的环境变量。",
        "translate": ""
    },
    {
        "source": "Unit tests are supposed to be really quick.",
        "suggest": "单元测试应该是非常快速的。",
        "translate": ""
    },
    {
        "source": "Integration tests may have a lot of work, so they can take longer to execute.",
        "suggest": "集成测试可能有很多工作要做，因此它们可能需要更长的时间才能执行。",
        "translate": ""
    },
    {
        "source": "Doctests are similar to integration tests, because they can include a lot of initialization code.",
        "suggest": "Doctests 与集成测试相似，因为它们可以包含很多初始化代码。",
        "translate": ""
    },
    {
        "source": "Do not suppose anything about unknown tests, base limits on the `TEST_WARN_TIMEOUT_S` constant.",
        "suggest": "不要对未知测试有任何猜想，它是 `TEST_WARN_TIMEOUT_S` 常量的基础限制。",
        "translate": ""
    },
    {
        "source": "Returns an `Instance` object denoting when the test should be considered timed out.",
        "suggest": "返回一个 `Instance` 对象，该对象指示何时应将测试视为超时。",
        "translate": ""
    },
    {
        "source": "The measured execution time of a unit test.",
        "suggest": "单元测试的测量执行时间。",
        "translate": ""
    },
    {
        "source": "The measured execution time of the whole test suite.",
        "suggest": "整个测试套件的测量执行时间。",
        "translate": ""
    },
    {
        "source": "Structure denoting time limits for test execution.",
        "suggest": "表示测试执行时间限制的结构体。",
        "translate": ""
    },
    {
        "source": "Creates a new `TimeThreshold` instance with provided durations.",
        "suggest": "使用提供的持续时间创建一个新的 `TimeThreshold` 实例。",
        "translate": ""
    },
    {
        "source": "Attempts to create a `TimeThreshold` instance with values obtained from the environment variable, and returns `None` if the variable is not set.",
        "suggest": "尝试使用从环境变量获取的值创建 `TimeThreshold` 实例，如果未设置该变量，则返回 `None`。",
        "translate": ""
    },
    {
        "source": "Environment variable format is expected to match `\\d+,\\d+`.",
        "suggest": "环境变量格式应与 `\\d+,\\d+` 匹配。",
        "translate": ""
    },
    {
        "source": "Panics if variable with provided name is set but contains inappropriate value.",
        "suggest": "Panics (如果设置了提供名称的变量，但包含不适当的值)。",
        "translate": ""
    },
    {
        "source": "Structure with parameters for calculating test execution time.",
        "suggest": "具有用于计算测试执行时间的参数的结构体。",
        "translate": ""
    },
    {
        "source": "Denotes if the test critical execution time limit excess should be considered a test failure.",
        "suggest": "表示是否将超出测试关键执行时间限制视为测试失败。",
        "translate": ""
    },
    {
        "source": "Common types used by `libtest`.",
        "suggest": "`libtest` 使用的常见类型。",
        "translate": ""
    },
    {
        "source": "Type of the test according to the [rust book](https://doc.rust-lang.org/cargo/guide/tests.html) conventions.",
        "suggest": "根据 [rust 书](https://doc.rust-lang.org/cargo/guide/tests.html) 约定的测试类型。",
        "translate": ""
    },
    {
        "source": "Unit-tests are expected to be in the `src` folder of the crate.",
        "suggest": "单元测试应位于 crate 的 `src` 文件夹中。",
        "translate": ""
    },
    {
        "source": "Integration-style tests are expected to be in the `tests` folder of the crate.",
        "suggest": "集成样式的测试应该位于 crate 的 `tests` 文件夹中。",
        "translate": ""
    },
    {
        "source": "Doctests are created by the `librustdoc` manually, so it's a different type of test.",
        "suggest": "Doctests 是由 `librustdoc` 手动创建的，因此它是另一种类型的测试。",
        "translate": ""
    },
    {
        "source": "Tests for the sources that don't follow the project layout convention (e.g.",
        "suggest": "测试不遵循项目布局约定的源 (例如，",
        "translate": ""
    },
    {
        "source": "tests in raw `main.rs` compiled by calling `rustc --test` directly).",
        "suggest": "在直接调用 `rustc --test` 编译的原始 `main.rs` 中进行测试)。",
        "translate": ""
    },
    {
        "source": "The name of a test.",
        "suggest": "测试的名称。",
        "translate": ""
    },
    {
        "source": "By convention this follows the rules for rust paths;",
        "suggest": "按照惯例，这遵循 rust 路径的规则;",
        "translate": ""
    },
    {
        "source": "i.e., it should be a series of identifiers separated by double colons.",
        "suggest": "即，它应该是由双冒号分隔的一系列标识符。",
        "translate": ""
    },
    {
        "source": "This way if some test runner wants to arrange the tests hierarchically it may.",
        "suggest": "这样，如果某些测试跑步者想要按层次排列测试，则可以。",
        "translate": ""
    },
    {
        "source": "Represents a benchmark function.",
        "suggest": "表示一个基准函数。",
        "translate": ""
    },
    {
        "source": "A function that runs a test.",
        "suggest": "运行测试的函数。",
        "translate": ""
    },
    {
        "source": "If the function returns successfully, the test succeeds;",
        "suggest": "如果函数成功返回，则测试成功; 否则，函数将失败。",
        "translate": ""
    },
    {
        "source": "if the function panics then the test fails.",
        "suggest": "如果函数 panics，则测试失败。",
        "translate": ""
    },
    {
        "source": "We may need to come up with a more clever definition of test in order to support isolation of tests into threads.",
        "suggest": "为了支持将测试隔离到线程中，我们可能需要提出一个更聪明的测试定义。",
        "translate": ""
    },
    {
        "source": "The definition of a single test.",
        "suggest": "单个测试的定义。",
        "translate": ""
    },
    {
        "source": "A test runner will run a list of these.",
        "suggest": "测试运行器将运行这些列表。",
        "translate": ""
    },
    {
        "source": "Build the unwinding from libunwind C/C++ source code.",
        "suggest": "从 libunwind C/C++ 源代码构建展开。",
        "translate": ""
    },
    {
        "source": "linking for Linux is handled in lib.rs",
        "suggest": "lib.rs 的链接在 lib.rs 中处理",
        "translate": ""
    },
    {
        "source": "This is handled in the target spec with late_link_args_[static|dynamic]",
        "suggest": "这是在目标规范中使用 late_link_args_[static|dynamic] 处理的",
        "translate": ""
    },
    {
        "source": "is handled in lib.rs",
        "suggest": "在 lib.rs 中处理",
        "translate": ""
    },
    {
        "source": "Compile the libunwind C/C++ source code.",
        "suggest": "编译 libunwind C/C++ 源代码。",
        "translate": ""
    },
    {
        "source": "libunwind expects a __LITTLE_ENDIAN__ macro to be set for LE archs, cf.",
        "suggest": "libunwind 期望为 LE 拱设置 __LITTLE_ENDIAN__ 宏，请参见。",
        "translate": ""
    },
    {
        "source": "easiest way to undefine since no API available in cc::Build to undefine",
        "suggest": "取消定义的最简单方法，因为 cc::Build 中没有可用的 API 来取消定义",
        "translate": ""
    },
    {
        "source": "use the same C compiler command to compile C++ code so we do not need to setup the C++ compiler env variables on the builders",
        "suggest": "使用相同的 C 编译器命令来编译 C++ 代码，因此我们不需要在构建器上设置 C++ 编译器 env 变量",
        "translate": ""
    },
    {
        "source": "linking for musl is handled in lib.rs",
        "suggest": "musl 的链接在 lib.rs 中处理",
        "translate": ""
    },
    {
        "source": "MSVC no extra unwinder support needed",
        "suggest": "MSVC 不需要额外的展开器支持",
        "translate": ""
    },
    {
        "source": "These \"unix\" family members do not have unwinder.",
        "suggest": "这些 \"unix\" 系列成员没有退绕机。",
        "translate": ""
    },
    {
        "source": "Note this also matches x86_64-unknown-none-linuxkernel.",
        "suggest": "请注意，这也与 x86_64-unknown-none-linuxkernel 匹配。",
        "translate": ""
    },
    {
        "source": "no unwinder on the system!",
        "suggest": "系统上没有 unwinder!",
        "translate": ""
    },
    {
        "source": "(not emscripten, which is \"unix\" family)",
        "suggest": "(不是 emscripten，这是 \"unix\" 系列)",
        "translate": ""
    },
    {
        "source": "Any new targets not listed above.",
        "suggest": "上面未列出的任何新目标。",
        "translate": ""
    },
    {
        "source": "When building with crt-static, we get `gcc_eh` from the `libc` crate, since glibc needs it, and needs it listed later on the linker command line.",
        "suggest": "当使用 crt-static 构建时，我们从 `libc` crate 获得 `gcc_eh`，因为 glibc 需要它，并且需要它稍后在链接器命令行中列出。",
        "translate": ""
    },
    {
        "source": "We don't want to duplicate it here.",
        "suggest": "我们不想在这里重复。",
        "translate": ""
    },
    {
        "source": "used only by ARM EHABI",
        "suggest": "仅由 ARM EHABI 使用",
        "translate": ""
    },
    {
        "source": "Not ARM EHABI",
        "suggest": "不是 ARM EHABI",
        "translate": ""
    },
    {
        "source": "On Android or ARM/Linux, these are implemented as macros:",
        "suggest": "在 Android 或 ARM/Linux 上，这些被实现为宏:",
        "translate": ""
    },
    {
        "source": "Propagate thumb bit to instruction pointer",
        "suggest": "将拇指位传播到指令指针",
        "translate": ""
    },
    {
        "source": "This function also doesn't exist on Android or ARM/Linux, so make it a no-op",
        "suggest": "Android 或 ARM/Linux 上也不存在此函数，因此请使其成为 no-op",
        "translate": ""
    },
    {
        "source": "Not 32-bit iOS",
        "suggest": "不是 32 位 iOS",
        "translate": ""
    },
    {
        "source": "32-bit iOS uses SjLj and does not provide _Unwind_Backtrace()",
        "suggest": "32 位 iOS 使用 SjLj，但不提供 _Unwind_Backtrace()",
        "translate": ""
    },
    {
        "source": "We declare these as opaque types.",
        "suggest": "我们将它们声明为不透明类型。",
        "translate": ""
    },
    {
        "source": "This is fine since you just need to pass them to _GCC_specific_handler and forget about them.",
        "suggest": "这很好，因为您只需要将它们传递给 _GCC_specific_handler 并忽略它们即可。",
        "translate": ""
    },
    {
        "source": "no ZSTs as there would be no allocation to reuse and pointer arithmetic would panic b) size match as required by Alloc contract c) alignments match as required by Alloc contract",
        "suggest": "没有 ZST，因为没有分配可重用，指针算法将 panic b) 根据 Alloc 合同的要求进行大小匹配 c) 根据 Alloc 合同的要求进行对齐匹配",
        "translate": ""
    },
    {
        "source": "is unable to symbolize within a process so it has a special format which can be used to symbolize later.",
        "suggest": "无法在进程中进行符号化，因此它具有可用于稍后符号化的特殊格式。",
        "translate": ""
    },
    {
        "source": "Generators cannot implement `for<'a, 'b> Generator<&'a mut Context<'b>>`, so we need to pass a raw pointer (see <https://github.com/rust-lang/rust/issues/68923>).",
        "suggest": "Generators 不能实现 `for<'a, 'b> Generator<&'a mut Context<'b>>`，所以我们需要传递一个裸体路径 (见 <https://github.com/rust-lang/rust/issues/68923>)。",
        "translate": ""
    },
    {
        "source": "Raw pointers and `NonNull` aren't `Send` or `Sync`, so that would make every single future non-Send/Sync as well, and we don't want that.",
        "suggest": "裸指针和 `NonNull` 不是 `Send` 或 `Sync`，因此每个 future non-Send/Sync 也是如此，我们不想要那样。",
        "translate": ""
    },
    {
        "source": "Memory copying",
        "suggest": "内存复制",
        "translate": ""
    },
    {
        "source": "ignores SO_SNDTIMEO.",
        "suggest": "忽略 SO_SNDTIMEO。",
        "translate": ""
    },
    {
        "source": "Redox, and old versions of Android lack `linkat`, so use `link` instead.",
        "suggest": "Redox 和旧版本的 Android 缺少 `linkat`，所以改用 `link`。",
        "translate": ""
    },
    {
        "source": "leaves it implementation-defined whether `link` follows symlinks, so rely on the `symlink_hard_link` test in library/std/src/fs/tests.rs to check the behavior.",
        "suggest": "让它实现定义 `link` 是否遵循符号链接，所以依靠 library/std/src/fs/tests.rs 中的 `symlink_hard_link` 测试来检查行为。",
        "translate": ""
    },
    {
        "source": "doesn't have /dev/null",
        "suggest": "不能有 /dev/null",
        "translate": ""
    },
    {
        "source": "has no fundamental capability to do this.",
        "suggest": "没有做到这一点的基本能力。",
        "translate": ""
    },
    {
        "source": "MAX_PATH 260",
        "suggest": "最大路径 260",
        "translate": ""
    },
    {
        "source": "allows the key created here to be 0, but the compare_exchange below relies on using 0 as a sentinel value to check who won the race to set the shared TLS key.",
        "suggest": "允许此处创建的密钥为 0，但下面的 compare_exchange 依赖于使用 0 作为标记值来检查谁赢得了设置共享 TLS 密钥的竞赛。",
        "translate": ""
    },
    {
        "source": "Vector Pack Even",
        "suggest": "Vector 包 Even",
        "translate": ""
    },
    {
        "source": "[Intel 64 and IA-32 Architectures Software Developer's Manual Volume 2:",
        "suggest": "[英特尔 64 位和 IA-32 架构软件开发人员手册第 2 卷:",
        "translate": ""
    },
    {
        "source": "intrinsic code generator",
        "suggest": "内在的代码生成器",
        "translate": ""
    },
    {
        "source": "insertion finished at leaf while there is an empty node on the second level.",
        "suggest": "插入在叶子完成，而第二层有一个空节点。",
        "translate": ""
    },
    {
        "source": "- after four only swaps we've finished",
        "suggest": "- 经过四次交换，我们已经完成了",
        "translate": ""
    },
    {
        "source": "A [`Weak`] pointer can be [`upgrade`][upgrade]d to an `Arc`, but this will return [`None`] if the value stored in the allocation has already been dropped.",
        "suggest": "[`Weak`] 指针可以 [`upgrade`][upgrade] 为 `Arc`，但如果存储在分配中的值已经被丢弃，这将返回 [`None`]。",
        "translate": ""
    },
    {
        "source": "however, they *do* keep the allocation (the backing store for the value) alive.",
        "suggest": "然而，他们确实保持分配 (值的后备存储) 处于活动状态。",
        "translate": ""
    },
    {
        "source": "For example, a tree could have strong `Arc` pointers from parent nodes to children, and [`Weak`] pointers from children back to their parents.",
        "suggest": "例如，一棵树可能具有从父节点到子节点的强 `Arc` 指针，以及从子节点返回到其父节点的 [`Weak`] 指针。",
        "translate": ""
    },
    {
        "source": "Forget the guard so it doesn't free the new ArcInner.",
        "suggest": "忘记守卫，这样它就不会释放新的 ArcInner。",
        "translate": ""
    },
    {
        "source": "For example it is **not** safe to build a `Vec<u8>` from a pointer to a C `char` array with length `size_t`.",
        "suggest": "例如，从指向长度为 `size_t` 的 C `char` 数组的指针构建 `Vec<u8>` 是 ** 不安全的。",
        "translate": ""
    },
    {
        "source": "doesn't cause spurious unused-unsafe warnings when it's inside of an outer unsafe block",
        "suggest": "当它位于外部不安全块内时，不会导致虚假的未使用不安全警告",
        "translate": ""
    },
    {
        "source": "The exact contents and format of the string are not specified, other than being a best-effort description of the type.",
        "suggest": "没有指定字符串的确切内容和格式，只是对类型的尽力描述。",
        "translate": ""
    },
    {
        "source": "If the iterator yields fewer than `N` items, `None` is returned and all already yielded items are dropped.",
        "suggest": "如果迭代器产生的结果少于 `N` 项，则返回 `None` 并丢弃所有已经产生的项。",
        "translate": ""
    },
    {
        "source": "When `derive`d on structs, it will produce a lexicographic ordering based on the top-to-bottom declaration order of the struct's members.",
        "suggest": "当在结构体上进行 `derive`d 时，它将根据结构体成员的自上而下的声明顺序生成字典顺序。",
        "translate": ""
    },
    {
        "source": "If the conversion can fail, use [`TryInto`].",
        "suggest": "如果转换失败，请使用 [`TryInto`]。",
        "translate": ""
    },
    {
        "source": "If the conversion can fail, use [`TryFrom`].",
        "suggest": "如果转换失败，请使用 [`TryFrom`]。",
        "translate": ""
    },
    {
        "source": "Rounds half-way cases away from zero.",
        "suggest": "将中途案例从零舍入。",
        "translate": ""
    },
    {
        "source": "It will call this closure on each element of the iterator, and yield elements while it returns `true`.",
        "suggest": "它将在迭代器的每个元素上调用此闭包，并在返回 `true` 时产生 yield 元素。",
        "translate": ""
    },
    {
        "source": "If applying the closure succeeded against every element of the iterator, `try_fold()` returns the final accumulator as success.",
        "suggest": "如果对迭代器的每个元素应用闭包成功，`try_fold()` 返回最终的累加器作为成功。",
        "translate": ""
    },
    {
        "source": "It applies this closure to each element of the iterator, and if they all return `true`, then so does `all()`.",
        "suggest": "它将这个闭包应用于迭代器的每个元素，如果它们都返回 `true`，那么 `all()` 也返回。",
        "translate": ""
    },
    {
        "source": "in other words, it will stop processing as soon as it finds a `false`, given that no matter what else happens, the result will also be `false`.",
        "suggest": "换句话说，它一旦找到 `false` 就会停止处理，因为无论发生什么，结果也将是 `false`。",
        "translate": ""
    },
    {
        "source": "It applies this closure to each element of the iterator, and if any of them return `true`, then so does `any()`.",
        "suggest": "它将这个闭包应用于迭代器的每个元素，如果它们中的任何一个返回 `true`，那么 `any()` 也是如此。",
        "translate": ""
    },
    {
        "source": "in other words, it will stop processing as soon as it finds a `true`, given that no matter what else happens, the result will also be `true`.",
        "suggest": "换句话说，它一旦找到 `true` 就会停止处理，因为无论发生什么，结果也将是 `true`。",
        "translate": ""
    },
    {
        "source": "in other words, it will stop processing as soon as it finds a `true`.",
        "suggest": "换句话说，它会在找到 `true` 后立即停止处理。",
        "translate": ""
    },
    {
        "source": "However, when `T` *has* no statically-known size, e.g., a slice [`[T]`][slice] or a [trait object], then `size_of_val_raw` can be used to get the dynamically-known size.",
        "suggest": "然而，当 `T`*没有* 静态大小时，例如，[`[T]`][slice] 或 [trait object]，那么 `size_of_val_raw` 可用于获取动态已知大小。",
        "translate": ""
    },
    {
        "source": "the output is between `0` and `other * (2^nbits - 1)`.",
        "suggest": "输出在 `0` 和 `other * (2^nbits - 1)` 之间。",
        "translate": ""
    },
    {
        "source": "(represented by rem)",
        "suggest": "(以 rem 为代表)",
        "translate": ""
    },
    {
        "source": "Subnormals are 0x000m...m where m is the mantissa.",
        "suggest": "次正规是 0x000m...m，其中 m 是尾数。",
        "translate": ""
    },
    {
        "source": "now `scale / 10 < mant <= scale * 10`.",
        "suggest": "现在 `scale / 10 < mant <= scale * 10`。",
        "translate": ""
    },
    {
        "source": "45, 6 (June 2010), 233-243.",
        "suggest": "45, 6 (2010 年 6 月)，233-243。",
        "translate": ""
    },
    {
        "source": "Computes `self / rhs`.",
        "suggest": "计算 `self / rhs`。",
        "translate": ""
    },
    {
        "source": "Computes `self.div_euclid(rhs)`.",
        "suggest": "计算 `self.div_euclid(rhs)`。",
        "translate": ""
    },
    {
        "source": "Computes `self % rhs`.",
        "suggest": "计算 `self % rhs`。",
        "translate": ""
    },
    {
        "source": "Failure during dereferencing can be extremely confusing when `DerefMut` is invoked implicitly.",
        "suggest": "当隐式调用 `DerefMut` 时，解引用过程中的失败可能会非常令人困惑。",
        "translate": ""
    },
    {
        "source": "That is, the infinite-precision sum must fit in a `usize`.",
        "suggest": "也就是说，无限精度和必须适合 `usize`。",
        "translate": ""
    },
    {
        "source": "That is, the infinite-precision sum must fit in a usize.",
        "suggest": "也就是说，无限精度的总和必须适合使用大小。",
        "translate": ""
    },
    {
        "source": "Use [`read_unaligned`] if this is not the case.",
        "suggest": "如果不是这种情况，请使用 [`read_unaligned`]。",
        "translate": ""
    },
    {
        "source": "Use [`write_unaligned`] if this is not the case.",
        "suggest": "如果不是这种情况，请使用 [`write_unaligned`]。",
        "translate": ""
    },
    {
        "source": "`pre_dec_end` does the right thing even for ZSTs.",
        "suggest": "`pre_dec_end` 甚至对 ZST 来说也做对了。",
        "translate": ""
    },
    {
        "source": "The caller has to ensure that `0 <= mid <= self.len()`.",
        "suggest": "调用者必须确保 `0 <= mid <= self.len()`.",
        "translate": ""
    },
    {
        "source": "If the slice yields exactly zero or one element, `true` is returned.",
        "suggest": "如果三个元素正好产生零个或一个元素，则返回 `true`。",
        "translate": ""
    },
    {
        "source": "See [below](#incorrect-usage) for an example incorrectly not taking this into account.",
        "suggest": "请参见 [below](#incorrect-usage) 以获取错误地未考虑到这一点的示例。",
        "translate": ""
    },
    {
        "source": "Do nothing.",
        "suggest": "没做什么。",
        "translate": ""
    },
    {
        "source": "For a safe alternative see [`str`] and [`IndexMut`].",
        "suggest": "有关安全的替代方案，请参见 [`str`] 和 [`IndexMut`]。",
        "translate": ""
    },
    {
        "source": "for a language like Arabic or Hebrew which are 'right to left' rather than 'left to right', this will be the _right_ side, not the left.",
        "suggest": "对于像阿拉伯语或希伯来语这样从右到左而不是从左到右的语言，这将是右侧，而不是左侧。",
        "translate": ""
    },
    {
        "source": "for a language like Arabic or Hebrew which are 'right to left' rather than 'left to right', this will be the _left_ side, not the right.",
        "suggest": "对于像阿拉伯语或希伯来语这样从右到左而不是从左到右的语言，这将是左侧，而不是右侧。",
        "translate": ""
    },
    {
        "source": "Let's dig into streams.",
        "suggest": "让我们深入研究流。",
        "translate": ""
    },
    {
        "source": "All ordering modes are possible.",
        "suggest": "所有排序模式都是可能的。",
        "translate": ""
    },
    {
        "source": "These correspond to the success and failure orderings of",
        "suggest": "这些对应于成功和失败的顺序",
        "translate": ""
    },
    {
        "source": "It needs to be paired with the [`fill_buf`] method to function properly.",
        "suggest": "需要配合 [`fill_buf`] 方法才能正常使用。",
        "translate": ""
    },
    {
        "source": "In this example, we use [`Cursor`] to read all the lines in a byte slice:",
        "suggest": "在这个例子中，我们使用 [`Cursor`] 读取一个字节中的所有行:",
        "translate": ""
    },
    {
        "source": "The `connect` method will connect this socket to a remote address.",
        "suggest": "`connect` 方法会将此套接字连接到远程地址。",
        "translate": ""
    },
    {
        "source": "components are normalized away, except at",
        "suggest": "组件被标准化掉，除了在",
        "translate": ""
    },
    {
        "source": "For indices outside of the range the resulting lane is 0.",
        "suggest": "对于越界的索引，结果 lane 是 0。",
        "translate": ""
    },
    {
        "source": "- [AMD64 Architecture Programmer's Manual, Volume 3: General-Purpose and System Instructions][amd64_ref].",
        "suggest": "- [AMD64 架构程序员手册，第 3 卷：通用和系统说明][amd64_ref]。",
        "translate": ""
    },
    {
        "source": "signedness does not make sense for them, but __mXXXi happens to be defined in terms of signed integers.",
        "suggest": "符号性对它们没有意义，但 __mXXXi 恰好是根据有符号整数定义的。",
        "translate": ""
    },
    {
        "source": "Truncate each intermediate integer to the 18 most significant bits, round by adding 1, and store bits \\[16:1\\] to dst using writemask k (elements are copied from src when the corresponding mask bit is not set).",
        "suggest": "将每个中间整数截断为 18 个最高有效位，通过加 1 舍入，并使用 writemask k 将位 \\[16:1\\] 存储到 dst (当相应的掩码位未设置时，从 src 复制元素)。",
        "translate": ""
    },
    {
        "source": "Truncate each intermediate integer to the 18 most significant bits, round by adding 1, and store bits \\[16:1\\] to dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).",
        "suggest": "将每个中间整数截断为 18 个最高有效位，通过加 1 舍入，并使用 zeromask k 将位 \\[16:1\\] 存储到 dst (当相应的掩码位未设置时，元素被清零)。",
        "translate": ""
    },
    {
        "source": "Horizontally add adjacent pairs of intermediate 32-bit integers, and pack the results in dst.",
        "suggest": "将相邻的 32 位中间整数对水平相加，并将结果打包到 dst 中。",
        "translate": ""
    },
    {
        "source": "Horizontally add adjacent pairs of intermediate 32-bit integers, and pack the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).",
        "suggest": "水平添加相邻的中间 32 位整数对，并使用 writemask k 将结果打包到 dst (当相应的掩码位未设置时，从 src 复制元素)。",
        "translate": ""
    },
    {
        "source": "Horizontally add adjacent pairs of intermediate 32-bit integers, and pack the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).",
        "suggest": "水平添加相邻的中间 32 位整数对，并使用 zeromask k 将结果打包到 dst (当相应的掩码位未设置时，元素被清零)。",
        "translate": ""
    },
    {
        "source": "Horizontally add adjacent pairs of intermediate signed 16-bit integers, and pack the saturated results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).",
        "suggest": "水平添加相邻的中间有符号 16 位整数对，并使用 zeromask k 将饱和结果打包到 dst 中 (当相应的掩码位未设置时，元素被清零)。",
        "translate": ""
    },
    {
        "source": "Store the results in the low 64 bits of 128-bit lanes of dst, with the high 64 bits of 128-bit lanes being copied from from a to dst, using writemask k (elements are copied from src when the corresponding mask bit is not set).",
        "suggest": "将结果存储在 dst 的 128 位通道的低 64 位中，并使用写掩码 k 将 128 位通道的高 64 位从 a 复制到 dst (当未使用相应的掩码位时，元素从 src 复制) 放)。",
        "translate": ""
    },
    {
        "source": "Store the results in the low 64 bits of 128-bit lanes of dst, with the high 64 bits of 128-bit lanes being copied from from a to dst, using zeromask k (elements are zeroed out when the corresponding mask bit is not set).",
        "suggest": "将结果存储在 dst 的 128 位通道的低 64 位中，128 位通道的高 64 位从 a 复制到 dst，使用 zeromask k (当相应的掩码位未设置时，元素被清零)。",
        "translate": ""
    },
    {
        "source": "Store the results in the high 64 bits of 128-bit lanes of dst, with the low 64 bits of 128-bit lanes being copied from from a to dst, using writemask k (elements are copied from src when the corresponding mask bit is not set).",
        "suggest": "将结果存储在 dst 的 128 位通道的高 64 位中，将 128 位通道的低 64 位从 a 复制到 dst，使用写掩码 k (当相应的掩码位不存在时，元素从 src 复制放)。",
        "translate": ""
    },
    {
        "source": "Store the results in the high 64 bits of 128-bit lanes of dst, with the low 64 bits of 128-bit lanes being copied from from a to dst, using zeromask k (elements are zeroed out when the corresponding mask bit is not set).",
        "suggest": "将结果存储在 dst 的 128 位通道的高 64 位中，将 128 位通道的低 64 位从 a 复制到 dst，使用 zeromask k (当相应的掩码位未设置时，元素被清零)。",
        "translate": ""
    },
    {
        "source": "For each bit in each packed 32-bit integer, the corresponding bit from src, a, and b are used to form a 3 bit index into imm8, and the value at that bit in imm8 is written to the corresponding bit in dst using writemask k at 32-bit granularity (32-bit elements are copied from src when the corresponding mask bit is not set).",
        "suggest": "对于每个打包的 32 位整数中的每一位，使用 src、a 和 b 中的相应位形成 imm8 的 3 位索引，并使用 writemask 将 imm8 中该位的值写入 dst 中的相应位 k 在 32 位粒度 (当相应的掩码位未设置时，从 src 复制 32 位元素)。",
        "translate": ""
    },
    {
        "source": "For each bit in each packed 32-bit integer, the corresponding bit from a, b, and c are used to form a 3 bit index into imm8, and the value at that bit in imm8 is written to the corresponding bit in dst using zeromask k at 32-bit granularity (32-bit elements are zeroed out when the corresponding mask bit is not set).",
        "suggest": "对于每个打包的 32 位整数中的每一位，来自 a、b 和 c 的相应位用于形成 imm8 的 3 位索引，并使用零掩码将 imm8 中该位的值写入 dst 中的相应位 k 在 32 位粒度 (当未设置相应的掩码位时，32 位元素被清零)。",
        "translate": ""
    },
    {
        "source": "For each bit in each packed 64-bit integer, the corresponding bit from a, b, and c are used to form a 3 bit index into imm8, and the value at that bit in imm8 is written to the corresponding bit in dst.",
        "suggest": "对于每个打包的 64 位整数中的每一位，a、b 和 c 中的相应位用于形成 imm8 中的 3 位索引，并将 imm8 中该位的值写入 dst 中的相应位。",
        "translate": ""
    },
    {
        "source": "For each bit in each packed 64-bit integer, the corresponding bit from src, a, and b are used to form a 3 bit index into imm8, and the value at that bit in imm8 is written to the corresponding bit in dst using writemask k at 64-bit granularity (64-bit elements are copied from src when the corresponding mask bit is not set).",
        "suggest": "对于每个打包的 64 位整数中的每一位，src、a 和 b 中的相应位用于形成 imm8 的 3 位索引，并使用 writemask 将 imm8 中该位的值写入 dst 中的相应位 k 在 64 位粒度 (当相应的掩码位未设置时，从 src 复制 64 位元素)。",
        "translate": ""
    },
    {
        "source": "For each bit in each packed 64-bit integer, the corresponding bit from a, b, and c are used to form a 3 bit index into imm8, and the value at that bit in imm8 is written to the corresponding bit in dst using zeromask k at 64-bit granularity (64-bit elements are zeroed out when the corresponding mask bit is not set).",
        "suggest": "对于每个打包的 64 位整数中的每一位，来自 a、b 和 c 的相应位用于在 imm8 中形成 3 位索引，并使用零掩码将 imm8 中该位的值写入 dst 中的相应位 k 在 64 位粒度 (当未设置相应的掩码位时，64 位元素将被清零)。",
        "translate": ""
    },
    {
        "source": "clang generates fmadd, gcc generates fmsub",
        "suggest": "clang 生成 fmadd，gcc 生成 fmsub",
        "translate": ""
    },
    {
        "source": "Gathered elements are merged into dst using writemask k (elements are copied from src when the corresponding mask bit is not set).",
        "suggest": "使用 writemask k 将收集到的元素合并到 dst (当相应的掩码位未设置时，从 src 复制元素)。",
        "translate": ""
    },
    {
        "source": "64-bit elements are stored at addresses starting at base_addr and offset by each 32-bit element in vindex (each index is scaled by the factor in scale) subject to mask k (elements are not stored when the corresponding mask bit is not set).",
        "suggest": "64 位元素存储在从 base_addr 开始的地址中，并由 vindex 中的每个 32 位元素偏移 (每个索引按比例因子缩放) 受掩码 k (未设置相应掩码位时不存储元素) .",
        "translate": ""
    },
    {
        "source": "64-bit elements are stored at addresses starting at base_addr and offset by each 64-bit element in vindex (each index is scaled by the factor in scale) subject to mask k (elements are not stored when the corresponding mask bit is not set).",
        "suggest": "64 位元素存储在从 base_addr 开始的地址处，并由 vindex 中的每个 64 位元素偏移 (每个索引按比例因子缩放) 受掩码 k (当相应掩码位未设置时不存储元素) .",
        "translate": ""
    },
    {
        "source": "32-bit elements are stored at addresses starting at base_addr and offset by each 32-bit element in vindex (each index is scaled by the factor in scale) subject to mask k (elements are not stored when the corresponding mask bit is not set).",
        "suggest": "32 位元素存储在从 base_addr 开始的地址处，并由 vindex 中的每个 32 位元素偏移 (每个索引按比例因子缩放) 受掩码 k (当相应掩码位未设置时不存储元素) .",
        "translate": ""
    },
    {
        "source": "This intrinsic is identical to _mm512_mask_permutexvar_epi32, and it is recommended that you use that intrinsic name.",
        "suggest": "此内联函数与 _mm512_mask_permutexvar_epi32 相同，建议您使用该内联函数名称。",
        "translate": ""
    },
    {
        "source": "Store tmp to dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).",
        "suggest": "使用 zeromask k 将 tmp 存储到 dst (当未设置相应的掩码位时，元素会被清零)。",
        "translate": ""
    },
    {
        "source": "the upper 384 bits of the result are zeroed.",
        "suggest": "结果的高 384 位被清零。",
        "translate": ""
    },
    {
        "source": "the upper 256 bits of the result are zeroed.",
        "suggest": "结果的高 256 位被清零。",
        "translate": ""
    },
    {
        "source": "Returns the minimum of all active elements in a.",
        "suggest": "返回 a 中所有活动元素的最小值。",
        "translate": ""
    },
    {
        "source": "Store the result in the lower element of dst using zeromask k (the element is zeroed out when mask bit 0 is not set), and copy the upper 3 packed elements from a to the upper elements of dst.",
        "suggest": "使用 zeromask k 将结果存储在 dst 的下元素中 (当未设置掩码位 0 时，元素被清零)，并将上 3 个打包元素从 a 复制到 dst 的上元素。",
        "translate": ""
    },
    {
        "source": "Store the result in the lower element of dst using zeromask k (the element is zeroed out when mask bit 0 is not set), and copy the upper element from a to the upper element of dst.",
        "suggest": "使用 zeromask k 将结果存储在 dst 的下元素中 (当掩码位 0 未设置时元素被清零)，并将上元素从 a 复制到 dst 的上元素。",
        "translate": ""
    },
    {
        "source": "Store the result in the lower element of dst using writemask k (the element is copied from c when mask bit 0 is not set), and copy the upper element from c to the upper element of dst.",
        "suggest": "使用 writemask k 将结果存储在 dst 的下层元素中 (当掩码位 0 未设置时，从 c 复制元素)，并将 c 上的上层元素复制到 dst 的上层元素。",
        "translate": ""
    },
    {
        "source": "Store the result in dst using zeromask k (the element is zeroed out when mask bit 0 is not set), and copy the upper element from a to the upper element of dst.",
        "suggest": "使用 zeromask k 将结果存储在 dst 中 (当未设置掩码位 0 时元素被清零)，并将上元素从 a 复制到 dst 的上元素。",
        "translate": ""
    },
    {
        "source": "Store the result in the lower element of dst using writemask k (the element is copied from a when mask bit 0 is not set), and copy the upper 3 packed elements from a to the upper elements of dst.",
        "suggest": "使用写掩码 k 将结果存储在 dst 的低位元素中 (当未设置掩码位 0 时从 a 复制该元素)，并将高 3 个压缩元素从 a 复制到 dst 的高位元素。",
        "translate": ""
    },
    {
        "source": "Store the result in the lower element of dst, and copy the upper element from a to the upper element of dst.",
        "suggest": "将结果存储在 dst 的下部元素中，然后将 a 的上部元素复制到 dst 的上部元素中。",
        "translate": ""
    },
    {
        "source": "Positive sums greater than 7FFFh are saturated to 7FFFh.",
        "suggest": "大于 7FFFh 的正和饱和到 7FFFh。",
        "translate": ""
    },
    {
        "source": "`mem_addr` must be aligned on a 64-byte boundary.",
        "suggest": "`mem_addr` 必须在 64 字节边界上对齐。",
        "translate": ""
    },
    {
        "source": "For Linux, they are defined in [linux/auxvec.h][auxvec_h].",
        "suggest": "对于 Linux，它们在 [linux/auxvec.h][auxvec_h] 中定义。",
        "translate": ""
    },
    {
        "source": "that in this case the `Vec` may not report a [`capacity`] of 0*.",
        "suggest": "在这种情况下，`Vec` 可能不会报告 0* 的 [`capacity`]。",
        "translate": ""
    },
    {
        "source": "loopback address",
        "suggest": "回环地址",
        "translate": ""
    },
    {
        "source": "*Exception flags* report which exceptions occurred since last they were reset.",
        "suggest": "*异常标志* 报告自上次重置后发生了哪些异常。",
        "translate": ""
    },
    {
        "source": "*Masking flags* can be used to mask (ignore) certain exceptions.",
        "suggest": "*屏蔽标志* 可用于屏蔽 (忽略) 的某些异常。",
        "translate": ""
    },
    {
        "source": "*Rounding mode flags* control the rounding mode of floating point instructions.",
        "suggest": "*舍入模式标志* 控制浮点指令的舍入模式。",
        "translate": ""
    },
    {
        "source": "2 casts x 4 bytes x 100",
        "suggest": "2 次转换 x 4 字节 x 100",
        "translate": ""
    },
    {
        "source": "Rebuild assuming data[0..start] is still a proper heap.",
        "suggest": "重建假设 data[0..start] 仍然是一个合适的堆。",
        "translate": ""
    },
    {
        "source": "takes O(self.len()) operations and about 2 * self.len() comparisons in the worst case while repeating `sift_up` takes O(tail_len * log(start)) operations and about 1 * tail_len * log_2(start) comparisons in the worst case, assuming start >= tail_len.",
        "suggest": "在最坏的情况下进行 O(self.len()) 次操作和大约 2 * self.len() 次比较，而在最坏情况下重复 `sift_up` 需要进行 O(tail_len * log(start)) 次操作和大约 1 * tail_len * log_2(start) 次比较，假设 start >= tail_len。",
        "translate": ""
    },
    {
        "source": "The index `i` is always less than self.len().",
        "suggest": "索引 `i` 始终小于 self.len()。",
        "translate": ""
    },
    {
        "source": "data[0..first_removed] is untouched, so we only need to rebuild the tail:",
        "suggest": "data[0..first_removed] 没有改变，所以我们只需要重建尾部:",
        "translate": ""
    },
    {
        "source": "Returns a slice of all values in the underlying vector, in arbitrary order.",
        "suggest": "以任意顺序返回基础 vector 中所有值的切片。",
        "translate": ""
    },
    {
        "source": "If such distinct edges exist, returns them in ascending order, meaning that a non-zero number of calls to `next_unchecked` on the `front` of the result and/or calls to `next_back_unchecked` on the `back` of the result will eventually reach the same edge.",
        "suggest": "如果存在这种不同的 edges，则按升序返回它们，这意味着在结果的 `front` 上对 `next_unchecked` 的非零调用次数或者对结果的 `back` 上的 `next_back_unchecked` 调用最终将达到相同的 edge。",
        "translate": ""
    },
    {
        "source": "If there are no such edges, i.e., if the tree contains no key within the range, returns a pair of empty options.",
        "suggest": "如果没有这样的 edges，即，如果树不包含范围内的键，则返回一对空选项。",
        "translate": ""
    },
    {
        "source": "Unless `BorrowType` is `Immut`, do not use the handles to visit the same KV twice.",
        "suggest": "除非 `BorrowType` 是 `Immut`，否则不要使用句柄两次访问同一个 KV。",
        "translate": ""
    },
    {
        "source": "Any pointer to an `InternalNode` can be directly cast to a pointer to the underlying `LeafNode` portion of the node, allowing code to act on leaf and internal nodes generically without having to even check which of the two a pointer is pointing at.",
        "suggest": "任何指向 `InternalNode` 的指针都可以直接转换为指向节点底层 `LeafNode` 部分的指针，从而允许代码在一般情况下作用于叶节点和内部节点，甚至无需检查指针指向的两个节点中的哪一个。",
        "translate": ""
    },
    {
        "source": "Temporarily takes out another mutable reference to the same node.",
        "suggest": "临时取出对同一节点的另一个可变引用。",
        "translate": ""
    },
    {
        "source": "Temporarily takes out another immutable handle on the same location.",
        "suggest": "临时取出同一位置的另一个不可变句柄。",
        "translate": ""
    },
    {
        "source": "Temporarily takes out another mutable handle on the same location.",
        "suggest": "临时取出同一位置的另一个可变句柄。",
        "translate": ""
    },
    {
        "source": "If found, returns an `Ok` with that node, the strictly ascending pair of edge indices in the node delimiting the range, and the corresponding pair of bounds for continuing the search in the child nodes, in case the node is internal.",
        "suggest": "如果找到，则返回带有该节点的 `Ok`，该节点中限定范围的严格递增的一对边缘索引，以及在该节点是内部节点的情况下，在子节点中继续搜索的相应一对边界。",
        "translate": ""
    },
    {
        "source": "As a diagnostic service, panics if the range specifies impossible bounds.",
        "suggest": "作为诊断服务，如果范围指定不可能的界限，则会发生 panics。",
        "translate": ""
    },
    {
        "source": "Returns either the KV index in the node at which the key (or an equivalent) exists, or the edge index where the key belongs, starting from a particular index.",
        "suggest": "返回键 (或等效项) 所在节点中的 KV 索引，或键所属的 edge 索引，从特定索引开始。",
        "translate": ""
    },
    {
        "source": "must be a valid edge index for the node.",
        "suggest": "必须是节点的有效 edge 索引。",
        "translate": ""
    },
    {
        "source": "Mirror image of `find_lower_bound_index` for the upper bound, with an additional parameter to skip part of the key array.",
        "suggest": "上限的 `find_lower_bound_index` 的镜像，使用一个附加参数来跳过键数组的一部分。",
        "translate": ""
    },
    {
        "source": "Safety: The TrustedRandomAccess contract requires that callers only  pass an index that is in bounds.",
        "suggest": "安全性: TrustedRandomAccess 契约要求调用方只传递一个在边界内的索引。",
        "translate": ""
    },
    {
        "source": "Assumes that the `VecDeque` is sorted by the key, for instance with [`make_contiguous().sort_by_key()`] using the same key extraction function.",
        "suggest": "假设 `VecDeque` 是按键排序的，例如 [`make_contiguous().sort_by_key()`] 使用相同的键提取函数。",
        "translate": ""
    },
    {
        "source": "The deque is assumed to be partitioned according to the given predicate.",
        "suggest": "假定双端队列根据给定的谓词进行了分区。",
        "translate": ""
    },
    {
        "source": "This means that all elements for which the predicate returns true are at the start of the deque and all elements for which the predicate returns false are at the end.",
        "suggest": "这意味着谓词返回 true 的所有元素都在双端队列的开头，而谓词返回 false 的所有元素都在末尾。",
        "translate": ""
    },
    {
        "source": "If this deque is not partitioned, the returned result is unspecified and meaningless, as this method performs a kind of binary search.",
        "suggest": "如果此双端队列未分区，则返回的结果是未指定且无意义的，因为此方法执行一种二分查找。",
        "translate": ""
    },
    {
        "source": "Positive signs are never printed by default, and the negative sign is only printed by default for signed values.",
        "suggest": "默认情况下从不打印正号，默认情况下仅对有符号值打印负号。",
        "translate": ""
    },
    {
        "source": "pretty-print the [`Debug`] formatting (adds linebreaks and indentation)",
        "suggest": "漂亮地打印 [`Debug`] 格式 (添加换行符和缩进)",
        "translate": ""
    },
    {
        "source": "This exists because stable `const fn` can only call stable `const fn`, so they cannot call `Self::new()`.",
        "suggest": "这是因为稳定的 `const fn` 只能调用稳定的 `const fn`，所以不能调用 `Self::new()`。",
        "translate": ""
    },
    {
        "source": "If you change `RawVec<T>::new` or dependencies, please take care to not introduce anything that would truly const-call something unstable.",
        "suggest": "如果您更改 `RawVec<T>::new` 或依赖项，请注意不要引入任何真正不稳定的东西。",
        "translate": ""
    },
    {
        "source": "Callers expect this function to be very cheap when there is already sufficient capacity.",
        "suggest": "当已经有足够的容量时，调用者希望这个函数非常便宜。",
        "translate": ""
    },
    {
        "source": "Therefore, we move all the resizing and error-handling logic from grow_amortized and handle_reserve behind a call, while making sure that the this function is likely to be inlined as just a comparison and a call if the comparison fails.",
        "suggest": "因此，我们将所有调整大小和错误处理逻辑从 grow_amortized 和 handle_reserve 移到一个调用之后，同时确保如果比较失败，这个函数很可能被内联为一个比较和一个调用。",
        "translate": ""
    },
    {
        "source": "Increments the strong reference count on the `Rc<T>` associated with the provided pointer by one.",
        "suggest": "将与提供的指针关联的 `Rc<T>` 上的强引用计数增加 1。",
        "translate": ""
    },
    {
        "source": "The pointer must have been obtained through `Rc::into_raw`, and the associated `Rc` instance must be valid (i.e.",
        "suggest": "指针必须是通过 `Rc::into_raw` 获得的，并且关联的 `Rc` 实例必须是有效的 (即",
        "translate": ""
    },
    {
        "source": "Retain Rc, but don't touch refcount by wrapping in ManuallyDrop",
        "suggest": "保留 Rc，但不要通过包装在手动丢弃中来触及引用计数",
        "translate": ""
    },
    {
        "source": "Decrements the strong reference count on the `Rc<T>` associated with the provided pointer by one.",
        "suggest": "将与提供的指针关联的 `Rc<T>` 上的强引用计数减一。",
        "translate": ""
    },
    {
        "source": "This method can be used to release the final `Rc` and backing storage, but **should not** be called after the final `Rc` has been released.",
        "suggest": "此方法可用于释放最终的 `Rc` 和后备存储，但**不应**在最终的 `Rc` 释放后调用。",
        "translate": ""
    },
    {
        "source": "TrustedLen contract guarantees that `upper_bound == `None` implies an iterator length exceeding `usize::MAX`.",
        "suggest": "TrustedLen 契约保证 `upper_bound == `None` 意味着迭代器长度超过 `usize::MAX`。",
        "translate": ""
    },
    {
        "source": "The default implementation would collect into a vec which would panic.",
        "suggest": "默认实现将收集到一个 vec 中，这将是 panic。",
        "translate": ""
    },
    {
        "source": "Thus we panic here immediately without invoking `Vec` code.",
        "suggest": "因此，我们立即在此处 panic 而不调用 `Vec` 代码。",
        "translate": ""
    },
    {
        "source": "Use a `Wake`-able type as a `Waker`.",
        "suggest": "使用 `Wake` 类型作为 `Waker`。",
        "translate": ""
    },
    {
        "source": "No heap allocations or atomic operations are used for this conversion.",
        "suggest": "此转换不使用堆分配或原子操作。",
        "translate": ""
    },
    {
        "source": "Use a `Wake`-able type as a `RawWaker`.",
        "suggest": "使用 `Wake` 类型作为 `RawWaker`。",
        "translate": ""
    },
    {
        "source": "However, the pointer might not actually point to allocated memory.",
        "suggest": "但是，指针实际上可能并不指向分配的内存。",
        "translate": ""
    },
    {
        "source": "that in this case the `Vec` might not report a [`capacity`] of 0*.",
        "suggest": "在这种情况下，`Vec` 可能不会报告 [`capacity`] 为 0*。",
        "translate": ""
    },
    {
        "source": "Even if you zero a `Vec`'s memory first, that might not actually happen because the optimizer does not consider this a side-effect that must be preserved.",
        "suggest": "即使您先将 `Vec` 的内存清零，这可能不会实际发生，因为优化器不认为这是一个必须保留的副作用。",
        "translate": ""
    },
    {
        "source": "This method provides unique access to all vec parts at once in `extend_from_within`.",
        "suggest": "此方法提供对 `extend_from_within` 中所有 vec 部分的唯一访问权。",
        "translate": ""
    },
    {
        "source": "Element was just initialized with `MaybeUninit::write`, so it's ok to increase len",
        "suggest": "Element 刚刚用 `MaybeUninit::write` 初始化，所以可以增加 len",
        "translate": ""
    },
    {
        "source": "Allocate a `Vec<T>` and fill it by cloning `s`'s items.",
        "suggest": "分配一个 `Vec<T>` 并通过克隆 `s` 的项来填充它。",
        "translate": ""
    },
    {
        "source": "Allocate a `Vec<T>` and move `s`'s items into it.",
        "suggest": "分配一个 `Vec<T>` 并将 `s` 的项移到其中。",
        "translate": ""
    },
    {
        "source": "Convert a clone-on-write slice into a vector.",
        "suggest": "将写时克隆切片转换为 vector。",
        "translate": ""
    },
    {
        "source": "If `s` already owns a `Vec<T>`, it will be returned directly.",
        "suggest": "如果 `s` 已经拥有 `Vec<T>`，则直接返回。",
        "translate": ""
    },
    {
        "source": "If `s` is borrowing a slice, a new `Vec<T>` will be allocated and filled by cloning `s`'s items into it.",
        "suggest": "如果 `s` 是借用了一个切片，将通过克隆 `s` 的项来分配和填充一个新的 `Vec`。",
        "translate": ""
    },
    {
        "source": "Convert a boxed slice into a vector by transferring ownership of the existing heap allocation.",
        "suggest": "通过转移现有堆分配的所有权，将 boxed 切片转换为 vector。",
        "translate": ""
    },
    {
        "source": "Convert a vector into a boxed slice.",
        "suggest": "将 vector 转换为 boxed。",
        "translate": ""
    },
    {
        "source": "If `v` has excess capacity, its items will be moved into a newly-allocated buffer with exactly the right capacity.",
        "suggest": "如果 `v` 有多余的容量，它的项将被移动到新分配的缓冲区中，缓冲区的容量恰好是正确的。",
        "translate": ""
    },
    {
        "source": "Allocate a `Vec<u8>` and fill it with a UTF-8 string.",
        "suggest": "分配一个 `Vec<u8>` 并用 UTF-8 字符串填充它。",
        "translate": ""
    },
    {
        "source": "Helper trait to hold specialized implementations of the in-place iterate-collect loop",
        "suggest": "Helper trait 用来保存原地迭代收集循环的专门实现",
        "translate": ""
    },
    {
        "source": "Collects an iterator (`self`) into the destination buffer (`dst`) and returns the number of items collected.",
        "suggest": "将迭代器 (`self`) 收集到目标缓冲区 (`dst`) 中并返回收集的项数。",
        "translate": ""
    },
    {
        "source": "is the last writable element of the allocation and used for bounds checks.",
        "suggest": "是分配的最后一个可写元素，用于边界检查。",
        "translate": ""
    },
    {
        "source": "Safety: InplaceIterable contract guarantees that for every element we read one slot in the underlying storage will have been freed up and we can immediately write back the result.",
        "suggest": "安全性: InplaceIterable 契约保证我们读取底层存储中的一个槽位的每个元素都将被释放，我们可以立即写回结果。",
        "translate": ""
    },
    {
        "source": "Per TrustedLen contract a `None` upper bound means that the iterator length truly exceeds usize::MAX, which would eventually lead to a capacity overflow anyway.",
        "suggest": "每个 TrustedLen 契约的 `None` 上限意味着迭代器长度确实超过 usize::MAX，无论如何最终都会导致容量溢出。",
        "translate": ""
    },
    {
        "source": "Since the other branch already panics eagerly (via `reserve()`) we do the same here.",
        "suggest": "由于另一个分支已经 panics 急切地 (通过 `reserve()`) 我们在这里做同样的事情。",
        "translate": ""
    },
    {
        "source": "This avoids additional codegen for a fallback code path which would eventually panic anyway.",
        "suggest": "这避免了额外的 codegen 用于回退代码路径，最终 panic 无论如何。",
        "translate": ""
    },
    {
        "source": "TrustedLen contract guarantees that `size_hint() == (_, None)` means that there are more than `usize::MAX` elements.",
        "suggest": "TrustedLen 契约保证 `size_hint() == (_, None)` 意味着有多个 `usize::MAX` 元素。",
        "translate": ""
    },
    {
        "source": "Since the previous branch would eagerly panic if the capacity is too large (via `with_capacity`) we do the same here.",
        "suggest": "因为如果容量太大 (通过 `with_capacity`)，前一个分支会急切地使用 panic，所以我们在这里做同样的事情。",
        "translate": ""
    },
    {
        "source": "reuse extend specialization for TrustedLen",
        "suggest": "重用 TrustedLen 的扩展专业化",
        "translate": ""
    },
    {
        "source": "Check that 20 moved into 10's place.",
        "suggest": "检查 20 是否移动到 10 的位置。",
        "translate": ""
    },
    {
        "source": "clean up the leak to keep miri happy",
        "suggest": "清理泄漏，让 miri 开心",
        "translate": ""
    },
    {
        "source": "regression test for issue #85322.",
        "suggest": "issue #85322 的回归测试。",
        "translate": ""
    },
    {
        "source": "Peekable previously implemented InPlaceIterable, but due to an interaction with IntoIter's current Clone implementation it failed to uphold the contract.",
        "suggest": "Peekable 之前实现了 InPlaceIterable，但由于与 IntoIter 当前 Clone 实现的交互，它未能遵守契约。",
        "translate": ""
    },
    {
        "source": "Apache License, Version 2.0, ([LICENSE-APACHE](LICENSE-APACHE) or https://www.apache.org/licenses/LICENSE-2.0)",
        "suggest": "Apache 许可证，版本 2.0、([LICENSE-APACHE](LICENSE-APACHE) 或 https://www.apache.org/licenses/LICENSE-2.0)",
        "translate": ""
    },
    {
        "source": "MIT license ([LICENSE-MIT](LICENSE-MIT) or https://opensource.org/licenses/MIT)",
        "suggest": "MIT 许可证 ([LICENSE-MIT](LICENSE-MIT) 或 https://opensource.org/licenses/MIT)",
        "translate": ""
    },
    {
        "source": "Backtrace accuracy",
        "suggest": "回溯的准确性",
        "translate": ""
    },
    {
        "source": "This crate implements best-effort attempts to get the native backtrace.",
        "suggest": "这个 crate 尽最大努力尝试获取本机回溯。",
        "translate": ""
    },
    {
        "source": "This is not always guaranteed to work, and some platforms don't return any backtrace at all.",
        "suggest": "这并不总是能保证工作，有些平台根本不返回任何回溯。",
        "translate": ""
    },
    {
        "source": "If your application requires accurate backtraces then it's recommended to closely evaluate this crate to see whether it's suitable for your use case on your target platforms.",
        "suggest": "如果您的应用程序需要准确的回溯，那么建议仔细评估此 crate 以查看它是否适合您在目标平台上的用例。",
        "translate": ""
    },
    {
        "source": "Even on supported platforms, there's a number of reasons that backtraces may be less-than-accurate, including but not limited to:",
        "suggest": "即使在受支持的平台上，回溯也有很多不准确的原因，包括但不限于:",
        "translate": ""
    },
    {
        "source": "Unwind information may not be available.",
        "suggest": "展开信息可能不可用。",
        "translate": ""
    },
    {
        "source": "This crate primarily implements backtraces by unwinding the stack, but not all functions may have unwinding information (e.g.",
        "suggest": "这个 crate 主要是通过展开栈来实现回溯，但并不是所有的函数都有展开信息 (例如",
        "translate": ""
    },
    {
        "source": "DWARF unwinding information).",
        "suggest": "DWARF 展开信息)。",
        "translate": ""
    },
    {
        "source": "Rust code may be compiled without unwinding information for some functions.",
        "suggest": "对于某些函数，Rust 代码可能在没有展开信息的情况下编译。",
        "translate": ""
    },
    {
        "source": "This can also happen for Rust code compiled with `-Cpanic=abort`.",
        "suggest": "使用 `-Cpanic=abort` 编译的 Rust 代码也可能发生这种情况。",
        "translate": ""
    },
    {
        "source": "You can remedy this, however, with `-Cforce-unwind-tables` as a compiler option.",
        "suggest": "但是，您可以使用 `-Cforce-unwind-tables` 作为编译器选项来解决此问题。",
        "translate": ""
    },
    {
        "source": "Unwind information may be inaccurate or corrupt.",
        "suggest": "展开信息可能不准确或损坏。",
        "translate": ""
    },
    {
        "source": "In the worst case inaccurate unwind information can lead this library to segfault.",
        "suggest": "在最坏的情况下，不准确的展开信息可能导致该库出现段错误。",
        "translate": ""
    },
    {
        "source": "In the best case inaccurate information will result in a truncated stack trace.",
        "suggest": "在最好的情况下，不准确的信息将导致栈跟踪被截断。",
        "translate": ""
    },
    {
        "source": "Backtraces may not report filenames/line numbers correctly due to missing or corrupt debug information.",
        "suggest": "由于调试信息丢失或损坏，回溯可能无法正确报告文件名/行号。",
        "translate": ""
    },
    {
        "source": "This won't lead to segfaults unlike corrupt unwinding information, but missing or malformed debug information will mean that filenames and line numbers will not be available.",
        "suggest": "与损坏的展开信息不同，这不会导致段错误，但缺少或格式错误的调试信息将意味着文件名和行号将不可用。",
        "translate": ""
    },
    {
        "source": "This may be because debug information wasn't generated by the compiler, or it's just missing on the filesystem.",
        "suggest": "这可能是因为调试信息不是由编译器生成的，或者它只是在文件系统中丢失了。",
        "translate": ""
    },
    {
        "source": "Not all platforms are supported.",
        "suggest": "并非所有平台都受支持。",
        "translate": ""
    },
    {
        "source": "For example there's no way to get a backtrace on WebAssembly at the moment.",
        "suggest": "例如，目前无法在 WebAssembly 上获得回溯。",
        "translate": ""
    },
    {
        "source": "Crate features may be disabled.",
        "suggest": "Crate 特性可能被禁用。",
        "translate": ""
    },
    {
        "source": "Currently this crate supports using Gimli libbacktrace on non-Windows platforms for reading debuginfo for backtraces.",
        "suggest": "目前这个 crate 支持在非 Windows 平台上使用 Gimli libbacktrace 来读取回溯的调试信息。",
        "translate": ""
    },
    {
        "source": "If both crate features are disabled, however, then these platforms will generate a backtrace but be unable to generate symbols for it.",
        "suggest": "但是，如果禁用了 crate 的两个特性，那么这些平台将生成回溯但不能为它生成符号。",
        "translate": ""
    },
    {
        "source": "In most standard workflows for most standard platforms you generally don't need to worry about these caveats.",
        "suggest": "在大多数标准平台的大多数标准工作流中，您通常不需要担心这些警告。",
        "translate": ""
    },
    {
        "source": "We'll try to fix ones where we can over time, but otherwise it's important to be aware of the limitations of unwinding-based backtraces!",
        "suggest": "随着时间的推移，我们将尝试修复那些可以修复的问题，但除此之外，重要的是要注意基于展开的回溯的局限性!",
        "translate": ""
    },
    {
        "source": "We know this is deprecated, it's only here for back-compat reasons.",
        "suggest": "我们知道这已被弃用，它仅用于向后兼容的原因。",
        "translate": ""
    },
    {
        "source": "Haiku implements the image_info struct and the get_next_image_info() functions to iterate through the loaded executable images.",
        "suggest": "Haiku 实现了 image_info 结构和 get_next_image_info() 函数来迭代加载的可执行图像。",
        "translate": ""
    },
    {
        "source": "The image_info struct contains a pointer to the start of the .text section within the virtual address space, as well as the size of that section.",
        "suggest": "image_info 结构体包含一个指向虚拟地址空间内 .text 部分开头的指针，以及该部分的大小。",
        "translate": ""
    },
    {
        "source": "All the read-only segments of the ELF-binary are in that part of the address space.",
        "suggest": "ELF 二进制文件的所有只读段都在地址空间的这一部分。",
        "translate": ""
    },
    {
        "source": "Load the first image to get a valid info struct",
        "suggest": "加载第一张图片以获取有效信息结构体",
        "translate": ""
    },
    {
        "source": "Request the current link map from the runtime linker:",
        "suggest": "从运行时链接器请求当前链接 map:",
        "translate": ""
    },
    {
        "source": "Each entry in the link map represents a loaded object:",
        "suggest": "链接 map 中的每个条目代表一个加载的对象:",
        "translate": ""
    },
    {
        "source": "Fetch the fully qualified path of the loaded object:",
        "suggest": "获取加载的对象的完全限定路径:",
        "translate": ""
    },
    {
        "source": "The base address of the object loaded into memory:",
        "suggest": "加载到内存中的对象的基地址:",
        "translate": ""
    },
    {
        "source": "Use the ELF header for this object to locate the program header:",
        "suggest": "使用此 object 的 ELF 标头来定位程序标头:",
        "translate": ""
    },
    {
        "source": "Program header addresses for the base executable are already absolute.",
        "suggest": "基本可执行文件的程序头地址已经是绝对的。",
        "translate": ""
    },
    {
        "source": "Other addresses are relative to the object base.",
        "suggest": "其他地址是相对于对象库的。",
        "translate": ""
    },
    {
        "source": "Everything else should doesn't know how to load native libraries.",
        "suggest": "其他的一切都不应该知道如何加载本机库。",
        "translate": ""
    },
    {
        "source": "the `#[rustc_skip_array_during_method_dispatch]` on `trait IntoIterator` hides this implementation from explicit `.into_iter()` calls on editions < 2021, so those calls will still resolve to the slice implementation, by reference.",
        "suggest": "`trait IntoIterator` 上的 `#[rustc_skip_array_during_method_dispatch]` 对小于 2021 的版本显式 `.into_iter()` 调用隐藏了此实现，因此这些调用仍将通过引用解析为 slice 实现。",
        "translate": ""
    },
    {
        "source": "Creates a consuming iterator, that is, one that moves each value out of the array (from start to end).",
        "suggest": "创建一个消费迭代器，即将每个值移出数组 (从开始到结束)。",
        "translate": ""
    },
    {
        "source": "The array cannot be used after calling this unless `T` implements `Copy`, so the whole array is copied.",
        "suggest": "除非 `T` 实现了 `Copy`，否则调用此数组后不能使用数组，因此整个数组都会被复制。",
        "translate": ""
    },
    {
        "source": "Arrays have special behavior when calling `.into_iter()` prior to the",
        "suggest": "在调用 `.into_iter()` 之前，数组具有特殊行为",
        "translate": ""
    },
    {
        "source": "2021 edition -- see the [array] Editions section for more information.",
        "suggest": "2021 版 -- 有关更多信息，请参见 [array] 版本部分。",
        "translate": ""
    },
    {
        "source": "Stores the location of the earliest currently active borrow.",
        "suggest": "存储当前最早活动借用的位置。",
        "translate": ""
    },
    {
        "source": "This gets updated whenver we go from having zero borrows to having a single borrow.",
        "suggest": "每当我们从零借用变为单一借用时，这个就会更新。",
        "translate": ""
    },
    {
        "source": "When a borrow occurs, this gets included in the generated `BorroeError/`BorrowMutError`",
        "suggest": "当借用发生时，这将包含在生成的 `BorroeError/`BorrowMutError` 中",
        "translate": ""
    },
    {
        "source": "is always the *first* active borrow",
        "suggest": "总是第一个主动借用",
        "translate": ""
    },
    {
        "source": "If a borrow occured, then we must already have an outstanding borrow, so `borrowed_at` will be `Some`",
        "suggest": "如果发生借用，那么我们肯定已经有一个未偿还的借用，所以 `borrowed_at` 就是 `Some`",
        "translate": ""
    },
    {
        "source": "An extended version of `escape_debug` that optionally permits escaping Extended Grapheme codepoints, single quotes, and double quotes.",
        "suggest": "`escape_debug` 的扩展版本，可选择允许转义扩展字素代码点、单引号和双引号。",
        "translate": ""
    },
    {
        "source": "This allows us to format characters like nonspacing marks better when they're at the start of a string, and allows escaping single quotes in characters, and double quotes in strings.",
        "suggest": "这允许我们在字符串开头时更好地格式化像非空格标记这样的字符，并允许转义字符中的单引号和字符串中的双引号。",
        "translate": ""
    },
    {
        "source": "Escape Extended Grapheme codepoints?",
        "suggest": "转义扩展字素代码点?",
        "translate": ""
    },
    {
        "source": "Escape single quotes?",
        "suggest": "转义单引号?",
        "translate": ""
    },
    {
        "source": "Escape double quotes?",
        "suggest": "转义双引号?",
        "translate": ""
    },
    {
        "source": "Pattern `Some(Less | Eq)` optimizes worse than negating `None | Some(Greater)`.",
        "suggest": "模式 `Some(Less | Eq)` 优化比否定 `None | Some(Greater)` 更糟糕。",
        "translate": ""
    },
    {
        "source": "The root cause was fixed upstream in LLVM with:",
        "suggest": "根本原因已在 LLVM 上游修复:",
        "translate": ""
    },
    {
        "source": "Revert this workaround once support for LLVM 12 gets dropped.",
        "suggest": "一旦获得对 LLVM 12 的支持，就恢复此变通方法。",
        "translate": ""
    },
    {
        "source": "Rustdocs on the impl block show a \"[+] show undocumented items\" toggle.",
        "suggest": "impl 块上的 Rustdocs 显示了 \"[+] show undocumented items\" 切换。",
        "translate": ""
    },
    {
        "source": "Rustdocs on functions do not.",
        "suggest": "函数上的 Rustdocs 不支持。",
        "translate": ""
    },
    {
        "source": "This method is meant as a convenience, but its implementation is also explicitly left unspecified.",
        "suggest": "此方法是为了方便起见，但它的实现也明确未指定。",
        "translate": ""
    },
    {
        "source": "It isn't guaranteed to be equivalent to repeated calls of [`hash`] and implementations of [`Hash`] should keep that in mind and call [`hash`] themselves if the slice isn't treated as a whole unit in the [`PartialEq`] implementation.",
        "suggest": "它不能保证等同于 [`hash`] 的重复调用，并且 [`Hash`] 的实现应该记住这一点，如果在 [`PartialEq`] 实现中没有将 6 视为整个单元，则调用 [`hash`] 本身。",
        "translate": ""
    },
    {
        "source": "For example, a [`VecDeque`] implementation might naïvely call [`as_slices`] and then [`hash_slice`] on each slice, but this is wrong since the two slices can change with a call to [`make_contiguous`] without affecting the [`PartialEq`] result.",
        "suggest": "例如，一个 [`VecDeque`] 实现可能天真地调用 [`as_slices`] 然后 [`hash_slice`] 对每个调用 [`hash_slice`]，但这是错误的，因为两个切片可以随调用更改为 [`make_contiguous`] 而不会影响 [`PartialEq`] 结果。",
        "translate": ""
    },
    {
        "source": "Since these slices aren't treated as singular units, and instead part of a larger deque, this method cannot be used.",
        "suggest": "由于这些切片不被视为单一单元，而是更大双端队列的一部分，因此无法使用此方法。",
        "translate": ""
    },
    {
        "source": "This trait makes no assumptions about how the various `write_*` methods are defined and implementations of [`Hash`] should not assume that they work one way or another.",
        "suggest": "这个 trait 不假设各种 `write_*` 方法是如何定义的，并且 [`Hash`] 的实现不应该假设它们以一种或另一种方式工作。",
        "translate": ""
    },
    {
        "source": "You cannot assume, for example, that a [`write_u32`] call is equivalent to four calls of [`write_u8`].",
        "suggest": "例如，您不能假设一个 [`write_u32`] 调用等同于 [`write_u8`] 的四个调用。",
        "translate": ""
    },
    {
        "source": "ResultShunt::next calls I::find, which has to advance `iter` in order to return `Some(_)`.",
        "suggest": "ResultShunt::next 调用 I::find，它必须提前 `iter` 才能返回 `Some(_)`。",
        "translate": ""
    },
    {
        "source": "Since `iter` has type `I: InPlaceIterable` it's guaranteed that at least one item will be moved out from the underlying source.",
        "suggest": "由于 `iter` 的类型为 `I: InPlaceIterable`，因此可以保证至少一个项将从基础源中移出。",
        "translate": ""
    },
    {
        "source": "Nested zips are also possible:",
        "suggest": "嵌套 zip 也可以:",
        "translate": ""
    },
    {
        "source": "This `struct` is created by [`zip`] or [`Iterator::zip`].",
        "suggest": "这个 `struct` 是由 [`zip`] 或 [`Iterator::zip`] 创建的。",
        "translate": ""
    },
    {
        "source": "Converts the arguments to iterators and zips them.",
        "suggest": "将参数转换为迭代器并压缩它们。",
        "translate": ""
    },
    {
        "source": "See the documentation of [`Iterator::zip`] for more.",
        "suggest": "有关更多信息，请参见 [`Iterator::zip`] 的文档。",
        "translate": ""
    },
    {
        "source": "Safety: This macro must only be used on types that are `Copy` and result in ranges which have an exact `size_hint()` where the upper bound must not be `None`.",
        "suggest": "安全性: 这个宏只能用于 `Copy` 的类型，并导致具有精确 `size_hint()` 的范围，其中上限不能是 `None`。",
        "translate": ""
    },
    {
        "source": "The TrustedRandomAccess contract requires that callers only  pass an index that is in bounds.",
        "suggest": "TrustedRandomAccess 契约要求调用者只传递一个在边界内的索引。",
        "translate": ""
    },
    {
        "source": "Additionally Self: TrustedRandomAccess is only implemented for Copy types which means even repeated reads of the same index would be safe.",
        "suggest": "另外 Self: TrustedRandomAccess 仅针对 Copy 类型实现，这意味着即使重复读取同一索引也是安全的。",
        "translate": ""
    },
    {
        "source": "put a value into the iterator",
        "suggest": "将一个值放入迭代器",
        "translate": ""
    },
    {
        "source": "The value reappears as the iterator continues",
        "suggest": "随着迭代器的继续，该值重新出现",
        "translate": ""
    },
    {
        "source": "Take the first two words.",
        "suggest": "以前两个单词为例。",
        "translate": ""
    },
    {
        "source": "Collect the rest of the words.",
        "suggest": "收集剩下的单词。",
        "translate": ""
    },
    {
        "source": "We can only do this because we used `by_ref` earlier.",
        "suggest": "我们只能这样做，因为我们之前使用了 `by_ref`。",
        "translate": ""
    },
    {
        "source": "Creates an iterator which can use the [`peek`] and [`peek_mut`] methods to look at the next element of the iterator without consuming it.",
        "suggest": "创建一个迭代器，它可以使用 [`peek`] 和 [`peek_mut`] 方法查看迭代器的下一个元素而不消耗它。",
        "translate": ""
    },
    {
        "source": "See their documentation for more information.",
        "suggest": "有关更多信息，请参见他们的文档。",
        "translate": ""
    },
    {
        "source": "Note that the underlying iterator is still advanced when [`peek`] or [`peek_mut`] are called for the first time: In order to retrieve the next element, [`next`] is called on the underlying iterator, hence any side effects (i.e.",
        "suggest": "注意，第一次调用 [`peek`] 或 [`peek_mut`] 时，底层迭代器仍然在前进: 为了检索下一个元素，在底层迭代器上调用 [`next`]，因此会产生任何副作用 (即",
        "translate": ""
    },
    {
        "source": "Using [`peek_mut`] to mutate the next item without advancing the iterator:",
        "suggest": "使用 [`peek_mut`] 在不推进迭代器的情况下改变下一个项:",
        "translate": ""
    },
    {
        "source": "skips elements until `n` elements are skipped or the end of the iterator is reached (whichever happens first).",
        "suggest": "跳过元素，直到跳过 `n` 个元素或到达迭代器的末尾 (以先发生者为准)。",
        "translate": ""
    },
    {
        "source": "After that, all the remaining elements are yielded.",
        "suggest": "之后，产生所有剩余的元素。",
        "translate": ""
    },
    {
        "source": "In particular, if the original iterator is too short, then the returned iterator is empty.",
        "suggest": "特别是，如果原始迭代器太短，则返回的迭代器为空。",
        "translate": ""
    },
    {
        "source": "Creates an iterator that yields the first `n` elements, or fewer if the underlying iterator ends sooner.",
        "suggest": "创建一个迭代器，它产生第一个 `n` 元素，如果底层迭代器提前结束，则产生更少的元素。",
        "translate": ""
    },
    {
        "source": "yields elements until `n` elements are yielded or the end of the iterator is reached (whichever happens first).",
        "suggest": "产生元素直到 `n` 元素被产生或到达迭代器的末尾 (以先发生的为准)。",
        "translate": ""
    },
    {
        "source": "The returned iterator is a prefix of length `n` if the original iterator contains at least `n` elements, otherwise it contains all of the (fewer than `n`) elements of the original iterator.",
        "suggest": "如果原始迭代器包含至少 `n` 个元素，则返回的迭代器是一个长度为 `n` 的前缀，否则它包含原始迭代器的所有 (少于 `n`) 个元素。",
        "translate": ""
    },
    {
        "source": "Note that the [`Fuse`] wrapper is a no-op on iterators that implement the [`FusedIterator`] trait.",
        "suggest": "请注意，[`Fuse`] 包装器对实现 [`FusedIterator`] trait 的迭代器是无操作的。",
        "translate": ""
    },
    {
        "source": "may therefore behave incorrectly if the [`FusedIterator`] trait is improperly implemented.",
        "suggest": "因此，如果 [`FusedIterator`] trait 实现不当，则可能会出现错误行为。",
        "translate": ""
    },
    {
        "source": "Initializing the `name` field Using `write` instead of assignment via `=` to not call `drop` on the old, uninitialized value.",
        "suggest": "初始化 `name` 字段 使用 `write` 而不是通过 `=` 赋值，而不是在旧的、未初始化的值上调用 `drop`。",
        "translate": ""
    },
    {
        "source": "However, using `.assume_init()` may trigger a `memcpy` of the 1024 bytes.",
        "suggest": "但是，使用 `.assume_init()` 可能会触发 1024 字节的 `memcpy`。",
        "translate": ""
    },
    {
        "source": "To assert our buffer has been initialized without copying it, we upgrade the `&mut MaybeUninit<[u8; 1024]>` to a `&mut [u8; 1024]`:",
        "suggest": "为了断言我们的缓冲区已经初始化而不复制它，我们将 `&mut MaybeUninit<[u8; 1024]>` 升级为 `&mut [u8; 1024]`:",
        "translate": ""
    },
    {
        "source": "in a future Rust version this method may become unnecessary when Rust allows [inline const expressions](https://github.com/rust-lang/rust/issues/76001).",
        "suggest": "在 future Rust 版本中，当 Rust 允许 [inline const expressions](https://github.com/rust-lang/rust/issues/76001) 时，此方法可能变得不必要。",
        "translate": ""
    },
    {
        "source": "The example below could then use `let mut buf = [const { MaybeUninit::<u8>::uninit() }; 32];`.",
        "suggest": "下面的示例可以使用 `let mut buf = [const { MaybeUninit::<u8>::uninit() }; 32];`。",
        "translate": ""
    },
    {
        "source": "Prints `-` for any negative value.",
        "suggest": "为任何负值打印 `-`。",
        "translate": ""
    },
    {
        "source": "Prints `-` for any negative value, or `+` otherwise.",
        "suggest": "为任何负值打印 `-`，否则打印 `+`。",
        "translate": ""
    },
    {
        "source": "This computes the integer `q` such that `self = q * rhs + r`, with `r = self.rem_euclid(rhs)` and `0 <= r < abs(rhs)`.",
        "suggest": "这将计算整数 `q`，使得 `self = q * rhs + r`、`r = self.rem_euclid(rhs)` 和 `0 <= r < abs(rhs)`。",
        "translate": ""
    },
    {
        "source": "In other words, the result is `self / rhs` rounded to the integer `q` such that `self >= q * rhs`.",
        "suggest": "换句话说，结果是 `self / rhs` 舍入为整数 `q`，使得 `self >= q * rhs`。",
        "translate": ""
    },
    {
        "source": "Returns an iterator that produces an escaped version of a `u8`, treating it as an ASCII character.",
        "suggest": "返回生成 `u8` 的转义版本的迭代器，将其视为 ASCII 字符。",
        "translate": ""
    },
    {
        "source": "The behavior is identical to [`ascii::escape_default`].",
        "suggest": "行为与 [`ascii::escape_default`] 相同。",
        "translate": ""
    },
    {
        "source": "If you'd like to explicitly call the destructor of a value, [`mem::drop`] can be used instead.",
        "suggest": "如果您想显式调用一个值的析构函数，可以使用 [`mem::drop`] 代替。",
        "translate": ""
    },
    {
        "source": "May panic if the index is out of bounds.",
        "suggest": "如果索引越界，则可能为 panic。",
        "translate": ""
    },
    {
        "source": "This is used, for example, on the accumulator in `try_fold`:",
        "suggest": "例如，这用于 `try_fold` 中的累加器:",
        "translate": ""
    },
    {
        "source": "The `?` operator and `try {}` blocks.",
        "suggest": "`?` 运算符和 `try {}` 块。",
        "translate": ""
    },
    {
        "source": "methods typically involve a type implementing this trait.",
        "suggest": "方法通常涉及实现此 trait 的类型。",
        "translate": ""
    },
    {
        "source": "For example, the closures passed to [`Iterator::try_fold`] and [`Iterator::try_for_each`] must return such a type.",
        "suggest": "例如，传递给 [`Iterator::try_fold`] 和 [`Iterator::try_for_each`] 的闭包必须返回这样的类型。",
        "translate": ""
    },
    {
        "source": "types are typically those containing two or more categories of values, some subset of which are so commonly handled via early returns that it's worth providing a terse (but still visible) syntax to make that easy.",
        "suggest": "类型通常是那些包含两个或更多类别值的类型，其中一些子集通常通过早期返回处理，因此值得提供一个简洁 (但仍然可见) 的语法来简化它。",
        "translate": ""
    },
    {
        "source": "This is most often seen for error handling with [`Result`] and [`Option`].",
        "suggest": "这在 [`Result`] 和 [`Option`] 的错误处理中最常见。",
        "translate": ""
    },
    {
        "source": "The quintessential implementation of this trait is on [`ControlFlow`].",
        "suggest": "这个 trait 的典型实现是在 [`ControlFlow`] 上。",
        "translate": ""
    },
    {
        "source": "Using `Try` in Generic Code",
        "suggest": "在泛型代码中使用 `Try`",
        "translate": ""
    },
    {
        "source": "was stabilized to call back in Rust 1.27, but this trait is much newer.",
        "suggest": "在 Rust 1.27 中稳定到调用，但是这个 trait 更新了很多。",
        "translate": ""
    },
    {
        "source": "To illustrate the various associated types and methods, let's implement our own version.",
        "suggest": "为了说明各种关联类型和方法，让我们实现我们自己的版本。",
        "translate": ""
    },
    {
        "source": "As a reminder, an infallible version of a fold looks something like this:",
        "suggest": "提醒一下，一个可靠的折叠版本看起来像这样:",
        "translate": ""
    },
    {
        "source": "So instead of `f` returning just an `A`, we'll need it to return some other type that produces an `A` in the \"don't short circuit\" path.",
        "suggest": "因此，不是 `f` 只返回一个 `A`，我们需要它返回一些在不要短路路径中产生一个 `A` 的其他类型。",
        "translate": ""
    },
    {
        "source": "Conveniently, that's also the type we need to return from the function.",
        "suggest": "方便的是，这也是我们需要从函数返回的类型。",
        "translate": ""
    },
    {
        "source": "Let's add a new generic parameter `R` for that type, and bound it to the output type that we want:",
        "suggest": "让我们为该类型添加一个新的泛型参数 `R`，并将其绑定到我们想要的输出类型:",
        "translate": ""
    },
    {
        "source": "If we get through the entire iterator, we need to wrap up the accumulator into the return type using [`Try::from_output`]:",
        "suggest": "如果我们遍历整个迭代器，我们需要使用 [`Try::from_output`] 将累加器包装成返回类型:",
        "translate": ""
    },
    {
        "source": "We'll also need [`FromResidual::from_residual`] to turn the residual back into the original type.",
        "suggest": "我们还需要 [`FromResidual::from_residual`] 将 residual 恢复为原始类型。",
        "translate": ""
    },
    {
        "source": "But because it's a supertrait of `Try`, we don't need to mention it in the bounds.",
        "suggest": "但因为它是 `Try` 的一个 super trait，所以我们不必在界限内提及它。",
        "translate": ""
    },
    {
        "source": "All types which implement `Try` can be recreated from their corresponding residual, so we'll just call it:",
        "suggest": "所有实现 `Try` 的类型都可以从它们对应的 residual 中重新创建，所以我们将调用它:",
        "translate": ""
    },
    {
        "source": "But this \"call `branch`, then `match` on it, and `return` if it was a `Break`\" is exactly what happens inside the `?` operator.",
        "suggest": "但是这个 \"调用`branch`，然后在它上面进行 `match`，如果它是 `Break`，则 `return`\" 正是在 `?` 操作符内部发生的事情。",
        "translate": ""
    },
    {
        "source": "So rather than do all this manually, we can just use `?` instead:",
        "suggest": "因此，我们可以使用 `?` 代替手动完成所有这些操作:",
        "translate": ""
    },
    {
        "source": "The type of the value produced by `?` when *not* short-circuiting.",
        "suggest": "当不短路时，`?` 产生的值的类型。",
        "translate": ""
    },
    {
        "source": "The type of the value passed to [`FromResidual::from_residual`] as part of `?` when short-circuiting.",
        "suggest": "短路时作为 `?` 的一部分传递给 [`FromResidual::from_residual`] 的值的类型。",
        "translate": ""
    },
    {
        "source": "This represents the possible values of the `Self` type which are *not* represented by the `Output` type.",
        "suggest": "这表示 `Self` 类型的可能值，而不是 `Output` 类型所表示的值。",
        "translate": ""
    },
    {
        "source": "The choice of this type is critical to interconversion.",
        "suggest": "这种类型的选择对于相互转化至关重要。",
        "translate": ""
    },
    {
        "source": "Unlike the `Output` type, which will often be a raw generic type, this type is typically a newtype of some sort to \"color\" the type so that it's distinguishable from the residuals of other types.",
        "suggest": "与 `Output` 类型不同，它通常是原始泛型类型，这种类型通常是某种类型的 newtype 到 \"color\" 类型，以便与其他类型的 residual 区别开来。",
        "translate": ""
    },
    {
        "source": "This is why `Result<T, E>::Residual` is not `E`, but `Result<Infallible, E>`.",
        "suggest": "这就是为什么 `Result<T, E>::Residual` 不是 `E`，而是 `Result<Infallible, E>`。",
        "translate": ""
    },
    {
        "source": "That way it's distinct from `ControlFlow<E>::Residual`, for example, and thus `?` on `ControlFlow` cannot be used in a method returning `Result`.",
        "suggest": "例如，这样它就不同于 `ControlFlow<E>::Residual`，因此 `ControlFlow` 上的 `?` 不能用于返回 `Result` 的方法中。",
        "translate": ""
    },
    {
        "source": "If you're making a generic type `Foo<T>` that implements `Try<Output = T>`, then typically you can use `Foo<std::convert::Infallible>` as its `Residual` type: that type will have a \"hole\" in the correct place, and will maintain the \"foo-ness\" of the residual so other types need to opt-in to interconversion.",
        "suggest": "如果您正在创建实现 `Try<Output = T>` 的泛型 `Foo<T>`，那么通常您可以使用 `Foo<std::convert::Infallible>` 作为它的 `Residual` 类型: 该类型将在正确位置有一个 \"hole\"，并将保留 residual 的 \"foo-ness\"，因此其他类型需要选择加入到相互转换中。",
        "translate": ""
    },
    {
        "source": "Constructs the type from its `Output` type.",
        "suggest": "从它的 `Output` 类型构造类型。",
        "translate": ""
    },
    {
        "source": "This should be implemented consistently with the `branch` method such that applying the `?` operator will get back the original value:",
        "suggest": "这应该与 `branch` 方法一致实现，以便应用 `?` 运算符将返回原始值:",
        "translate": ""
    },
    {
        "source": "Used in `?` to decide whether the operator should produce a value (because this returned [`ControlFlow::Continue`]) or propagate a value back to the caller (because this returned [`ControlFlow::Break`]).",
        "suggest": "在 `?` 来决定操作符是应该生成一个值 (因为它返回了 [`ControlFlow::Continue`])，还是将一个值传播回调用者(因为它返回了 [`ControlFlow::Break`])。",
        "translate": ""
    },
    {
        "source": "Used to specify which residuals can be converted into which [`Try`] types.",
        "suggest": "用于指定哪些 residuals 可以转换为哪些 [`Try`] 类型。",
        "translate": ""
    },
    {
        "source": "Every `Try` type needs to be recreatable from its own associated `Residual` type, but can also have additional `FromResidual` implementations to support interconversion with other `Try` types.",
        "suggest": "每个 `Try` 类型都需要从它自己关联的 `Residual` 类型重新创建，但也可以有额外的 `FromResidual` 实现来支持与其他 `Try` 类型的相互转换。",
        "translate": ""
    },
    {
        "source": "Constructs the type from a compatible `Residual` type.",
        "suggest": "从兼容的 `Residual` 类型构造类型。",
        "translate": ""
    },
    {
        "source": "This should be implemented consistently with the `branch` method such that applying the `?` operator will get back an equivalent residual:",
        "suggest": "这应该与 `branch` 方法一致地实现，以便应用 `?` 运算符将得到等效的 residual:",
        "translate": ""
    },
    {
        "source": "(It may not be an *identical* residual when interconversion is involved.)",
        "suggest": "(当涉及到相互转换时，它可能不是一个相同的 residual。)",
        "translate": ""
    },
    {
        "source": "Returns the provided default result (if none), or applies a function to the contained value (if any).",
        "suggest": "返回提供的默认结果 (如果没有)，或将函数应用于包含的值 (如果有)。",
        "translate": ""
    },
    {
        "source": "Computes a default function result (if none), or applies a different function to the contained value (if any).",
        "suggest": "计算 default 函数的结果 (如果没有)，或将不同的函数应用于包含的值 (如果有)。",
        "translate": ""
    },
    {
        "source": "Entry-like operations to insert a value and return a reference",
        "suggest": "类似条目的操作，插入一个值并返回一个引用",
        "translate": ""
    },
    {
        "source": "See also [`Option::get_or_insert`], which doesn't update the value if the option already contains [`Some`].",
        "suggest": "另请参见 [`Option::get_or_insert`]，如果选项已包含 [`Some`]，则不会更新值。",
        "translate": ""
    },
    {
        "source": "See also [`Option::insert`], which updates the value even if the option already contains [`Some`].",
        "suggest": "另请参见 [`Option::insert`]，即使选项已包含 [`Some`]，它也会更新值。",
        "translate": ""
    },
    {
        "source": "At a high level, a <code>[Pin]\\<P></code> ensures that the pointee of any pointer type `P` has a stable location in memory, meaning it cannot be moved elsewhere and its memory cannot be deallocated until it gets dropped.",
        "suggest": "在高层次上，<code>[Pin]\\</code><P> 确保任何指针类型 `P` 的指针在内存中都有一个稳定的位置，这意味着它不能被移动到其他地方，并且它的内存不能被释放，直到它被丢弃。",
        "translate": ""
    },
    {
        "source": "Rust allows passing all types by-value, and common smart-pointer types such as <code>[Box]\\<T></code> and <code>[&mut] T</code> allow replacing and moving the values they contain: you can move out of a <code>[Box]\\<T></code>, or you can use [`mem::swap`].",
        "suggest": "Rust 允许按值传递所有类型，以及常见的智能指针类型，例如 <code>[Box]\\</code><T> 和 <code>[&mut] T</code> 允许替换和移动它们包含的值: 您可以移出 <code>[Box]\\</code><T>，或者您可以使用 [`mem::swap`]。",
        "translate": ""
    },
    {
        "source": "<code>[Pin]\\<P></code> wraps a pointer type `P`, so <code>[Pin]<[Box]\\<T>></code> functions much like a regular <code>[Box]\\<T></code>:",
        "suggest": "<code>[Pin]\\</code><P> 包装一个指针类型 `P`，所以 <code>[Pin]<[Box]\\></code><T><code>[Pin]<[Box]\\></code> 函数很像一个普通的 <code>[Box]\\</code><T>:",
        "translate": ""
    },
    {
        "source": "when a <code>[Pin]<[Box]\\<T>></code> gets dropped, so do its contents, and the memory gets deallocated.",
        "suggest": "当 <code>[Pin]<[Box]\\></code><T><code>[Pin]<[Box]\\></code> 被丢弃，其内容也被丢弃，内存被释放。",
        "translate": ""
    },
    {
        "source": "Similarly, <code>[Pin]<[&mut] T></code> is a lot like <code>[&mut] T</code>.",
        "suggest": "类似地，<code>[Pin]<[&mut] T></code>很像 <code>[&mut] T</code>。",
        "translate": ""
    },
    {
        "source": "However, <code>[Pin]\\<P></code> does not let clients actually obtain a <code>[Box]\\<T></code> or <code>[&mut] T</code> to pinned data, which implies that you cannot use operations such as [`mem::swap`]:",
        "suggest": "然而，<code>[Pin]\\</code><P> 不让客户实际获得 <code>[Box]\\</code><T> 或 <code>[&mut] T</code> 固定数据，这意味着您不能使用 [`mem::swap`] 之类的操作:",
        "translate": ""
    },
    {
        "source": "It is worth reiterating that <code>[Pin]\\<P></code> does *not* change the fact that a Rust compiler considers all types movable.",
        "suggest": "值得重申的是 <code>[Pin]\\</code><P> 不会改变一个事实，即 Rust 编译器认为所有类型都是可移动的。",
        "translate": ""
    },
    {
        "source": "remains callable for any `T`.",
        "suggest": "对于任何 `T` 仍然可以调用。",
        "translate": ""
    },
    {
        "source": "Instead, <code>[Pin]\\<P></code> prevents certain *values* (pointed to by pointers wrapped in <code>[Pin]\\<P></code>) from being moved by making it impossible to call methods that require <code>[&mut] T</code> on them (like [`mem::swap`]).",
        "suggest": "相反，<code>[Pin]\\</code><P> 防止某些值 (由 <code>[Pin]\\</code><P>) 使其无法调用需要 <code>[&mut] T</code> 方法 (如 [`mem::swap`]) 而被移动。",
        "translate": ""
    },
    {
        "source": "<code>[Pin]\\<P></code> can be used to wrap any pointer type `P`, and as such it interacts with [`Deref`] and [`DerefMut`].",
        "suggest": "<code>[Pin]\\</code><P> 可用于包装任何指针类型 `P`，因此它与 [`Deref`] 和 [`DerefMut`] 交互。",
        "translate": ""
    },
    {
        "source": "A <code>[Pin]\\<P></code> where <code>P: [Deref]</code> should be considered as a \"`P`-style pointer\" to a pinned <code>P::[Target]</code> – so, a <code>[Pin]<[Box]\\<T>></code> is an owned pointer to a pinned `T`, and a <code>[Pin]<[Rc]\\<T>></code> is a reference-counted pointer to a pinned `T`.",
        "suggest": "<code>[Pin]\\</code><P>其中 <code>P: [Deref]</code> 应被视为固定 <code>P::[Target]</code>的 \"`P`-style pointer\" - 因此，<code>[Pin]<[Box]\\></code><T><code>[Pin]<[Box]\\></code>是指向固定 `T` 的拥有指针，以及 <code>[Pin]<[Rc]\\></code><T><code>[Pin]<[Rc]\\></code> 是指向固定 `T` 的引用计数指针。",
        "translate": ""
    },
    {
        "source": "For correctness, <code>[Pin]\\<P></code> relies on the implementations of [`Deref`] and [`DerefMut`] not to move out of their `self` parameter, and only ever to return a pointer to pinned data when they are called on a pinned pointer.",
        "suggest": "为正确起见，<code>[Pin]\\</code><P> 依赖于 [`Deref`] 和 [`DerefMut`] 的实现不会移出它们的 `self` 参数，并且只在固定指针上调用它们时才返回指向固定数据的指针。",
        "translate": ""
    },
    {
        "source": "Types that do not care about pinning implement the [`Unpin`] auto-trait, which cancels the effect of <code>[Pin]\\<P></code>.",
        "suggest": "不关心 pinning 的类型实现了 [`Unpin`] auto-trait，取消了 <code>[Pin]\\</code><P>.",
        "translate": ""
    },
    {
        "source": "For <code>T: [Unpin]</code>, <code>[Pin]<[Box]\\<T>></code> and <code>[Box]\\<T></code> function identically, as do <code>[Pin]<[&mut] T></code> and <code>[&mut] T</code>.",
        "suggest": "对于 <code>T: [Unpin]</code>, <code>[Pin]<[Box]\\></code><T><code>[Pin]<[Box]\\></code> 和 <code>[Box]\\</code><T> 函数相同，<code>[Pin]<[&mut] T></code> 和 <code>[&mut] T</code>。",
        "translate": ""
    },
    {
        "source": "Note that pinning and [`Unpin`] only affect the pointed-to type <code>P::[Target]</code>, not the pointer type `P` itself that got wrapped in <code>[Pin]\\<P></code>.",
        "suggest": "请注意，固定和 [`Unpin`] 仅影响指向类型 <code>P::[Target]</code>，而不影响包含在 <code>[Pin]\\</code> 的指针类型 `P` 本身 <P>.",
        "translate": ""
    },
    {
        "source": "For example, whether or not <code>[Box]\\<T></code> is [`Unpin`] has no effect on the behavior of <code>[Pin]<[Box]\\<T>></code> (here, `T` is the pointed-to type).",
        "suggest": "例如，是否 <code>[Box]\\</code><T> 是 [`Unpin`] 对 <code>[Pin]<[Box]\\></code> 的行为没有影响 <T><code>[Pin]<[Box]\\></code> (这里，`T` 是指向类型)。",
        "translate": ""
    },
    {
        "source": "Before we go into more details to explain the guarantees and choices associated with <code>[Pin]\\<P></code>, we discuss some examples for how it might be used.",
        "suggest": "在我们详细解释与 <code>[Pin]\\</code> 相关的保证和选择之前 <code>[Pin]\\</code><P>，我们讨论了一些如何使用它的例子。",
        "translate": ""
    },
    {
        "source": "Moreover, the [`Drop`][Drop] implementation of a linked list element will patch the pointers of its predecessor and successor to remove itself from the list.",
        "suggest": "此外，链表元素的 [`Drop`][Drop] 实现将修补其前任和后继的指针以将其从列表中删除。",
        "translate": ""
    },
    {
        "source": "Memory can be \"invalidated\" by deallocation, but also by replacing a <code>[Some]\\(v)</code> by [`None`], or calling [`Vec::set_len`] to \"kill\" some elements off of a vector.",
        "suggest": "内存可以通过释放为 \"invalidated\"，也可以通过将 <code>[Some]\\(v)</code> 替换为 [`None`]，或将 vector 中的某些元素从 [`Vec::set_len`] 调用到 \"kill\"。",
        "translate": ""
    },
    {
        "source": "It is still completely okay not ever to call [`drop`] on a pinned element (e.g., you can still call [`mem::forget`] on a <code>[Pin]<[Box]\\<T>></code>).",
        "suggest": "永远不要在固定元素上调用 [`drop`] 仍然是完全可以的 (例如，您仍然可以在 <code>[Pin]<[Box]\\></code><T><code>[Pin]<[Box]\\></code>)。",
        "translate": ""
    },
    {
        "source": "If your type uses pinning (such as the two examples above), you have to be careful when implementing [`Drop`][Drop].",
        "suggest": "如果您的类型使用固定 (例如上面的两个示例)，则在实现 [`Drop`][Drop] 时必须小心。",
        "translate": ""
    },
    {
        "source": "The [`drop`] function takes <code>[&mut] self</code>, but this is called *even if your type was previously pinned*!",
        "suggest": "[`drop`] 函数采用 <code>[&mut] self</code>，但这被称为即使您的类型之前已固定!</code>",
        "translate": ""
    },
    {
        "source": "This can never cause a problem in safe code because implementing a type that relies on pinning requires unsafe code, but be aware that deciding to make use of pinning in your type (for example by implementing some operation on <code>[Pin]<[&]Self></code> or <code>[Pin]<[&mut] Self></code>) has consequences for your [`Drop`][Drop]implementation as well: if an element of your type could have been pinned, you must treat [`Drop`][Drop] as implicitly taking <code>[Pin]<[&mut] Self></code>.",
        "suggest": "这永远不会在安全代码中导致问题，因为实现依赖于固定的类型需要不安全的代码，但请注意决定在您的类型中使用固定 (例如通过对 <code>[Pin]<[&] Self></code> 或 <code>[Pin]<[&mut] Self></code>) 对您的 [`Drop`][Drop] 实现也有影响: 如果您的类型的元素可以被固定，则您必须将 [`Drop`][Drop] 视为隐式使用 <code>[Pin]<[&mut] Self></code> .",
        "translate": ""
    },
    {
        "source": "For example, you could implement [`Drop`][Drop] as follows:",
        "suggest": "例如，您可以按如下方式实现 [`Drop`][Drop]:",
        "translate": ""
    },
    {
        "source": "When working with pinned structs, the question arises how one can access the fields of that struct in a method that takes just <code>[Pin]<[&mut] Struct></code>.",
        "suggest": "在使用固定结构体时，问题是如何在只需要 <code>[Pin]<[&mut] 结构体></code> 的方法中访问该结构体的字段。",
        "translate": ""
    },
    {
        "source": "The usual approach is to write helper methods (so called *projections*) that turn <code>[Pin]<[&mut] Struct></code> into a reference to the field, but what type should that reference have?",
        "suggest": "通常的方法是编写辅助方法 (所谓的 *projections*)，将 <code>[Pin]<[&mut] 结构体 ></code> 转换为对字段的引用，但该引用应该具有什么类型?",
        "translate": ""
    },
    {
        "source": "Is it <code>[Pin]<[&mut] Field></code> or <code>[&mut] Field</code>?",
        "suggest": "是 <code>[Pin]<[&mut] Field></code> 还是 <code>[&mut] Field</code>?</code>",
        "translate": ""
    },
    {
        "source": "The same question arises with the fields of an `enum`, and also when considering container/wrapper types such as <code>[Vec]\\<T></code>, <code>[Box]\\<T></code>, or <code>[RefCell]\\<T></code>.",
        "suggest": "`enum` 的字段以及在考虑 container/wrapper 类型 (例如 <code>[Vec]\\</code><T>, <code>[Box]\\</code><T>, 或 <code>[RefCell]\\</code><T>.",
        "translate": ""
    },
    {
        "source": "It turns out that it is actually up to the author of the data structure to decide whether the pinned projection for a particular field turns <code>[Pin]<[&mut] Struct></code> into <code>[Pin]<[&mut] Field></code> or <code>[&mut] Field</code>.",
        "suggest": "事实证明，实际上是由数据结构的作者决定特定字段的固定 projection 是将 <code>[Pin]<[&mut] 结构体 ></code> 转换为 <code>[Pin]<[&mut] Field></code> 或 <code>[&mut] Field</code>.</code>",
        "translate": ""
    },
    {
        "source": "It may seem counter-intuitive that the field of a pinned struct might not be pinned, but that is actually the easiest choice: if a <code>[Pin]<[&mut] Field></code> is never created, nothing can go wrong!",
        "suggest": "固定结构体的字段可能不被固定似乎违反直觉，但这实际上是最简单的选择: 如果从未创建 <code>[Pin]<[&mut] Field></code> 则不会出错!",
        "translate": ""
    },
    {
        "source": "Fields without structural pinning may have a projection method that turns <code>[Pin]<[&mut] Struct></code> into <code>[&mut] Field</code>:",
        "suggest": "没有结构固定的字段可能具有将 <code>[Pin]<[&mut] 结构体 ></code> 转换为 <code>[&mut] Field</code>:</code> 的 projection 方法 <code>[&mut] Field</code>:</code>",
        "translate": ""
    },
    {
        "source": "You may also <code>impl [Unpin] for Struct</code> *even if* the type of `field` is not [`Unpin`].",
        "suggest": "您也可以 <code>impl [Unpin] for Struct</code> 即使 `field` 的类型不是 [`Unpin`].</code>",
        "translate": ""
    },
    {
        "source": "What that type thinks about pinning is not relevant when no <code>[Pin]<[&mut] Field></code> is ever created.",
        "suggest": "当没有创建 <code>[Pin]<[&mut] Field></code>时，该类型对固定的看法 <code>[Pin]<[&mut] Field></code>。",
        "translate": ""
    },
    {
        "source": "This allows writing a projection that creates a <code>[Pin]<[&mut] Field></code>, thus witnessing that the field is pinned:",
        "suggest": "这允许编写一个创建 <code>[Pin]<[&mut] Field></code> 的 projection，从而见证该字段被固定:",
        "translate": ""
    },
    {
        "source": "This is the default, but [`Unpin`] is a safe trait, so as the author of the struct it is your responsibility *not* to add something like <code>impl\\<T> [Unpin] for Struct\\<T></code>.",
        "suggest": "这是默认值，但 [`Unpin`] 是一个安全的 trait，因此作为结构体的作者，您有责任*不*添加类似 <code>impl\\[Unpin] for 结构体 \\</code><T> <code>impl\\[Unpin] for 结构体 \\</code><T>.",
        "translate": ""
    },
    {
        "source": "(Notice that adding a projection operation requires unsafe code, so the fact that [`Unpin`] is a safe trait does not break the principle that you only have to worry about any of this if you use [`unsafe`].)",
        "suggest": "(请注意，添加投影操作需要不安全的代码，因此 [`Unpin`] 是安全的 trait 的事实并没有破坏您只需要在使用 [`unsafe`] 时担心任何这些的原则。)",
        "translate": ""
    },
    {
        "source": "This is the exact point that was raised in the [previous section][drop-impl]: [`drop`] takes <code>[&mut] self</code>, but the struct (and hence its fields) might have been pinned before.",
        "suggest": "这正是 [上一节][drop-impl] 中提出的要点: [`drop`] 采用 <code>[&mut] self</code>，但是结构体 (以及它的字段) 之前可能已经被固定了。</code>",
        "translate": ""
    },
    {
        "source": "You have to guarantee that you do not move a field inside your [`Drop`][Drop] implementation.",
        "suggest": "您必须保证不会在您的 [`Drop`][Drop] 实现中移动任何字段。",
        "translate": ""
    },
    {
        "source": "This can be tricky, as witnessed by <code>[VecDeque]\\<T></code>: the destructor of <code>[VecDeque]\\<T></code> can fail to call [`drop`] on all elements if one of the destructors panics.",
        "suggest": "这可能很棘手，正如 <code>[VecDeque]\\</code><T>: <code>[VecDeque]\\</code> 的析构函数 <code>[VecDeque]\\</code><T> 如果析构函数 panics 之一，则可能无法在所有元素上调用 [`drop`]。",
        "translate": ""
    },
    {
        "source": "This violates the [`Drop`][Drop] guarantee, because it can lead to elements being deallocated without their destructor being called.",
        "suggest": "这违反了 [`Drop`][Drop] 保证，因为它可能导致元素在没有调用析构函数的情况下被释放。",
        "translate": ""
    },
    {
        "source": "(<code>[VecDeque]\\<T></code> has no pinning projections, so this does not cause unsoundness.)",
        "suggest": "(<code>[VecDeque]\\</code><T> 没有固定 projection，所以这不会导致不稳定。)",
        "translate": ""
    },
    {
        "source": "For example, if the struct contains an <code>[Option]\\<T></code> and there is a [`take`][Option::take]-like operation with type <code>fn([Pin]<[&mut] Struct\\<T>>) -> [Option]\\<T></code>, that operation can be used to move a `T` out of a pinned `Struct<T>` – which means pinning cannot be structural for the field holding this data.",
        "suggest": "例如，如果结构体包含一个 <code>[Option]\\</code><T>并且有一个类似 [`take`][Option::take] 的操作，类型为 <code>fn ([Pin]<[&mut] 结构体 \\>) -> [Option]\\</code><T> <code>fn ([Pin]<[&mut] 结构体 \\>) -> [Option]\\</code><T>，该操作可用于将 `T` 从固定的 `Struct<T>` 中移出 - 这意味着固定不能对保存此数据的字段进行结构化。",
        "translate": ""
    },
    {
        "source": "For a more complex example of moving data out of a pinned type, imagine if <code>[RefCell]\\<T></code> had a method <code>fn get_pin_mut(self: [Pin]<[&mut] Self>) -> [Pin]<[&mut] T></code>.",
        "suggest": "有关将数据移出固定类型的更复杂示例，请想象如果 <code>[RefCell]\\</code><T>有一个方法 <code>fn get_pin_mut(self: [Pin]<[&mut] Self>) -> [Pin]<[&mut] T></code>。",
        "translate": ""
    },
    {
        "source": "This is catastrophic, it means we can first pin the content of the <code>[RefCell]\\<T></code> (using <code>[RefCell]::get_pin_mut</code>) and then move that content using the mutable reference we got later.",
        "suggest": "这是灾难性的，这意味着我们可以先固定 <code>[RefCell]\\</code><T> (使用 <code>[RefCell]::get_pin_mut</code> ) 然后使用我们稍后获得的 <code>[RefCell]::get_pin_mut</code> 引用移动该内容。",
        "translate": ""
    },
    {
        "source": "For a type like <code>[Vec]\\<T></code>, both possibilities (structural pinning or not) make sense.",
        "suggest": "对于像 <code>[Vec]\\</code> 这样的类型 <T>，两种可能性 (结构固定与否) 都有意义。",
        "translate": ""
    },
    {
        "source": "A <code>[Vec]\\<T></code> with structural pinning could have `get_pin`/`get_pin_mut` methods to get pinned references to elements.",
        "suggest": "<code>[Vec]\\</code><T> 使用结构固定可以有 `get_pin`/`get_pin_mut` 方法来固定引用到元素。",
        "translate": ""
    },
    {
        "source": "However, it could *not* allow calling [`pop`][Vec::pop] on a pinned <code>[Vec]\\<T></code> because that would move the (structurally pinned) contents!",
        "suggest": "但是，它可能*不允许*在固定的 <code>[Vec]\\</code> 上调用 [`pop`][Vec::pop]<T> 因为那会移动 (结构固定的) 内容!",
        "translate": ""
    },
    {
        "source": "A <code>[Vec]\\<T></code> without structural pinning could <code>impl\\<T> [Unpin] for [Vec]\\<T></code>, because the contents are never pinned and the <code>[Vec]\\<T></code> itself is fine with being moved as well.",
        "suggest": "<code>[Vec]\\</code><T>没有结构固定可以 <code>impl\\[Unpin] for [Vec]\\</code><T> <code>impl\\[Unpin] for [Vec]\\</code><T>，因为内容永远不会被固定并且 <code>[Vec]\\</code><T> 本身也可以移动。",
        "translate": ""
    },
    {
        "source": "This is why <code>[Box]\\<T>: [Unpin]</code> holds for all `T`.",
        "suggest": "这就是为什么 <code>[Box]\\: [Unpin]</code><T><code>[Box]\\: [Unpin]</code> Unpin <code>[Box]\\: [Unpin]</code> 适用于所有 `T`。",
        "translate": ""
    },
    {
        "source": "It makes sense to do this for pointer types, because moving the <code>[Box]\\<T></code> does not actually move the `T`: the <code>[Box]\\<T></code> can be freely movable (aka [`Unpin`]) even if the `T` is not.",
        "suggest": "对指针类型这样做是有意义的，因为移动 <code>[Box]\\</code><T> 实际上并没有移动 `T`: <code>[Box]\\</code><T> 即使 `T` 不是，也可以自由移动 (又名 [`Unpin`])。",
        "translate": ""
    },
    {
        "source": "In fact, even <code>[Pin]<[Box]\\<T>></code> and <code>[Pin]<[&mut] T></code> are always [`Unpin`] themselves, for the same reason:",
        "suggest": "事实上，即使 <code>[Pin]<[Box]\\></code><T><code>[Pin]<[Box]\\></code> 和 <code>[Pin]<[&mut] T></code> 总是 [`Unpin`] 本身，原因相同:",
        "translate": ""
    },
    {
        "source": "their contents (the `T`) are pinned, but the pointers themselves can be moved without moving the pinned data.",
        "suggest": "它们的内容 (`T`) 是固定的，但指针本身可以在不移动固定数据的情况下移动。",
        "translate": ""
    },
    {
        "source": "For both <code>[Box]\\<T></code> and <code>[Pin]<[Box]\\<T>></code>, whether the content is pinned is entirely independent of whether the pointer is pinned, meaning pinning is *not* structural.",
        "suggest": "对于 <code>[Box]\\</code><T> 和 <code>[Pin]<[Box]\\></code><T><code>[Pin]<[Box]\\></code>，内容是否固定完全独立于指针是否固定，意味着固定是*非*结构的。",
        "translate": ""
    },
    {
        "source": "But if your combinator contains any other data that does not need to be pinned, you can make those fields not structural and hence freely access them with a mutable reference even when you just have <code>[Pin]<[&mut] Self></code> (such as in your own [`poll`] implementation).",
        "suggest": "但是，如果您的组合器包含任何其他不需要固定的数据，您可以使这些字段不是结构化的，因此即使您只有 <code>[Pin]<[&mut] Self></code> (例如在您自己的 [`poll`] 实现中)。",
        "translate": ""
    },
    {
        "source": "Both the starting and resulting pointer must be either in bounds or one byte past the end of the same [allocated object].",
        "suggest": "起始指针和结果指针都必须在边界内或在同一个 [allocated object] 的末尾之后一个字节。",
        "translate": ""
    },
    {
        "source": "The resulting pointer \"remembers\" the [allocated object] that `self` points to;",
        "suggest": "结果指针 \"remembers\" 是 `self` 指向的 [allocated object];",
        "translate": ""
    },
    {
        "source": "it may not be used to read or write other allocated objects.",
        "suggest": "它不能用于读取或写入其他分配的对象。",
        "translate": ""
    },
    {
        "source": "Both the starting and other pointer must be either in bounds or one byte past the end of the same [allocated object].",
        "suggest": "起始指针和其他指针都必须在边界内或在同一个 [allocated object] 的末尾之后一个字节。",
        "translate": ""
    },
    {
        "source": "The entire memory range of this slice must be contained within a single [allocated object]!",
        "suggest": "整个内存范围必须包含在单个 [allocated object] 内!",
        "translate": ""
    },
    {
        "source": "would create a reference to an uninitialized `bool`, and thus be Undefined Behavior!",
        "suggest": "将创建对未初始化的 `bool` 的引用，因此是未定义的行为!",
        "translate": ""
    },
    {
        "source": "Allocated object",
        "suggest": "分配对象",
        "translate": ""
    },
    {
        "source": "For several operations, such as [`offset`] or field projections (`expr.field`), the notion of an \"allocated object\" becomes relevant.",
        "suggest": "对于一些操作，例如 [`offset`] 或 projection (`expr.field`)，\"allocated object\" 的概念变得相关。",
        "translate": ""
    },
    {
        "source": "An allocated object is a contiguous region of memory.",
        "suggest": "分配的对象是一个连续的内存区域。",
        "translate": ""
    },
    {
        "source": "Common examples of allocated objects include stack-allocated variables (each variable is a separate allocated object), heap allocations (each allocation created by the global allocator is a separate allocated object), and `static` variables.",
        "suggest": "分配对象的常见示例包括栈分配变量 (每个变量都是一个单独的分配对象)、堆分配 (每个分配器创建的分配都是一个单独的分配对象) 和 `static` 变量。",
        "translate": ""
    },
    {
        "source": "SPIR-V's Logical addressing model doesn't allow for arbitrary reinterpretation of values as (chunkable) byte arrays, and the loop in the block optimization in `swap_nonoverlapping_bytes` is hard to rewrite back into the (unoptimized) direct swapping implementation, so we disable it.",
        "suggest": "SPIR-V 的逻辑寻址模型不允许将值任意重新解释为 (chunkable) 字节数组，并且 `swap_nonoverlapping_bytes` 中块优化中的循环很难重写回 (unoptimized) 直接交换实现，因此我们禁用它。",
        "translate": ""
    },
    {
        "source": "the block optimization also prevents MIR optimizations from understanding `mem::replace`, `Option::take`, etc. - a better overall solution might be to make `swap_nonoverlapping` into an intrinsic, which a backend can choose to implement using the block optimization, or not.",
        "suggest": "块优化还阻止 MIR 优化理解 `mem::replace`、`Option::take` 等 - 更好的整体解决方案可能是使 `swap_nonoverlapping` 成为内联函数，后端可以选择使用块优化来实现或不实现。",
        "translate": ""
    },
    {
        "source": "Only apply the block optimization in `swap_nonoverlapping_bytes` for types at least as large as the block size, to avoid pessimizing codegen.",
        "suggest": "仅对至少与块大小一样大的类型应用 `swap_nonoverlapping_bytes` 中的块优化，以避免对 codegen 产生负面影响。",
        "translate": ""
    },
    {
        "source": "Direct swapping, for the cases not going through the block optimization.",
        "suggest": "直接交换，用于未经过块优化的情况。",
        "translate": ""
    },
    {
        "source": "Note, however, that the `expr` in `addr_of!(expr)` is still subject to all the usual rules.",
        "suggest": "但是请注意，`addr_of!(expr)` 中的 `expr` 仍受所有常规规则的约束。",
        "translate": ""
    },
    {
        "source": "In particular, `addr_of!(*ptr::null())` is Undefined Behavior because it dereferences a NULL pointer.",
        "suggest": "特别是，`addr_of!(*ptr::null())` 是未定义行为，因为它引用了 NULL 指针。",
        "translate": ""
    },
    {
        "source": "See [`addr_of_mut`] for how to create a pointer to unininitialized data.",
        "suggest": "有关如何创建指向未初始化数据的指针，请参见 [`addr_of_mut`]。",
        "translate": ""
    },
    {
        "source": "Doing that with `addr_of` would not make much sense since one could only read the data, and that would be Undefined Behavior.",
        "suggest": "用 `addr_of` 这样做没有多大意义，因为人们只能读取数据，这将是未定义行为。",
        "translate": ""
    },
    {
        "source": "Note, however, that the `expr` in `addr_of_mut!(expr)` is still subject to all the usual rules.",
        "suggest": "但请注意，`addr_of_mut!(expr)` 中的 `expr` 仍受所有常规规则的约束。",
        "translate": ""
    },
    {
        "source": "In particular, `addr_of_mut!(*ptr::null_mut())` is Undefined Behavior because it dereferences a NULL pointer.",
        "suggest": "特别是，`addr_of_mut!(*ptr::null_mut())` 是未定义行为，因为它引用了 NULL 指针。",
        "translate": ""
    },
    {
        "source": "Creating a pointer to unaligned data:",
        "suggest": "创建指向未对齐数据的指针:",
        "translate": ""
    },
    {
        "source": "Creating a pointer to uninitialized data:",
        "suggest": "创建指向未初始化数据的指针:",
        "translate": ""
    },
    {
        "source": "Returns the provided default (if [`Err`]), or applies a function to the contained value (if [`Ok`]),",
        "suggest": "返回提供的默认值 (如果 [`Err`])，或者将函数应用于包含的值 (如果 [`Ok`])，",
        "translate": ""
    },
    {
        "source": "Maps a `Result<T, E>` to `U` by applying a fallback function to a contained [`Err`] value, or a default function to a contained [`Ok`] value.",
        "suggest": "Maps 通过将回退函数应用于包含的 [`Err`] 值，或将默认函数应用于包含的 [`Ok`] 值，将 `Result<T, E>` 转换为 `U`。",
        "translate": ""
    },
    {
        "source": "Returns the contained [`Err`] value, but never panics.",
        "suggest": "返回包含的 [`Err`] 值，但从不返回 panics。",
        "translate": ""
    },
    {
        "source": "Unlike [`unwrap_err`], this method is known to never panic on the result types it is implemented for.",
        "suggest": "与 [`unwrap_err`] 不同，已知此方法永远不会在其实现的结果类型上使用 panic。",
        "translate": ""
    },
    {
        "source": "Therefore, it can be used instead of `unwrap_err` as a maintainability safeguard that will fail to compile if the ok type of the `Result` is later changed to a type that can actually occur.",
        "suggest": "因此，它可以代替 `unwrap_err` 用作可维护性保障，如果 `Result` 的 ok 类型稍后更改为实际可以发生的类型，则将无法编译。",
        "translate": ""
    },
    {
        "source": "Returns an iterator that produces an escaped version of this slice, treating it as an ASCII string.",
        "suggest": "返回一个迭代器，该迭代器产生此转义版本的一个 ASCII 字符串，将其视为一个 ASCII 字符串。",
        "translate": ""
    },
    {
        "source": "An iterator over the escaped version of a byte slice.",
        "suggest": "一个字节的转义版本的迭代器。",
        "translate": ""
    },
    {
        "source": "This `struct` is created by the [`slice::escape_ascii`] method.",
        "suggest": "这个 `struct` 是由 [`slice::escape_ascii`] 方法创建的。",
        "translate": ""
    },
    {
        "source": "Convert pair of `ops::Bound`s into `ops::Range` without performing any bounds checking and (in debug) overflow checking",
        "suggest": "将一对 `ops::Bound` 转换为 `ops::Range` 而不执行任何边界检查和 (在调试中) 溢出检查",
        "translate": ""
    },
    {
        "source": "Convert pair of `ops::Bound`s into `ops::Range`.",
        "suggest": "将一对 `ops::Bound` 转换为 `ops::Range`。",
        "translate": ""
    },
    {
        "source": "Returns `None` on overflowing indices.",
        "suggest": "在索引溢出时返回 `None`。",
        "translate": ""
    },
    {
        "source": "Don't bother with checking `start < end` and `end <= len` since these checks are handled by `Range` impls",
        "suggest": "不要费心检查 `start < end` 和 `end <= len`，因为这些检查是由 `Range` impls 处理的",
        "translate": ""
    },
    {
        "source": "Panics on overflowing indices.",
        "suggest": "Panics 关于溢出的索引。",
        "translate": ""
    },
    {
        "source": "same as the `get_unchecked` above",
        "suggest": "与上面的 `get_unchecked` 相同",
        "translate": ""
    },
    {
        "source": "The size_of check above ensures that values are 1 byte wide, as required for the transmute and write_bytes",
        "suggest": "上述检查的大小确保值为 1 字节宽，这是转换和写入字节所需要的",
        "translate": ""
    },
    {
        "source": "Returns the byte position of the next character, or the length of the underlying string if there are no more characters.",
        "suggest": "返回下一个字符的字节位置，如果没有更多字符，则返回底层字符串的长度。",
        "translate": ""
    },
    {
        "source": "May vary by platform as necessary.",
        "suggest": "根据平台的需要可能有所不同。",
        "translate": ""
    },
    {
        "source": "Must be able to contain the difference between two instances of [`Instant`] or two instances of [`SystemTime`].",
        "suggest": "必须能够包含两个 [`Instant`] 实例或两个 [`SystemTime`] 实例之间的差异。",
        "translate": ""
    },
    {
        "source": "This constraint gives it a value of about 584,942,417,355 years in practice, which is currently used on all platforms.",
        "suggest": "该约束使其在实践中的值约为 584,942,417,355 年，目前在所有平台上都使用。",
        "translate": ""
    },
    {
        "source": "Remove this test when `std::raw` is removed.",
        "suggest": "移除 `std::raw` 时移除此测试。",
        "translate": ""
    },
    {
        "source": "The replacement pointer metadata APIs are tested in library/core/tests/ptr.rs",
        "suggest": "替换指针元数据 API 在 library/core/tests/ptr.rs 中测试",
        "translate": ""
    },
    {
        "source": "IEEE 754 floating point compliance tests",
        "suggest": "IEEE 754 浮点符合性测试",
        "translate": ""
    },
    {
        "source": "To understand IEEE 754's requirements on a programming language, one must understand that the requirements of IEEE 754 rest on the total programming environment, and not entirely on any one component.",
        "suggest": "要了解 IEEE 754 对编程语言的要求，必须了解 IEEE 754 的要求取决于整个编程环境，而不是完全取决于任何一个组件。",
        "translate": ""
    },
    {
        "source": "That means the hardware, language, and even libraries are considered part of conforming floating point support in a programming environment.",
        "suggest": "这意味着硬件、语言甚至库都被视为编程环境中符合浮点支持的一部分。",
        "translate": ""
    },
    {
        "source": "A programming language's duty, accordingly, is:",
        "suggest": "因此，编程语言的职责是:",
        "translate": ""
    },
    {
        "source": "offer access to the hardware where the hardware offers support",
        "suggest": "提供对硬件提供支持的硬件的访问",
        "translate": ""
    },
    {
        "source": "provide operations that fulfill the remaining requirements of the standard",
        "suggest": "提供满足标准剩余要求的操作",
        "translate": ""
    },
    {
        "source": "provide the ability to write additional software that can fulfill those requirements",
        "suggest": "提供编写能够满足这些需求的附加软件的能力",
        "translate": ""
    },
    {
        "source": "This may be fulfilled in any combination that the language sees fit.",
        "suggest": "这可以通过语言认为合适的任何组合来实现。",
        "translate": ""
    },
    {
        "source": "However, to claim that a language supports IEEE 754 is to suggest that it has fulfilled requirements 1 and 2, without deferring minimum requirements to libraries.",
        "suggest": "然而，声称一种语言支持 IEEE 754 是在暗示它已经满足了要求 1 和 2，而没有将最低要求提交给库",
        "translate": ""
    },
    {
        "source": "This is because support for IEEE 754 is defined as complete support for at least one specified floating point type as an \"arithmetic\" and \"interchange\" format, plus specified type conversions to \"external character sequences\" and integer types.",
        "suggest": "这是因为对 IEEE 754 的支持被定义为完全支持至少一种指定的浮点类型，如算术和交换格式，以及到外部字符序列和整数类型的指定类型转换。",
        "translate": ""
    },
    {
        "source": "For our purposes, \"interchange format\"          => f32, f64 \"arithmetic format\"           => f32, f64, and any \"soft floats\" \"external character sequence\" => str from any float \"integer format\"              => {i,u}{8,16,32,64,128}",
        "suggest": "出于我们的目的，\"交换格式\" => f32、f64 \"算术格式\" => f32、f64 和任何 \"软浮点数\" \"外部字符序列\" => 来自任何浮点数 \"整数格式\" => {i,u}{8,16,32,64,128} 的 str",
        "translate": ""
    },
    {
        "source": "None of these tests are against Rust's own implementation.",
        "suggest": "这些测试都不是针对 Rust 自己的实现的。",
        "translate": ""
    },
    {
        "source": "They are only tests against the standard.",
        "suggest": "它们只是针对标准的测试。",
        "translate": ""
    },
    {
        "source": "That is why they accept wildly diverse inputs or may seem to duplicate other tests.",
        "suggest": "这就是为什么他们接受各种各样的输入或似乎重复其他测试的原因。",
        "translate": ""
    },
    {
        "source": "Please consider this carefully when adding, removing, or reorganizing these tests.",
        "suggest": "在添加、删除或重新组织这些测试时，请仔细考虑这一点。",
        "translate": ""
    },
    {
        "source": "They are here so that it is clear what tests are required by the standard and what can be changed.",
        "suggest": "它们在这里是为了清楚标准要求哪些测试以及可以更改哪些测试。",
        "translate": ""
    },
    {
        "source": "IEEE 754 for many tests is applied to specific bit patterns.",
        "suggest": "许多测试的 IEEE 754 适用于特定的位模式。",
        "translate": ""
    },
    {
        "source": "These generally are not applicable to NaN, however.",
        "suggest": "但是，这些通常不适用于 NaN。",
        "translate": ""
    },
    {
        "source": "ToString uses the default fmt::Display impl without special concerns, and bypasses other parts of the formatting infrastructure, which makes it ideal for testing here.",
        "suggest": "ToString 使用默认的 fmt::Display impl 没有特别的顾虑，并绕过格式结构体的其他部分，这使得它非常适合这里的测试。",
        "translate": ""
    },
    {
        "source": "We must preserve signs on all numbers.",
        "suggest": "我们必须保留所有数字上的符号。",
        "translate": ""
    },
    {
        "source": "That includes zero.",
        "suggest": "这包括零。",
        "translate": ""
    },
    {
        "source": "and 0 are == normally, so test bit equality.",
        "suggest": "和 0 通常是 ==，所以测试位相等。",
        "translate": ""
    },
    {
        "source": "\"+\"?(\"inf\"|\"infinity\") in any case => Infinity",
        "suggest": "\"+\"?(\"inf\"|\"infinity\") 在任何情况下 => 无穷大",
        "translate": ""
    },
    {
        "source": "yes! this means you are weLcOmE tO mY iNfInItElY tWiStEd MiNd",
        "suggest": "是的。这意味着欢迎您来到我无限扭曲的心灵",
        "translate": ""
    },
    {
        "source": "\"-inf\"|\"-infinity\" in any case => Negative Infinity",
        "suggest": "\"-inf\"|\"-infinity\" 在任何情况下 => 负无穷大",
        "translate": ""
    },
    {
        "source": "(\"+\"|\"-\"\")?\"s\"?\"nan\" in any case => qNaN",
        "suggest": "(\"+\"|\"-\"\")?\"s\"?\"nan\" 在任何情况下 => qNaN",
        "translate": ""
    },
    {
        "source": "Forward the abort message to libc's android_set_abort_message.",
        "suggest": "将终止消息转发到 libc 的 android_set_abort_message。",
        "translate": ""
    },
    {
        "source": "We try our best to populate the message but as this function may already be called as part of a failed allocation, it may not be possible to do so.",
        "suggest": "我们尽最大努力填充消息，但是由于该函数可能已经作为失败分配的一部分被调用，因此可能无法这样做。",
        "translate": ""
    },
    {
        "source": "Some methods of core are on purpose avoided (such as try_reserve) as these rely on the correct resolution of rust_eh_personality which is loosely defined in panic_abort.",
        "suggest": "core 的一些方法是故意避免的 (例如 try_reserve)，因为这些方法依赖于 rust_eh_personality 的正确解析，它在 panic_abort 中松散地定义。",
        "translate": ""
    },
    {
        "source": "Weakly resolve the symbol for android_set_abort_message.",
        "suggest": "弱解析 android_set_abort_message 的符号。",
        "translate": ""
    },
    {
        "source": "This function is only available for API >= 21.",
        "suggest": "此函数仅适用于 API >= 21。",
        "translate": ""
    },
    {
        "source": "Allocate a new buffer to append the null byte.",
        "suggest": "分配一个新缓冲区以附加空字节。",
        "translate": ""
    },
    {
        "source": "allocation failure",
        "suggest": "分配失败",
        "translate": ""
    },
    {
        "source": "has the ability to attach a message as part of the abort.",
        "suggest": "能够附加消息作为中止的一部分。",
        "translate": ""
    },
    {
        "source": "Note that the returned iterator will not check if the environment variables are valid Unicode.",
        "suggest": "请注意，返回的迭代器不会检查环境变量是否为有效的 Unicode。",
        "translate": ""
    },
    {
        "source": "If you want to panic on invalid UTF-8, use the [`vars`] function instead.",
        "suggest": "如果您想在无效的 UTF-8 上使用 panic，请改用 [`vars`] 函数。",
        "translate": ""
    },
    {
        "source": "Errors if the environment variable is not present.",
        "suggest": "如果环境变量不存在，则会出错。",
        "translate": ""
    },
    {
        "source": "Errors if the environment variable is not valid Unicode.",
        "suggest": "如果环境变量不是有效的 Unicode，则会出错。",
        "translate": ""
    },
    {
        "source": "If this is not desired, consider using [`var_os`].",
        "suggest": "如果不需要，请考虑使用 [`var_os`]。",
        "translate": ""
    },
    {
        "source": "Note that the method will not check if the environment variable is valid Unicode.",
        "suggest": "请注意，该方法不会检查环境变量是否为有效的 Unicode。",
        "translate": ""
    },
    {
        "source": "If you want to have an error on invalid UTF-8, use the [`var`] function instead.",
        "suggest": "如果您想在无效的 UTF-8 上出错，请改用 [`var`] 函数。",
        "translate": ""
    },
    {
        "source": "glibc passes `argc`, `argv`, and `envp` to functions in `.init_array`, as a non-standard extension.",
        "suggest": "glibc 将 `argc`、`argv` 和 `envp` 作为非标准扩展传递给 `.init_array` 中的函数。",
        "translate": ""
    },
    {
        "source": "The returned iterator will panic during iteration if any argument to the process is not valid Unicode.",
        "suggest": "如果进程的任何参数不是有效的 Unicode，则返回的迭代器将在迭代期间 panic。",
        "translate": ""
    },
    {
        "source": "This allows `std::env::args_os` to work even in a `cdylib` or `staticlib`, as it does on macOS and Windows.",
        "suggest": "这使得 `std::env::args_os` 甚至可以在 `cdylib` 或 `staticlib` 中工作，就像在 macOS 和 Windows 上一样。",
        "translate": ""
    },
    {
        "source": "Note that the returned iterator will not check if the arguments to the process are valid Unicode.",
        "suggest": "请注意，返回的迭代器不会检查进程的参数是否为有效的 Unicode。",
        "translate": ""
    },
    {
        "source": "If you want to panic on invalid UTF-8, use the [`args`] function instead.",
        "suggest": "如果您想在无效的 UTF-8 上使用 panic，请改用 [`args`] 函数。",
        "translate": ""
    },
    {
        "source": "Errors must describe themselves through the [`Display`] and [`Debug`] traits.",
        "suggest": "错误必须通过 [`Display`] 和 [`Debug`] traits 来描述自己。",
        "translate": ""
    },
    {
        "source": "Error messages are typically concise lowercase sentences without trailing punctuation:",
        "suggest": "错误消息通常是简洁的小写句子，没有尾随标点符号:",
        "translate": ""
    },
    {
        "source": "Errors may provide cause chain information.",
        "suggest": "错误可能会提供原因链信息。",
        "translate": ""
    },
    {
        "source": "[`Error::source()`] is generally used when errors cross \"abstraction boundaries\".",
        "suggest": "[`Error::source()`] 通常在错误交叉 \"abstraction boundaries\" 时使用。",
        "translate": ""
    },
    {
        "source": "CString has a length at least 1",
        "suggest": "CString 的长度至少为 1",
        "translate": ""
    },
    {
        "source": "to_bytes_with_nul returns slice with length at least 1",
        "suggest": "to_bytes_with_nul 返回长度至少为 1 的字节",
        "translate": ""
    },
    {
        "source": "Converts a [`Box`]`<`[`OsStr`]`>` into an [`OsString`] without copying or allocating.",
        "suggest": "无需复制或分配即可将 [`Box`]`<`[`OsStr`]`>` 转换为 [`OsString`]。",
        "translate": ""
    },
    {
        "source": "is neither a regular file nor a symlink to a regular file.",
        "suggest": "既不是普通文件，也不是普通文件的符号链接。",
        "translate": ""
    },
    {
        "source": "The current process does not have the permission rights to read `from` or write `to`.",
        "suggest": "当前进程没有读取 `from` 或写入 `to` 的权限。",
        "translate": ""
    },
    {
        "source": "is a fat pointer, but &&str is a thin pointer.",
        "suggest": "是一个胖指针，而 && str 是一个瘦指针。",
        "translate": ""
    },
    {
        "source": "This operation is unsupported on this platform.",
        "suggest": "此平台不支持此操作。",
        "translate": ""
    },
    {
        "source": "This means that the operation can never succeed.",
        "suggest": "这意味着操作永远不会成功。",
        "translate": ""
    },
    {
        "source": "Creates a new I/O error from a known kind of error as well as a constant message.",
        "suggest": "从已知类型的错误以及恒定消息创建一个新的 I/O 错误。",
        "translate": ""
    },
    {
        "source": "This function does not allocate.",
        "suggest": "这个函数不分配。",
        "translate": ""
    },
    {
        "source": "This function should maybe change to",
        "suggest": "这个函数应该改成",
        "translate": ""
    },
    {
        "source": "in the future, when const generics allow that.",
        "suggest": "在 future 中，当 const 泛型允许时。",
        "translate": ""
    },
    {
        "source": "For more information on the `move` keyword, see the [closures][closure] section of the Rust book or the [threads] section.",
        "suggest": "有关 `move` 关键字的更多信息，请参见 Rust 书籍的 [闭包][closure] 部分或 [线程][threads] 部分。",
        "translate": ""
    },
    {
        "source": "Do not assume that this type has the same memory layout as the underlying system representation.",
        "suggest": "不要假设此类型与底层系统表示具有相同的内存布局。",
        "translate": ""
    },
    {
        "source": "Do not assume that this struct is implemented as the underlying system representation.",
        "suggest": "不要假设这个结构体是作为底层系统表示实现的。",
        "translate": ""
    },
    {
        "source": "The memory layout is not part of the stable interface that std exposes.",
        "suggest": "内存布局不是 std 公开的稳定接口的一部分。",
        "translate": ""
    },
    {
        "source": "Notably, octal numbers and hexadecimal numbers are not allowed per [IETF RFC 6943].",
        "suggest": "值得注意的是，每个 [IETF RFC 6943] 不允许使用八进制数和十六进制数。",
        "translate": ""
    },
    {
        "source": "This corresponds to the constant `INADDR_ANY` in other languages.",
        "suggest": "这对应于其他语言中的常量 `INADDR_ANY`。",
        "translate": ""
    },
    {
        "source": "Peek the next character from the input",
        "suggest": "Peek 输入的下一个字符",
        "translate": ""
    },
    {
        "source": "Disallow octal number in IP string.",
        "suggest": "禁止在 IP 字符串中使用八进制数。",
        "translate": ""
    },
    {
        "source": "Converts an [`OsString`] into a [`PathBuf`]",
        "suggest": "将 [`OsString`] 转换为 [`PathBuf`]",
        "translate": ""
    },
    {
        "source": "Converts a [`PathBuf`] into an [`OsString`]",
        "suggest": "将 [`PathBuf`] 转换为 [`OsString`]",
        "translate": ""
    },
    {
        "source": "Converts a [`String`] into a [`PathBuf`]",
        "suggest": "将 [`String`] 转换为 [`PathBuf`]",
        "translate": ""
    },
    {
        "source": "Converts a [`PathBuf`] into an [`Arc`] by moving the [`PathBuf`] data into a new [`Arc`] buffer.",
        "suggest": "通过将 [`PathBuf`] 数据移动到新的 [`Arc`] 缓冲区，将 [`PathBuf`] 转换为 [`Arc`]。",
        "translate": ""
    },
    {
        "source": "Converts a [`Path`] into an [`Arc`] by copying the [`Path`] data into a new [`Arc`] buffer.",
        "suggest": "通过将 [`Path`] 数据复制到新的 [`Arc`] 缓冲区，将 [`Path`] 转换为 [`Arc`]。",
        "translate": ""
    },
    {
        "source": "Converts a [`PathBuf`] into an [`Rc`] by moving the [`PathBuf`] data into a new `Rc` buffer.",
        "suggest": "通过将 [`PathBuf`] 数据移动到新的 `Rc` 缓冲区，将 [`PathBuf`] 转换为 [`Rc`]。",
        "translate": ""
    },
    {
        "source": "Converts a [`Path`] into an [`Rc`] by copying the [`Path`] data into a new `Rc` buffer.",
        "suggest": "通过将 [`Path`] 数据复制到新的 `Rc` 缓冲区，将 [`Path`] 转换为 [`Rc`]。",
        "translate": ""
    },
    {
        "source": "<code>[std::marker]::{[Copy], [Send], [Sized], [Sync], [Unpin]}</code>, marker traits that indicate fundamental properties of types.",
        "suggest": "<code>[std::marker]::{[Copy], [Send], [Sized], [Sync], [Unpin]}</code>，指示类型基本属性的标记 traits。",
        "translate": ""
    },
    {
        "source": "<code>[std::ops]::{[Drop], [Fn], [FnMut], [FnOnce]}</code>, various operations for both destructors and overloading `()`.",
        "suggest": "<code>[std::ops]::{[Drop], [Fn], [FnMut], [FnOnce]}</code>，用于析构函数和重载 `()` 的各种操作。",
        "translate": ""
    },
    {
        "source": "<code>[std::mem]::[drop][mem::drop]</code>, a convenience function for explicitly dropping a value.",
        "suggest": "<code>[std::mem]::[drop][mem::drop]</code>，一种用于明确丢弃值的便利功能。",
        "translate": ""
    },
    {
        "source": "<code>[std::boxed]::[Box]</code>, a way to allocate values on the heap.",
        "suggest": "<code>[std::boxed]::[Box]</code>，一种在堆上分配值的方法。",
        "translate": ""
    },
    {
        "source": "<code>[std::borrow]::[ToOwned]</code>, the conversion trait that defines [`to_owned`], the generic method for creating an owned type from a borrowed type.",
        "suggest": "<code>[std::borrow]::[ToOwned]</code>，定义 [`to_owned`] 的转换 trait，泛型从借用类型创建拥有所有权的类型的方法。",
        "translate": ""
    },
    {
        "source": "<code>[std::clone]::[Clone]</code>, the ubiquitous trait that defines [`clone`][Clone::clone], the method for producing a copy of a value.",
        "suggest": "<code>[std::clone]::[Clone]</code>，无处不在的 trait 定义了 [`clone`][Clone::clone]，生成值的副本的方法。",
        "translate": ""
    },
    {
        "source": "<code>[std::cmp]::{[PartialEq], [PartialOrd], [Eq], [Ord]}</code>, the comparison traits, which implement the comparison operators and are often seen in trait bounds.",
        "suggest": "<code>[std::cmp]::{[PartialEq], [PartialOrd], [Eq], [Ord]}</code>，比较 traits，实现比较一致，经常在 trait bounds 中看到。",
        "translate": ""
    },
    {
        "source": "<code>[std::convert]::{[AsRef], [AsMut], [Into], [From]}</code>, generic conversions, used by savvy API authors to create overloaded methods.",
        "suggest": "<code>[std::convert]::{[AsRef], [AsMut], [Into], [From]}</code>, 泛型转换，由精明的 API 作者用来创建重载方法。",
        "translate": ""
    },
    {
        "source": "<code>[std::default]::[Default]</code>, types that have default values.",
        "suggest": "<code>[std::default]::[Default]</code>，具有默认值的类型。",
        "translate": ""
    },
    {
        "source": "<code>[std::iter]::{[Iterator], [Extend], [IntoIterator], [DoubleEndedIterator], [ExactSizeIterator]}</code>, iterators of various kinds.",
        "suggest": "<code>[std::iter]::{[Iterator], [Extend], [IntoIterator], [DoubleEndedIterator], [ExactSizeIterator]}</code>，各种迭代器。",
        "translate": ""
    },
    {
        "source": "<code>[std::option]::[Option]::{[self][Option], [Some], [None]}</code>, a type which expresses the presence or absence of a value.",
        "suggest": "<code>[std::option]::[Option]::{[self][Option], [Some], [None]}</code>，一种表示值存在与否的类型。",
        "translate": ""
    },
    {
        "source": "<code>[std::result]::[Result]::{[self][Result], [Ok], [Err]}</code>, a type for functions that may succeed or fail.",
        "suggest": "<code>[std::result]::[Result]::{[self][Result], [Ok], [Err]}</code>，一种可能成功或失败的函数类型。",
        "translate": ""
    },
    {
        "source": "<code>[std::string]::{[String], [ToString]}</code>, heap-allocated strings.",
        "suggest": "<code>[std::string]::{[String], [ToString]}</code>，堆分配的字符串。",
        "translate": ""
    },
    {
        "source": "<code>[std::vec]::[Vec]</code>, a growable, heap-allocated vector.",
        "suggest": "<code>[std::vec]::[Vec]</code>，一个可增长的、堆分配的 vector。",
        "translate": ""
    },
    {
        "source": "override our `deny(warnings)`",
        "suggest": "覆盖我们的 `deny(warnings)`",
        "translate": ""
    },
    {
        "source": "This creates a slice iterator, producing references to each value.",
        "suggest": "这将创建一个切片迭代器，产生对每个值的引用。",
        "translate": ""
    },
    {
        "source": "The `array_into_iter` lint suggests this change for future compatibility:",
        "suggest": "`array_into_iter` lint 建议进行此更改以实现未来兼容性:",
        "translate": ""
    },
    {
        "source": "You can explicitly iterate an array by value using `IntoIterator::into_iter` or `std::array::IntoIter::new`:",
        "suggest": "您可以使用 `IntoIterator::into_iter` 或 `std::array::IntoIter::new` 按值显式迭代数组:",
        "translate": ""
    },
    {
        "source": "ignored because 2021 testing is still unstable",
        "suggest": "被忽略，因为 2021 测试仍然不稳定",
        "translate": ""
    },
    {
        "source": "This iterates by reference:",
        "suggest": "这通过引用进行迭代:",
        "translate": ""
    },
    {
        "source": "This iterates by value:",
        "suggest": "这是按值迭代的:",
        "translate": ""
    },
    {
        "source": "IntoIter can also start a chain.",
        "suggest": "IntoIter 也可以启动一个链。",
        "translate": ""
    },
    {
        "source": "(implemented for `[T; N]`, `&[T; N]` and `&mut [T; N]`)",
        "suggest": "(为 `[T; N]`、`&[T; N]` 和 `&mut [T; N]` 实现)",
        "translate": ""
    },
    {
        "source": "You can also iterate over reference to the array's elements:",
        "suggest": "您还可以迭代数组元素的引用:",
        "translate": ""
    },
    {
        "source": "Prior to Rust 1.53, arrays did not implement `IntoIterator` by value, so the method call `array.into_iter()` auto-referenced into a slice iterator.",
        "suggest": "在 Rust 1.53 之前，数组没有通过值实现 `IntoIterator`，因此该方法调用 `array.into_iter()` 自动引用到切片迭代器中。",
        "translate": ""
    },
    {
        "source": "Right now, the old behavior is preserved in the 2015 and 2018 editions of Rust for compatibility, ignoring `IntoIterator` by value.",
        "suggest": "现在，为了兼容性，旧的行为被保留在 2015 和 2018 年版本的 Rust 中，忽略了 `IntoIterator` 的值。",
        "translate": ""
    },
    {
        "source": "In the future, the behavior on the 2015 and 2018 edition might be made consistent to the behavior of later editions.",
        "suggest": "将来，2015 年和 2018 年版本的行为可能会与以后版本的行为一致。",
        "translate": ""
    },
    {
        "source": "Starting in the 2021 edition, `array.into_iter()` will use `IntoIterator` normally to iterate by value, and `iter()` should be used to iterate by reference like previous editions.",
        "suggest": "从 2021 年版开始，`array.into_iter()` 通常会使用 `IntoIterator` 按值迭代，`iter()` 应该像以前的版本一样用于按引用迭代。",
        "translate": ""
    },
    {
        "source": "Future language versions might start treating the `array.into_iter()` syntax on editions 2015 and 2018 the same as on edition 2021.",
        "suggest": "未来的语言版本可能会开始将 2015 和 2018 版的 `array.into_iter()` 语法与 2021 版相同。",
        "translate": ""
    },
    {
        "source": "So code using those older editions should still be written with this change in mind, to prevent breakage in the future.",
        "suggest": "因此，在编写使用这些旧版本的代码时仍应牢记这一更改，以防止将来出现破坏。",
        "translate": ""
    },
    {
        "source": "The safest way to accomplish this is to avoid the `into_iter` syntax on those editions.",
        "suggest": "实现这一点最安全的方法是避免这些版本中的 `into_iter` 语法。",
        "translate": ""
    },
    {
        "source": "If an edition update is not viable/desired, there are multiple alternatives:",
        "suggest": "如果版本更新不是不可行/不理想，则有多种选择:",
        "translate": ""
    },
    {
        "source": "use `iter`, equivalent to the old behavior, creating references",
        "suggest": "使用 `iter`，相当于旧行为，创建引用",
        "translate": ""
    },
    {
        "source": "use [`array::IntoIter`], equivalent to the post-2021 behavior (Rust 1.51+)",
        "suggest": "使用 [`array::IntoIter`]，相当于 2021 年后的行为 (Rust 1.51+)",
        "translate": ""
    },
    {
        "source": "replace `for ...",
        "suggest": "替换 `for ....",
        "translate": ""
    },
    {
        "source": "in array.into_iter() {` with `for ...",
        "suggest": "in array.into_iter() {` 和 `for ...",
        "translate": ""
    },
    {
        "source": "in array {`, equivalent to the post-2021 behavior (Rust 1.53+)",
        "suggest": "in array {`，相当于 2021 年后的行为 (Rust 1.53+)",
        "translate": ""
    },
    {
        "source": "Additionally, `f32` can represent some special values:",
        "suggest": "此外，`f32` 可以表示一些特殊值:",
        "translate": ""
    },
    {
        "source": "−0.0: IEEE 754 floating point numbers have a bit that indicates their sign, so −0.0 is a possible value.",
        "suggest": "-0.0: IEEE 754 浮点数有一个表示它们的符号的位，所以 `-0.0` 是一个可能的值。",
        "translate": ""
    },
    {
        "source": "For comparison −0.0 = +0.0, but floating point operations can carry the sign bit through arithmetic operations.",
        "suggest": "对于比较 `-0.0 = +0.0`，但浮点运算可以通过算术运算携带符号位。",
        "translate": ""
    },
    {
        "source": "This means −0.0 × +0.0 produces −0.0 and a negative number rounded to a value smaller than a float can represent also produces −0.0.",
        "suggest": "这意味着 `-0.0 × +0.0` 产生 `-0.0`，四舍五入到小于浮点值的负数也产生 `-0.0`。",
        "translate": ""
    },
    {
        "source": "Only called once during runtime initialization.",
        "suggest": "在运行时初始化期间只调用一次。",
        "translate": ""
    },
    {
        "source": "Luckily `park` comes with the guarantee that if it got an `unpark` just before on an unparked thread it does not park.",
        "suggest": "幸运的是，`park` 保证如果它在未停放的线程上获得 `unpark`，则它不会 park。",
        "translate": ""
    },
    {
        "source": "This is generally created by methods like [`Mutex::lock`](crate::sync::Mutex::lock) or [`RwLock::read`](crate::sync::RwLock::read).",
        "suggest": "这通常是由 [`Mutex::lock`](crate::sync::Mutex::lock) 或 [`RwLock::read`](crate::sync::RwLock::read) 之类的方法创建的。",
        "translate": ""
    },
    {
        "source": "This module contains code that is shared between all platforms, mostly utility or fallback code.",
        "suggest": "该模块包含在所有平台之间共享的代码，主要是实用程序或回退代码。",
        "translate": ""
    },
    {
        "source": "This explicitly does not include code that is shared between only a few platforms, such as when reusing an implementation from `unix` or `unsupported`.",
        "suggest": "这明确不包括仅在少数平台之间共享的代码，例如当重用来自 `unix` 或 `unsupported` 的实现时。",
        "translate": ""
    },
    {
        "source": "In those cases the desired code should be included directly using the #[path] attribute, not moved to this module.",
        "suggest": "在这些情况下，应使用 #[path] 属性直接包含所需的代码，而不是移动到此模块中。",
        "translate": ""
    },
    {
        "source": "Currently `sys_common` contains a lot of code that should live in this module, ideally `sys_common` would only contain platform-independent abstractions on top of `sys`.",
        "suggest": "目前 `sys_common` 包含很多应该存在于这个模块中的代码，理想情况下 `sys_common` 将只包含在 `sys` 之上的与平台无关的抽象。",
        "translate": ""
    },
    {
        "source": "Progress on this is tracked in #84187.",
        "suggest": "在 #84187 中跟踪了这方面的进展。",
        "translate": ""
    },
    {
        "source": "must be called only once during runtime initialization.",
        "suggest": "在运行时初始化期间只能调用一次。",
        "translate": ""
    },
    {
        "source": "this is not guaranteed to run, for example when Rust code is called externally.",
        "suggest": "这不能保证运行，例如在外部调用 Rust 代码时。",
        "translate": ""
    },
    {
        "source": "must be called only once during runtime cleanup.",
        "suggest": "在运行时清理期间只能调用一次。",
        "translate": ""
    },
    {
        "source": "this is not guaranteed to run, for example when the program aborts.",
        "suggest": "这不能保证运行，例如当程序中止时。",
        "translate": ""
    },
    {
        "source": "This module provides a synchronization primitive that does not use thread local variables.",
        "suggest": "这个模块提供了一个不使用线程局部变量的同步原语。",
        "translate": ""
    },
    {
        "source": "This is needed for signaling that a thread has finished execution.",
        "suggest": "这需要发出线程已完成执行的信号。",
        "translate": ""
    },
    {
        "source": "The signal is sent once all TLS destructors have finished at which point no new thread locals should be created.",
        "suggest": "一旦所有 TLS 析构函数完成，就发送信号，此时不应创建新的线程局部变量。",
        "translate": ""
    },
    {
        "source": "Notify the waiter.",
        "suggest": "通知等待者。",
        "translate": ""
    },
    {
        "source": "The waiter is either notified right away (if currently blocked in `Waiter::wait()`) or later when it calls the `Waiter::wait()` method.",
        "suggest": "等待者要么立即收到通知 (如果当前在 `Waiter::wait()` 中被阻止)，要么稍后在调用 `Waiter::wait()` 方法时收到通知。",
        "translate": ""
    },
    {
        "source": "Wait for a notification.",
        "suggest": "等待通知。",
        "translate": ""
    },
    {
        "source": "If `Notifier::notify()` has already been called, this will return immediately, otherwise the current thread is blocked until notified.",
        "suggest": "如果 `Notifier::notify()` 已经被调用，这将立即返回，否则当前线程被阻塞直到通知。",
        "translate": ""
    },
    {
        "source": "These symbols are all defined by `libm`, or by `compiler-builtins` on unsupported platforms.",
        "suggest": "这些符号都是由 `libm` 定义的，或者在不受支持的平台上由 `compiler-builtins` 定义。",
        "translate": ""
    },
    {
        "source": "continue working in sandbox",
        "suggest": "继续在沙盒中工作",
        "translate": ""
    },
    {
        "source": "Change the root directory of the current process to the specified path.",
        "suggest": "将当前进程的根目录更改为指定路径。",
        "translate": ""
    },
    {
        "source": "This typically requires privileges, such as root or a specific capability.",
        "suggest": "这通常需要权限，例如 root 或特定功能。",
        "translate": ""
    },
    {
        "source": "This does not change the current working directory;",
        "suggest": "这不会改变当前的工作目录;",
        "translate": ""
    },
    {
        "source": "you should call [`std::env::set_current_dir`][`crate::env::set_current_dir`] afterwards.",
        "suggest": "之后您应该调用 [`std::env::set_current_dir`][`crate::env::set_current_dir`]。",
        "translate": ""
    },
    {
        "source": "Use linux as the default platform when documenting on other platforms like Windows",
        "suggest": "在 Windows 等其他平台上进行记录时，使用 linux 作为默认平台",
        "translate": ""
    },
    {
        "source": "requires that the control pointer is NULL when the len is 0.",
        "suggest": "当 len 为 0 时，要求控制指针为 NULL。",
        "translate": ""
    },
    {
        "source": "Most operating systems, but not Linux or emscripten, return the previous pointer when its length is zero.",
        "suggest": "大多数操作系统，但不是 Linux 或 emscripten，当其长度为零时返回前一个指针。",
        "translate": ""
    },
    {
        "source": "Therefore, check if the previous pointer is the same as the current one.",
        "suggest": "因此，请检查前一个指针是否与当前指针相同。",
        "translate": ""
    },
    {
        "source": "Returns `true` if the ancillary data is empty.",
        "suggest": "如果辅助数据为空，则返回 `true`。",
        "translate": ""
    },
    {
        "source": "This is only possible if the status came from a `wait` system call which was passed `WUNTRACED`, and was then converted into an `ExitStatus`.",
        "suggest": "这仅在状态来自 `wait` 系统调用时才可能，该系统调用通过 `WUNTRACED`，然后转换为 `ExitStatus`。",
        "translate": ""
    },
    {
        "source": "This is only possible if the status came from a `wait` system call which was passed `WCONTINUED`, and was then converted into an `ExitStatus`.",
        "suggest": "这只有在状态来自 `wait` 系统调用时才有可能，该系统调用通过 `WCONTINUED`，然后转换为 `ExitStatus`。",
        "translate": ""
    },
    {
        "source": "pre_exec closures are ignored on VxWorks",
        "suggest": "在 VxWorks 上忽略 pre_exec 闭包",
        "translate": ""
    },
    {
        "source": "This method is not yet properly implemented on VxWorks",
        "suggest": "此方法尚未在 VxWorks 上正确实现",
        "translate": ""
    },
    {
        "source": "FreeBSD's stack autogrows, and optionally includes a guard page at the bottom.",
        "suggest": "FreeBSD 的栈会自动增长，并且可以选择在底部包含一个保护页面。",
        "translate": ""
    },
    {
        "source": "If we try to remap the bottom of the stack ourselves, FreeBSD's guard page moves upwards.",
        "suggest": "如果我们自己尝试重新映射栈底，FreeBSD 的保护页面就会向上移动。",
        "translate": ""
    },
    {
        "source": "So we'll just use the builtin guard page.",
        "suggest": "所以我们将只使用内置的保护页面。",
        "translate": ""
    },
    {
        "source": "Technically the number of guard pages is tunable and controlled by the security.bsd.stack_guard_page sysctl, but there are few reasons to change it from the default.",
        "suggest": "从技术上讲，保护页面的数量是由 security.bsd.stack_guard_page sysctl 可调和控制的，但几乎没有理由将其从默认值更改。",
        "translate": ""
    },
    {
        "source": "The default value has been 1 ever since FreeBSD 11.1 and 10.4.",
        "suggest": "自 FreeBSD 11.1 和 10.4 以来，默认值一直为 1。",
        "translate": ""
    },
    {
        "source": "Header must fit in the padding before an aligned pointer",
        "suggest": "标题必须适合对齐指针之前的填充",
        "translate": ""
    },
    {
        "source": "Heap memory management on Windows is done by using the system Heap API (heapapi.h)",
        "suggest": "Windows 上的堆内存管理是通过使用系统 Heap API (heapapi.h) 完成的",
        "translate": ""
    },
    {
        "source": "Flag to indicate that the memory returned by `HeapAlloc` should be zeroed.",
        "suggest": "指示 `HeapAlloc` 返回的内存应清零的标志。",
        "translate": ""
    },
    {
        "source": "Get a handle to the default heap of the current process, or null if the operation fails.",
        "suggest": "获取当前进程的默认堆的句柄，如果操作失败，则为 null。",
        "translate": ""
    },
    {
        "source": "Successful calls to this function within the same process are assumed to always return the same handle, which remains valid for the entire lifetime of the process.",
        "suggest": "假设在同一进程中成功调用此函数会返回相同的句柄，该句柄在整个进程生命周期内始终有效。",
        "translate": ""
    },
    {
        "source": "Allocate a block of `dwBytes` bytes of memory from a given heap `hHeap`.",
        "suggest": "从给定的堆 `hHeap` 分配一块 `dwBytes` 字节的内存。",
        "translate": ""
    },
    {
        "source": "The allocated memory may be uninitialized, or zeroed if `dwFlags` is set to `HEAP_ZERO_MEMORY`.",
        "suggest": "如果 `dwFlags` 设置为 `HEAP_ZERO_MEMORY`，分配的内存可能未初始化或归零。",
        "translate": ""
    },
    {
        "source": "Returns a pointer to the newly-allocated memory or null if the operation fails.",
        "suggest": "返回指向新分配内存的指针，如果操作失败，则返回 null。",
        "translate": ""
    },
    {
        "source": "The returned pointer will be aligned to at least `MIN_ALIGN`.",
        "suggest": "返回的指针将至少与 `MIN_ALIGN` 对齐。",
        "translate": ""
    },
    {
        "source": "must be a non-null handle returned by `GetProcessHeap`.",
        "suggest": "必须是 `GetProcessHeap` 返回的非空句柄。",
        "translate": ""
    },
    {
        "source": "must be set to either zero or `HEAP_ZERO_MEMORY`.",
        "suggest": "必须设置为零或 `HEAP_ZERO_MEMORY`。",
        "translate": ""
    },
    {
        "source": "Note that `dwBytes` is allowed to be zero, contrary to some other allocators.",
        "suggest": "请注意，与其他一些分配器相反，`dwBytes` 可以为零。",
        "translate": ""
    },
    {
        "source": "Reallocate a block of memory behind a given pointer `lpMem` from a given heap `hHeap`, to a block of at least `dwBytes` bytes, either shrinking the block in place, or allocating at a new location, copying memory, and freeing the original location.",
        "suggest": "将给定指针 `lpMem` 后面的一块内存从给定的堆 `hHeap` 重新分配到至少 `dwBytes` 字节的块，要么将块缩小到位，要么在新位置分配，复制内存并释放原始位置。",
        "translate": ""
    }
]
