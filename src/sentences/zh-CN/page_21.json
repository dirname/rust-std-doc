[
    {
        "source": "ERR_TIMED_OUT: The time limit for the operation elapsed before the operation completed.",
        "suggest": "ERR_TIMED_OUT: 操作完成之前经过的时间限制。",
        "translate": ""
    },
    {
        "source": "ERR_SHOULD_WAIT: The operation cannot be performed currently but potentially could succeed if the caller waits for a prerequisite to be satisfied, for example waiting for a handle to be readable or writable.",
        "suggest": "ERR_SHOULD_WAIT: 该操作当前无法执行，但是如果调用方等待先决条件得到满足，例如等待句柄可读写，则可能会成功执行该操作。",
        "translate": ""
    },
    {
        "source": "Example: Attempting to read from a message pipe that has no messages waiting but has an open remote will return ERR_SHOULD_WAIT.",
        "suggest": "示例: 尝试从没有等待消息但具有打开的远程消息的消息管道中读取，将返回 ERR_SHOULD_WAIT。",
        "translate": ""
    },
    {
        "source": "Attempting to read from a message pipe that has no messages waiting and has a closed remote end will return ERR_REMOTE_CLOSED.",
        "suggest": "尝试从没有消息等待且具有封闭的远程端的消息管道中读取将返回 ERR_REMOTE_CLOSED。",
        "translate": ""
    },
    {
        "source": "ERR_CANCELED: The in-progress operation (e.g., a wait) has been",
        "suggest": "ERR_CANCELED: 正在进行的操作 (例如，等待)",
        "translate": ""
    },
    {
        "source": "ERR_PEER_CLOSED: The operation failed because the remote end of the subject of the operation was closed.",
        "suggest": "ERR_PEER_CLOSED: 操作失败，因为操作对象的远端已关闭。",
        "translate": ""
    },
    {
        "source": "ERR_NOT_FOUND: The requested entity is not found.",
        "suggest": "ERR_NOT_FOUND: 找不到请求的实体。",
        "translate": ""
    },
    {
        "source": "ERR_ALREADY_EXISTS: An object with the specified identifier already exists.",
        "suggest": "ERR_ALREADY_EXISTS: 具有指定标识符的 object 已经存在。",
        "translate": ""
    },
    {
        "source": "Example: Attempting to create a file when a file already exists with that name.",
        "suggest": "示例: 当已经存在具有该名称的文件时，尝试创建一个文件。",
        "translate": ""
    },
    {
        "source": "ERR_ALREADY_BOUND: The operation failed because the named entity is already owned or controlled by another entity.",
        "suggest": "ERR_ALREADY_BOUND: 操作失败，因为命名实体已经由另一个实体拥有或控制。",
        "translate": ""
    },
    {
        "source": "The operation could succeed later if the current owner releases the entity.",
        "suggest": "如果当前所有者释放该实体，则该操作可能会在以后成功。",
        "translate": ""
    },
    {
        "source": "ERR_UNAVAILABLE: The subject of the operation is currently unable to perform the operation.",
        "suggest": "ERR_UNAVAILABLE: 该操作的主题当前无法执行该操作。",
        "translate": ""
    },
    {
        "source": "This is used when there's no direct way for the caller to observe when the subject will be able to perform the operation and should thus retry.",
        "suggest": "当调用者无法直接观察对象何时能够执行操作并应重试时，可以使用此方法。",
        "translate": ""
    },
    {
        "source": "Permission check errors",
        "suggest": "权限检查错误",
        "translate": ""
    },
    {
        "source": "ERR_ACCESS_DENIED: The caller did not have permission to perform the specified operation.",
        "suggest": "ERR_ACCESS_DENIED: 调用者没有执行指定操作的权限。",
        "translate": ""
    },
    {
        "source": "Input-output errors",
        "suggest": "输入输出错误",
        "translate": ""
    },
    {
        "source": "ERR_IO: Otherwise unspecified error occurred during I/O.",
        "suggest": "ERR_IO: 否则在 I/O 期间发生未指定的错误。",
        "translate": ""
    },
    {
        "source": "ERR_REFUSED: The entity the I/O operation is being performed on rejected the operation.",
        "suggest": "ERR_REFUSED: I/O 操作正在被拒绝的实体。",
        "translate": ""
    },
    {
        "source": "Example: an I2C device NAK'ing a transaction or a disk controller rejecting an invalid command.",
        "suggest": "例如: I2C 设备 NAK' 事务或磁盘控制器拒绝无效命令。",
        "translate": ""
    },
    {
        "source": "ERR_IO_DATA_INTEGRITY: The data in the operation failed an integrity check and is possibly corrupted.",
        "suggest": "ERR_IO_DATA_INTEGRITY: 操作中的数据完整性检查失败，并且可能已损坏。",
        "translate": ""
    },
    {
        "source": "Example: CRC or Parity error.",
        "suggest": "示例: CRC 或奇偶校验错误。",
        "translate": ""
    },
    {
        "source": "ERR_IO_DATA_LOSS: The data in the operation is currently unavailable and may be permanently lost.",
        "suggest": "ERR_IO_DATA_LOSS: 操作中的数据当前不可用，并且可能会永久丢失。",
        "translate": ""
    },
    {
        "source": "Example: A disk block is irrecoverably damaged.",
        "suggest": "示例: 磁盘块不可恢复地损坏。",
        "translate": ""
    },
    {
        "source": "Filesystem specific errors",
        "suggest": "文件系统特定错误",
        "translate": ""
    },
    {
        "source": "ERR_FILE_BIG: A file exceeds a filesystem-specific size limit.",
        "suggest": "ERR_FILE_BIG: 文件超出了文件系统特定的大小限制。",
        "translate": ""
    },
    {
        "source": "ERR_NO_SPACE: Filesystem or device space is exhausted.",
        "suggest": "ERR_NO_SPACE: 文件系统或设备空间已用尽。",
        "translate": ""
    },
    {
        "source": "A weak symbol allows interposition, e.g. for perf measurements that want to disable randomness for consistency.",
        "suggest": "弱符号允许插入，例如用于想要禁用一致性随机性的性能测量。",
        "translate": ""
    },
    {
        "source": "Otherwise, we'll try a raw syscall.",
        "suggest": "否则，我们将尝试原始的 syscall。",
        "translate": ""
    },
    {
        "source": "(`getrandom` was added in glibc 2.25, musl 1.1.20, android API level 28)",
        "suggest": "(在 glibc 2.25，Musl 1.1.20，android API 级别 28 中添加了 `getrandom`)",
        "translate": ""
    },
    {
        "source": "Fall back to reading /dev/urandom if `getrandom` is not supported on the current kernel.",
        "suggest": "如果当前内核不支持 `getrandom`，则回退到读取 /dev/urandom。",
        "translate": ""
    },
    {
        "source": "Also fall back in case it is disabled by something like seccomp or inside of virtual machines.",
        "suggest": "如果使用 seccomp 之类的功能或在虚拟机内部将其禁用，也请回退。",
        "translate": ""
    },
    {
        "source": "getrandom_fill_bytes here can fail if getrandom() returns EAGAIN, meaning it would have blocked because the non-blocking pool (urandom) has not initialized in the kernel yet due to a lack of entropy.",
        "suggest": "如果 getrandom() 返回 EAGAIN，则 getrandom_fill_bytes 可能失败，这意味着它会被阻塞，因为非阻塞池 (urandom) 由于缺少熵而尚未在内核中初始化。",
        "translate": ""
    },
    {
        "source": "The fallback we do here is to avoid blocking applications which could depend on this call without ever knowing they do and don't have a work around.",
        "suggest": "我们这样做的后盾是避免阻塞可能依赖于此调用的应用程序，而无需知道它们是否起作用。",
        "translate": ""
    },
    {
        "source": "The PRNG of /dev/urandom will still be used but over a possibly predictable entropy pool.",
        "suggest": "/dev/urandom 的 PRNG 仍将使用，但要在可能可预测的熵池上使用。",
        "translate": ""
    },
    {
        "source": "getrandom failed because it is permanently or temporarily (because of missing entropy) unavailable.",
        "suggest": "getrandom 失败，因为它永久或暂时 (由于缺少熵) 不可用。",
        "translate": ""
    },
    {
        "source": "Open /dev/urandom, read from it, and close it again.",
        "suggest": "打开 /dev/urandom，从中读取，然后再次将其关闭。",
        "translate": ""
    },
    {
        "source": "permits a maximum buffer size of 256 bytes",
        "suggest": "允许最大缓冲区大小为 256 字节",
        "translate": ""
    },
    {
        "source": "for older macos which doesn't support getentropy",
        "suggest": "对于不支持熵的较旧 macos",
        "translate": ""
    },
    {
        "source": "On iOS and MacOS `SecRandomCopyBytes` calls `CCRandomCopyBytes` with `kCCRandomDefault`.",
        "suggest": "在 iOS 和 MacOS 上，`SecRandomCopyBytes` 用 `kCCRandomDefault` 调用 `CCRandomCopyBytes`。",
        "translate": ""
    },
    {
        "source": "manages a CSPRNG which is seeded from `/dev/random` and which runs on its own thread accessed via GCD.",
        "suggest": "管理从 `/dev/random` 播种的 CSPRNG，该 CSPRNG 在通过 GCD 访问的其自己的线程上运行。",
        "translate": ""
    },
    {
        "source": "This seems needlessly heavyweight for the purposes of generating two u64s once per thread in `hashmap_random_keys`.",
        "suggest": "为了在 `hashmap_random_keys` 中每个线程一次生成两个 u64，这似乎不必要。",
        "translate": ""
    },
    {
        "source": "Therefore `SecRandomCopyBytes` is only used on iOS where direct access to `/dev/urandom` is blocked by the sandbox.",
        "suggest": "因此，`SecRandomCopyBytes` 仅在沙箱阻止直接访问 `/dev/urandom` 的 iOS 上使用。",
        "translate": ""
    },
    {
        "source": "Open rand:, read from it, and close it again.",
        "suggest": "打开兰特:，从中读取，然后再次将其关闭。",
        "translate": ""
    },
    {
        "source": "guarded by the `inner` RwLock",
        "suggest": "由 `inner` RwLock 保护",
        "translate": ""
    },
    {
        "source": "According to POSIX, when a thread tries to acquire this read lock while it already holds the write lock (or vice versa, or tries to acquire the write lock twice),",
        "suggest": "根据 POSIX，当线程在已持有写锁的情况下尝试获取此读锁时 (反之亦然，或者尝试两次获取写锁)，",
        "translate": ""
    },
    {
        "source": "So, in principle, all we have to do here is check `r == 0` to be sure we properly got the lock.",
        "suggest": "因此，原则上，我们要做的就是检查 `r == 0`，以确保我们正确地获得了锁。",
        "translate": ""
    },
    {
        "source": "However, (at least) glibc before version 2.25 does not conform to this spec, and can return `r == 0` even when this thread already holds the write lock.",
        "suggest": "但是，(至少) 版本 2.25 之前的 glibc 不符合该规范，并且即使该线程已持有写锁，它也可以返回 `r == 0`。",
        "translate": ""
    },
    {
        "source": "We thus check for this situation ourselves and panic when detecting that a thread got the write lock more than once, or got a read and a write lock.",
        "suggest": "因此，当我们检测到线程多次获得写锁定，或者获得读和写锁定时，我们自己和 panic 都检查了这种情况。",
        "translate": ""
    },
    {
        "source": "Above, we make sure to only access `write_locked` when `r == 0` to avoid data races.",
        "suggest": "上面，我们确保仅在 `r == 0` 时访问 `write_locked`，以避免数据竞争。",
        "translate": ""
    },
    {
        "source": "succeeded when it should not have.",
        "suggest": "在不应该的时候成功了。",
        "translate": ""
    },
    {
        "source": "According to POSIX, for a properly initialized rwlock this can only return EAGAIN or EDEADLK or 0.",
        "suggest": "根据 POSIX，对于正确初始化的 rwlock，它只能返回 EAGAIN 或 EDEADLK 或 0。",
        "translate": ""
    },
    {
        "source": "We rely on that.",
        "suggest": "我们依靠这一点。",
        "translate": ""
    },
    {
        "source": "See comments above for why we check for EDEADLK and write_locked.",
        "suggest": "有关我们为什么检查 EDEADLK 和 write_locked 的信息，请参见上面的评论。",
        "translate": ""
    },
    {
        "source": "For the same reason, we also need to check that there are no readers (tracked in `num_readers`).",
        "suggest": "出于同样的原因，我们还需要检查是否没有 readers (在 `num_readers` 中跟踪)。",
        "translate": ""
    },
    {
        "source": "According to POSIX, for a properly initialized rwlock this can only return EDEADLK or 0.",
        "suggest": "根据 POSIX，对于正确初始化的 rwlock，此操作只能返回 EDEADLK 或 0。",
        "translate": ""
    },
    {
        "source": "On DragonFly pthread_rwlock_destroy() returns EINVAL if called on a rwlock that was just initialized with libc::PTHREAD_RWLOCK_INITIALIZER.",
        "suggest": "在 DragonFly 上，如果在刚刚用 libc::PTHREAD_RWLOCK_INITIALIZER 初始化的 rwlock 上调用，则 pthread_rwlock_destroy() 返回 EINVAL。",
        "translate": ""
    },
    {
        "source": "Once it is used (locked/unlocked) or pthread_rwlock_init() is called, this behaviour no longer occurs.",
        "suggest": "一旦使用了 (locked/unlocked) 或 pthread_rwlock_init()，将不再发生此行为。",
        "translate": ""
    },
    {
        "source": "Signal handler for the SIGSEGV and SIGBUS handlers.",
        "suggest": "SIGSEGV 和 SIGBUS 处理程序的信号处理程序。",
        "translate": ""
    },
    {
        "source": "We've got guard pages (unmapped pages) at the end of every thread's stack, so if a thread ends up running into the guard page it'll trigger this handler.",
        "suggest": "每个线程栈的末尾都有保护页面 (未映射的页面)，因此，如果线程最终运行到保护页面中，它将触发此处理程序。",
        "translate": ""
    },
    {
        "source": "We want to detect these cases and print out a helpful error saying that the stack has overflowed.",
        "suggest": "我们要检测这些情况并打印出一个有用的错误，指出栈已溢出。",
        "translate": ""
    },
    {
        "source": "All other signals, however, should go back to what they were originally supposed to do.",
        "suggest": "但是，所有其他信号应返回到它们最初应该执行的操作。",
        "translate": ""
    },
    {
        "source": "This handler currently exists purely to print an informative message whenever a thread overflows its stack.",
        "suggest": "当前，此处理程序纯粹是为了在线程溢出其栈时打印提示性消息而存在。",
        "translate": ""
    },
    {
        "source": "We then abort to exit and indicate a crash, but to avoid a misleading SIGSEGV that might lead users to believe that unsafe code has accessed an invalid pointer;",
        "suggest": "然后，我们终止以退出并指示崩溃，但要避免产生误导性的 SIGSEGV，这可能会导致用户认为不安全的代码已访问了无效的指针;",
        "translate": ""
    },
    {
        "source": "the SIGSEGV encountered when overflowing the stack is expected and well-defined.",
        "suggest": "栈溢出时遇到的 SIGSEGV 是预期的，并且定义明确。",
        "translate": ""
    },
    {
        "source": "If this is not a stack overflow, the handler un-registers itself and then returns (to allow the original signal to be delivered again).",
        "suggest": "如果这不是栈溢出，则处理程序将对其自身进行注销，然后返回 (以允许再次发送原始信号)。",
        "translate": ""
    },
    {
        "source": "Returning from this kind of signal handler is technically not defined to work when reading the POSIX spec strictly, but in practice it turns out many large systems and all implementations allow returning from a signal handler to work.",
        "suggest": "从技术上说，严格阅读 POSIX 规范时，从这种信号处理程序返回的函数没有定义为可以正常工作，但实际上，事实证明，这是许多大型系统，并且所有实现都允许从信号处理程序返回工作。",
        "translate": ""
    },
    {
        "source": "For a more detailed explanation see the comments on #26458.",
        "suggest": "有关更详细的说明，请参见 #26458 上的注释。",
        "translate": ""
    },
    {
        "source": "If the faulting address is within the guard page, then we print a message saying so and abort.",
        "suggest": "如果故障地址在保护页面内，则我们将显示一条消息，然后终止。",
        "translate": ""
    },
    {
        "source": "Unregister ourselves by reverting back to the default behavior.",
        "suggest": "通过恢复为默认行为来注销自己。",
        "translate": ""
    },
    {
        "source": "See comment above for why this function returns.",
        "suggest": "有关为什么返回此函数的信息，请参见上面的注释。",
        "translate": ""
    },
    {
        "source": "Configure our signal handler if one is not already set.",
        "suggest": "如果尚未设置信号处理程序，请进行配置。",
        "translate": ""
    },
    {
        "source": "Configure alternate signal stack, if one is not already set.",
        "suggest": "如果尚未设置备用信号栈，则配置备用信号栈。",
        "translate": ""
    },
    {
        "source": "Workaround for bug in macOS implementation of sigaltstack UNIX2003 which returns ENOMEM when disabling a stack while passing ss_size smaller than MINSIGSTKSZ.",
        "suggest": "sigaltstack UNIX2003 的 macOS 实现中的错误的变通办法，当禁用 ss_size 小于 MINSIGSTKSZ 时，该栈在禁用栈时返回 ENOMEM。",
        "translate": ""
    },
    {
        "source": "According to POSIX both ss_sp and ss_size should be ignored in this case.",
        "suggest": "根据 POSIX，在这种情况下，应同时忽略 ss_sp 和 ss_size。",
        "translate": ""
    },
    {
        "source": "We know from `get_stackp` that the alternate stack we installed is part of a mapping that started one page earlier, so walk back a page and unmap from there.",
        "suggest": "从 `get_stackp` 中我们知道，我们安装的备用栈是早于一页开始的映射的一部分，因此请返回页面并从此处取消映射。",
        "translate": ""
    },
    {
        "source": "Some platforms may have pthread_t as a pointer in which case we still want a thread to be Send/Sync",
        "suggest": "某些平台可能将 pthread_t 用作指针，在这种情况下，我们仍然希望线程为 Send/Sync",
        "translate": ""
    },
    {
        "source": "EINVAL means |stack_size| is either too small or not a multiple of the system page size.",
        "suggest": "EINVAL 表示 | stack_size | 太小或不是系统页面大小的倍数。",
        "translate": ""
    },
    {
        "source": "Because it's definitely >= PTHREAD_STACK_MIN, it must be an alignment issue.",
        "suggest": "因为肯定是 >= PTHREAD_STACK_MIN，所以它一定是对齐问题。",
        "translate": ""
    },
    {
        "source": "Round up to the nearest page and try again.",
        "suggest": "向上舍入到最近的页面，然后重试。",
        "translate": ""
    },
    {
        "source": "if the thread creation fails and this assert fails, then p will be leaked.",
        "suggest": "如果线程创建失败并且该断言失败，则 p 将被泄漏。",
        "translate": ""
    },
    {
        "source": "However, an alternative design could cause double-free which is clearly worse.",
        "suggest": "但是，替代设计可能会导致双重释放，这显然更糟。",
        "translate": ""
    },
    {
        "source": "Next, set up our stack overflow handler which may get triggered if we run out of stack.",
        "suggest": "接下来，设置我们的栈溢出处理程序，如果我们用完栈，可能会触发该处理程序。",
        "translate": ""
    },
    {
        "source": "pthread wrapper only appeared in glibc 2.12, so we use syscall directly.",
        "suggest": "pthread 包装器仅出现在 glibc 2.12 中，因此我们直接使用 syscall。",
        "translate": ""
    },
    {
        "source": "Newlib, Haiku, Emscripten, and VxWorks have no way to set a thread name.",
        "suggest": "Newlib，Haiku，Emscripten 和 VxWorks 无法设置线程名称。",
        "translate": ""
    },
    {
        "source": "determine whether Fuchsia has a way to set a thread name.",
        "suggest": "确定 Fuchsia 是否可以设置线程名称。",
        "translate": ""
    },
    {
        "source": "If we're awoken with a signal then the return value will be -1 and nanosleep will fill in `ts` with the remaining time.",
        "suggest": "如果我们被信号唤醒，则返回值为 -1，nanosleep 将使用剩余时间填充 `ts`。",
        "translate": ""
    },
    {
        "source": "This is initialized in init() and only read from after",
        "suggest": "这是在 init() 中初始化的，只能在之后读取",
        "translate": ""
    },
    {
        "source": "main thread",
        "suggest": "主线程",
        "translate": ""
    },
    {
        "source": "new thread",
        "suggest": "新线程",
        "translate": ""
    },
    {
        "source": "Precondition: PAGE_SIZE is initialized.",
        "suggest": "前提条件: PAGE_SIZE 已初始化。",
        "translate": ""
    },
    {
        "source": "Ensure stackaddr is page aligned!",
        "suggest": "确保 stackaddr 是页面对齐的!",
        "translate": ""
    },
    {
        "source": "A parent process might have reset RLIMIT_STACK to be non-page aligned.",
        "suggest": "父进程可能已将 RLIMIT_STACK 重置为非页面对齐。",
        "translate": ""
    },
    {
        "source": "The pthread_attr_getstack() reports the usable stack area stackaddr < stackaddr + stacksize, so if stackaddr is not page-aligned, calculate the fix such that stackaddr < new_page_aligned_stackaddr < stackaddr + stacksize",
        "suggest": "pthread_attr_getstack() 报告可用的栈区域 stackaddr <stackaddr + stacksize，因此，如果 stackaddr 不是页面对齐的，则计算修正值，使 stackaddr <new_page_aligned_stackaddr <stackaddr + stacksize",
        "translate": ""
    },
    {
        "source": "doesn't allocate the whole stack right away, and the kernel has its own stack-guard mechanism to fault when growing too close to an existing mapping.",
        "suggest": "不会立即分配整个栈，并且内核有其自己的栈保护机制，当它与现有映射的距离太近时会出错。",
        "translate": ""
    },
    {
        "source": "If we map our own guard, then the kernel starts enforcing a rather large gap above that, rendering much of the possible stack space useless.",
        "suggest": "如果我们使用自己的保护程序 map，则内核将开始在此之上强制执行一个较大的间隙，从而使很多可能的栈空间变得无用。",
        "translate": ""
    },
    {
        "source": "See #43052.",
        "suggest": "请参见 #43052。",
        "translate": ""
    },
    {
        "source": "Instead, we'll just note where we expect rlimit to start faulting, so our handler can report \"stack overflow\", and trust that the kernel's own stack guard will work.",
        "suggest": "取而代之的是，我们只需要注意 rlimit 会在哪里开始出错，以便我们的处理程序可以报告 \"stack overflow\"，并相信内核自己的栈保护将起作用。",
        "translate": ""
    },
    {
        "source": "For the main thread, the musl's pthread_attr_getstack returns the current stack size, rather than maximum size it can eventually grow to.",
        "suggest": "对于主线程，musl 的 pthread_attr_getstack 返回当前的栈大小，而不是其最终可以增长到的最大大小。",
        "translate": ""
    },
    {
        "source": "It cannot be used to determine the position of kernel's stack guard.",
        "suggest": "它不能用于确定内核的栈保护的位置。",
        "translate": ""
    },
    {
        "source": "Reallocate the last page of the stack.",
        "suggest": "重新分配栈的最后一页。",
        "translate": ""
    },
    {
        "source": "This ensures SIGBUS will be raised on stack overflow.",
        "suggest": "这样可以确保在栈溢出时引发 SIGBUS。",
        "translate": ""
    },
    {
        "source": "Systems which enforce strict PAX MPROTECT do not allow to mprotect() a mapping with less restrictive permissions than the initial mmap() used, so we mmap() here with read/write permissions and only then mprotect() it to no permissions at all.",
        "suggest": "强制执行严格 PAX MPROTECT 的系统不允许 mprotect() 具有比使用的初始 mmap() 少的限制性权限的映射，因此我们这里的 mmap() 具有 read/write 权限，然后只有 mprotect() 完全没有权限。",
        "translate": ""
    },
    {
        "source": "See issue #50313.",
        "suggest": "请参见 issue #50313。",
        "translate": ""
    },
    {
        "source": "musl versions before 1.1.19 always reported guard size obtained from pthread_attr_get_np as zero.",
        "suggest": "1.1.19 之前的 musl 版本始终将从 pthread_attr_get_np 获得的防护大小报告为零。",
        "translate": ""
    },
    {
        "source": "Use page size as a fallback.",
        "suggest": "使用页面大小作为后备。",
        "translate": ""
    },
    {
        "source": "FIXME does freebsd really fault *below* the guard addr?",
        "suggest": "FIXME freebsd 是否真的在 *保护地址以下* 故障?",
        "translate": ""
    },
    {
        "source": "glibc used to include the guard area within the stack, as noted in the BUGS section of `man pthread_attr_getguardsize`.",
        "suggest": "如 `man pthread_attr_getguardsize` 的 `BUGS` 部分所述，glibc 曾经将保护区包括在栈内。",
        "translate": ""
    },
    {
        "source": "This has been corrected starting with glibc 2.27, and in some distro backports, so the guard is now placed at the end (below) the stack.",
        "suggest": "从 glibc 2.27 开始，并且在某些发行版本的反向移植中，此问题已得到纠正，因此现在将保护放置在栈的 (below) 的末尾。",
        "translate": ""
    },
    {
        "source": "There's no easy way for us to know which we have at runtime, so we'll just match any fault in the range right above or below the stack base to call that fault a stack overflow.",
        "suggest": "没有简单的方法让我们知道在运行时有哪些故障，因此我们只匹配栈基础上方或下方范围内的任何故障，以调用导致栈溢出的故障。",
        "translate": ""
    },
    {
        "source": "glibc >= 2.15 has a __pthread_get_minstack() function that returns PTHREAD_STACK_MIN plus bytes needed for thread-local storage.",
        "suggest": "glibc>= 2.15 具有一个 __pthread_get_minstack() 函数，该函数返回 PTHREAD_STACK_MIN 以及线程本地存储所需的字节。",
        "translate": ""
    },
    {
        "source": "We need that information to avoid blowing up when a small stack is created in an application with big thread-local storage requirements.",
        "suggest": "我们需要这些信息，以避免在具有大量线程本地存储需求的应用程序中创建一个小的栈时发生崩溃。",
        "translate": ""
    },
    {
        "source": "See #6233 for rationale and details.",
        "suggest": "有关原理和详细信息，请参见 #6233。",
        "translate": ""
    },
    {
        "source": "No point in looking up __pthread_get_minstack() on non-glibc platforms.",
        "suggest": "在非 glibc 平台上查找 __pthread_get_minstack() 毫无意义。",
        "translate": ""
    },
    {
        "source": "just a guess",
        "suggest": "只是一个猜测",
        "translate": ""
    },
    {
        "source": "Provides thread-local destructors without an associated \"key\", which can be more efficient.",
        "suggest": "提供不具有关联的 \"key\" 的线程局部析构函数，这可以提高效率。",
        "translate": ""
    },
    {
        "source": "Since what appears to be glibc 2.18 this symbol has been shipped which GCC and clang both use to invoke destructors in thread_local globals, so let's do the same!",
        "suggest": "由于看起来好像是 glibc 2.18，因此已经发布了该符号，GCC 和 clang 都使用它们在 thread_local 全局变量中调用析构函数，所以我们做同样的事情!",
        "translate": ""
    },
    {
        "source": "Note, however, that we run on lots older linuxes, as well as cross compiling from a newer linux to an older linux, so we also have a fallback implementation to use as well.",
        "suggest": "但是请注意，我们在许多较旧的 Linux 上运行，以及从较新的 linux 到较旧的 linux 进行交叉编译，因此我们也有一个可替代的实现。",
        "translate": ""
    },
    {
        "source": "This implementation is very similar to register_dtor_fallback in sys_common/thread_local.rs.",
        "suggest": "此实现与 sys_common/thread_local.rs 中的 register_dtor_fallback 非常相似。",
        "translate": ""
    },
    {
        "source": "The main difference is that we want to hook into macOS's analog of the above linux function, _tlv_atexit.",
        "suggest": "主要区别在于我们希望将 hook 转换为上述 linux 函数 _tlv_atexit 的 macOS 模拟。",
        "translate": ""
    },
    {
        "source": "will run the registered dtors before any TLS slots get freed, and when the main thread exits.",
        "suggest": "将在释放任何 TLS 插槽之前以及在主线程退出时运行已注册的 dtor。",
        "translate": ""
    },
    {
        "source": "Unfortunately, calling _tlv_atexit while tls dtors are running is UB.",
        "suggest": "不幸的是，在 tls dtor 运行时调用 _tlv_atexit 是 UB。",
        "translate": ""
    },
    {
        "source": "The workaround below is to register, via _tlv_atexit, a custom DTOR list once per thread.",
        "suggest": "以下解决方法是每个线程通过 _tlv_atexit 注册一个自定义 DTOR 列表。",
        "translate": ""
    },
    {
        "source": "thread_local dtors are pushed to the DTOR list without calling _tlv_atexit.",
        "suggest": "将 thread_local dtor 推送到 DTOR 列表，而无需调用 _tlv_atexit。",
        "translate": ""
    },
    {
        "source": "not used on all platforms",
        "suggest": "并非在所有平台上都使用",
        "translate": ""
    },
    {
        "source": "two aspects of this `if`-`else` are required for LLVM to optimize it into a branchless form (see also #75545):",
        "suggest": "LLVM 需要将此 `if`-`else` 的两个方面优化为无分支形式 (另请参见 #75545) :",
        "translate": ""
    },
    {
        "source": "shows up as a common expression in both branches, i.e.",
        "suggest": "在两个分支中都显示为通用表达式，即",
        "translate": ""
    },
    {
        "source": "the `else` must have its `- 1` subtraction after the common one, not interleaved with it (it used to be `self.t.tv_sec - 1 - other.t.tv_sec`)",
        "suggest": "`else` 必须在公用号之后加上 `- 1` 减号，而不是与之交错 (以前是 `self.t.tv_sec - 1 - other.t.tv_sec`)",
        "translate": ""
    },
    {
        "source": "the `Duration::new` call (or any other additional complexity) is outside of the `if`-`else`, not duplicated in both branches",
        "suggest": "`Duration::new` 调用 (或其他任何其他复杂性) 在 `if`-`else` 之外，在两个分支中均不重复",
        "translate": ""
    },
    {
        "source": "Ideally this code could be rearranged such that it more directly expresses the lower-cost behavior we want from it.",
        "suggest": "理想情况下，可以重新排列此代码，以便更直接地表达我们希望从中获得的低成本行为。",
        "translate": ""
    },
    {
        "source": "INFO_BITS conceptually is an `Option<mach_timebase_info>`.",
        "suggest": "INFO_BITS 在概念上是 `Option<mach_timebase_info>`。",
        "translate": ""
    },
    {
        "source": "We can do this in 64 bits because we know 0 is never a valid value for the `denom` field.",
        "suggest": "我们可以用 64 位来完成此操作，因为我们知道 0 永远不是 `denom` 字段的有效值。",
        "translate": ""
    },
    {
        "source": "Encoding this as a single `AtomicU64` allows us to use `Relaxed` operations, as we are only interested in the effects on a single memory location.",
        "suggest": "将其编码为单个 `AtomicU64`，使我们可以使用 `Relaxed` 操作，因为我们仅对单个存储位置上的影响感兴趣。",
        "translate": ""
    },
    {
        "source": "If a previous thread has initialized `INFO_BITS`, use it.",
        "suggest": "如果先前的线程已初始化 `INFO_BITS`，请使用它。",
        "translate": ""
    },
    {
        "source": "otherwise learn for ourselves",
        "suggest": "否则要为自己学习",
        "translate": ""
    },
    {
        "source": "Support for \"weak linkage\" to symbols on Unix",
        "suggest": "支持 \"weak linkage\" 到 Unix 上的符号",
        "translate": ""
    },
    {
        "source": "Some I/O operations we do in libstd require newer versions of OSes but we need to maintain binary compatibility with older releases for now.",
        "suggest": "我们在 libstd 中执行的某些 I/O 操作需要较新版本的 OS，但目前我们需要与较早版本保持二进制兼容性。",
        "translate": ""
    },
    {
        "source": "In order to use the new functionality when available we use this module for detection.",
        "suggest": "为了在可用时使用新功能，我们使用此模块进行检测。",
        "translate": ""
    },
    {
        "source": "One option to use here is weak linkage, but that is unfortunately only really workable on Linux.",
        "suggest": "此处使用的一种选择是弱链接，但是不幸的是，仅在 Linux 上才真正可行。",
        "translate": ""
    },
    {
        "source": "Hence, use dlsym to get the symbol value at runtime.",
        "suggest": "因此，使用 dlsym 在运行时获取符号值。",
        "translate": ""
    },
    {
        "source": "This is also done for compatibility with older versions of glibc, and to avoid creating dependencies on GLIBC_PRIVATE symbols.",
        "suggest": "这样做也是为了与 glibc 的较早版本兼容，并避免在 GLIBC_PRIVATE 符号上创建依赖项。",
        "translate": ""
    },
    {
        "source": "It assumes that we've been dynamically linked to the library the symbol comes from, but that is currently always the case for things like libpthread/libc.",
        "suggest": "假定我们已经动态链接到符号所来自的库，但是对于诸如 libpthread/libc 之类的东西，目前始终如此。",
        "translate": ""
    },
    {
        "source": "A long time ago this used weak linkage for the __pthread_get_minstack symbol, but that caused Debian to detect an unnecessarily strict versioned dependency on libc6 (#23628).",
        "suggest": "很久以前，它对 __pthread_get_minstack 符号使用了弱链接，但是这导致 Debian 检测到对 libc6 (#23628) 不必要的严格版本控制。",
        "translate": ""
    },
    {
        "source": "There are a variety of `#[cfg]`s controlling which targets are involved in each instance of `weak!` and `syscall!`.",
        "suggest": "有各种 `#[cfg]` 控制 `weak!` 和 `syscall!` 的每个实例中涉及哪些目标。",
        "translate": ""
    },
    {
        "source": "Rather than trying to unify all of that, we'll just allow that some unix targets don't use this module at all.",
        "suggest": "而不是试图统一所有这些，我们只允许某些 unix 目标根本不使用此模块。",
        "translate": ""
    },
    {
        "source": "Relaxed is fine here because we fence before reading through the pointer (see the comment below).",
        "suggest": "在这里放宽是可以的，因为在读取指针之前设置了障碍(请参见下面的注释)。",
        "translate": ""
    },
    {
        "source": "The caller is presumably going to read through this value (by calling the function we've dlsymed).",
        "suggest": "可能是调用者将读取该值 (通过调用 dlsymed 的函数)。",
        "translate": ""
    },
    {
        "source": "This means we'd need to have loaded it with at least C11's consume ordering in order to be guaranteed that the data we read from the pointer isn't from before the pointer was stored.",
        "suggest": "这意味着我们需要至少用 C11 的消耗顺序加载它，以确保从指针读取的数据不是存储指针之前的数据。",
        "translate": ""
    },
    {
        "source": "Rust has no equivalent to memory_order_consume, so we use an acquire fence (sorry, ARM).",
        "suggest": "Rust 不具有 memory_order_consume 的等效项，因此我们使用获取栅栏 (对不起，ARM)。",
        "translate": ""
    },
    {
        "source": "Now, in practice this likely isn't needed even on CPUs where relaxed and consume mean different things.",
        "suggest": "现在，实际上，即使在放松和消耗意味着不同的 CPU 上也不需要这样做。",
        "translate": ""
    },
    {
        "source": "The symbols we're loading are probably present (or not) at init, and even if they aren't the runtime dynamic loader is extremely likely have sufficient barriers internally (possibly implicitly, for example the ones provided by invoking `mprotect`).",
        "suggest": "我们正在加载的符号可能在 init 上存在 (或不存在)，即使它们不是运行时动态加载程序，也极有可能在内部具有足够的屏障 (可能是隐式的，例如，调用 `mprotect` 所提供的屏障)。",
        "translate": ""
    },
    {
        "source": "That said, none of that's *guaranteed*, and so we fence.",
        "suggest": "也就是说，这些都没有保证，所以我们采取了防范措施。",
        "translate": ""
    },
    {
        "source": "Cold because it should only happen during first-time initalization.",
        "suggest": "Cold，因为它只应在首次初始化时发生。",
        "translate": ""
    },
    {
        "source": "This synchronizes with the acquire fence in `get`.",
        "suggest": "这与 `get` 中的获取 fence 同步。",
        "translate": ""
    },
    {
        "source": "This looks like a hack, but concat_idents only accepts idents (not paths).",
        "suggest": "这看起来像黑客，但是 concat_idents 仅接受身份 (不包含路径)。",
        "translate": ""
    },
    {
        "source": "Use a weak symbol from libc when possible, allowing `LD_PRELOAD` interposition, but if it's not found just use a raw syscall.",
        "suggest": "尽可能使用 libc 的弱符号，允许 `LD_PRELOAD` 插入，但如果找不到，则使用原始 syscall。",
        "translate": ""
    },
    {
        "source": "This is not necessarily correct.",
        "suggest": "这不一定是正确的。",
        "translate": ""
    },
    {
        "source": "May want to consider making it part of the spec definition?",
        "suggest": "可能要考虑使其成为规格定义的一部分?",
        "translate": ""
    },
    {
        "source": "The caller must guarantee `s` points to a valid 0-terminated string.",
        "suggest": "调用方必须保证 `s` 指向有效的 0 终止的字符串。",
        "translate": ""
    },
    {
        "source": "This platform has no threads, so we can use a Cell here.",
        "suggest": "该平台没有线程，因此我们可以在此处使用 Cell。",
        "translate": ""
    },
    {
        "source": "no threads on this platform",
        "suggest": "该平台上没有线程",
        "translate": ""
    },
    {
        "source": "All empty stubs because this platform does not yet support threads, so lock acquisition always succeeds.",
        "suggest": "所有空的存根，因为该平台尚不支持线程，因此锁获取始终会成功。",
        "translate": ""
    },
    {
        "source": "do nothing",
        "suggest": "没做什么",
        "translate": ""
    },
    {
        "source": "right now there is no concept of \"thread exit\", but this is likely going to show up at some point in the form of an exported symbol that the wasm runtime is going to be expected to call.",
        "suggest": "现在没有 \"thread exit\" 的概念，但是这可能会以导出符号的形式在某些时候显示出来，表明 wasm 运行时将被调用。",
        "translate": ""
    },
    {
        "source": "For now we basically just ignore the arguments, but if such a function starts to exist it will likely look like the OSX implementation in `unix/fast_thread_local.rs`",
        "suggest": "现在，我们基本上只是忽略该参数，但是如果这样的函数开始存在，则可能看起来像 `unix/fast_thread_local.rs` 中的 OSX 实现。",
        "translate": ""
    },
    {
        "source": "ignore SIGPIPE",
        "suggest": "忽略 SIGPIPE",
        "translate": ""
    },
    {
        "source": "ensure that access to the environment is synchronized",
        "suggest": "确保对环境的访问是同步的",
        "translate": ""
    },
    {
        "source": "initial priority",
        "suggest": "最初的优先级",
        "translate": ""
    },
    {
        "source": "initial stack size.",
        "suggest": "初始栈大小。",
        "translate": ""
    },
    {
        "source": "task options",
        "suggest": "任务选项",
        "translate": ""
    },
    {
        "source": "Because FileDesc was not used, each duplicated file descriptor needs to be closed manually",
        "suggest": "由于未使用 FileDesc，因此需要手动关闭每个重复的文件描述符",
        "translate": ""
    },
    {
        "source": "The unique id of the process (this should never be negative).",
        "suggest": "进程的唯一标识 (永远不能为负)。",
        "translate": ""
    },
    {
        "source": "WASI-specific extension to the primitives in the `std::ffi` module",
        "suggest": "WA00 特定于 `std::ffi` 模块中原语的扩展",
        "translate": ""
    },
    {
        "source": "WASI-specific extensions to primitives in the `std::fs` module.",
        "suggest": "WA00 特定于 `std::fs` 模块中基元的扩展。",
        "translate": ""
    },
    {
        "source": "WASI-specific extensions to [`File`].",
        "suggest": "WA00 特定于 [`File`] 的扩展。",
        "translate": ""
    },
    {
        "source": "Note that similar to [`File::read_vectored`], it is not an error to return with a short read.",
        "suggest": "请注意，类似于 [`File::read_vectored`]，短读返回不会出错。",
        "translate": ""
    },
    {
        "source": "Similar to [`Read::read_exact`] but uses [`read_at`] instead of `read`.",
        "suggest": "与 [`Read::read_exact`] 相似，但使用 [`read_at`] 代替 `read`。",
        "translate": ""
    },
    {
        "source": "Note that similar to [`File::write_vectored`], it is not an error to return a short write.",
        "suggest": "请注意，与 [`File::write_vectored`] 相似，返回短写也不是错误。",
        "translate": ""
    },
    {
        "source": "Returns the current position within the file.",
        "suggest": "返回文件中的当前位置。",
        "translate": ""
    },
    {
        "source": "This corresponds to the `fd_tell` syscall and is similar to `seek` where you offset 0 bytes from the current position.",
        "suggest": "这对应于 `fd_tell` syscall，并且类似于 `seek`，其中您从当前位置偏移了 0 个字节。",
        "translate": ""
    },
    {
        "source": "Adjust the flags associated with this file.",
        "suggest": "调整与此文件关联的标志。",
        "translate": ""
    },
    {
        "source": "This corresponds to the `fd_fdstat_set_flags` syscall.",
        "suggest": "这对应于 `fd_fdstat_set_flags` syscall。",
        "translate": ""
    },
    {
        "source": "Adjust the rights associated with this file.",
        "suggest": "调整与此文件关联的权限。",
        "translate": ""
    },
    {
        "source": "This corresponds to the `fd_fdstat_set_rights` syscall.",
        "suggest": "这对应于 `fd_fdstat_set_rights` syscall。",
        "translate": ""
    },
    {
        "source": "Provide file advisory information on a file descriptor.",
        "suggest": "提供有关文件描述符的文件咨询信息。",
        "translate": ""
    },
    {
        "source": "This corresponds to the `fd_advise` syscall.",
        "suggest": "这对应于 `fd_advise` syscall。",
        "translate": ""
    },
    {
        "source": "Force the allocation of space in a file.",
        "suggest": "强制在文件中分配空间。",
        "translate": ""
    },
    {
        "source": "This corresponds to the `fd_allocate` syscall.",
        "suggest": "这对应于 `fd_allocate` syscall。",
        "translate": ""
    },
    {
        "source": "Create a directory.",
        "suggest": "创建一个目录。",
        "translate": ""
    },
    {
        "source": "This corresponds to the `path_create_directory` syscall.",
        "suggest": "这对应于 `path_create_directory` syscall。",
        "translate": ""
    },
    {
        "source": "Read the contents of a symbolic link.",
        "suggest": "读取符号链接的内容。",
        "translate": ""
    },
    {
        "source": "This corresponds to the `path_readlink` syscall.",
        "suggest": "这对应于 `path_readlink` syscall。",
        "translate": ""
    },
    {
        "source": "Return the attributes of a file or directory.",
        "suggest": "返回文件或目录的属性。",
        "translate": ""
    },
    {
        "source": "This corresponds to the `path_filestat_get` syscall.",
        "suggest": "这对应于 `path_filestat_get` syscall。",
        "translate": ""
    },
    {
        "source": "Unlink a file.",
        "suggest": "取消链接文件。",
        "translate": ""
    },
    {
        "source": "This corresponds to the `path_unlink_file` syscall.",
        "suggest": "这对应于 `path_unlink_file` syscall。",
        "translate": ""
    },
    {
        "source": "Remove a directory.",
        "suggest": "删除目录。",
        "translate": ""
    },
    {
        "source": "This corresponds to the `path_remove_directory` syscall.",
        "suggest": "这对应于 `path_remove_directory` syscall。",
        "translate": ""
    },
    {
        "source": "bind fd_fdstat_get - need to define a custom return type",
        "suggest": "绑定 fd_fdstat_get - 需要定义一个自定义返回类型",
        "translate": ""
    },
    {
        "source": "bind fd_readdir - can't return `ReadDir` since we only have entry name",
        "suggest": "绑定 fd_readdir - 无法返回 `ReadDir`，因为我们只有条目名",
        "translate": ""
    },
    {
        "source": "bind fd_filestat_set_times maybe?",
        "suggest": "绑定 fd_filestat_set_times 也许?",
        "translate": ""
    },
    {
        "source": "- on crates.io for unix",
        "suggest": "- 在 crates.io 上用于 unix",
        "translate": ""
    },
    {
        "source": "bind path_filestat_set_times maybe?",
        "suggest": "绑定 path_filestat_set_times 也许?",
        "translate": ""
    },
    {
        "source": "bind poll_oneoff maybe?",
        "suggest": "绑定 poll_oneoff 也许?",
        "translate": ""
    },
    {
        "source": "- probably should wait for I/O to settle",
        "suggest": "- 可能应该等待 I/O 稳定下来",
        "translate": ""
    },
    {
        "source": "bind random_get maybe?",
        "suggest": "绑定 random_get 也许?",
        "translate": ""
    },
    {
        "source": "WASI-specific extensions to [`fs::OpenOptions`].",
        "suggest": "WA00 特定于 [`fs::OpenOptions`] 的扩展。",
        "translate": ""
    },
    {
        "source": "Pass custom `dirflags` argument to `path_open`.",
        "suggest": "将自定义 `dirflags` 参数传递给 `path_open`。",
        "translate": ""
    },
    {
        "source": "This option configures the `dirflags` argument to the `path_open` syscall which `OpenOptions` will eventually call.",
        "suggest": "此选项将 `dirflags` 参数配置为 `OpenOptions` 最终将调用的 `path_open` 系统调用。",
        "translate": ""
    },
    {
        "source": "The `dirflags` argument configures how the file is looked up, currently primarily affecting whether symlinks are followed or not.",
        "suggest": "`dirflags` 参数配置如何查找文件，当前主要影响是否遵循符号链接。",
        "translate": ""
    },
    {
        "source": "By default this value is `__WASI_LOOKUP_SYMLINK_FOLLOW`, or symlinks are followed.",
        "suggest": "默认情况下，此值为 `__WASI_LOOKUP_SYMLINK_FOLLOW`，否则将遵循符号链接。",
        "translate": ""
    },
    {
        "source": "You can call this method with 0 to disable following symlinks",
        "suggest": "您可以使用 0 调用此方法以禁用以下符号链接",
        "translate": ""
    },
    {
        "source": "Indicates whether `OpenOptions` must open a directory or not.",
        "suggest": "指示 `OpenOptions` 是否必须打开目录。",
        "translate": ""
    },
    {
        "source": "This method will configure whether the `__WASI_O_DIRECTORY` flag is passed when opening a file.",
        "suggest": "此方法将配置打开文件时是否传递 `__WASI_O_DIRECTORY` 标志。",
        "translate": ""
    },
    {
        "source": "When passed it will require that the opened path is a directory.",
        "suggest": "传递时，将要求打开的路径是目录。",
        "translate": ""
    },
    {
        "source": "This option is by default `false`",
        "suggest": "默认情况下，此选项为 `false`",
        "translate": ""
    },
    {
        "source": "Indicates whether `__WASI_FDFLAG_DSYNC` is passed in the `fs_flags` field of `path_open`.",
        "suggest": "指示是否在 `path_open` 的 `fs_flags` 字段中传递 `__WASI_FDFLAG_DSYNC`。",
        "translate": ""
    },
    {
        "source": "Indicates whether `__WASI_FDFLAG_NONBLOCK` is passed in the `fs_flags` field of `path_open`.",
        "suggest": "指示是否在 `path_open` 的 `fs_flags` 字段中传递 `__WASI_FDFLAG_NONBLOCK`。",
        "translate": ""
    },
    {
        "source": "Indicates whether `__WASI_FDFLAG_RSYNC` is passed in the `fs_flags` field of `path_open`.",
        "suggest": "指示是否在 `path_open` 的 `fs_flags` 字段中传递 `__WASI_FDFLAG_RSYNC`。",
        "translate": ""
    },
    {
        "source": "Indicates whether `__WASI_FDFLAG_SYNC` is passed in the `fs_flags` field of `path_open`.",
        "suggest": "指示是否在 `path_open` 的 `fs_flags` 字段中传递 `__WASI_FDFLAG_SYNC`。",
        "translate": ""
    },
    {
        "source": "Indicates the value that should be passed in for the `fs_rights_base` parameter of `path_open`.",
        "suggest": "指示应为 `path_open` 的 `fs_rights_base` 参数传递的值。",
        "translate": ""
    },
    {
        "source": "This option defaults based on the `read` and `write` configuration of this `OpenOptions` builder.",
        "suggest": "默认情况下，此选项基于此 `OpenOptions` 构建器的 `read` 和 `write` 配置。",
        "translate": ""
    },
    {
        "source": "If this method is called, however, the exact mask passed in will be used instead.",
        "suggest": "但是，如果调用此方法，则将使用传入的确切掩码。",
        "translate": ""
    },
    {
        "source": "Indicates the value that should be passed in for the `fs_rights_inheriting` parameter of `path_open`.",
        "suggest": "指示应为 `path_open` 的 `fs_rights_inheriting` 参数传递的值。",
        "translate": ""
    },
    {
        "source": "The default for this option is the same value as what will be passed for the `fs_rights_base` parameter but if this method is called then the specified value will be used instead.",
        "suggest": "此选项的默认值与将为 `fs_rights_base` 参数传递的值相同，但是如果调用此方法，则将使用指定的值代替。",
        "translate": ""
    },
    {
        "source": "Open a file or directory.",
        "suggest": "打开文件或目录。",
        "translate": ""
    },
    {
        "source": "This corresponds to the `path_open` syscall.",
        "suggest": "这对应于 `path_open` syscall。",
        "translate": ""
    },
    {
        "source": "WASI-specific extensions to [`fs::Metadata`].",
        "suggest": "WA00 特定于 [`fs::Metadata`] 的扩展。",
        "translate": ""
    },
    {
        "source": "Returns the `st_dev` field of the internal `filestat_t`",
        "suggest": "返回内部 `filestat_t` 的 `st_dev` 字段",
        "translate": ""
    },
    {
        "source": "Returns the `st_ino` field of the internal `filestat_t`",
        "suggest": "返回内部 `filestat_t` 的 `st_ino` 字段",
        "translate": ""
    },
    {
        "source": "Returns the `st_nlink` field of the internal `filestat_t`",
        "suggest": "返回内部 `filestat_t` 的 `st_nlink` 字段",
        "translate": ""
    },
    {
        "source": "Returns the `st_size` field of the internal `filestat_t`",
        "suggest": "返回内部 `filestat_t` 的 `st_size` 字段",
        "translate": ""
    },
    {
        "source": "Returns the `st_atim` field of the internal `filestat_t`",
        "suggest": "返回内部 `filestat_t` 的 `st_atim` 字段",
        "translate": ""
    },
    {
        "source": "Returns the `st_mtim` field of the internal `filestat_t`",
        "suggest": "返回内部 `filestat_t` 的 `st_mtim` 字段",
        "translate": ""
    },
    {
        "source": "Returns the `st_ctim` field of the internal `filestat_t`",
        "suggest": "返回内部 `filestat_t` 的 `st_ctim` 字段",
        "translate": ""
    },
    {
        "source": "WASI-specific extensions for [`fs::FileType`].",
        "suggest": "[`fs::FileType`] 的 WASI 特定扩展。",
        "translate": ""
    },
    {
        "source": "Adds support for special WASI file types such as block/character devices, pipes, and sockets.",
        "suggest": "增加了对特殊 WASI 文件类型的支持，例如 block/character 设备，管道和套接字。",
        "translate": ""
    },
    {
        "source": "Returns `true` if this file type is a character device.",
        "suggest": "如果此文件类型是字符设备，则返回 `true`。",
        "translate": ""
    },
    {
        "source": "Returns `true` if this file type is a socket datagram.",
        "suggest": "如果此文件类型是套接字数据报，则返回 `true`。",
        "translate": ""
    },
    {
        "source": "Returns `true` if this file type is a socket stream.",
        "suggest": "如果此文件类型是套接字流，则返回 `true`。",
        "translate": ""
    },
    {
        "source": "WASI-specific extension methods for [`fs::DirEntry`].",
        "suggest": "[`fs::DirEntry`] 的 WASI 特定扩展方法。",
        "translate": ""
    },
    {
        "source": "Returns the underlying `d_ino` field of the `dirent_t`",
        "suggest": "返回 `dirent_t` 的基础 `d_ino` 字段",
        "translate": ""
    },
    {
        "source": "Create a hard link.",
        "suggest": "创建一个硬链接。",
        "translate": ""
    },
    {
        "source": "This corresponds to the `path_link` syscall.",
        "suggest": "这对应于 `path_link` syscall。",
        "translate": ""
    },
    {
        "source": "Rename a file or directory.",
        "suggest": "重命名文件或目录。",
        "translate": ""
    },
    {
        "source": "This corresponds to the `path_rename` syscall.",
        "suggest": "这对应于 `path_rename` syscall。",
        "translate": ""
    },
    {
        "source": "Create a symbolic link.",
        "suggest": "创建一个符号链接。",
        "translate": ""
    },
    {
        "source": "This corresponds to the `path_symlink` syscall.",
        "suggest": "这对应于 `path_symlink` syscall。",
        "translate": ""
    },
    {
        "source": "This is a convenience API similar to `std::os::unix::fs::symlink` and `std::os::windows::fs::symlink_file` and `std::os::windows::fs::symlink_dir`.",
        "suggest": "这是一种便捷的 API，类似于 `std::os::unix::fs::symlink`，`std::os::windows::fs::symlink_file` 和 `std::os::windows::fs::symlink_dir`。",
        "translate": ""
    },
    {
        "source": "WASI-specific extensions to general I/O primitives",
        "suggest": "通用 I/O 原语的 WASI 特定扩展",
        "translate": ""
    },
    {
        "source": "A trait to extract the raw WASI file descriptor from an underlying object.",
        "suggest": "trait，用于从基础 object 提取原始 WASI 文件描述符。",
        "translate": ""
    },
    {
        "source": "use fd with native WASI bindings",
        "suggest": "将 fd 与原生 WASI 绑定一起使用",
        "translate": ""
    },
    {
        "source": "Platform-specific extensions to `std` for WASI.",
        "suggest": "WASI 的特定于 `std` 的平台扩展。",
        "translate": ""
    },
    {
        "source": "Provides access to platform-level information on WASI, and exposes WASI-specific functions that would otherwise be inappropriate as part of the core `std` library.",
        "suggest": "提供对 WASI 上平台级信息的访问，并公开特定于 WASI 的函数，否则该函数不适合作为 core `std` 库的一部分。",
        "translate": ""
    },
    {
        "source": "`IoSliceMut` and `IoVec` have exactly the same memory layout",
        "suggest": "`IoSliceMut` 和 `IoVec` 具有完全相同的内存布局",
        "translate": ""
    },
    {
        "source": "`IoSlice` and `CIoVec` have exactly the same memory layout",
        "suggest": "`IoSlice` 和 `CIoVec` 具有完全相同的内存布局",
        "translate": ""
    },
    {
        "source": "can we handle the return code here even though we can't on unix?",
        "suggest": "即使不能在 unix 上运行，我们也可以在这里处理返回码吗?",
        "translate": ""
    },
    {
        "source": "not currently implemented in wasi yet",
        "suggest": "目前尚未在 wasi 中实现",
        "translate": ""
    },
    {
        "source": "If we've reached the capacity of our buffer then we need to read some more from the OS, otherwise we pick up at our old offset.",
        "suggest": "如果我们已经达到缓冲区的容量，那么我们需要从操作系统中读取更多信息，否则，我们将从旧的偏移量开始使用。",
        "translate": ""
    },
    {
        "source": "If we didn't actually read anything, this is in theory the end of the directory.",
        "suggest": "如果我们实际上什么都没读，那么从理论上讲这就是目录的末尾。",
        "translate": ""
    },
    {
        "source": "If we're not able to read a directory entry then that means it must have been truncated at the end of the buffer, so reset our offset so we can go back and reread into the buffer, picking up where we last left off.",
        "suggest": "如果我们无法读取目录条目，则意味着它必须在缓冲区末尾被截断，因此请重置偏移量，以便我们可以返回并重新读入缓冲区，从上次中断的地方开始。",
        "translate": ""
    },
    {
        "source": "If the file name was truncated, then we need to reinvoke `readdir` so we truncate our buffer to start over and reread this descriptor.",
        "suggest": "如果文件名被截断，那么我们需要重新调用 `readdir`，因此我们将缓冲区截断以重新开始并重新读取该描述符。",
        "translate": ""
    },
    {
        "source": "Note that if our offset is 0 that means the file name is massive and we need a bigger buffer.",
        "suggest": "请注意，如果我们的偏移量为 0，则意味着文件名很大，我们需要更大的缓冲区。",
        "translate": ""
    },
    {
        "source": "These names are skipped on all other platforms, so let's skip them here too",
        "suggest": "这些名称在所有其他平台上都会被跳过，因此我们也要在此处跳过它们",
        "translate": ""
    },
    {
        "source": "If rights haven't otherwise been specified try to pick a reasonable set.",
        "suggest": "如果没有另外指定权限，请尝试选择合理的权限。",
        "translate": ""
    },
    {
        "source": "This can always be overridden by users via extension traits, and implementations may give us fewer rights silently than we ask for.",
        "suggest": "用户始终可以通过扩展名 traits 来覆盖此权限，并且实现方式可能给我们带来的静默权限比我们要求的少。",
        "translate": ""
    },
    {
        "source": "So given that, just look at `read` and `write` and bucket permissions based on that.",
        "suggest": "因此，鉴于此，只需查看 `read` 和 `write` 以及基于此的存储桶权限即可。",
        "translate": ""
    },
    {
        "source": "some of these should probably be read-only or write-only...",
        "suggest": "其中一些可能应该是只读的或只写的...",
        "translate": ""
    },
    {
        "source": "Permissions haven't been fully figured out in wasi yet, so this is likely temporary",
        "suggest": "wasi 中尚未完全弄清楚权限，因此这可能是暂时的",
        "translate": ""
    },
    {
        "source": "Try to get a best effort initial capacity for the vector we're going to fill.",
        "suggest": "尽最大努力为我们将要填充的 vector 设置初始容量。",
        "translate": ""
    },
    {
        "source": "Note that if it's not a symlink we don't use a file to avoid allocating gigabytes if you read_link a huge movie file by accident.",
        "suggest": "请注意，如果它不是符号链接，则如果您意外地 read_link 一个巨大的电影文件，则我们不会使用文件来避免分配千兆字节。",
        "translate": ""
    },
    {
        "source": "Additionally we add 1 to the initial size so if it doesn't change until when we call `readlink` the returned length will be less than the capacity, guaranteeing that we got all the data.",
        "suggest": "另外，我们在初始大小上加上 1，因此，如果在调用 `readlink` 之前它没有变化，则返回的长度将小于容量，从而确保我们获得了所有数据。",
        "translate": ""
    },
    {
        "source": "this'll fail in just a moment",
        "suggest": "这将在片刻内失败",
        "translate": ""
    },
    {
        "source": "Now that we have an initial guess of how big to make our buffer, call `readlink` in a loop until it fails or reports it filled fewer bytes than we asked for, indicating we got everything.",
        "suggest": "现在我们已经初步估计了缓冲区的大小，可以循环调用 `readlink` 直到它失败或报告它填充的字节数少于我们要求的字节，这表明我们已经拥有了一切。",
        "translate": ""
    },
    {
        "source": "This seems to not be in wasi's API yet, and we may need to end up emulating it ourselves.",
        "suggest": "这似乎还不在 wasi 的 API 中，我们可能需要最终自己对其进行仿真。",
        "translate": ""
    },
    {
        "source": "For now just return an error.",
        "suggest": "现在只需返回一个错误。",
        "translate": ""
    },
    {
        "source": "Attempts to open a bare path `p`.",
        "suggest": "尝试打开裸路径 `p`。",
        "translate": ""
    },
    {
        "source": "WASI has no fundamental capability to do this.",
        "suggest": "WASI 没有做到这一点的基本能力。",
        "translate": ""
    },
    {
        "source": "All syscalls and operations are relative to already-open file descriptors.",
        "suggest": "所有系统调用和操作都相对于已经打开的文件描述符。",
        "translate": ""
    },
    {
        "source": "The C library, however, manages a map of pre-opened file descriptors to their path, and then the C library provides an API to look at this.",
        "suggest": "但是，C 库管理一个预打开的文件描述符 map 到它们的路径，然后 C 库提供一个 API 来查看它。",
        "translate": ""
    },
    {
        "source": "In other words, when you want to open a path `p`, you have to find a previously opened file descriptor in a global table and then see if `p` is relative to that file descriptor.",
        "suggest": "换句话说，当您要打开路径 `p` 时，必须在表格中找到先前打开的文件描述符，然后查看 `p` 是否相对于该文件描述符。",
        "translate": ""
    },
    {
        "source": "This function, if successful, will return two items:",
        "suggest": "如果成功，此函数将返回两个项:",
        "translate": ""
    },
    {
        "source": "The first is a `ManuallyDrop<WasiFd>`.",
        "suggest": "第一个是 `ManuallyDrop<WasiFd>`。",
        "translate": ""
    },
    {
        "source": "This represents a pre-opened file descriptor which we don't have ownership of, but we can use.",
        "suggest": "这表示一个预先打开的文件描述符，我们没有所有权，但是可以使用。",
        "translate": ""
    },
    {
        "source": "You shouldn't actually drop the `fd`.",
        "suggest": "您实际上不应该丢弃 `fd`。",
        "translate": ""
    },
    {
        "source": "The second is a path that should be a part of `p` and represents a relative traversal from the file descriptor specified to the desired location `p`.",
        "suggest": "第二个路径应该是 `p` 的一部分，代表从指定的文件描述符到所需位置 `p` 的相对遍历。",
        "translate": ""
    },
    {
        "source": "If successful you can use the returned file descriptor to perform file-descriptor-relative operations on the path returned as well.",
        "suggest": "如果成功，您也可以使用返回的文件描述符在返回的路径上执行相对于文件描述符的操作。",
        "translate": ""
    },
    {
        "source": "The `rights` argument indicates what operations are desired on the returned file descriptor, and if successful the returned file descriptor should have the appropriate rights for performing `rights` actions.",
        "suggest": "`rights` 参数指示对返回的文件描述符进行哪些操作，如果成功，则返回的文件描述符应具有执行 `rights` 动作的适当权限。",
        "translate": ""
    },
    {
        "source": "Note that this can fail if `p` doesn't look like it can be opened relative to any pre-opened file descriptor.",
        "suggest": "请注意，如果 `p` 看起来无法相对于任何预打开的文件描述符打开，则此操作可能会失败。",
        "translate": ""
    },
    {
        "source": "System bindings for the wasm/web platform",
        "suggest": "wasm/web 平台的系统绑定",
        "translate": ""
    },
    {
        "source": "This module contains the facade (aka platform-specific) implementations of OS level functionality for wasm.",
        "suggest": "该模块包含 wasm 的 OS 级功能的外观 (又称平台特定) 实现。",
        "translate": ""
    },
    {
        "source": "Note that this wasm is *not* the emscripten wasm, so we have no runtime here.",
        "suggest": "请注意，此 wasm *不是* 脚本 wasm，因此此处没有运行时。",
        "translate": ""
    },
    {
        "source": "Add a few symbols not in upstream `libc` just yet.",
        "suggest": "暂时不在上游 `libc` 中添加一些符号。",
        "translate": ""
    },
    {
        "source": "No need for a lock if we're single-threaded, but this function will need to get implemented for multi-threaded scenarios",
        "suggest": "如果我们是单线程的，则不需要锁，但是需要为多线程方案实现此函数",
        "translate": ""
    },
    {
        "source": "See src/libstd/sys/unix/os.rs, same as that",
        "suggest": "看到的与 src/libstd/sys/unix/os.rs 相同",
        "translate": ""
    },
    {
        "source": "precision... seems ignored though?",
        "suggest": "精度... 虽然似乎被忽略了?",
        "translate": ""
    },
    {
        "source": "This is an implementation of a global allocator on the wasm32 platform when emscripten is not in use.",
        "suggest": "当不使用 emscripten 时，这是 wasm32 平台上的 alloc 分配器的实现。",
        "translate": ""
    },
    {
        "source": "In that situation there's no actual runtime for us to lean on for allocation, so instead we provide our own!",
        "suggest": "在这种情况下，我们没有实际的运行时可以依靠分配，因此我们提供了自己的运行时!",
        "translate": ""
    },
    {
        "source": "The wasm32 instruction set has two instructions for getting the current amount of memory and growing the amount of memory.",
        "suggest": "wasm32 指令集有两条指令，用于获取当前的内存量和增加的内存量。",
        "translate": ""
    },
    {
        "source": "These instructions are the foundation on which we're able to build an allocator, so we do so!",
        "suggest": "这些说明是我们能够构建分配器的基础，所以我们做到了!",
        "translate": ""
    },
    {
        "source": "Note that the instructions are also pretty \"global\" and this is the \"global\" allocator after all!",
        "suggest": "请注意，指令也很漂亮 \"global\"，毕竟这就是 \"global\" 分配器!",
        "translate": ""
    },
    {
        "source": "The crate is a port of dlmalloc.c from C to Rust and is basically just so we can have \"pure Rust\" for now which is currently technically required (can't link with C yet).",
        "suggest": "crate 是 dlmalloc.c 从 C 到 Rust 的端口，基本上就是这样，我们现在可以拥有 \"pure Rust\"，这是当前在技术上需要的 (尚不能与 C 链接)。",
        "translate": ""
    },
    {
        "source": "The crate itself provides a global allocator which on wasm has no synchronization as there are no threads!",
        "suggest": "crate 本身提供了一个分配器，该分配器在 wasm 上没有同步，因为没有线程!",
        "translate": ""
    },
    {
        "source": "DLMALLOC access is guranteed to be safe because the lock gives us unique and non-reentrant access.",
        "suggest": "保证 DLMALLOC 访问是安全的，因为该锁为我们提供了独特且不可重入的访问权限。",
        "translate": ""
    },
    {
        "source": "Calling malloc() is safe because preconditions on this function match the trait method preconditions.",
        "suggest": "调用 malloc() 是安全的，因为此函数上的前提条件与 trait 方法的前提条件匹配。",
        "translate": ""
    },
    {
        "source": "Calling calloc() is safe because preconditions on this function match the trait method preconditions.",
        "suggest": "调用 calloc() 是安全的，因为此函数上的前提条件与 trait 方法的前提条件匹配。",
        "translate": ""
    },
    {
        "source": "Calling free() is safe because preconditions on this function match the trait method preconditions.",
        "suggest": "调用 free() 是安全的，因为此函数上的前提条件与 trait 方法的前提条件匹配。",
        "translate": ""
    },
    {
        "source": "Calling realloc() is safe because preconditions on this function match the trait method preconditions.",
        "suggest": "调用 realloc() 是安全的，因为此函数上的前提条件与 trait 方法的前提条件匹配。",
        "translate": ""
    },
    {
        "source": "Ok so here's where things get a little depressing.",
        "suggest": "好的，这就是令人沮丧的地方。",
        "translate": ""
    },
    {
        "source": "At this point in time we need to synchronously acquire a lock, but we're contending with some other thread.",
        "suggest": "在这一点上，我们需要同步获取一个锁，但是我们正在与其他线程竞争。",
        "translate": ""
    },
    {
        "source": "Typically we'd execute some form of `i32.atomic.wait` like so:",
        "suggest": "通常，我们将执行某种形式的 `i32.atomic.wait`，如下所示:",
        "translate": ""
    },
    {
        "source": "1,  //     expected value",
        "suggest": "1，  // 期望值",
        "translate": ""
    },
    {
        "source": "Unfortunately though in doing so we would cause issues for the main thread.",
        "suggest": "不幸的是，尽管这样做会导致主线程出现问题。",
        "translate": ""
    },
    {
        "source": "The main thread in a web browser *cannot ever block*, no exceptions.",
        "suggest": "Web 浏览器中的主线程永远不会阻塞，没有任何的例外。",
        "translate": ""
    },
    {
        "source": "This means that the main thread can't actually execute the `i32.atomic.wait` instruction.",
        "suggest": "这意味着主线程实际上不能执行 `i32.atomic.wait` 指令。",
        "translate": ""
    },
    {
        "source": "As a result if we want to work within the context of browsers we need to figure out some sort of allocation scheme for the main thread where when there's contention on the global malloc lock we do...",
        "suggest": "因此，如果我们想在浏览器的上下文中工作，我们需要为主线程找出某种分配方案，当在 malloc 锁上发生争用时，我们会执行...",
        "translate": ""
    },
    {
        "source": "something.",
        "suggest": "某物。",
        "translate": ""
    },
    {
        "source": "Possible ideas include:",
        "suggest": "可能的想法包括:",
        "translate": ""
    },
    {
        "source": "Attempt to acquire the global lock.",
        "suggest": "尝试获取 δ 锁。",
        "translate": ""
    },
    {
        "source": "If it fails, fall back to memory allocation via `memory.grow`.",
        "suggest": "如果失败，则通过 `memory.grow` 回退到内存分配。",
        "translate": ""
    },
    {
        "source": "Later just ...",
        "suggest": "后来只是...",
        "translate": ""
    },
    {
        "source": "somehow ...",
        "suggest": "不知何故...",
        "translate": ""
    },
    {
        "source": "inject this raw page back into the main allocator as it gets sliced up over time.",
        "suggest": "随着时间的推移，将原始页面重新注入到主分配器中。",
        "translate": ""
    },
    {
        "source": "This strategy has the downside of forcing allocation of a page to happen whenever the main thread contents with other threads, which is unfortunate.",
        "suggest": "这种策略的缺点是，每当主线程与其他线程一起出现时，就强制进行页面分配，这是不幸的。",
        "translate": ""
    },
    {
        "source": "Maintain a form of \"two level\" allocator scheme where the main thread has its own allocator.",
        "suggest": "维护一种 \"two level\" 分配器方案的形式，其中主线程具有其自己的分配器。",
        "translate": ""
    },
    {
        "source": "Somehow this allocator would also be balanced with a global allocator, not only to have allocations cross between threads but also to ensure that the two allocators stay \"balanced\" in terms of free'd memory and such.",
        "suggest": "某种程度上，该分配器也将与分配器保持平衡，这不仅可以使线程之间的分配交叉，而且可以确保两个分配器在释放内存等方面保持 \"balanced\"。",
        "translate": ""
    },
    {
        "source": "This, however, seems significantly complicated.",
        "suggest": "但是，这似乎非常复杂。",
        "translate": ""
    },
    {
        "source": "Out of a lack of other ideas, the current strategy implemented here is to simply spin.",
        "suggest": "由于缺乏其他想法，此处实现的当前策略只是简单地旋转。",
        "translate": ""
    },
    {
        "source": "Typical spin loop algorithms have some form of \"hint\" here to the CPU that it's what we're doing to ensure that the CPU doesn't get too hot, but wasm doesn't have such an instruction.",
        "suggest": "典型的自旋循环算法在这里对 CPU 使用某种形式的 \"hint\"，这是我们正在做的工作，以确保 CPU 不会过热，但是 wasm 没有这样的指令。",
        "translate": ""
    },
    {
        "source": "To be clear, spinning here is not a great solution.",
        "suggest": "需要明确的是，在此处旋转不是一个很好的解决方案。",
        "translate": ""
    },
    {
        "source": "Another thread with the lock may take quite a long time to wake up.",
        "suggest": "另一个带锁的线程可能需要很长时间才能唤醒。",
        "translate": ""
    },
    {
        "source": "For example it could be in `memory.grow` or it could be evicted from the CPU for a timeslice like 10ms.",
        "suggest": "例如，它可能位于 `memory.grow` 中，或者可能从 CPU 驱逐了 10ms 之类的时间片。",
        "translate": ""
    },
    {
        "source": "For these periods of time our thread will \"helpfully\" sit here and eat CPU time until it itself is evicted or the lock holder finishes.",
        "suggest": "在这些时间段内，我们的线程将 \"helpfully\" 坐在这里并占用 CPU 时间，直到它本身被驱逐或锁持有者完成为止。",
        "translate": ""
    },
    {
        "source": "This means we're just burning and wasting CPU time to no one's benefit.",
        "suggest": "这意味着我们只是在浪费 CPU 时间，没有人受益。",
        "translate": ""
    },
    {
        "source": "Spinning does have the nice properties, though, of being semantically correct, being fair to all threads for memory allocation, and being simple enough to implement.",
        "suggest": "但是，旋转确实具有不错的属性，即语义上正确，对所有线程公平分配内存，并且实现起来非常简单。",
        "translate": ""
    },
    {
        "source": "This will surely (hopefully) be replaced in the future with a real memory allocator that can handle the restriction of the main thread.",
        "suggest": "在 future 中，肯定会将 (hopefully) 替换为可以处理主线程限制的实际内存分配器。",
        "translate": ""
    },
    {
        "source": "We can also possibly add an optimization here to detect when a thread is the main thread or not and block on all non-main-thread threads.",
        "suggest": "我们还可以在此处添加优化，以检测线程何时为主线程，并在所有非主线程上阻塞。",
        "translate": ""
    },
    {
        "source": "Currently, however, we have no way of knowing which wasm thread is on the browser main thread, but if we could figure out we could at least somewhat mitigate the cost of this spinning.",
        "suggest": "但是，当前，我们无法知道浏览器主线程上有哪个 wasm 线程，但是如果可以确定，我们至少可以在某种程度上减轻这种旋转的成本。",
        "translate": ""
    },
    {
        "source": "Note that due to the above logic we don't actually need to wake anyone up, but if we did it'd likely look something like this:",
        "suggest": "请注意，由于上述逻辑，我们实际上不需要唤醒任何人，但是如果我们这样做，则可能看起来像这样:",
        "translate": ""
    },
    {
        "source": "1, //     only one thread );",
        "suggest": "1，// 只有一个线程) ;",
        "translate": ""
    },
    {
        "source": "no atomics, no threads, that's easy!",
        "suggest": "没有原子，没有线程，这很容易!",
        "translate": ""
    },
    {
        "source": "On wasm these should always be null, so there's nothing for us to do here",
        "suggest": "在 wasm 上，这些值应始终为 null，因此我们在这里无事可做",
        "translate": ""
    },
    {
        "source": "Condition variables are implemented with a simple counter internally that is likely to cause spurious wakeups.",
        "suggest": "条件变量在内部使用简单的计数器实现，很可能会导致虚假唤醒。",
        "translate": ""
    },
    {
        "source": "Blocking on a condition variable will first read the value of the internal counter, unlock the given mutex, and then block if and only if the counter's value is still the same.",
        "suggest": "阻塞条件变量将首先读取内部计数器的值，解锁给定的互斥锁，然后在且仅当计数器的值仍然相同时才阻塞。",
        "translate": ""
    },
    {
        "source": "Notifying a condition variable will modify the counter (add one for now) and then wake up a thread waiting on the address of the counter.",
        "suggest": "通知条件变量将修改计数器 (现在添加一个)，然后唤醒等待计数器地址的线程。",
        "translate": ""
    },
    {
        "source": "A thread waiting on the condition variable will as a result avoid going to sleep if it's notified after the lock is unlocked but before it fully goes to sleep.",
        "suggest": "因此，等待条件变量的线程如果在解锁之后但在完全进入睡眠状态之前得到通知，则将避免进入睡眠状态。",
        "translate": ""
    },
    {
        "source": "A sleeping thread is guaranteed to be woken up at some point as it can only be woken up with a call to `wake`.",
        "suggest": "确保只能在唤醒 `wake` 的情况下唤醒睡眠线程。",
        "translate": ""
    },
    {
        "source": "Note that it's possible for 2 or more threads to be woken up by a call to `notify_one` with this implementation.",
        "suggest": "注意，通过此实现，调用 `notify_one` 可能会唤醒 2 个或更多线程。",
        "translate": ""
    },
    {
        "source": "That can happen where the modification of `cnt` causes any threads in the middle of `wait` to avoid going to sleep, and the subsequent `wake` may wake up a thread that's actually blocking.",
        "suggest": "如果 `cnt` 的修改导致 `wait` 中间的任何线程避免进入睡眠状态，并且随后的 `wake` 可能唤醒实际上正在阻塞的线程，则会发生这种情况。",
        "translate": ""
    },
    {
        "source": "We consider this a spurious wakeup, though, which all users of condition variables must already be prepared to handle.",
        "suggest": "但是，我们认为这是一个虚假的唤醒，所有条件变量的用户必须已经准备好处理。",
        "translate": ""
    },
    {
        "source": "As a result, this source of spurious wakeups is currently though to be ok, although it may be problematic later on if it causes too many spurious wakeups.",
        "suggest": "结果，这种杂散唤醒的来源目前尚可，尽管以后如果引起过多的杂散唤醒可能会出现问题。",
        "translate": ""
    },
    {
        "source": "nothing to do",
        "suggest": "没事做",
        "translate": ""
    },
    {
        "source": "ptr() is always valid",
        "suggest": "ptr() 始终有效",
        "translate": ""
    },
    {
        "source": "implemented by loading our current counter's value, unlocking the mutex, and blocking if the counter still has the same value.",
        "suggest": "通过加载当前计数器的值，解锁互斥锁并在计数器仍具有相同值的情况下阻塞来实现。",
        "translate": ""
    },
    {
        "source": "Notifications happen by incrementing the counter and then waking a thread.",
        "suggest": "通过增加计数器然后唤醒线程来进行通知。",
        "translate": ""
    },
    {
        "source": "Incrementing the counter after we unlock the mutex will prevent us from sleeping and otherwise the call to `wake` will wake us up once we're asleep.",
        "suggest": "解锁互斥锁后增加计数器的值将阻止我们进入睡眠状态，否则，一旦我们进入睡眠状态，调用 `wake` 就会唤醒我们。",
        "translate": ""
    },
    {
        "source": "0 == woken, 1 == not equal to `ticket`, 2 == timeout (shouldn't happen)",
        "suggest": "0 == 唤醒，1 == 不等于 `ticket`，2 == 超时 (不应该发生)",
        "translate": ""
    },
    {
        "source": "If the return value is 2 then a timeout happened, so we return `false` as we weren't actually notified.",
        "suggest": "如果返回值为 2，则发生超时，因此我们返回 `false`，因为实际上没有收到通知。",
        "translate": ""
    },
    {
        "source": "Mutexes have a pretty simple implementation where they contain an `i32` internally that is 0 when unlocked and 1 when the mutex is locked.",
        "suggest": "互斥锁有一个非常简单的实现，其中内部包含一个 `i32`，该 `i32` 在解锁时为 0，在互斥锁被锁定时为 1。",
        "translate": ""
    },
    {
        "source": "Acquisition has a fast path where it attempts to cmpxchg the 0 to a 1, and if it fails it then waits for a notification.",
        "suggest": "采集有一条快速的路径，尝试将 0 cmpxchg 设置为 1，如果失败，则等待通知。",
        "translate": ""
    },
    {
        "source": "Releasing a lock is then done by swapping in 0 and then notifying any waiters, if present.",
        "suggest": "然后释放一个锁，方法是将 0 交换，然后通知任何侍者 (如果有的话)。",
        "translate": ""
    },
    {
        "source": "the caller must uphold the safety contract for `memory_atomic_wait32`.",
        "suggest": "调用者必须坚持 `memory_atomic_wait32` 的安全保证。",
        "translate": ""
    },
    {
        "source": "we expect our mutex is locked",
        "suggest": "我们希望我们的互斥锁被锁定",
        "translate": ""
    },
    {
        "source": "wait infinitely",
        "suggest": "无限等待",
        "translate": ""
    },
    {
        "source": "we should have either woke up (0) or got a not-equal due to a race (1).",
        "suggest": "我们应该已经 woke up (0)，或者由于 race (1) 而变得不相等。",
        "translate": ""
    },
    {
        "source": "We should never time out (2)",
        "suggest": "我们永远都不要超时 (2)",
        "translate": ""
    },
    {
        "source": "wake up one waiter, if any",
        "suggest": "叫醒一位等待者 (如果有)",
        "translate": ""
    },
    {
        "source": "Reentrant mutexes are similarly implemented to mutexs above except that instead of \"1\" meaning unlocked we use the id of a thread to represent whether it has locked a mutex.",
        "suggest": "可重入互斥锁的实现与上述互斥锁类似，不同之处在于，除了 \"1\" 表示已解锁之外，我们使用线程的 ID 表示它是否已锁定互斥锁。",
        "translate": ""
    },
    {
        "source": "That way we have an atomic counter which always holds the id of the thread that currently holds the lock (or 0 if the lock is unlocked).",
        "suggest": "这样，我们有一个原子计数器，该计数器始终保存当前持有锁的线程的 ID (如果锁已解锁，则为 0)。",
        "translate": ""
    },
    {
        "source": "Once a thread acquires a lock recursively, which it detects by looking at the value that's already there, it will update a local `recursions` counter in a nonatomic fashion (as we hold the lock).",
        "suggest": "一旦线程以递归方式获取了锁 (通过查看已经存在的值来检测到锁)，它将以非原子方式 (当我们持有锁时) 更新本地 `recursions` 计数器。",
        "translate": ""
    },
    {
        "source": "The lock is then fully released when this recursion counter reaches 0.",
        "suggest": "然后，当此递归计数器达到 0 时，锁将完全释放。",
        "translate": ""
    },
    {
        "source": "nothing to do...",
        "suggest": "没事做...",
        "translate": ""
    },
    {
        "source": "the caller must gurantee that `self.ptr()` and `owner` are valid i32.",
        "suggest": "调用者必须保证 `self.ptr()` 和 `owner` 是有效的 i32。",
        "translate": ""
    },
    {
        "source": "we transitioned from unlocked to locked",
        "suggest": "我们从解锁转变为锁定",
        "translate": ""
    },
    {
        "source": "we currently own this lock, so let's update our count and return true.",
        "suggest": "我们目前拥有此锁，因此让我们更新计数并返回 true。",
        "translate": ""
    },
    {
        "source": "Someone else owns the lock, let our caller take care of it",
        "suggest": "别人拥有锁，让我们的调用者来照顾它",
        "translate": ""
    },
    {
        "source": "If we didn't ever recursively lock the lock then we fully unlock the mutex and wake up a waiter, if any.",
        "suggest": "如果我们从未递归锁定该锁，那么我们将完全解锁互斥锁并唤醒等待者 (如果有)。",
        "translate": ""
    },
    {
        "source": "Otherwise we decrement our recursive counter and let some one else take care of the zero.",
        "suggest": "否则，我们递减递归计数器，并让其他人处理零。",
        "translate": ""
    },
    {
        "source": "the caller must gurantee that `self.ptr()` is valid i32.",
        "suggest": "调用者必须保证 `self.ptr()` 是有效的 i32。",
        "translate": ""
    },
    {
        "source": "Use an atomic wait to block the current thread artificially with a timeout listed.",
        "suggest": "使用原子等待来人为地阻塞当前线程，并列出超时。",
        "translate": ""
    },
    {
        "source": "Note that we should never be notified (return value of 0) or our comparison should never fail (return value of 1) so we should always only resume execution through a timeout (return value 2).",
        "suggest": "请注意，我们永远都不会被通知 (返回值 0)，或者我们的比较永远不会失败 (返回值 1)，因此我们应该始终仅通过超时 (返回值 2) 来恢复执行。",
        "translate": ""
    },
    {
        "source": "This is only used by atomics primitives when the `atomics` feature is enabled.",
        "suggest": "仅当启用 `atomics` 功能时，原子基元才使用此功能。",
        "translate": ""
    },
    {
        "source": "In that mode we currently just use our own thread-local to store our current thread's ID, and then we lazily initialize it to something allocated from a global counter.",
        "suggest": "在这种模式下，我们当前仅使用我们自己的本地线程来存储当前线程的 ID，然后将其延迟初始化为从计数器分配的值。",
        "translate": ""
    },
    {
        "source": "If our thread ID isn't set yet then we need to allocate one.",
        "suggest": "如果尚未设置线程 ID，则需要分配一个线程 ID。",
        "translate": ""
    },
    {
        "source": "Do so with with a simple \"atomically add to a global counter\" strategy.",
        "suggest": "使用简单的 \"atomically add to a global counter\" 策略即可做到这一点。",
        "translate": ""
    },
    {
        "source": "This strategy doesn't handled what happens when the counter overflows, however, so just abort everything once the counter overflows and eventually we could have some sort of recycling scheme (or maybe this is all totally irrelevant by that point!).",
        "suggest": "但是，该策略无法处理计数器溢出时发生的情况，因此，一旦计数器溢出，只需终止所有操作，最终我们就可以采用某种回收方案 (或者到那时为止这完全不相关! )。",
        "translate": ""
    },
    {
        "source": "In any case though we're using a CAS loop instead of a `fetch_add` to ensure that the global counter never overflows.",
        "suggest": "在任何情况下，尽管我们使用 CAS 循环而不是 `fetch_add` 来确保绝对不会溢出计数器。",
        "translate": ""
    },
    {
        "source": "quotes cannot be escaped in command names",
        "suggest": "引号不能在命令名称中转义",
        "translate": ""
    },
    {
        "source": "Implements the Windows command-line argument parsing algorithm.",
        "suggest": "实现 Windows 命令行参数解析算法。",
        "translate": ""
    },
    {
        "source": "Microsoft's documentation for the Windows CLI argument format can be found at <https://docs.microsoft.com/en-us/previous-versions//17w5ykft(v=vs.85)>.",
        "suggest": "Microsoft 的 Windows CLI 参数格式的文档可以在下面找到 <https://docs.microsoft.com/previous-versions//17w5ykft (v=vs.85)>。",
        "translate": ""
    },
    {
        "source": "includes a function to do this in shell32.dll, but linking with that DLL causes the process to be registered as a GUI application.",
        "suggest": "在 shell32.dll 中包含一个用于执行此操作的函数，但是与该 DLL 的链接导致该进程被注册为 GUI 应用程序。",
        "translate": ""
    },
    {
        "source": "GUI applications add a bunch of overhead, even if no windows are drawn.",
        "suggest": "即使没有绘制 windows，GUI 应用程序也会增加大量开销。",
        "translate": ""
    },
    {
        "source": "See <https://randomascii.wordpress.com/2018/12/03/a-not-called-function-can-cause-a-5x-slowdown/>.",
        "suggest": "请参见 <https://randomascii.wordpress.com/2018/12/03/a-not-called-function-can-cause-a-5x-slowdown/>。",
        "translate": ""
    },
    {
        "source": "This function was tested for equivalence to the shell32.dll implementation in Windows 10 Pro v1803, using an exhaustive test suite available at <https://gist.github.com/notriddle/dde431930c392e428055b2dc22e638f5> or <https://paste.gg/p/anonymous/47d6ed5f5bd549168b1c69c799825223>.",
        "suggest": "使用 <https://gist.github.com/notriddle/dde431930c392e428055b2dc22e638f5> 或 <https://paste.gg/p/anonymous/47d6ed5f5bd549168b1c69c799825223> 处提供的详尽测试套件，对该函数进行了与 Windows 10 Pro v1803 中的 shell32.dll 实现等效的测试。",
        "translate": ""
    },
    {
        "source": "The executable name at the beginning is special.",
        "suggest": "开头的可执行文件名称很特殊。",
        "translate": ""
    },
    {
        "source": "The executable name ends at the next quote mark, no matter what.",
        "suggest": "无论如何，可执行文件的名称都在下一个引号引起来。",
        "translate": ""
    },
    {
        "source": "Implement quirk: when they say whitespace here, they include the entire ASCII control plane:",
        "suggest": "实现怪癖: 当他们在此处说空白时，它们包括整个 ASCII 控制平面:",
        "translate": ""
    },
    {
        "source": "\"However, if lpCmdLine starts with any amount of whitespace, CommandLineToArgvW will consider the first argument to be an empty string.",
        "suggest": "` 但是，如果 lpCmdLine 以任意数量的空格开头，CommandLineToArgvW 会将第一个参数视为空字符串。",
        "translate": ""
    },
    {
        "source": "Excess whitespace at the end of lpCmdLine is ignored.\"",
        "suggest": "lpCmdLine 末尾多余的空格将被忽略。`",
        "translate": ""
    },
    {
        "source": "The executable name ends at the next whitespace, no matter what.",
        "suggest": "无论如何，可执行文件的名称都在下一个空格结束。",
        "translate": ""
    },
    {
        "source": "include empty quoted strings at the end of the arguments list",
        "suggest": "在参数列表的末尾包含带引号的空字符串",
        "translate": ""
    },
    {
        "source": "C definitions used by libnative that don't belong in liblibc",
        "suggest": "libnative 使用的不属于 liblibc 的 C 定义",
        "translate": ""
    },
    {
        "source": "Note that these are not actually HANDLEs, just values to pass to GetStdHandle",
        "suggest": "请注意，这些实际上不是句柄，只是要传递给 GetStdHandle 的值",
        "translate": ""
    },
    {
        "source": "List of Windows system error codes with descriptions:",
        "suggest": "Windows 系统错误代码列表及其说明:",
        "translate": ""
    },
    {
        "source": "we only use some variants",
        "suggest": "我们只用一些成员",
        "translate": ""
    },
    {
        "source": "Functions forbidden when targeting UWP",
        "suggest": "定位 UWP 时禁止使用该函数",
        "translate": ""
    },
    {
        "source": "Allowed but unused by UWP",
        "suggest": "UWP 允许但未使用",
        "translate": ""
    },
    {
        "source": "UWP specific functions & types",
        "suggest": "UWP 特定的函数和类型",
        "translate": ""
    },
    {
        "source": "Shared between Desktop & UWP",
        "suggest": "在桌面和 UWP 之间共享",
        "translate": ""
    },
    {
        "source": "Vista / Server 2008",
        "suggest": "Vista/Server 2008",
        "translate": ""
    },
    {
        "source": "Vista / Server 2003",
        "suggest": "Vista/Server 2003",
        "translate": ""
    },
    {
        "source": "Functions that aren't available on every version of Windows that we support, but we still use them and just provide some form of a fallback implementation.",
        "suggest": "我们支持的每个 Windows 版本均不提供该函数，但是我们仍然使用它们，仅提供某种形式的后备实现。",
        "translate": ""
    },
    {
        "source": "Win8 / Server 2012",
        "suggest": "Win8 / 服务器 2012",
        "translate": ""
    },
    {
        "source": "Windows 8 / Server 2012",
        "suggest": "Windows 8 / 服务器 2012",
        "translate": ""
    },
    {
        "source": "If this api is unavailable, there cannot be anything waiting, because WaitOnAddress would've panicked.",
        "suggest": "如果此 api 不可用，将没有任何等待，因为 WaitOnAddress 会感到恐慌。",
        "translate": ""
    },
    {
        "source": "So it's fine to do nothing here.",
        "suggest": "因此，在此处不执行任何操作都很好。",
        "translate": ""
    },
    {
        "source": "On 32-bit x86 MSVC these functions aren't defined, so we just define shims which promote everything fo f64, perform the calculation, and then demote back to f32.",
        "suggest": "在 32 位 x86 MSVC 上未定义这些函数，因此我们仅定义垫片，以提升 f64 的所有功能，执行计算，然后降级回 f32。",
        "translate": ""
    },
    {
        "source": "While not precisely correct should be \"correct enough\" for now.",
        "suggest": "虽然目前尚不完全正确，但现在应该是 \"correct enough\"。",
        "translate": ""
    },
    {
        "source": "A \"compatibility layer\" for supporting older versions of Windows",
        "suggest": "\"compatibility layer\"，用于支持较早版本的 Windows",
        "translate": ""
    },
    {
        "source": "The standard library uses some Windows API functions that are not present on older versions of Windows.",
        "suggest": "标准库使用一些 Windows API 函数，这些 Windows API 函数在 Windows 的较早版本中不存在。",
        "translate": ""
    },
    {
        "source": "(Note that the oldest version of Windows that Rust supports is Windows 7 (client) and Windows Server 2008 (server).) This module implements a form of delayed DLL import binding, using `GetModuleHandle` and `GetProcAddress` to look up DLL entry points at runtime.",
        "suggest": "(请注意，Rust 支持的最早的 Windows 版本是 Windows 7 (client) 和 Windows Server 2008 (服务器)。) 该模块实现了一种延迟的 DLL 导入绑定形式，使用 `GetModuleHandle` 和 `GetProcAddress` 在运行时查找 DLL 入口点。",
        "translate": ""
    },
    {
        "source": "This implementation uses a static initializer to look up the DLL entry points.",
        "suggest": "此实现使用静态初始化来查找 DLL 入口点。",
        "translate": ""
    },
    {
        "source": "The CRT (C runtime) executes static initializers before `main` is called (for binaries) and before `DllMain` is called (for DLLs).",
        "suggest": "CRT (C 运行时) 在调用 `main` (对于二进制文件) 和调用 `DllMain` (对于 DLL) 之前执行静态初始化程序。",
        "translate": ""
    },
    {
        "source": "This is the ideal time to look up DLL imports, because we are guaranteed that no other threads will attempt to call these entry points.",
        "suggest": "这是查找 DLL 导入的理想时间，因为我们保证没有其他线程会尝试调用这些入口点。",
        "translate": ""
    },
    {
        "source": "Thus, we can look up the imports and store them in `static mut` fields without any synchronization.",
        "suggest": "因此，我们可以查找导入并将其存储在 `static mut` 字段中，而无需进行任何同步。",
        "translate": ""
    },
    {
        "source": "This has an additional advantage: Because the DLL import lookup happens at module initialization, the cost of these lookups is deterministic, and is removed from the code paths that actually call the DLL imports.",
        "suggest": "这还有一个额外的优势: 因为 DLL 导入查找是在模块初始化时发生的，所以这些查找的开销是确定性的，并且从实际上调用 DLL 导入的代码路径中删除了。",
        "translate": ""
    },
    {
        "source": "That is, there is no unpredictable \"cache miss\" that occurs when calling a DLL import.",
        "suggest": "也就是说，调用 DLL 导入时，不会发生不可预测的 \"cache miss\"。",
        "translate": ""
    },
    {
        "source": "For applications that benefit from predictable delays, this is a benefit.",
        "suggest": "对于受益于可预测的延迟的应用程序，这是一个好处。",
        "translate": ""
    },
    {
        "source": "This also eliminates the comparison-and-branch from the hot path.",
        "suggest": "这也消除了热路径中的比较和分支。",
        "translate": ""
    },
    {
        "source": "Currently, the standard library uses only a small number of dynamic DLL imports.",
        "suggest": "当前，标准库仅使用少量动态 DLL 导入。",
        "translate": ""
    },
    {
        "source": "If this number grows substantially, then the cost of performing all of the lookups at initialization time might become substantial.",
        "suggest": "如果该数目显着增加，则在初始化时执行所有查找的成本可能会变得很高。",
        "translate": ""
    },
    {
        "source": "The mechanism of registering a static initializer with the CRT is documented in [CRT Initialization](https://docs.microsoft.com/en-us/cpp/c-runtime-library/crt-initialization?view=msvc-160).",
        "suggest": "[CRT 初始化](https://docs.microsoft.com/en-us/cpp/c-runtime-library/crt-initialization?view=msvc-160) 中记录了向 CRT 注册静态初始化的机制。",
        "translate": ""
    },
    {
        "source": "It works by contributing a global symbol to the `.CRT$XCU` section.",
        "suggest": "它通过在 `.CRT$XCU` 部分添加一个符号来起作用。",
        "translate": ""
    },
    {
        "source": "The linker builds a table of all static initializer functions.",
        "suggest": "链接器会建立一个包含所有静态初始化函数的表。",
        "translate": ""
    },
    {
        "source": "The CRT startup code then iterates that table, calling each initializer function.",
        "suggest": "然后，CRT 启动代码将迭代该表，并调用每个初始化函数。",
        "translate": ""
    },
    {
        "source": "The environment that a static initializer function runs in is highly constrained.",
        "suggest": "静态初始化函数运行的环境受到严格限制。",
        "translate": ""
    },
    {
        "source": "There are **many** restrictions on what static initializers can safely do.",
        "suggest": "静态初始值设定项可以安全执行的操作有很多限制。",
        "translate": ""
    },
    {
        "source": "Static initializer functions **MUST NOT** do any of the following (this list is not comprehensive):",
        "suggest": "静态初始化函数 **不得** 执行以下任何一项操作 (此列表并不全面) :",
        "translate": ""
    },
    {
        "source": "touch any other static field that is used by a different static initializer, because the order that static initializers run in is not defined.",
        "suggest": "触摸其他静态初始化所使用的任何其他静态字段，因为未定义静态初始化程序运行的顺序。",
        "translate": ""
    },
    {
        "source": "call `LoadLibrary` or any other function that acquires the DLL loader lock.",
        "suggest": "调用 `LoadLibrary` 或任何其他获得 DLL 加载程序锁的函数。",
        "translate": ""
    },
    {
        "source": "call any Rust function or CRT function that touches any static (global) state.",
        "suggest": "调用任何接触 (global) 静态状态的 Rust 函数或 CRT 函数。",
        "translate": ""
    },
    {
        "source": "Points to the DLL import, or the fallback function.",
        "suggest": "指向 DLL 导入或后备函数。",
        "translate": ""
    },
    {
        "source": "This static can be an ordinary, unsynchronized, mutable static because we guarantee that all of the writes finish during CRT initialization, and all of the reads occur after CRT initialization.",
        "suggest": "该静态可以是普通的，非同步的静态静态，因为我们保证在 CRT 初始化期间所有写操作都将完成，并且所有读取都在 CRT 初始化之后进行。",
        "translate": ""
    },
    {
        "source": "This symbol is what allows the CRT to find the `init` function and call it.",
        "suggest": "这个符号使 CRT 可以找到 `init` 函数并调用它。",
        "translate": ""
    },
    {
        "source": "It is marked `#[used]` because otherwise Rust would assume that it was not used, and would remove it.",
        "suggest": "之所以标记为 `#[used]`，是因为否则 Rust 会假定未使用它，并将其删除。",
        "translate": ""
    },
    {
        "source": "There is no locking here.",
        "suggest": "这里没有锁定。",
        "translate": ""
    },
    {
        "source": "This code is executed before main() is entered, and is guaranteed to be single-threaded.",
        "suggest": "该代码在输入 main() 之前执行，并且保证是单线程的。",
        "translate": ""
    },
    {
        "source": "DO NOT do anything interesting or complicated in this function!",
        "suggest": "不要在此函数中做任何有趣或复杂的事情!",
        "translate": ""
    },
    {
        "source": "DO NOT call any Rust functions or CRT functions, if those functions touch any global state, because this function runs during global initialization.",
        "suggest": "如果那些 Rust 函数或 CRT 函数接触到任何状态，则不要调用任何 Rust 函数或 CRT 函数，因为此函数在初始化时运行。",
        "translate": ""
    },
    {
        "source": "For example, DO NOT do any dynamic allocation, don't call LoadLibrary, etc.",
        "suggest": "例如，请勿进行任何动态分配，请勿调用 LoadLibrary 等。",
        "translate": ""
    },
    {
        "source": "encoding for \"Unicode\".",
        "suggest": "\"Unicode\" 的编码。",
        "translate": ""
    },
    {
        "source": "Windows-specific extensions to the primitives in the `std::ffi` module.",
        "suggest": "`std::ffi` 模块中原语的 Windows 特定扩展。",
        "translate": ""
    },
    {
        "source": "For historical reasons, the Windows API uses a form of potentially ill-formed UTF-16 encoding for strings.",
        "suggest": "由于历史原因，Windows API 对字符串使用了一种格式可能不正确的 UTF-16 编码。",
        "translate": ""
    },
    {
        "source": "Specifically, the 16-bit code units in Windows strings may contain [isolated surrogate code points which are not paired together][ill-formed-utf-16].",
        "suggest": "具体来说，Windows 字符串中的 16 位代码单元可能包含 [未配对在一起的孤立代理代码点][ill-formed-utf-16]。",
        "translate": ""
    },
    {
        "source": "The Unicode standard requires that surrogate code points (those in the range U+D800 to U+DFFF) always be *paired*, because in the UTF-16 encoding a *surrogate code unit pair* is used to encode a single character.",
        "suggest": "Unicode 标准要求代理代码点 (在 U+D800 到 U+DFFF 范围内的代码点) 总是成对的，因为在 UTF-16 编码中，*surrogate code 单元对 `*` 用于编码单个字符。",
        "translate": ""
    },
    {
        "source": "For compatibility with code that does not enforce these pairings, Windows does not enforce them, either.",
        "suggest": "为了与不强制执行这些配对的代码兼容，Windows 也不强制执行它们。",
        "translate": ""
    },
    {
        "source": "While it is not always possible to convert such a string losslessly into a valid UTF-16 string (or even UTF-8), it is often desirable to be able to round-trip such a string from and to Windows APIs losslessly.",
        "suggest": "虽然不一定总是可以无损地将这样的字符串转换为有效的 UTF-16 字符串 (甚至 UTF-8)，但是通常希望能够无损地将这样的字符串往返于 Windows API 之间。",
        "translate": ""
    },
    {
        "source": "For example, some Rust code may be \"bridging\" some Windows APIs together, just passing `WCHAR` strings among those APIs without ever really looking into the strings.",
        "suggest": "例如，某些 Rust 代码可能与某些 Windows API 一起成为 \"bridging\"，仅在这些 API 之间传递 `WCHAR` 字符串，而无需真正研究这些字符串。",
        "translate": ""
    },
    {
        "source": "If Rust code *does* need to look into those strings, it can convert them to valid UTF-8, possibly lossily, by substituting invalid sequences with [`U+FFFD REPLACEMENT CHARACTER`][U+FFFD], as is conventionally done in other Rust APIs that deal with string encodings.",
        "suggest": "如果确实需要 Rust 代码查看这些字符串，则可以通过用 [`U+FFFD REPLACEMENT CHARACTER`][U+FFFD] 替换无效的序列来将它们转换为有效的 UTF-8，这可能是有损的，就像在其他处理字符串编码的 Rust API 中所做的那样。",
        "translate": ""
    },
    {
        "source": "and `OsStrExt`",
        "suggest": "和 `OsStrExt`",
        "translate": ""
    },
    {
        "source": "is the Rust wrapper for owned strings in the preferred representation of the operating system.",
        "suggest": "是操作系统的首选表示形式中所拥有的字符串的 Rust 包装器。",
        "translate": ""
    },
    {
        "source": "On Windows, this struct gets augmented with an implementation of the [`OsStringExt`] trait, which has a [`OsStringExt::from_wide`] method.",
        "suggest": "在 Windows 上，此结构体通过 [`OsStringExt`] trait 的实现得到增强，该实现具有 [`OsStringExt::from_wide`] 方法。",
        "translate": ""
    },
    {
        "source": "This lets you create an [`OsString`] from a `&[u16]` slice;",
        "suggest": "这使您可以从 `&[u16]` 切片创建 [`OsString`]。",
        "translate": ""
    },
    {
        "source": "presumably you get such a slice out of a `WCHAR` Windows API.",
        "suggest": "大概是从 `WCHAR` Windows API 中得到的切片。",
        "translate": ""
    },
    {
        "source": "Similarly, [`OsStr`] is the Rust wrapper for borrowed strings from preferred representation of the operating system.",
        "suggest": "同样，[`OsStr`] 是 Rust 包装器，用于从操作系统的首选表示形式中借用字符串。",
        "translate": ""
    },
    {
        "source": "On Windows, the [`OsStrExt`] trait provides the [`OsStrExt::encode_wide`] method, which outputs an [`EncodeWide`] iterator.",
        "suggest": "在 Windows 上，[`OsStrExt`] trait 提供了 [`OsStrExt::encode_wide`] 方法，该方法输出 [`EncodeWide`] 迭代器。",
        "translate": ""
    },
    {
        "source": "You can [`collect`] this iterator, for example, to obtain a `Vec<u16>`;",
        "suggest": "例如，您可以 [`collect`] 这个迭代器，以获得一个 `Vec<u16>`;",
        "translate": ""
    },
    {
        "source": "you can later get a pointer to this vector's contents and feed it to Windows APIs.",
        "suggest": "您以后可以获取指向此 vector 内容的指针，并将其提供给 Windows API。",
        "translate": ""
    },
    {
        "source": "These traits, along with [`OsString`] and [`OsStr`], work in conjunction so that it is possible to **round-trip** strings from Windows and back, with no loss of data, even if the strings are ill-formed UTF-16.",
        "suggest": "这些 traits 与 [`OsString`] 和 [`OsStr`] 一起工作，这样就可以在 Windows 和后面往返字符串，而不会丢失数据，即使字符串是格式错误的 UTF-16。",
        "translate": ""
    },
    {
        "source": "Windows-specific extensions to [`OsString`].",
        "suggest": "Windows 特定于 [`OsString`] 的扩展。",
        "translate": ""
    },
    {
        "source": "Creates an `OsString` from a potentially ill-formed UTF-16 slice of",
        "suggest": "从可能是格式不正确的 UTF-16 切片创建 `OsString`",
        "translate": ""
    },
    {
        "source": "16-bit code units.",
        "suggest": "16 位代码单元。",
        "translate": ""
    },
    {
        "source": "This is lossless: calling [`OsStrExt::encode_wide`] on the resulting string will always return the original code units.",
        "suggest": "这是无损的: 在结果字符串上调用 [`OsStrExt::encode_wide`] 将始终返回原始代码单元。",
        "translate": ""
    },
    {
        "source": "Windows-specific extensions to [`OsStr`].",
        "suggest": "Windows 特定于 [`OsStr`] 的扩展。",
        "translate": ""
    },
    {
        "source": "Re-encodes an `OsStr` as a wide character sequence, i.e., potentially ill-formed UTF-16.",
        "suggest": "将 `OsStr` 重新编码为宽字符序列，即可能格式不正确的 UTF-16。",
        "translate": ""
    },
    {
        "source": "This is lossless: calling [`OsStringExt::from_wide`] and then `encode_wide` on the result will yield the original code units.",
        "suggest": "这是无损的: 在结果上调用 [`OsStringExt::from_wide`]，然后调用 `encode_wide`，将产生原始代码单元。",
        "translate": ""
    },
    {
        "source": "Note that the encoding does not add a final null terminator.",
        "suggest": "请注意，编码不会添加最终的空终止符。",
        "translate": ""
    },
    {
        "source": "Read 10 bytes, starting 72 bytes from the start of the file.",
        "suggest": "从文件开头开始读取 10 个字节，从 72 个字节开始。",
        "translate": ""
    },
    {
        "source": "Write a byte string starting 72 bytes from the start of the file.",
        "suggest": "从文件开头开始写一个字节字符串，从 72 个字节开始。",
        "translate": ""
    },
    {
        "source": "Open without read and write permission, for example if you only need to call `stat` on the file",
        "suggest": "在没有读写权限的情况下打开，例如，如果您只需要在文件上调用 `stat`",
        "translate": ""
    },
    {
        "source": "Do not allow others to read or modify this file while we have it open for writing.",
        "suggest": "当我们打开该文件以供写入时，请勿允许他人读取或修改此文件。",
        "translate": ""
    },
    {
        "source": "Sets the flag value to `SecurityIdentification`.",
        "suggest": "将标志值设置为 `SecurityIdentification`。",
        "translate": ""
    },
    {
        "source": "Windows-specific extensions for the primitives in the `std::fs` module.",
        "suggest": "`std::fs` 模块中原语的 Windows 特定扩展。",
        "translate": ""
    },
    {
        "source": "Windows-specific extensions to [`fs::File`].",
        "suggest": "Windows 特定于 [`fs::File`] 的扩展。",
        "translate": ""
    },
    {
        "source": "Seeks to a given position and reads a number of bytes.",
        "suggest": "搜寻到给定位置并读取多个字节。",
        "translate": ""
    },
    {
        "source": "The current cursor **is** affected by this function, it is set to the end of the read.",
        "suggest": "当前游标受此函数的影响，它被设置为读取的结尾。",
        "translate": ""
    },
    {
        "source": "Reading beyond the end of the file will always return with a length of 0\\.",
        "suggest": "超出文件末尾的读取将始终以 0\\ 的长度返回。",
        "translate": ""
    },
    {
        "source": "Note that similar to `File::read`, it is not an error to return with a short read.",
        "suggest": "请注意，类似于 `File::read`，短读返回不会出错。",
        "translate": ""
    },
    {
        "source": "When returning from such a short read, the file pointer is still updated.",
        "suggest": "从如此短的读取返回时，文件指针仍会更新。",
        "translate": ""
    },
    {
        "source": "Seeks to a given position and writes a number of bytes.",
        "suggest": "搜寻到给定位置并写入多个字节。",
        "translate": ""
    },
    {
        "source": "The current cursor **is** affected by this function, it is set to the end of the write.",
        "suggest": "当前游标受此函数的影响，它被设置为写入结束。",
        "translate": ""
    },
    {
        "source": "When writing beyond the end of the file, the file is appropriately extended and the intermediate bytes are left uninitialized.",
        "suggest": "当写入超出文件末尾时，文件将适当扩展，并且中间字节将保持未初始化状态。",
        "translate": ""
    },
    {
        "source": "Note that similar to `File::write`, it is not an error to return a short write.",
        "suggest": "请注意，与 `File::write` 相似，返回短写也不是错误。",
        "translate": ""
    },
    {
        "source": "When returning from such a short write, the file pointer is still updated.",
        "suggest": "从这么短的写入返回时，文件指针仍会更新。",
        "translate": ""
    },
    {
        "source": "Windows-specific extensions to [`fs::OpenOptions`].",
        "suggest": "Windows 特定于 [`fs::OpenOptions`] 的扩展。",
        "translate": ""
    },
    {
        "source": "Overrides the `dwDesiredAccess` argument to the call to [`CreateFile`] with the specified value.",
        "suggest": "将 `dwDesiredAccess` 参数覆盖为具有指定值的 [`CreateFile`]。",
        "translate": ""
    },
    {
        "source": "This will override the `read`, `write`, and `append` flags on the `OpenOptions` structure.",
        "suggest": "这将覆盖 `OpenOptions` 结构体上的 `read`，`write` 和 `append` 标志。",
        "translate": ""
    },
    {
        "source": "This method provides fine-grained control over the permissions to read, write and append data, attributes (like hidden and system), and extended attributes.",
        "suggest": "此方法提供对读取，写入和附加数据，属性 (如隐藏和系统) 和扩展属性的权限的细粒度控制。",
        "translate": ""
    },
    {
        "source": "Overrides the `dwShareMode` argument to the call to [`CreateFile`] with the specified value.",
        "suggest": "将 `dwShareMode` 参数覆盖为具有指定值的 [`CreateFile`]。",
        "translate": ""
    },
    {
        "source": "By default `share_mode` is set to `FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE`.",
        "suggest": "默认情况下，`share_mode` 设置为 `FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE`。",
        "translate": ""
    },
    {
        "source": "This allows other processes to read, write, and delete/rename the same file while it is open.",
        "suggest": "这允许其他进程在打开文件时读取，写入和 delete/rename。",
        "translate": ""
    },
    {
        "source": "Removing any of the flags will prevent other processes from performing the corresponding operation until the file handle is closed.",
        "suggest": "删除任何标志将阻止其他进程执行相应的操作，直到关闭文件句柄为止。",
        "translate": ""
    },
    {
        "source": "Sets extra flags for the `dwFileFlags` argument to the call to [`CreateFile2`] to the specified value (or combines it with `attributes` and `security_qos_flags` to set the `dwFlagsAndAttributes` for [`CreateFile`]).",
        "suggest": "将 `dwFileFlags` 参数的额外标志设置为 [`CreateFile2`] 的指定值 (或将其与 `attributes` 和 `security_qos_flags` 组合以将 `dwFlagsAndAttributes` 设置为 [`CreateFile`])。",
        "translate": ""
    },
    {
        "source": "Custom flags can only set flags, not remove flags set by Rust's options.",
        "suggest": "自定义标志只能设置标志，而不能删除 Rust 选项设置的标志。",
        "translate": ""
    },
    {
        "source": "This option overwrites any previously set custom flags.",
        "suggest": "此选项将覆盖以前设置的所有自定义标志。",
        "translate": ""
    },
    {
        "source": "Sets the `dwFileAttributes` argument to the call to [`CreateFile2`] to the specified value (or combines it with `custom_flags` and `security_qos_flags` to set the `dwFlagsAndAttributes` for [`CreateFile`]).",
        "suggest": "将 `dwFileAttributes` 参数设置为 [`CreateFile2`] 的指定值 (或将其与 `custom_flags` 和 `security_qos_flags` 组合以将 `dwFlagsAndAttributes` 设置为 [`CreateFile`])。",
        "translate": ""
    },
    {
        "source": "If a _new_ file is created because it does not yet exist and `.create(true)` or `.create_new(true)` are specified, the new file is given the attributes declared with `.attributes()`.",
        "suggest": "如果由于 _new_ 文件尚不存在而创建了 _new_ 文件，并且已指定 `.create(true)` 或 `.create_new(true)`，则将为新文件提供 `.attributes()` 声明的属性。",
        "translate": ""
    },
    {
        "source": "If an _existing_ file is opened with `.create(true).truncate(true)`, its existing attributes are preserved and combined with the ones declared with `.attributes()`.",
        "suggest": "如果使用 `.create(true).truncate(true)` 打开 _existing_ 文件，则将保留其现有属性并将其与 `.attributes()` 声明的属性合并。",
        "translate": ""
    },
    {
        "source": "In all other cases the attributes get ignored.",
        "suggest": "在所有其他情况下，属性将被忽略。",
        "translate": ""
    },
    {
        "source": "Sets the `dwSecurityQosFlags` argument to the call to [`CreateFile2`] to the specified value (or combines it with `custom_flags` and `attributes` to set the `dwFlagsAndAttributes` for [`CreateFile`]).",
        "suggest": "将 `dwSecurityQosFlags` 参数设置为 [`CreateFile2`] 的指定值 (或将其与 `custom_flags` 和 `attributes` 组合以将 `dwFlagsAndAttributes` 设置为 [`CreateFile`])。",
        "translate": ""
    },
    {
        "source": "By default `security_qos_flags` is not set.",
        "suggest": "默认情况下，未设置 `security_qos_flags`。",
        "translate": ""
    },
    {
        "source": "It should be specified when opening a named pipe, to control to which degree a server process can act on behalf of a client process (security impersonation level).",
        "suggest": "在打开命名管道时应指定此名称，以控制服务器进程可以代表客户端进程执行的程度 (安全模拟级别)。",
        "translate": ""
    },
    {
        "source": "When `security_qos_flags` is not set, a malicious program can gain the elevated privileges of a privileged Rust process when it allows opening user-specified paths, by tricking it into opening a named pipe.",
        "suggest": "如果未设置 `security_qos_flags`，则恶意程序可以通过诱使程序打开命名管道来允许其打开用户指定的路径，从而获得权限 Rust 进程的提升的权限。",
        "translate": ""
    },
    {
        "source": "So arguably `security_qos_flags` should also be set when opening arbitrary paths.",
        "suggest": "因此可以说在打开任意路径时也应设置 `security_qos_flags`。",
        "translate": ""
    },
    {
        "source": "However the bits can then conflict with other flags, specifically `FILE_FLAG_OPEN_NO_RECALL`.",
        "suggest": "但是，这些位可能会与其他标志 (特别是 `FILE_FLAG_OPEN_NO_RECALL`) 发生冲突。",
        "translate": ""
    },
    {
        "source": "For information about possible values, see [Impersonation Levels] on the Windows Dev Center site.",
        "suggest": "有关可能的值的信息，请参见 Windows Dev Center 网站上的 [Impersonation Levels]。",
        "translate": ""
    },
    {
        "source": "The `SECURITY_SQOS_PRESENT` flag is set automatically when using this method.",
        "suggest": "使用此方法时，`SECURITY_SQOS_PRESENT` 标志会自动设置。",
        "translate": ""
    },
    {
        "source": "Windows-specific extensions to [`fs::Metadata`].",
        "suggest": "Windows 特定于 [`fs::Metadata`] 的扩展。",
        "translate": ""
    },
    {
        "source": "The data members that this trait exposes correspond to the members of the [`BY_HANDLE_FILE_INFORMATION`] structure.",
        "suggest": "trait 公开的数据成员与 [`BY_HANDLE_FILE_INFORMATION`] 结构体的成员相对应。",
        "translate": ""
    },
    {
        "source": "Returns the value of the `dwFileAttributes` field of this metadata.",
        "suggest": "返回此元数据的 `dwFileAttributes` 字段的值。",
        "translate": ""
    },
    {
        "source": "This field contains the file system attribute information for a file or directory.",
        "suggest": "该字段包含文件或目录的文件系统属性信息。",
        "translate": ""
    },
    {
        "source": "For possible values and their descriptions, see [File Attribute Constants] in the Windows Dev Center.",
        "suggest": "有关可能的值及其说明，请参见 Windows 开发人员中心中的 [File Attribute Constants]。",
        "translate": ""
    },
    {
        "source": "Returns the value of the `ftCreationTime` field of this metadata.",
        "suggest": "返回此元数据的 `ftCreationTime` 字段的值。",
        "translate": ""
    },
    {
        "source": "The returned 64-bit value is equivalent to a [`FILETIME`] struct, which represents the number of 100-nanosecond intervals since January 1, 1601 (UTC).",
        "suggest": "返回的 64 位值等效于 [`FILETIME`] 结构体，它表示自 1601 年 1 月 1 日以来的 100 纳秒间隔 (UTC)。",
        "translate": ""
    },
    {
        "source": "The struct is automatically converted to a `u64` value, as that is the recommended way to use it.",
        "suggest": "建议将结构体自动转换为 `u64` 值。",
        "translate": ""
    },
    {
        "source": "If the underlying filesystem does not support creation time, the returned value is 0.",
        "suggest": "如果基础文件系统不支持创建时间，则返回值为 0。",
        "translate": ""
    },
    {
        "source": "Returns the value of the `ftLastAccessTime` field of this metadata.",
        "suggest": "返回此元数据的 `ftLastAccessTime` 字段的值。",
        "translate": ""
    },
    {
        "source": "For a file, the value specifies the last time that a file was read from or written to.",
        "suggest": "对于文件，该值指定最后一次读取或写入文件的时间。",
        "translate": ""
    },
    {
        "source": "For a directory, the value specifies when the directory was created.",
        "suggest": "对于目录，该值指定创建目录的时间。",
        "translate": ""
    },
    {
        "source": "For both files and directories, the specified date is correct, but the time of day is always set to midnight.",
        "suggest": "对于文件和目录，指定的日期都是正确的，但是一天中的时间始终设置为午夜。",
        "translate": ""
    },
    {
        "source": "If the underlying filesystem does not support last access time, the returned value is 0.",
        "suggest": "如果基础文件系统不支持上次访问时间，则返回值为 0。",
        "translate": ""
    },
    {
        "source": "Returns the value of the `ftLastWriteTime` field of this metadata.",
        "suggest": "返回此元数据的 `ftLastWriteTime` 字段的值。",
        "translate": ""
    },
    {
        "source": "For a file, the value specifies the last time that a file was written to.",
        "suggest": "对于文件，该值指定文件的最后写入时间。",
        "translate": ""
    },
    {
        "source": "For a directory, the structure specifies when the directory was created.",
        "suggest": "对于目录，结构体指定目录的创建时间。",
        "translate": ""
    },
    {
        "source": "If the underlying filesystem does not support the last write time, the returned value is 0.",
        "suggest": "如果基础文件系统不支持上次写入时间，则返回值为 0。",
        "translate": ""
    },
    {
        "source": "Returns the value of the `nFileSize{High,Low}` fields of this metadata.",
        "suggest": "返回此元数据的 `nFileSize{High,Low}` 字段的值。",
        "translate": ""
    },
    {
        "source": "The returned value does not have meaning for directories.",
        "suggest": "返回的值对目录没有意义。",
        "translate": ""
    },
    {
        "source": "Returns the value of the `dwVolumeSerialNumber` field of this metadata.",
        "suggest": "返回此元数据的 `dwVolumeSerialNumber` 字段的值。",
        "translate": ""
    },
    {
        "source": "This will return `None` if the `Metadata` instance was created from a call to `DirEntry::metadata`.",
        "suggest": "如果 `Metadata` 实例是从调用创建到 `DirEntry::metadata`，则将返回 `None`。",
        "translate": ""
    },
    {
        "source": "If this `Metadata` was created by using `fs::metadata` or `File::metadata`, then this will return `Some`.",
        "suggest": "如果此 `Metadata` 是使用 `fs::metadata` 或 `File::metadata` 创建的，则它将返回 `Some`。",
        "translate": ""
    },
    {
        "source": "Returns the value of the `nNumberOfLinks` field of this metadata.",
        "suggest": "返回此元数据的 `nNumberOfLinks` 字段的值。",
        "translate": ""
    },
    {
        "source": "Returns the value of the `nFileIndex{Low,High}` fields of this metadata.",
        "suggest": "返回此元数据的 `nFileIndex{Low,High}` 字段的值。",
        "translate": ""
    },
    {
        "source": "Windows-specific extensions to [`fs::FileType`].",
        "suggest": "Windows 特定于 [`fs::FileType`] 的扩展。",
        "translate": ""
    },
    {
        "source": "On Windows, a symbolic link knows whether it is a file or directory.",
        "suggest": "在 Windows 上，符号链接知道它是文件还是目录。",
        "translate": ""
    },
    {
        "source": "Returns `true` if this file type is a symbolic link that is also a directory.",
        "suggest": "如果此文件类型是也是目录的符号链接，则返回 `true`。",
        "translate": ""
    },
    {
        "source": "Returns `true` if this file type is a symbolic link that is also a file.",
        "suggest": "如果此文件类型是也是文件的符号链接，则返回 `true`。",
        "translate": ""
    },
    {
        "source": "Creates a new file symbolic link on the filesystem.",
        "suggest": "在文件系统上创建一个新的文件符号链接。",
        "translate": ""
    },
    {
        "source": "The `link` path will be a file symbolic link pointing to the `original` path.",
        "suggest": "`link` 路径将是指向 `original` 路径的文件符号链接。",
        "translate": ""
    },
    {
        "source": "Creates a new directory symlink on the filesystem.",
        "suggest": "在文件系统上创建一个新的目录符号链接。",
        "translate": ""
    },
    {
        "source": "The `link` path will be a directory symbolic link pointing to the `original` path.",
        "suggest": "`link` 路径将是指向 `original` 路径的目录符号链接。",
        "translate": ""
    },
    {
        "source": "Windows-specific extensions to general I/O primitives.",
        "suggest": "Windows 的通用 I/O 原语扩展。",
        "translate": ""
    },
    {
        "source": "Raw HANDLEs.",
        "suggest": "原始的句柄。",
        "translate": ""
    },
    {
        "source": "Raw SOCKETs.",
        "suggest": "未加工的袜子。",
        "translate": ""
    },
    {
        "source": "Extracts raw handles.",
        "suggest": "提取原始句柄。",
        "translate": ""
    },
    {
        "source": "Extracts the raw handle, without taking any ownership.",
        "suggest": "提取原始句柄，无需任何所有权。",
        "translate": ""
    },
    {
        "source": "Construct I/O objects from raw handles.",
        "suggest": "从原始句柄构造 I/O 对象。",
        "translate": ""
    },
    {
        "source": "Constructs a new I/O object from the specified raw handle.",
        "suggest": "从指定的原始句柄创建一个新的 I/O 对象。",
        "translate": ""
    },
    {
        "source": "This function will **consume ownership** of the handle given, passing responsibility for closing the handle to the returned object.",
        "suggest": "此函数将消耗给定句柄的所有权，将关闭句柄的责任传递给返回的对象。",
        "translate": ""
    },
    {
        "source": "A trait to express the ability to consume an object and acquire ownership of its raw `HANDLE`.",
        "suggest": "trait，用于表达使用对象并获得其原始 `HANDLE` 所有权的能力。",
        "translate": ""
    },
    {
        "source": "Consumes this object, returning the raw underlying handle.",
        "suggest": "消费此 object，返回原始基础句柄。",
        "translate": ""
    },
    {
        "source": "This function **transfers ownership** of the underlying handle to the caller.",
        "suggest": "该函数将基础句柄的所有权转让给调用者。",
        "translate": ""
    },
    {
        "source": "Callers are then the unique owners of the handle and must close it once it's no longer needed.",
        "suggest": "这样，调用方便是该句柄的唯一所有者，一旦不再需要该句柄，则必须将其关闭。",
        "translate": ""
    },
    {
        "source": "Extracts raw sockets.",
        "suggest": "提取原始套接字。",
        "translate": ""
    },
    {
        "source": "Extracts the underlying raw socket from this object.",
        "suggest": "从此 object 中提取基础原始套接字。",
        "translate": ""
    },
    {
        "source": "Creates I/O objects from raw sockets.",
        "suggest": "从原始套接字创建 I/O 对象。",
        "translate": ""
    },
    {
        "source": "Creates a new I/O object from the given raw socket.",
        "suggest": "从给定的原始套接字创建一个新的 I/O object。",
        "translate": ""
    },
    {
        "source": "This function will **consume ownership** of the socket provided and it will be closed when the returned object goes out of scope.",
        "suggest": "此函数将消耗提供的套接字的所有权，并且在返回的对象离开作用域时将关闭。",
        "translate": ""
    },
    {
        "source": "A trait to express the ability to consume an object and acquire ownership of its raw `SOCKET`.",
        "suggest": "trait，用于表达使用对象并获得其原始 `SOCKET` 所有权的能力。",
        "translate": ""
    },
    {
        "source": "Consumes this object, returning the raw underlying socket.",
        "suggest": "消耗此对象，返回原始基础套接字。",
        "translate": ""
    },
    {
        "source": "This function **transfers ownership** of the underlying socket to the caller.",
        "suggest": "此函数将基础套接字的所有权转让给调用者。",
        "translate": ""
    },
    {
        "source": "Callers are then the unique owners of the socket and must close it once it's no longer needed.",
        "suggest": "这样，调用方便是套接字的唯一所有者，并且在不再需要套接字时必须将其关闭。",
        "translate": ""
    },
    {
        "source": "Platform-specific extensions to `std` for Windows.",
        "suggest": "针对 Windows 的 `std` 的特定于平台的扩展。",
        "translate": ""
    },
    {
        "source": "Provides access to platform-level information for Windows, and exposes Windows-specific idioms that would otherwise be inappropriate as part the core `std` library.",
        "suggest": "提供对 Windows 的平台级信息的访问，并公开 Windows 特定的习惯用法，否则这些习惯用法作为 core `std` 库的一部分将是不合适的。",
        "translate": ""
    },
    {
        "source": "These extensions allow developers to use `std` types and idioms with Windows in a way that the normal platform-agnostic idioms would not normally support.",
        "suggest": "这些扩展使开发人员可以将 `std` 类型和惯用语与 Windows 一起使用，而通常与平台无关的惯用语通常不支持这种方式。",
        "translate": ""
    },
    {
        "source": "Extensions to `std::process` for Windows.",
        "suggest": "Windows 的 `std::process` 扩展。",
        "translate": ""
    },
    {
        "source": "Windows-specific extensions to [`process::ExitStatus`].",
        "suggest": "Windows 特定于 [`process::ExitStatus`] 的扩展。",
        "translate": ""
    },
    {
        "source": "Creates a new `ExitStatus` from the raw underlying `u32` return value of a process.",
        "suggest": "根据进程的原始底层 `u32` 返回值创建新的 `ExitStatus`。",
        "translate": ""
    },
    {
        "source": "Windows-specific extensions to the [`process::Command`] builder.",
        "suggest": "Windows 特定于 [`process::Command`] 构建器的扩展。",
        "translate": ""
    },
    {
        "source": "Sets the [process creation flags][1] to be passed to `CreateProcess`.",
        "suggest": "设置要传递给 `CreateProcess` 的 [process creation flags][1]。",
        "translate": ""
    },
    {
        "source": "These will always be ORed with `CREATE_UNICODE_ENVIRONMENT`.",
        "suggest": "这些将始终与 `CREATE_UNICODE_ENVIRONMENT` 进行或运算。",
        "translate": ""
    },
    {
        "source": "Forces all arguments to be wrapped in quote (`\"`) characters.",
        "suggest": "强制所有参数用 (`\"`) 引号括起来。",
        "translate": ""
    },
    {
        "source": "This is useful for passing arguments to [MSYS2/Cygwin][1] based executables: these programs will expand unquoted arguments containing wildcard characters (`?` and `*`) by searching for any file paths matching the wildcard pattern.",
        "suggest": "这对于将参数传递给基于 [MSYS2/Cygwin][1] 的可执行文件很有用: 这些程序将通过搜索与通配符模式匹配的任何文件路径来扩展包含通配符 (`?` 和 `*`) 的不带引号的参数。",
        "translate": ""
    },
    {
        "source": "Adding quotes has no effect when passing arguments to programs that use [msvcrt][2].",
        "suggest": "将参数传递给使用 [msvcrt][2] 的程序时，添加引号无效。",
        "translate": ""
    },
    {
        "source": "This includes programs built with both MinGW and MSVC.",
        "suggest": "这包括使用 MinGW 和 MSVC 构建的程序。",
        "translate": ""
    },
    {
        "source": "Windows-specific primitives.",
        "suggest": "Windows 特定的原语。",
        "translate": ""
    },
    {
        "source": "Extensions to `std::thread` for Windows.",
        "suggest": "Windows 的 `std::thread` 扩展。",
        "translate": ""
    },
    {
        "source": "should be a reference",
        "suggest": "应该是一个引用",
        "translate": ""
    },
    {
        "source": "Thus the result will be e g 'ReadDir(\"C:\\\")'",
        "suggest": "因此结果将是例如 'ReadDir(\"C:\\\")'",
        "translate": ""
    },
    {
        "source": "check for '.' and '..'",
        "suggest": "检查 '.' 和 '..'",
        "translate": ""
    },
    {
        "source": "reserved unless this is a reparse point",
        "suggest": "保留，除非这是一个修复点",
        "translate": ""
    },
    {
        "source": "We have to set `SECURITY_SQOS_PRESENT` here, because one of the valid flags we can receive is `SECURITY_ANONYMOUS = 0x0`, which we can't check for later on.",
        "suggest": "我们必须在此处设置 `SECURITY_SQOS_PRESENT`，因为我们可以接收到的有效标志之一是 `SECURITY_ANONYMOUS = 0x0`，我们以后将无法对其进行检查。",
        "translate": ""
    },
    {
        "source": "Casting to `i64` is fine, `SetFilePointerEx` reinterprets this integer as `u64`.",
        "suggest": "强制转换为 `i64`，`SetFilePointerEx` 将此整数重新解释为 `u64`。",
        "translate": ""
    },
    {
        "source": "Absolute paths start with an NT internal namespace prefix `\\??\\` We should not let it leak through.",
        "suggest": "绝对路径以 NT 内部名称空间前缀 `\\??\\` 开头。我们不应让其泄漏出去。",
        "translate": ""
    },
    {
        "source": "add more info here (e.g., mode)",
        "suggest": "在此处添加更多信息 (例如，模式)",
        "translate": ""
    },
    {
        "source": "On Windows symlinks to files and directories are removed differently.",
        "suggest": "在 Windows 上，指向文件和目录的符号链接的删除方式有所不同。",
        "translate": ""
    },
    {
        "source": "rmdir only deletes dir symlinks and junctions, not file symlinks.",
        "suggest": "rmdir 仅删除目录符号链接和结点，而不删除文件符号链接。",
        "translate": ""
    },
    {
        "source": "Open the link with no access mode, instead of generic read.",
        "suggest": "在没有访问模式的情况下打开链接，而不是泛型读取。",
        "translate": ""
    },
    {
        "source": "By default FILE_LIST_DIRECTORY is denied for the junction \"C:\\Documents and Settings\", so this is needed for a common case.",
        "suggest": "缺省情况下，结点 \"C:\\Documents and Settings\" 拒绝 FILE_LIST_DIRECTORY，因此在常见情况下需要这样做。",
        "translate": ""
    },
    {
        "source": "Formerly, symlink creation required the SeCreateSymbolicLink privilege.",
        "suggest": "以前，创建符号链接需要 SeCreateSymbolicLink 权限。",
        "translate": ""
    },
    {
        "source": "For the Windows 10 Creators Update, Microsoft loosened this to allow unprivileged symlink creation if the computer is in Developer Mode, but SYMBOLIC_LINK_FLAG_ALLOW_UNPRIVILEGED_CREATE must be added to dwFlags to opt into this behaviour.",
        "suggest": "对于 Windows 10 Creators 更新，Microsoft 放宽了此限制，以允许在计算机处于开发人员模式时创建未经授权的符号链接，但是必须将 SYMBOLIC_LINK_FLAG_ALLOW_UNPRIVILEGED_CREATE 添加到 dwFlags 中才能采用此行为。",
        "translate": ""
    },
    {
        "source": "Older Windows objects to SYMBOLIC_LINK_FLAG_ALLOW_UNPRIVILEGED_CREATE, so if we encounter ERROR_INVALID_PARAMETER, retry without that flag.",
        "suggest": "较旧的 Windows 对象为 SYMBOLIC_LINK_FLAG_ALLOW_UNPRIVILEGED_CREATE，因此，如果遇到 ERROR_INVALID_PARAMETER，请重试该标志。",
        "translate": ""
    },
    {
        "source": "No read or write permissions are necessary",
        "suggest": "无需读取或写入权限",
        "translate": ""
    },
    {
        "source": "This flag is so we can open directories too",
        "suggest": "这个标志是为了让我们也可以打开目录",
        "translate": ""
    },
    {
        "source": "Creating a directory junction on windows involves dealing with reparse points and the DeviceIoControl function, and this code is a skeleton of what can be found here:",
        "suggest": "在 windows 上创建目录连接涉及处理重解析点和 DeviceIoControl 函数，此代码是在此处可以找到的内容的框架:",
        "translate": ""
    },
    {
        "source": "this conversion is very hacky",
        "suggest": "这种转换很 hacky",
        "translate": ""
    },
    {
        "source": "An owned container for `HANDLE` object, closing them on Drop.",
        "suggest": "`HANDLE` object 的拥有所有权的容器，在 Drop 上将其关闭。",
        "translate": ""
    },
    {
        "source": "All methods are inherited through a `Deref` impl to `RawHandle`",
        "suggest": "所有方法都是通过 `Deref` impl 继承到 `RawHandle`",
        "translate": ""
    },
    {
        "source": "A wrapper type for `HANDLE` objects to give them proper Send/Sync inference as well as Rust-y methods.",
        "suggest": "`HANDLE` 对象的包装类型，以为其提供正确的 Send/Sync 推断以及 Rust-y 方法。",
        "translate": ""
    },
    {
        "source": "This does **not** drop the handle when it goes out of scope, use `Handle` instead for that.",
        "suggest": "当它离开作用域时，它不会丢弃句柄，而是使用 `Handle` 代替那个。",
        "translate": ""
    },
    {
        "source": "The special treatment of BrokenPipe is to deal with Windows pipe semantics, which yields this error when *reading* from a pipe after the other end has closed;",
        "suggest": "BrokenPipe 的特殊处理是处理 Windows 管道语义，当另一端关闭后从管道读取时，会产生此错误。",
        "translate": ""
    },
    {
        "source": "we interpret that as EOF on the pipe.",
        "suggest": "我们将其解释为管道上的 EOF。",
        "translate": ""
    },
    {
        "source": "Fallback memchr is fastest on Windows.",
        "suggest": "后备 Memchr 在 Windows 上最快。",
        "translate": ""
    },
    {
        "source": "For performance reasons unfold the loop eight times.",
        "suggest": "出于性能原因，将循环展开八次。",
        "translate": ""
    },
    {
        "source": "Many Windows APIs follow a pattern of where we hand a buffer and then they will report back to us how large the buffer should be or how many bytes currently reside in the buffer.",
        "suggest": "许多 Windows API 遵循一种模式，将缓冲区交给我们，然后它们会向我们报告缓冲区应该有多大或缓冲区中当前有多少字节。",
        "translate": ""
    },
    {
        "source": "This function is an abstraction over these functions by making them easier to call.",
        "suggest": "通过使这些函数更易于调用，该函数是这些函数的抽象。",
        "translate": ""
    },
    {
        "source": "The first callback, `f1`, is yielded a (pointer, len) pair which can be passed to a syscall.",
        "suggest": "第一个回调 `f1` 产生了 (指针，len) 对，该对可以传递给系统调用。",
        "translate": ""
    },
    {
        "source": "The `ptr` is valid for `len` items (u16 in this case).",
        "suggest": "`ptr` 对 `len` 项 (在这种情况下为 u16) 有效。",
        "translate": ""
    },
    {
        "source": "The closure is expected to return what the syscall returns which will be interpreted by this function to determine if the syscall needs to be invoked again (with more buffer space).",
        "suggest": "预计闭包将返回系统调用返回的内容，此函数将对此进行解释，以确定是否需要再次调用系统调用 (具有更多的缓冲区空间)。",
        "translate": ""
    },
    {
        "source": "Once the syscall has completed (errors bail out early) the second closure is yielded the data which has been read from the syscall.",
        "suggest": "一旦系统调用完成 (错误可以尽早解决)，第二个闭包就会产生从系统调用中读取的数据。",
        "translate": ""
    },
    {
        "source": "The return value from this closure is then the return value of the function.",
        "suggest": "该闭包的返回值就是函数的返回值。",
        "translate": ""
    },
    {
        "source": "Start off with a stack buf but then spill over to the heap if we end up needing more space.",
        "suggest": "从栈缓冲区开始，但如果最终需要更多空间，则溢出到堆中。",
        "translate": ""
    },
    {
        "source": "This function is typically called on windows API functions which will return the correct length of the string, but these functions also return the `0` on error.",
        "suggest": "通常在 windows API 函数上调用此函数，该函数将返回正确的字符串长度，但是这些函数也会在出错时返回 `0`。",
        "translate": ""
    },
    {
        "source": "In some cases, however, the returned \"correct length\" may actually be 0!",
        "suggest": "但是，在某些情况下，返回的 \"correct length\" 实际上可能为 0!",
        "translate": ""
    },
    {
        "source": "To handle this case we call `SetLastError` to reset it to 0 and then check it again if we get the \"0 error value\".",
        "suggest": "为了处理这种情况，我们调用 `SetLastError` 将其重置为 0，然后再次检查是否获得 \"0 error value\"。",
        "translate": ""
    },
    {
        "source": "If the \"last error\" is still 0 then we interpret it as a 0 length buffer and not an actual error.",
        "suggest": "如果 \"last error\" 仍为 0，则我们将其解释为长度为 0 的缓冲区，而不是实际错误。",
        "translate": ""
    },
    {
        "source": "don't include the 0",
        "suggest": "不要包含 0",
        "translate": ""
    },
    {
        "source": "Note that a duration is a (u64, u32) (seconds, nanoseconds) pair, and the timeouts in windows APIs are typically u32 milliseconds.",
        "suggest": "请注意，持续时间是 (u64，u32) (秒，纳秒) 对，并且 windows API 中的超时通常为 u32 毫秒。",
        "translate": ""
    },
    {
        "source": "To translate, we have two pieces to take care of:",
        "suggest": "要翻译，我们需要注意以下两点:",
        "translate": ""
    },
    {
        "source": "Nanosecond precision is rounded up",
        "suggest": "纳秒精度舍入",
        "translate": ""
    },
    {
        "source": "Greater than u32::MAX milliseconds (50 days) is rounded up to INFINITE (never time out).",
        "suggest": "大于 u32::MAX 毫秒 (50 天) 的值会四舍五入为 INFINITE (永远不会超时)。",
        "translate": ""
    },
    {
        "source": "Use `__fastfail` to abort the process",
        "suggest": "使用 `__fastfail` 中止该进程",
        "translate": ""
    },
    {
        "source": "This is the same implementation as in libpanic_abort's `__rust_start_panic`.",
        "suggest": "这与 libpanic_abort 的 `__rust_start_panic` 中的实现相同。",
        "translate": ""
    },
    {
        "source": "See that function for more information on `__fastfail`",
        "suggest": "有关 `__fastfail` 的更多信息，请参见该函数。",
        "translate": ""
    },
    {
        "source": "For BCryptGenRandom",
        "suggest": "对于 BCryptGenRandom",
        "translate": ""
    },
    {
        "source": "System Mutexes",
        "suggest": "系统互斥锁",
        "translate": ""
    },
    {
        "source": "The Windows implementation of mutexes is a little odd and it may not be immediately obvious what's going on.",
        "suggest": "Windows 互斥锁的实现有些奇怪，可能并不马上就知道发生了什么。",
        "translate": ""
    },
    {
        "source": "The primary oddness is that SRWLock is used instead of CriticalSection, and this is done because:",
        "suggest": "最奇怪的是，使用 SRWLock 而不是 CriticalSection，这是因为:",
        "translate": ""
    },
    {
        "source": "SRWLock is several times faster than CriticalSection according to benchmarks performed on both Windows 8 and Windows 7.",
        "suggest": "根据在 Windows 8 和 Windows 7 上执行的基准测试，SRWLock 比 CriticalSection 快几倍。",
        "translate": ""
    },
    {
        "source": "CriticalSection allows recursive locking while SRWLock deadlocks.",
        "suggest": "CriticalSection 允许在 SRWLock 死锁时进行递归锁定。",
        "translate": ""
    },
    {
        "source": "The Unix implementation deadlocks so consistency is preferred.",
        "suggest": "Unix 实现死锁，因此首选一致性。",
        "translate": ""
    },
    {
        "source": "See #19962 for more details.",
        "suggest": "有关更多详细信息，请参见 #19962。",
        "translate": ""
    },
    {
        "source": "While CriticalSection is fair and SRWLock is not, the current Rust policy is that there are no guarantees of fairness.",
        "suggest": "尽管 CriticalSection 是公平的，而 SRWLock 不公平，但当前的 Rust 策略是不保证公平。",
        "translate": ""
    },
    {
        "source": "SRW Locks are movable (while not borrowed).",
        "suggest": "SRW 锁是可动的 (不借用)。",
        "translate": ""
    },
    {
        "source": "SRWLock does not need to be destroyed.",
        "suggest": "SRWLock 不需要销毁。",
        "translate": ""
    },
    {
        "source": "Checks whether the Windows socket interface has been started already, and if not, starts it.",
        "suggest": "检查 Windows 套接字接口是否已经启动，如果没有启动，则启动它。",
        "translate": ""
    },
    {
        "source": "version 2.2",
        "suggest": "版本 2.2",
        "translate": ""
    },
    {
        "source": "Returns the last error from the Windows socket interface.",
        "suggest": "从 Windows 套接字接口返回最后一个错误。",
        "translate": ""
    },
    {
        "source": "Checks if the signed integer is the Windows constant `SOCKET_ERROR` (-1) and if so, returns the last error from the Windows socket interface.",
        "suggest": "检查有符号整数是否为 Windows 常量 `SOCKET_ERROR` (-1)，如果是，则从 Windows 套接字接口返回最后一个错误。",
        "translate": ""
    },
    {
        "source": "This function must be called before another call to the socket API is made.",
        "suggest": "必须在调用套接字 API 之前调用此函数。",
        "translate": ""
    },
    {
        "source": "A variant of `cvt` for `getaddrinfo` which return 0 for a success.",
        "suggest": "`getaddrinfo` 的 `cvt` 成员，成功返回 0。",
        "translate": ""
    },
    {
        "source": "Just to provide the same interface as sys/unix/net.rs",
        "suggest": "仅提供与 sys/unix/net.rs 相同的接口",
        "translate": ""
    },
    {
        "source": "On unix when a socket is shut down all further reads return 0, so we do the same on windows to map a shut down socket to returning EOF.",
        "suggest": "在 unix 上，当套接字关闭时，所有后续读取都返回 0，因此我们在 windows 到 map 上执行相同的操作，即关闭套接字以返回 EOF。",
        "translate": ""
    },
    {
        "source": "tests `error_string` above",
        "suggest": "测试 `error_string` 以上",
        "translate": ""
    },
    {
        "source": "Implementation of `std::os` functionality for Windows.",
        "suggest": "Windows 的 `std::os` 功能的实现。",
        "translate": ""
    },
    {
        "source": "This value is calculated from the macro",
        "suggest": "该值是根据宏计算得出的",
        "translate": ""
    },
    {
        "source": "NTSTATUS errors may be encoded as HRESULT, which may returned from GetLastError.",
        "suggest": "NTSTATUS 错误可能被编码为 HRESULT，它可以从 GetLastError 返回。",
        "translate": ""
    },
    {
        "source": "For more information about Windows error codes, see `[MS-ERREF]`:",
        "suggest": "有关 Windows 错误代码的更多信息，请参见 `[MS-ERREF]`:",
        "translate": ""
    },
    {
        "source": "Sometimes FormatMessageW can fail e.g., system doesn't like langId,",
        "suggest": "有时 FormatMessageW 可能会失败，例如，系统不喜欢 langId，",
        "translate": ""
    },
    {
        "source": "Trim trailing CRLF inserted by FormatMessageW",
        "suggest": "修剪尾随 CRLF 由 FormatMessageW 插入",
        "translate": ""
    },
    {
        "source": "allows environment variables to start with an equals symbol (in any other position, this is the separator between variable name and value).",
        "suggest": "允许环境变量以等号开头 (在任何其他位置，这是变量名和值之间的分隔符)。",
        "translate": ""
    },
    {
        "source": "Since`s` has at least length 1 at this point (because the empty string terminates the array of environment variables), we can safely slice.",
        "suggest": "由于此时 s 的长度至少为 1 (因为空字符串终止了环境变量的数组)，因此我们可以安全地进行切片。",
        "translate": ""
    },
    {
        "source": "On Windows, the PATH environment variable is semicolon separated.",
        "suggest": "在 Windows 上，PATH 环境变量以分号分隔。",
        "translate": ""
    },
    {
        "source": "Double quotes are used as a way of introducing literal semicolons (since c:\\some;dir is a valid Windows path).",
        "suggest": "双引号用作引入字面量分号的方法 (因为 c:\\some;dir 是有效的 Windows 路径)。",
        "translate": ""
    },
    {
        "source": "Double quotes are not themselves permitted in path names, so there is no way to escape a double quote.",
        "suggest": "路径名本身不允许使用双引号，因此无法转义双引号。",
        "translate": ""
    },
    {
        "source": "Quoted regions can appear in arbitrary locations, so",
        "suggest": "引用的区域可以出现在任意位置，所以",
        "translate": ""
    },
    {
        "source": "Should parse as [c:\\foo, c:\\some;dir, c:\\bar].",
        "suggest": "应该解析为 [c:\\foo, c:\\some;dir, c:\\bar]。",
        "translate": ""
    },
    {
        "source": "(The above is based on testing; there is no clear reference available for the grammar.)",
        "suggest": "(以上内容基于测试; 语法上没有明显的引用。)",
        "translate": ""
    },
    {
        "source": "sz includes the null terminator",
        "suggest": "sz 包含空终止符",
        "translate": ""
    },
    {
        "source": "The underlying OsString/OsStr implementation on Windows is a wrapper around the \"WTF-8\" encoding;",
        "suggest": "Windows 上的基本 OsString/OsStr 实现是 \"WTF-8\" 编码的包装。",
        "translate": ""
    },
    {
        "source": "see the `wtf8` module for more.",
        "suggest": "有关更多信息，请参见 `wtf8` 模块。",
        "translate": ""
    },
    {
        "source": "Slice is just a wrapper for Wtf8, and self.inner.as_slice() returns &Wtf8.",
        "suggest": "切片只是 Wtf8 的包装，self.inner.as_slice() 返回 &Wtf8。",
        "translate": ""
    },
    {
        "source": "Therefore, transmuting &Wtf8 to &Slice is safe.",
        "suggest": "因此，将 &Wtf8 转换为 &Slice 是安全的。",
        "translate": ""
    },
    {
        "source": "Slice is just a wrapper for Wtf8, and self.inner.as_mut_slice() returns &mut Wtf8.",
        "suggest": "切片只是 Wtf8 的包装，self.inner.as_mut_slice() 返回 &mut Wtf8。",
        "translate": ""
    },
    {
        "source": "Therefore, transmuting &mut Wtf8 to &mut Slice is safe.",
        "suggest": "因此，将 &mut Wtf8 转换为 &mut 切片是安全的。",
        "translate": ""
    },
    {
        "source": "Additionally, care should be taken to ensure the slice is always valid Wtf8.",
        "suggest": "此外，应注意确保切片始终是有效的 Wtf8。",
        "translate": ""
    },
    {
        "source": "must be a valid wtf8 encoded slice",
        "suggest": "必须是有效的 wtf8 编码的切片",
        "translate": ""
    },
    {
        "source": "is layout compatible with &Slice, which is compatible with &Wtf8, which is compatible with &[u8].",
        "suggest": "是与 &Slice 兼容的布局，与 &Slice 兼容的 &Wtf8 与 &[u8] 兼容。",
        "translate": ""
    },
    {
        "source": "in verbatim paths only recognize an exact drive prefix",
        "suggest": "逐字路径中的字符只能识别确切的驱动器前缀",
        "translate": ""
    },
    {
        "source": "no valid prefix beginning with \"\\\\\" recognized",
        "suggest": "无法识别以 \"\\\\\" 开头的有效前缀",
        "translate": ""
    },
    {
        "source": "no prefix",
        "suggest": "无前缀",
        "translate": ""
    },
    {
        "source": "Parses a drive prefix, e.g. \"C:\" and \"C:\\whatever\"",
        "suggest": "解析驱动器前缀，例如 \"C:\" 和 \"C:\\whatever\"",
        "translate": ""
    },
    {
        "source": "In most DOS systems, it is not possible to have more than 26 drive letters.",
        "suggest": "在大多数 DOS 系统中，驱动器号不能超过 26 个。",
        "translate": ""
    },
    {
        "source": "See <https://en.wikipedia.org/wiki/Drive_letter_assignment#Common_assignments>.",
        "suggest": "请参见 <https://en.wikipedia.org/wiki/Drive_letter_assignment#Common_assignments>。",
        "translate": ""
    },
    {
        "source": "Parses a drive prefix exactly, e.g.",
        "suggest": "精确解析驱动器前缀，例如",
        "translate": ""
    },
    {
        "source": "only parse two bytes: the drive letter and the drive separator",
        "suggest": "仅解析两个字节: 驱动器号和驱动器分隔符",
        "translate": ""
    },
    {
        "source": "and `prefix` are valid wtf8 and utf8 encoded slices respectively, `path[prefix.len()]` is thus a code point boundary and `path[prefix.len()..]` is a valid wtf8 encoded slice.",
        "suggest": "和 `prefix` 分别是有效的 wtf8 和 utf8 编码的切片，因此 `path[prefix.len()]` 是代码点边界，而 `path[prefix.len()..]` 是有效的 wtf8 编码的切片。",
        "translate": ""
    },
    {
        "source": "Parse the next path component.",
        "suggest": "解析下一个路径组件。",
        "translate": ""
    },
    {
        "source": "Returns the next component and the rest of the path excluding the component and separator.",
        "suggest": "返回路径的下一个组成部分和剩余部分，不包括组成部分和分隔符。",
        "translate": ""
    },
    {
        "source": "Does not recognize `/` as a separator character if `verbatim` is true.",
        "suggest": "如果 `verbatim` 为 true，则不能将 `/` 识别为分隔符。",
        "translate": ""
    },
    {
        "source": "a series of multiple separator characters is treated as a single separator, except in verbatim paths",
        "suggest": "一系列的多个分隔符被视为单个分隔符 (逐字路径中除外)",
        "translate": ""
    },
    {
        "source": "Panic safe The max `separator_end` is `bytes.len()` and `bytes[bytes.len()..]` is a valid index.",
        "suggest": "Panic safe 最大值 `separator_end` 为 `bytes.len()`，`bytes[bytes.len()..]` 为有效索引。",
        "translate": ""
    },
    {
        "source": "`path` is a valid wtf8 encoded slice and each of the separators ('/', '\\') is encoded in a single byte, therefore `bytes[separator_start]` and `bytes[separator_end]` must be code point boundaries and thus `bytes[..separator_start]` and `bytes[separator_end..]` are valid wtf8 slices.",
        "suggest": "`path` 是有效的 wtf8 编码切片，并且每个分隔符 (`/`，'\\') 都编码在一个字节中，因此 `bytes[separator_start]` 和 `bytes[separator_end]` 必须是代码点边界，因此 `bytes[..separator_start]` 和 `bytes[separator_end..]` 是有效的 wtf8 切片。",
        "translate": ""
    },
    {
        "source": "Although this looks similar to `anon_pipe` in the Unix module it's actually subtly different.",
        "suggest": "尽管这看起来与 Unix 模块中的 `anon_pipe` 相似，但实际上有细微的差别。",
        "translate": ""
    },
    {
        "source": "Here we'll return two pipes in the `Pipes` return value, but one is intended for \"us\" where as the other is intended for \"someone else\".",
        "suggest": "在这里，我们将在 `Pipes` 返回值中返回两个管道，但是一个管道用于 \"us\"，而另一个管道用于 \"someone else\"。",
        "translate": ""
    },
    {
        "source": "Currently the only use case for this function is pipes for stdio on processes in the standard library, so \"ours\" is the one that'll stay in our process whereas \"theirs\" will be inherited to a child.",
        "suggest": "当前，此函数的唯一用例是标准库中进程的标准输入输出管道，因此 \"ours\" 将保留在我们的进程中，而 \"theirs\" 将被继承给子进程。",
        "translate": ""
    },
    {
        "source": "The ours/theirs pipes are *not* specifically readable or writable.",
        "suggest": "ours/theirs 管道 *不是* 专门可读或可写的。",
        "translate": ""
    },
    {
        "source": "Each one only supports a read or a write, but which is which depends on the boolean flag given.",
        "suggest": "每个仅支持读或写，但这取决于给定的布尔标志。",
        "translate": ""
    },
    {
        "source": "If `ours_readable` is `true`, then `ours` is readable and `theirs` is writable.",
        "suggest": "如果 `ours_readable` 是 `true`，那么 `ours` 是可读的，`theirs` 是可写的。",
        "translate": ""
    },
    {
        "source": "Conversely, if `ours_readable` is `false`, then `ours` is writable and `theirs` is readable.",
        "suggest": "相反，如果 `ours_readable` 是 `false`，则 `ours` 是可写的，并且 `theirs` 是可读的。",
        "translate": ""
    },
    {
        "source": "Also note that the `ours` pipe is always a handle opened up in overlapped mode.",
        "suggest": "另请注意，`ours` 管道始终是在重叠模式下打开的句柄。",
        "translate": ""
    },
    {
        "source": "This means that technically speaking it should only ever be used with `OVERLAPPED` instances, but also works out ok if it's only ever used once at a time (which we do indeed guarantee).",
        "suggest": "这意味着从技术上讲，它只能用于 `OVERLAPPED` 实例，但是一次只能使用一次也可以 (我们确实保证)。",
        "translate": ""
    },
    {
        "source": "Note that we specifically do *not* use `CreatePipe` here because unfortunately the anonymous pipes returned do not support overlapped operations.",
        "suggest": "请注意，我们这里特别 *不* 使用 `CreatePipe`，因为不幸的是，返回的匿名管道不支持重叠的操作。",
        "translate": ""
    },
    {
        "source": "Instead, we create a \"hopefully unique\" name and create a named pipe which has overlapped operations enabled.",
        "suggest": "而是，我们创建一个 \"hopefully unique\" 名称并创建一个已启用重叠操作的命名管道。",
        "translate": ""
    },
    {
        "source": "Once we do this, we connect do it as usual via `CreateFileW`, and then we return those reader/writer halves.",
        "suggest": "完成此操作后，我们将照常通过 `CreateFileW` 进行连接，然后返回这些 reader/writer 一半。",
        "translate": ""
    },
    {
        "source": "Note that the `ours` pipe return value is always the named pipe, whereas `theirs` is just the normal file.",
        "suggest": "请注意，`ours` 管道返回值始终是命名管道，而 `theirs` 只是普通文件。",
        "translate": ""
    },
    {
        "source": "This should hopefully shield us from child processes which assume their stdout is a named pipe, which would indeed be odd!",
        "suggest": "希望这可以使我们免受子进程的影响，这些子进程假设其 stdout 是命名管道，这确实是奇怪的!",
        "translate": ""
    },
    {
        "source": "We pass the `FILE_FLAG_FIRST_PIPE_INSTANCE` flag above, and we're also just doing a best effort at selecting a unique name.",
        "suggest": "我们通过了上面的 `FILE_FLAG_FIRST_PIPE_INSTANCE` 标志，并且我们也在尽力选择唯一的名称。",
        "translate": ""
    },
    {
        "source": "If `ERROR_ACCESS_DENIED` is returned then it could mean that we accidentally conflicted with an already existing pipe, so we try again.",
        "suggest": "如果返回 `ERROR_ACCESS_DENIED`，则可能意味着我们意外地与已经存在的管道发生冲突，因此请重试。",
        "translate": ""
    },
    {
        "source": "Don't try again too much though as this could also perhaps be a legit error.",
        "suggest": "尽管不要再尝试太多，因为这也可能是合法错误。",
        "translate": ""
    },
    {
        "source": "If `ERROR_INVALID_PARAMETER` is returned, this probably means we're running on pre-Vista version where `PIPE_REJECT_REMOTE_CLIENTS` is not supported, so we continue retrying without it.",
        "suggest": "如果返回 `ERROR_INVALID_PARAMETER`，则可能意味着我们正在不支持 `PIPE_REJECT_REMOTE_CLIENTS` 的 Vista 之前版本上运行，因此我们将继续尝试不使用 `PIPE_REJECT_REMOTE_CLIENTS`。",
        "translate": ""
    },
    {
        "source": "This implies reduced security on Windows versions older than Vista by allowing connections to this pipe from remote machines.",
        "suggest": "这意味着允许通过远程计算机连接到此管道，从而降低了 Vista 之前的 Windows 版本的安全性。",
        "translate": ""
    },
    {
        "source": "Proper fix would increase the number of FFI imports and introduce significant amount of Windows XP specific code with no clean testing strategy For more info,",
        "suggest": "正确的修复会增加 FFI 导入的数量，并引入大量 Windows XP 专用代码，而没有干净的测试策略。有关更多信息，",
        "translate": ""
    },
    {
        "source": "Connect to the named pipe we just created.",
        "suggest": "连接到我们刚刚创建的命名管道。",
        "translate": ""
    },
    {
        "source": "This handle is going to be returned in `theirs`, so if `ours` is readable we want this to be writable, otherwise if `ours` is writable we want this to be readable.",
        "suggest": "该句柄将在 `theirs` 中返回，因此，如果 `ours` 是可读的，我们希望它是可写的，否则，如果 `ours` 是可写的，我们希望它是可读的。",
        "translate": ""
    },
    {
        "source": "Additionally we don't enable overlapped mode on this because most client processes aren't enabled to work with that.",
        "suggest": "另外，我们不对此启用重叠模式，因为大多数客户端进程均未启用重叠模式。",
        "translate": ""
    },
    {
        "source": "In a loop we wait for either pipe's scheduled read operation to complete.",
        "suggest": "在一个循环中，我们等待任何一个管道的预定读取操作完成。",
        "translate": ""
    },
    {
        "source": "If the operation completes with 0 bytes, that means EOF was reached, in which case we just finish out the other pipe entirely.",
        "suggest": "如果操作以 0 个字节完成，则表示已达到 EOF，在这种情况下，我们将完全结束另一个管道。",
        "translate": ""
    },
    {
        "source": "Note that overlapped I/O is in general super unsafe because we have to be careful to ensure that all pointers in play are valid for the entire duration of the I/O operation (where tons of operations can also fail).",
        "suggest": "请注意，重叠的 I/O 通常是超级不安全的，因为我们必须注意确保所有正在播放的指针在 I/O 操作的整个持续时间内都是有效的 (其中大量操作也可能会失败)。",
        "translate": ""
    },
    {
        "source": "The destructor for `AsyncPipe` ends up taking care of most of this.",
        "suggest": "`AsyncPipe` 的析构函数最终将完成大部分工作。",
        "translate": ""
    },
    {
        "source": "needs a stable address",
        "suggest": "需要一个稳定的地址",
        "translate": ""
    },
    {
        "source": "Create an event which we'll use to coordinate our overlapped operations, this event will be used in WaitForMultipleObjects and passed as part of the OVERLAPPED handle.",
        "suggest": "创建一个用于协调重叠操作的事件，该事件将在 WaitForMultipleObjects 中使用，并作为 OVERLAPPED 句柄的一部分传递。",
        "translate": ""
    },
    {
        "source": "Note that we do a somewhat clever thing here by flagging the event as being manually reset and setting it initially to the signaled state.",
        "suggest": "请注意，我们在这里通过将事件标记为手动重置并将其初始设置为信号状态来做一些聪明的事情。",
        "translate": ""
    },
    {
        "source": "This means that we'll naturally fall through the WaitForMultipleObjects call above for pipes created initially, and the only time an even will go back to \"unset\" will be once an I/O operation is successfully scheduled (what we want).",
        "suggest": "这意味着对于最初创建的管道，我们自然会经历上面的 WaitForMultipleObjects 调用，并且一旦成功调度了 I/O 操作 (我们想要的)，偶数返回 \"unset\" 的唯一时间。",
        "translate": ""
    },
    {
        "source": "Executes an overlapped read operation.",
        "suggest": "执行重叠的读取操作。",
        "translate": ""
    },
    {
        "source": "Must not currently be reading, and returns whether the pipe is currently at EOF or not.",
        "suggest": "当前不能正在读取，并返回管道当前是否处于 EOF。",
        "translate": ""
    },
    {
        "source": "If the pipe is not at EOF then `result()` must be called to complete the read later on (may block), but if the pipe is at EOF then `result()` should not be called as it will just block forever.",
        "suggest": "如果管道不在 EOF 处，则必须调用 `result()` 以完成以后的读取 (可能会阻塞)，但是，如果管道在 EOF 处，则不应调用 `result()`，因为它将永远阻塞。",
        "translate": ""
    },
    {
        "source": "If this read finished immediately then our overlapped event will remain signaled (it was signaled coming in here) and we'll progress down to the method below.",
        "suggest": "如果此读取立即完成，则我们的重叠事件将继续发出信号 (信号已传入此处)，然后我们将继续进行下面的方法。",
        "translate": ""
    },
    {
        "source": "Otherwise the I/O operation is scheduled and the system set our event to not signaled, so we flag ourselves into the reading state and move on.",
        "suggest": "否则，将调度 I/O 操作，并且系统会将事件设置为不发出信号，因此我们将自己标记为读取状态并继续前进。",
        "translate": ""
    },
    {
        "source": "Wait for the result of the overlapped operation previously executed.",
        "suggest": "等待先前执行的重叠操作的结果。",
        "translate": ""
    },
    {
        "source": "Takes a parameter `wait` which indicates if this pipe is currently being read whether the function should block waiting for the read to complete.",
        "suggest": "接受参数 `wait`，该参数指示当前是否正在读取此管道，函数是否应阻塞以等待读取完成。",
        "translate": ""
    },
    {
        "source": "Returns values:",
        "suggest": "返回值:",
        "translate": ""
    },
    {
        "source": "finished any pending read and the pipe is not at EOF (keep going)",
        "suggest": "完成所有未完成的读取，并且管道未处于 EOF 位置 (继续运行)",
        "translate": ""
    },
    {
        "source": "finished any pending read and pipe is at EOF (stop issuing reads)",
        "suggest": "完成所有未完成的读取，并且管道位于 EOF (停止发出读取)",
        "translate": ""
    },
    {
        "source": "Finishes out reading this pipe entirely.",
        "suggest": "完成全部读取此管道。",
        "translate": ""
    },
    {
        "source": "Waits for any pending and schedule read, and then calls `read_to_end` if necessary to read all the remaining information.",
        "suggest": "等待任何未决和计划读取，然后在必要时调用 `read_to_end` 以读取所有剩余信息。",
        "translate": ""
    },
    {
        "source": "If we have a pending read operation, then we have to make sure that it's *done* before we actually drop this type.",
        "suggest": "如果我们有一个待处理的读取操作，那么在实际丢弃此类型之前，必须确保它已完成。",
        "translate": ""
    },
    {
        "source": "The kernel requires that the `OVERLAPPED` and buffer pointers are valid for the entire I/O operation.",
        "suggest": "内核要求 `OVERLAPPED` 和缓冲区指针对于整个 I/O 操作均有效。",
        "translate": ""
    },
    {
        "source": "To do that, we call `CancelIo` to cancel any pending operation, and if that succeeds we wait for the overlapped result.",
        "suggest": "为此，我们调用 `CancelIo` 取消任何挂起的操作，如果操作成功，我们将等待重叠的结果。",
        "translate": ""
    },
    {
        "source": "If anything here fails, there's not really much we can do, so we leak the buffer/OVERLAPPED pointers to ensure we're at least memory safe.",
        "suggest": "如果这里的任何事情失败了，我们实际上无能为力，因此我们泄漏了 buffer/OVERLAPPED 指针以确保我们至少是内存安全的。",
        "translate": ""
    },
    {
        "source": "not currently exposed in std::process",
        "suggest": "当前不在 std::process 中公开",
        "translate": ""
    },
    {
        "source": "To have the spawning semantics of unix/windows stay the same, we need to read the *child's* PATH if one is provided.",
        "suggest": "为了使 unix/windows 的生成语义保持不变，我们需要读取 *child'* PATH (如果已提供)。",
        "translate": ""
    },
    {
        "source": "See #15149 for more details.",
        "suggest": "有关更多详细信息，请参见 #15149。",
        "translate": ""
    },
    {
        "source": "Split the value and test each path to see if the program exists.",
        "suggest": "拆分该值并测试每个路径以查看程序是否存在。",
        "translate": ""
    },
    {
        "source": "add null terminator",
        "suggest": "添加空终止符",
        "translate": ""
    },
    {
        "source": "stolen from the libuv code.",
        "suggest": "从 libuv 代码中被盗。",
        "translate": ""
    },
    {
        "source": "Prepare all stdio handles to be inherited by the child.",
        "suggest": "准备所有要由子节点继承的标准输入输出句柄。",
        "translate": ""
    },
    {
        "source": "This currently involves duplicating any existing ones with the ability to be inherited by child processes.",
        "suggest": "当前，这涉及复制具有子进程继承能力的任何现有进程。",
        "translate": ""
    },
    {
        "source": "Note, however, that once an inheritable handle is created, *any* spawned child will inherit that handle.",
        "suggest": "但是请注意，一旦创建了可继承的句柄，*any* 产生的子代将继承该句柄。",
        "translate": ""
    },
    {
        "source": "We only want our own child to inherit this handle, so we wrap the remaining portion of this spawn in a mutex.",
        "suggest": "我们只希望自己的子节点继承此句柄，因此我们将这个 spawn 的其余部分包装在互斥锁中。",
        "translate": ""
    },
    {
        "source": "For more information, msdn also has an article about this race:",
        "suggest": "有关更多信息，msdn 还提供了有关此竞赛的文章:",
        "translate": ""
    },
    {
        "source": "We close the thread handle because we don't care about keeping the thread id valid, and we aren't keeping the thread handle around to be able to close it later.",
        "suggest": "我们关闭线程句柄是因为我们不关心保持线程 ID 有效，也不是为了保持线程句柄的稍后使用而关闭它。",
        "translate": ""
    },
    {
        "source": "If no stdio handle is available, then inherit means that it should still be unavailable so propagate the INVALID_HANDLE_VALUE.",
        "suggest": "如果没有标准输入输出句柄可用，则继承意味着它仍将不可用，因此传播 INVALID_HANDLE_VALUE。",
        "translate": ""
    },
    {
        "source": "Open up a reference to NUL with appropriate read/write permissions as well as the ability to be inherited to child processes (as this is about to be inherited).",
        "suggest": "使用适当的 read/write 权限以及继承给子进程的能力 (因为这将被继承)，对 NUL 打开引用。",
        "translate": ""
    },
    {
        "source": "A value representing a child process.",
        "suggest": "代表子进程的值。",
        "translate": ""
    },
    {
        "source": "The lifetime of this value is linked to the lifetime of the actual process - the Process destructor calls self.finish() which waits for the process to terminate.",
        "suggest": "此值的生命周期链接到实际进程的生命周期 - 进程析构函数调用 self.finish()，它等待进程终止。",
        "translate": ""
    },
    {
        "source": "Converts a raw `c::DWORD` to a type-safe `ExitStatus` by wrapping it without copying.",
        "suggest": "通过包装原始 `c::DWORD` 而无需复制将其转换为类型安全的 `ExitStatus`。",
        "translate": ""
    },
    {
        "source": "exit codes with the high bit set typically mean some form of unhandled exception or warning.",
        "suggest": "设置高位的退出代码通常表示某种形式的未处理异常或警告。",
        "translate": ""
    },
    {
        "source": "In this scenario printing the exit code in decimal doesn't always make sense because it's a very large and somewhat gibberish number.",
        "suggest": "在这种情况下，用十进制打印退出代码并不总是很有意义，因为它是一个很大且有点乱码的数字。",
        "translate": ""
    },
    {
        "source": "The hex code is a bit more recognizable and easier to search for, so print that.",
        "suggest": "十六进制代码更易于识别，更易于搜索，因此请打印出来。",
        "translate": ""
    },
    {
        "source": "Produces a wide string *without terminating null*;",
        "suggest": "产生一个宽字符串 *without terminating null*;",
        "translate": ""
    },
    {
        "source": "returns an error if `prog` or any of the `args` contain a nul.",
        "suggest": "如果 `prog` 或任何 `args` 包含 nul，则返回错误。",
        "translate": ""
    },
    {
        "source": "Encode the command and arguments in a command line string such that the spawned process may recover them using CommandLineToArgvW.",
        "suggest": "将命令和参数编码在命令行字符串中，以使生成的进程可以使用 CommandLineToArgvW 恢复它们。",
        "translate": ""
    },
    {
        "source": "Always quote the program name so CreateProcess doesn't interpret args as part of the name if the binary wasn't found first time.",
        "suggest": "始终引用程序名称，这样，如果第一次没有找到二进制文件，则 CreateProcess 不会将 args 解释为名称的一部分。",
        "translate": ""
    },
    {
        "source": "If an argument has 0 characters then we need to quote it to ensure that it actually gets passed through on the command line or otherwise it will be dropped entirely when parsed on the other end.",
        "suggest": "如果一个参数有 0 个字符，那么我们需要用引号将其括起来，以确保它实际上是在命令行中通过的，否则在另一端进行解析时它将被完全丢弃。",
        "translate": ""
    },
    {
        "source": "Add n+1 backslashes to total 2n+1 before internal '\"'.",
        "suggest": "在内部 '\"' 之前，将 n + 1 个反斜杠加到总计 2n + 1。",
        "translate": ""
    },
    {
        "source": "Add n backslashes to total 2n before ending '\"'.",
        "suggest": "在结束 '\"' 之前，将 n 个反斜杠加到总计 2n。",
        "translate": ""
    },
    {
        "source": "On Windows we pass an \"environment block\" which is not a char**, but rather a concatenation of null-terminated k=v\\0 sequences, with a final \\0 to terminate.",
        "suggest": "在 Windows 上，我们传递的 \"environment block\" 不是 char **，而是空终止的 k=v\\0 序列的串联，最后一个 \\0 终止。",
        "translate": ""
    },
    {
        "source": "This API isn't available on XP, so don't panic in that case and just pray it works out ok.",
        "suggest": "该 API 在 XP 上不可用，因此不要在这种情况下使用 panic，只是祈祷它可以正常工作。",
        "translate": ""
    },
    {
        "source": "Set the thread stack guarantee for the main thread.",
        "suggest": "设置主线程的线程栈保证。",
        "translate": ""
    },
    {
        "source": "Don't cache handles but get them fresh for every read/write.",
        "suggest": "不要缓存句柄，但应为每个 read/write 刷新它们。",
        "translate": ""
    },
    {
        "source": "This allows us to track changes to the value over time (such as if a process calls `SetStdHandle` while it's running).",
        "suggest": "这使我们能够跟踪随时间变化的值 (例如，如果进程在运行时调用 `SetStdHandle`)。",
        "translate": ""
    },
    {
        "source": "See #40490.",
        "suggest": "请参见 #40490。",
        "translate": ""
    },
    {
        "source": "Apparently Windows doesn't handle large reads on stdin or writes to stdout/stderr well (see #13304 for details).",
        "suggest": "显然，Windows 不能处理 stdin 上的大量读取，也不能很好地写入 stdout/stderr (有关详细信息，请参见 #13304)。",
        "translate": ""
    },
    {
        "source": "From MSDN (2011): \"The storage for this buffer is allocated from a shared heap for the process that is 64 KB in size.",
        "suggest": "从 MSDN (2011): ` 此缓冲区的存储是从共享堆分配的，用于 64 KB 大小的进程。",
        "translate": ""
    },
    {
        "source": "The maximum size of the buffer will depend on heap usage.\"",
        "suggest": "缓冲区的最大大小将取决于堆的使用情况。`",
        "translate": ""
    },
    {
        "source": "We choose the cap at 8 KiB because libuv does the same, and it seems to be acceptable so far.",
        "suggest": "我们选择上限为 8 KiB，因为 libuv 也是这样做的，到目前为止，这似乎是可以接受的。",
        "translate": ""
    },
    {
        "source": "The standard buffer size of BufReader for Stdin should be able to hold 3x more bytes than there are `u16`'s in MAX_BUFFER_SIZE.",
        "suggest": "Stdin 的 BufReader 的标准缓冲区大小应比 MAX_BUFFER_SIZE 中的 `u16` 字节多 3 倍。",
        "translate": ""
    },
    {
        "source": "This ensures the read data can always be completely decoded from UTF-16 to UTF-8.",
        "suggest": "这确保了读取的数据始终可以从 UTF-16 到 UTF-8 完全解码。",
        "translate": ""
    },
    {
        "source": "will return false (0) if this is a pipe (we don't care about the reported mode).",
        "suggest": "如果这是管道，将返回 false (0) (我们不在乎报告的模式)。",
        "translate": ""
    },
    {
        "source": "This will only detect Windows Console, not other terminals connected to a pipe like MSYS.",
        "suggest": "这将仅检测 Windows 控制台，而不检测连接到 MSYS 等管道的其他终端。",
        "translate": ""
    },
    {
        "source": "Which is exactly what we need, as only Windows Console needs a conversion to UTF-16.",
        "suggest": "正是我们需要的，因为只有 Windows 控制台需要转换为 UTF-16。",
        "translate": ""
    },
    {
        "source": "Don't close the handle",
        "suggest": "不要关闭句柄",
        "translate": ""
    },
    {
        "source": "As the console is meant for presenting text, we assume bytes of `data` come from a string and are encoded as UTF-8, which needs to be encoded as UTF-16.",
        "suggest": "由于控制台是用来显示文本的，因此我们假设 `data` 的字节来自字符串，并且编码为 UTF-8，需要将其编码为 UTF-16。",
        "translate": ""
    },
    {
        "source": "If the data is not valid UTF-8 we write out as many bytes as are valid.",
        "suggest": "如果数据无效 UTF-8，我们将写出尽可能多的字节。",
        "translate": ""
    },
    {
        "source": "Only when there are no valid bytes (which will happen on the next call), return an error.",
        "suggest": "仅当没有有效字节时 (将在下一次调用中发生)，才返回错误。",
        "translate": ""
    },
    {
        "source": "Figure out how many bytes of as UTF-8 were written away as UTF-16.",
        "suggest": "找出有多少字节的 UTF-8 被写为 UTF-16。",
        "translate": ""
    },
    {
        "source": "Make sure we didn't end up writing only half of a surrogate pair (even though the chance is tiny).",
        "suggest": "确保我们最终不会只写代理对的一半 (即使机会很小)。",
        "translate": ""
    },
    {
        "source": "Because it is not possible for user code to re-slice `data` in such a way that a missing surrogate can be produced (and also because of the UTF-8 validation above), write the missing surrogate out now.",
        "suggest": "由于用户代码不可能重新生成 `data`，从而无法生成丢失的替代项 (并且也由于上面的 UTF-8 验证)，因此请立即写出丢失的替代项。",
        "translate": ""
    },
    {
        "source": "Buffering it would mean we have to lie about the number of bytes written.",
        "suggest": "缓冲它意味着我们必须说谎所写的字节数。",
        "translate": ""
    },
    {
        "source": "low surrogate We just hope this works, and give up otherwise",
        "suggest": "低代理我们只是希望这行得通，否则就放弃",
        "translate": ""
    },
    {
        "source": "Calculate the number of bytes of `utf8` that were actually written.",
        "suggest": "计算实际写入的 `utf8` 字节数。",
        "translate": ""
    },
    {
        "source": "Low surrogate.",
        "suggest": "低代理。",
        "translate": ""
    },
    {
        "source": "We already counted 3 bytes for the other.",
        "suggest": "我们已经为另一个计数了 3 个字节。",
        "translate": ""
    },
    {
        "source": "In the worst case, an UTF-8 string can take 3 bytes for every `u16` of an UTF-16.",
        "suggest": "在最坏的情况下，对于 UTF-16 中的每个 `u16`，UTF-8 字符串可能占用 3 个字节。",
        "translate": ""
    },
    {
        "source": "So we can read at most a third of `buf.len()` chars and uphold the guarantee no data gets lost.",
        "suggest": "因此，我们最多可以读取 `buf.len()` 字符的三分之一，并坚持保证不会丢失任何数据。",
        "translate": ""
    },
    {
        "source": "We assume that if the last `u16` is an unpaired surrogate they got sliced apart by our buffer size, and keep it around for the next read hoping to put them together.",
        "suggest": "我们假设如果最后一个 `u16` 是不成对的代理，则它们将根据我们的缓冲区大小进行分割，并保留它以备下一次读取时使用，以将它们放在一起。",
        "translate": ""
    },
    {
        "source": "This is a best effort, and may not work if we are not the only reader on Stdin.",
        "suggest": "这是尽力而为的，如果我们不是 Stdin 上唯一的 reader，则可能无法正常工作。",
        "translate": ""
    },
    {
        "source": "Insert possibly remaining unpaired surrogate from last read.",
        "suggest": "插入上次读取的可能剩余的未配对代理。",
        "translate": ""
    },
    {
        "source": "Special case: `Stdin::read` guarantees we can always read at least one new `u16` and combine it with an unpaired surrogate, because the UTF-8 buffer is at least",
        "suggest": "特殊情况: `Stdin::read` 保证我们总是可以读取至少一个新的 `u16` 并将其与未配对的代理结合，因为 UTF-8 缓冲区至少是",
        "translate": ""
    },
    {
        "source": "4 bytes.",
        "suggest": "4 字节。",
        "translate": ""
    },
    {
        "source": "high surrogate",
        "suggest": "高代理",
        "translate": ""
    },
    {
        "source": "Configure the `pInputControl` parameter to not only return on `\\r\\n` but also Ctrl-Z, the traditional DOS method to indicate end of character stream / user input (SUB).",
        "suggest": "配置 `pInputControl` 参数不仅要返回 `\\r\\n`，还要配置 Ctrl-Z，这是传统的 DOS 方法，用于指示字符流 / 用户输入 (SUB) 的结尾。",
        "translate": ""
    },
    {
        "source": "See #38274 and https://stackoverflow.com/questions/43836040/win-api-readconsole.",
        "suggest": "请参见 #38274 和 https://stackoverflow.com/questions/43836040/win-api-readconsole。",
        "translate": ""
    },
    {
        "source": "We can't really do any better than forget all data and return an error.",
        "suggest": "我们真的无法做得比忘记所有数据并返回错误更好。",
        "translate": ""
    },
    {
        "source": "FIXME On UNIX, we guard against stack sizes that are too small but that's because pthreads enforces that stacks are at least PTHREAD_STACK_MIN bytes big.",
        "suggest": "FIXME 在 UNIX 上，我们会防止栈大小过小，但这是因为 pthread 强制栈的大小至少为 PTHREAD_STACK_MIN 个字节。",
        "translate": ""
    },
    {
        "source": "has no such lower limit, it's just that below a certain threshold you can't do anything useful.",
        "suggest": "没有这样的下限，只是低于某个阈值您什么也做不了。",
        "translate": ""
    },
    {
        "source": "That threshold is application and architecture-specific, however.",
        "suggest": "但是，该阈值是特定于应用程序和体系结构的。",
        "translate": ""
    },
    {
        "source": "Round up to the next 64 kB because that's what the NT kernel does, might as well make it explicit.",
        "suggest": "舍入到下一个 64 kB，因为这是 NT 内核所做的，也可能使其明确。",
        "translate": ""
    },
    {
        "source": "This function will return 0 if there are no other threads to execute, but this also means that the yield was useless so this isn't really a case that needs to be worried about.",
        "suggest": "如果没有其他线程要执行，则此函数将返回 0，但这也意味着 yield 没用，因此实际上不必担心这种情况。",
        "translate": ""
    },
    {
        "source": "Turns out, like pretty much everything, Windows is pretty close the functionality that Unix provides, but slightly different!",
        "suggest": "事实证明，与几乎所有内容一样，Windows 与 Unix 提供的功能非常接近，但略有不同!",
        "translate": ""
    },
    {
        "source": "In the case of TLS, Windows does not provide an API to provide a destructor for a TLS variable.",
        "suggest": "对于 TLS，Windows 不提供 API 为 TLS 变量提供析构函数。",
        "translate": ""
    },
    {
        "source": "This ends up being pretty crucial to this implementation, so we need a way around this.",
        "suggest": "这最终对于实现非常关键，因此我们需要一种解决方法。",
        "translate": ""
    },
    {
        "source": "The solution here ended up being a little obscure, but fear not, the internet has informed me [1][2] that this solution is not unique (no way I could have thought of it as well!).",
        "suggest": "这里的解决方案最终有点晦涩难懂，但是请不要担心，互联网已经通知我 [1][2] 这个解决方案不是唯一的 (我也无法想到它! )。",
        "translate": ""
    },
    {
        "source": "The key idea is to insert some hook somewhere to run arbitrary code on thread termination.",
        "suggest": "关键思想是在某个位置插入一些 hook 以便在线程终止时运行任意代码。",
        "translate": ""
    },
    {
        "source": "With this in place we'll be able to run anything we like, including all TLS destructors!",
        "suggest": "有了这个，我们将能够运行任何我们喜欢的东西，包括所有 TLS 析构函数!",
        "translate": ""
    },
    {
        "source": "To accomplish this feat, we perform a number of threads, all contained within this module:",
        "suggest": "为了实现这一壮举，我们执行了许多线程，所有线程都包含在此模块中:",
        "translate": ""
    },
    {
        "source": "All TLS destructors are tracked by *us*, not the windows runtime.",
        "suggest": "所有 TLS 析构函数都由 *us* 而不是 windows 运行时跟踪。",
        "translate": ""
    },
    {
        "source": "This means that we have a global list of destructors for each TLS key that we know about.",
        "suggest": "这意味着我们对每个已知的 TLS 密钥都有一个析构函数的列表。",
        "translate": ""
    },
    {
        "source": "When a thread exits, we run over the entire list and run dtors for all non-null keys.",
        "suggest": "当线程退出时，我们遍历整个列表并为所有非空键运行 dtor。",
        "translate": ""
    },
    {
        "source": "This attempts to match Unix semantics in this regard.",
        "suggest": "在这方面，这试图匹配 Unix 语义。",
        "translate": ""
    },
    {
        "source": "This ends up having the overhead of using a global list, having some locks here and there, and in general just adding some more code bloat.",
        "suggest": "最终，这将产生使用列表的开销，到处都有一些锁，并且通常只会增加一些代码膨胀。",
        "translate": ""
    },
    {
        "source": "We attempt to optimize runtime by forgetting keys that don't have destructors, but this only gets us so far.",
        "suggest": "我们试图通过忘记没有析构函数的键来优化运行时，但这只能使我们走得更远。",
        "translate": ""
    },
    {
        "source": "For more details and nitty-gritty, see the code sections below!",
        "suggest": "有关更多细节和细节，请参见下面的代码部分!",
        "translate": ""
    },
    {
        "source": "Native bindings",
        "suggest": "原生绑定",
        "translate": ""
    },
    {
        "source": "This section is just raw bindings to the native functions that Windows provides, There's a few extra calls to deal with destructors.",
        "suggest": "这部分只是 Windows 提供的原生函数的原始绑定。还有一些额外的调用来处理析构函数。",
        "translate": ""
    },
    {
        "source": "Dtor registration",
        "suggest": "Dtor 注册",
        "translate": ""
    },
    {
        "source": "has no native support for running destructors so we manage our own list of destructors to keep track of how to destroy keys.",
        "suggest": "没有对运行析构函数的原生支持，因此我们管理自己的析构函数列表以跟踪如何销毁密钥。",
        "translate": ""
    },
    {
        "source": "We then install a callback later to get invoked whenever a thread exits, running all appropriate destructors.",
        "suggest": "然后，我们稍后安装一个回调，以便在线程退出时被调用，并运行所有适当的析构函数。",
        "translate": ""
    },
    {
        "source": "Currently unregistration from this list is not supported.",
        "suggest": "当前不支持从该列表中注销。",
        "translate": ""
    },
    {
        "source": "A destructor can be registered but cannot be unregistered.",
        "suggest": "析构函数可以注册，但不能取消注册。",
        "translate": ""
    },
    {
        "source": "There's various simplifying reasons for doing this, the big ones being:",
        "suggest": "这样做有多种简化原因，其中最大的原因是:",
        "translate": ""
    },
    {
        "source": "Currently we don't even support deallocating TLS keys, so normal operation doesn't need to deallocate a destructor.",
        "suggest": "当前，我们甚至不支持释放 TLS 密钥，因此正常操作不需要释放析构函数。",
        "translate": ""
    },
    {
        "source": "There is no point in time where we know we can unregister a destructor because it could always be getting run by some remote thread.",
        "suggest": "我们没有时间知道可以注销析构函数，因为它总是可以被某个远程线程运行。",
        "translate": ""
    },
    {
        "source": "Typically processes have a statically known set of TLS keys which is pretty small, and we'd want to keep this memory alive for the whole process anyway really.",
        "suggest": "通常，进程具有一组静态已知的 TLS 密钥，该密钥非常小，并且无论如何，我们还是希望为整个进程保持活动状态的内存。",
        "translate": ""
    },
    {
        "source": "Perhaps one day we can fold the `Box` here into a static allocation, expanding the `StaticKey` structure to contain not only a slot for the TLS key but also a slot for the destructor queue on windows.",
        "suggest": "也许有一天我们可以将 `Box` 折叠成静态分配，扩展 `StaticKey` 结构体，使其不仅包含用于 TLS 密钥的插槽，而且还包含用于 windows 上的析构函数队列的插槽。",
        "translate": ""
    },
    {
        "source": "An optimization for another day!",
        "suggest": "改天再优化!",
        "translate": ""
    },
    {
        "source": "nothing to drop, we successfully added the node to the list",
        "suggest": "没什么可丢弃的，我们已成功将节点添加到列表中",
        "translate": ""
    },
    {
        "source": "Where the Magic (TM) Happens",
        "suggest": "Magic (TM) 发生的地方",
        "translate": ""
    },
    {
        "source": "If you're looking at this code, and wondering \"what is this doing?\", you're not alone!",
        "suggest": "如果您正在查看此代码，并且想知道 \"what is this doing?\"，您并不孤单!",
        "translate": ""
    },
    {
        "source": "I'll try to break this down step by step:",
        "suggest": "我将尝试逐步解决此问题:",
        "translate": ""
    },
    {
        "source": "What's up with CRT$XLB?",
        "suggest": "CRT $ XLB 怎么了?",
        "translate": ""
    },
    {
        "source": "For anything about TLS destructors to work on Windows, we have to be able to run *something* when a thread exits.",
        "suggest": "对于 TLS 析构函数在 Windows 上运行的任何要求，我们必须能够在线程退出时运行 *something*。",
        "translate": ""
    },
    {
        "source": "To do so, we place a very special static in a very special location.",
        "suggest": "为此，我们将一个非常特殊的静态变量放置在一个非常特殊的位置。",
        "translate": ""
    },
    {
        "source": "If this is encoded in just the right way, the kernel's loader is apparently nice enough to run some function of ours whenever a thread exits!",
        "suggest": "如果以正确的方式对此进行编码，则内核的加载器显然足够好，以便在线程退出时运行我们的某些函数!",
        "translate": ""
    },
    {
        "source": "How nice of the kernel!",
        "suggest": "内核真好!",
        "translate": ""
    },
    {
        "source": "Lots of detailed information can be found in source [1] above, but the gist of it is that this is leveraging a feature of Microsoft's PE format (executable format) which is not actually used by any compilers today.",
        "suggest": "可以在上面的源 [1] 中找到很多详细信息，但是要点是，这是利用了 Microsoft 的 PE 格式 (可执行格式) 的功能，该功能目前尚未被任何编译器实际使用。",
        "translate": ""
    },
    {
        "source": "This apparently translates to any callbacks in the \".CRT$XLB\" section being run on certain events.",
        "suggest": "显然，这将转换为 \".CRT$XLB\" 部分中在某些事件上运行的所有回调。",
        "translate": ""
    },
    {
        "source": "So after all that, we use the compiler's #[link_section] feature to place a callback pointer into the magic section so it ends up being called.",
        "suggest": "因此，毕竟，我们使用编译器的 #[link_section] 功能将回调指针放置到 magic 节中，以便最终被调用。",
        "translate": ""
    },
    {
        "source": "What's up with this callback?",
        "suggest": "这个回调是怎么回事?",
        "translate": ""
    },
    {
        "source": "The callback specified receives a number of parameters from...",
        "suggest": "指定的回调从... 接收许多参数。",
        "translate": ""
    },
    {
        "source": "someone!",
        "suggest": "有人!",
        "translate": ""
    },
    {
        "source": "(the kernel? the runtime? I'm not quite sure!) There are a few events that this gets invoked for, but we're currently only interested on when a thread or a process \"detaches\" (exits).",
        "suggest": "(内核? 运行时? 我不太确定! ) 有一些事件被调用，但是我们目前仅对线程或进程 \"detaches\" (exits) 感兴趣。",
        "translate": ""
    },
    {
        "source": "The process part happens for the last thread and the thread part happens for any normal thread.",
        "suggest": "进程部分发生在最后一个线程中，而线程部分发生在任何普通线程中。",
        "translate": ""
    },
    {
        "source": "Ok, what's up with running all these destructors?",
        "suggest": "好的，运行所有这些析构函数是怎么回事?",
        "translate": ""
    },
    {
        "source": "This will likely need to be improved over time, but this function attempts a \"poor man's\" destructor callback system.",
        "suggest": "随着时间的推移，这可能需要改进，但是此函数尝试使用 \"poor man's\" 析构函数回调系统。",
        "translate": ""
    },
    {
        "source": "Once we've got a list of what to run, we iterate over all keys, check their values, and then run destructors if the values turn out to be non null (setting them to null just beforehand).",
        "suggest": "有了要运行的内容的列表后，我们将遍历所有键，检查它们的值，然后运行析构函数 (如果值原来不是非 null 的话) (事先将它们设置为 null)。",
        "translate": ""
    },
    {
        "source": "We do this a few times in a loop to basically match Unix semantics.",
        "suggest": "我们循环执行几次以基本匹配 Unix 语义。",
        "translate": ""
    },
    {
        "source": "If we don't reach a fixed point after a short while then we just inevitably leak something most likely.",
        "suggest": "如果不久之后我们没有达到一个固定的点，那么我们就不可避免地泄漏了最有可能发生的事情。",
        "translate": ""
    },
    {
        "source": "The article mentions weird stuff about \"/INCLUDE\"?",
        "suggest": "文章提到了关于 \"/INCLUDE\" 的怪异东西?",
        "translate": ""
    },
    {
        "source": "It sure does!",
        "suggest": "当然可以!",
        "translate": ""
    },
    {
        "source": "Specifically we're talking about this quote:",
        "suggest": "具体来说，我们在谈论这个引用:",
        "translate": ""
    },
    {
        "source": "The Microsoft run-time library facilitates this process by defining a memory image of the TLS Directory and giving it the special name “__tls_used” (Intel x86 platforms) or “_tls_used” (other platforms).",
        "suggest": "Microsoft 运行时库通过定义 TLS 目录的内存映像并为其赋予特殊名称 `__tls_used` (英特尔 x86 平台) 或 `_tls_used` (其他平台) 来简化此过程。",
        "translate": ""
    },
    {
        "source": "The linker looks for this memory image and uses the data there to create the TLS Directory.",
        "suggest": "链接器查找此内存映像，然后使用那里的数据创建 TLS 目录。",
        "translate": ""
    },
    {
        "source": "Other compilers that support TLS and work with the Microsoft linker must use this same technique.",
        "suggest": "其他支持 TLS 并与 Microsoft 链接器一起使用的编译器必须使用相同的技术。",
        "translate": ""
    },
    {
        "source": "Basically what this means is that if we want support for our TLS destructors/our hook being called then we need to make sure the linker does not omit this symbol.",
        "suggest": "基本上，这意味着如果我们要支持我们的 TLS destructors/our hook，那么我们需要确保链接器不会省略该符号。",
        "translate": ""
    },
    {
        "source": "Otherwise it will omit it and our callback won't be wired up.",
        "suggest": "否则它将忽略它，并且我们的回调函数也不会连接。",
        "translate": ""
    },
    {
        "source": "We don't actually use the `/INCLUDE` linker flag here like the article mentions because the Rust compiler doesn't propagate linker flags, but instead we use a shim function which performs a volatile 1-byte load from the address of the symbol to ensure it sticks around.",
        "suggest": "我们实际上并没有像本文提到的那样在这里使用 `/INCLUDE` 链接器标志，因为 Rust 编译器不会传播链接器标志，而是使用 shim 函数，该函数从符号地址执行易失性 1 字节加载以确保它坚持。",
        "translate": ""
    },
    {
        "source": "we don't want LLVM eliminating this symbol for any reason, and",
        "suggest": "我们不希望 LLVM 由于任何原因消除此符号，并且",
        "translate": ""
    },
    {
        "source": "when the symbol makes it to the linker the linker will take over",
        "suggest": "当符号到达链接器时，链接器将接管",
        "translate": ""
    },
    {
        "source": "See comments above for what this is doing.",
        "suggest": "请参见上面的注释，以了解此操作。",
        "translate": ""
    },
    {
        "source": "Note that we don't need this trickery on GNU windows, just on MSVC.",
        "suggest": "请注意，仅在 MSVC 上，我们就不需要在 GNU windows 上使用这种技巧。",
        "translate": ""
    },
    {
        "source": "actually called above",
        "suggest": "实际在上面",
        "translate": ""
    },
    {
        "source": "Thread parker implementation for Windows.",
        "suggest": "Windows 的线程停放器实现。",
        "translate": ""
    },
    {
        "source": "This uses WaitOnAddress and WakeByAddressSingle if available (Windows 8+).",
        "suggest": "如果可用 (Windows 8+)，它将使用 WaitOnAddress 和 WakeByAddressSingle。",
        "translate": ""
    },
    {
        "source": "This modern API is exactly the same as the futex syscalls the Linux thread parker uses.",
        "suggest": "这个现代的 API 与 Linux 线程停放者使用的 futex 系统调用完全相同。",
        "translate": ""
    },
    {
        "source": "When These APIs are available, the implementation of this thread parker matches the Linux thread parker exactly.",
        "suggest": "当这些 API 可用时，此线程驻留程序的实现与 Linux 线程驻留程序完全匹配。",
        "translate": ""
    },
    {
        "source": "However, when the modern API is not available, this implementation falls back to NT Keyed Events, which are similar, but have some important differences.",
        "suggest": "但是，当现代 API 不可用时，此实现将回退到 NT 键控事件，它们相似，但有一些重要区别。",
        "translate": ""
    },
    {
        "source": "These are available since Windows XP.",
        "suggest": "从 Windows XP 开始可用。",
        "translate": ""
    },
    {
        "source": "WaitOnAddress first checks the state of the thread parker to make sure it no WakeByAddressSingle calls can be missed between updating the parker state and calling the function.",
        "suggest": "WaitOnAddress 首先检查线程停放状态，以确保在更新停放状态和调用函数之间不会丢失 WakeByAddressSingle 调用。",
        "translate": ""
    },
    {
        "source": "NtWaitForKeyedEvent does not have this option, and unconditionally blocks without checking the parker state first.",
        "suggest": "NtWaitForKeyedEvent 没有此选项，并且无条件阻止而无需先检查 Parker 状态。",
        "translate": ""
    },
    {
        "source": "Instead, NtReleaseKeyedEvent (unlike WakeByAddressSingle) *blocks* until it woke up a thread waiting for it by NtWaitForKeyedEvent.",
        "suggest": "相反，NtReleaseKeyedEvent (与 WakeByAddressSingle 不同)*阻塞*，直到它唤醒 NtWaitForKeyedEvent 等待它的线程。",
        "translate": ""
    },
    {
        "source": "This way, we can be sure no events are missed, but we need to be careful not to block unpark() if park_timeout() was woken up by a timeout instead of unpark().",
        "suggest": "这样，我们可以确定没有丢失任何事件，但是如果 park_timeout() 是由超时而不是 unpark() 引起的，则我们必须注意不要阻塞 unpark()。",
        "translate": ""
    },
    {
        "source": "Unlike WaitOnAddress, NtWaitForKeyedEvent/NtReleaseKeyedEvent operate on a HANDLE (created with NtCreateKeyedEvent).",
        "suggest": "与 WaitOnAddress 不同，NtWaitForKeyedEvent/NtReleaseKeyedEvent 在 HANDLE 上操作 (使用 NtCreateKeyedEvent 创建)。",
        "translate": ""
    },
    {
        "source": "This means that we can be sure a succesfully awoken park() was awoken by unpark() and not a NtReleaseKeyedEvent call from some other code, as these events are not only matched by the key (address of the parker (state)), but also by this HANDLE.",
        "suggest": "这意味着我们可以确保成功唤醒的 park() 被 unpark() 唤醒，而不是其他代码中的 NtReleaseKeyedEvent 调用，因为这些事件不仅与键 (派克 (state)) 的地址，而且还与该 HANDLE 匹配) 匹配。",
        "translate": ""
    },
    {
        "source": "We lazily allocate this handle the first time it is needed.",
        "suggest": "我们在第一次需要时就懒惰地分配了这个句柄。",
        "translate": ""
    },
    {
        "source": "The fast path (calling park() after unpark() was already called) and the possible states are the same for both implementations.",
        "suggest": "快速路径 (在已经调用 unpark() 之后调用 park()) 和可能的状态对于这两种实现都是相同的。",
        "translate": ""
    },
    {
        "source": "This is used here to make sure the fast path does not even check which API to use, but can return right away, independent of the used API.",
        "suggest": "此处用于确保快速路径甚至不检查要使用的 API，而是可以立即返回，而与所使用的 API 无关。",
        "translate": ""
    },
    {
        "source": "Only the slow paths (which will actually block/wake a thread) check which API is available and have different implementations.",
        "suggest": "只有慢速路径 (实际上将使 block/wake 成为一个线程) 会检查哪个 API 可用并具有不同的实现。",
        "translate": ""
    },
    {
        "source": "Unfortunately, NT Keyed Events are an undocumented Windows API.",
        "suggest": "不幸的是，NT 键控事件是一个未记录的 Windows API。",
        "translate": ""
    },
    {
        "source": "However:",
        "suggest": "然而:",
        "translate": ""
    },
    {
        "source": "This API is relatively simple with obvious behaviour, and there are several (unofficial) articles documenting the details.",
        "suggest": "该 API 相对简单，具有明显的行为，并且有几篇 (unofficial) 文章记录了这些细节。",
        "translate": ""
    },
    {
        "source": "has been using this API for years (on Windows versions before Windows 8).",
        "suggest": "已经使用此 API 多年 (在 Windows 8 之前的 Windows 版本上)。",
        "translate": ""
    },
    {
        "source": "Many big projects extensively use parking_lot, such as servo and the Rust compiler itself.",
        "suggest": "许多大型项目广泛使用 parking_lot，例如伺服和 Rust 编译器本身。",
        "translate": ""
    },
    {
        "source": "It is the underlying API used by Windows SRW locks and Windows critical sections.",
        "suggest": "它是 Windows SRW 锁和 Windows 关键部分使用的基础 API。",
        "translate": ""
    },
    {
        "source": "The source code of the implementations of Wine, ReactOs, and Windows XP are available and match the expected behaviour.",
        "suggest": "Wine，ReactOs 和 Windows XP 的实现的源代码可用，并且符合预期的行为。",
        "translate": ""
    },
    {
        "source": "The main risk with an undocumented API is that it might change in the future.",
        "suggest": "未记录 API 的主要风险是 future 中可能会更改。",
        "translate": ""
    },
    {
        "source": "But since we only use it for older versions of Windows, that's not a problem.",
        "suggest": "但是，由于我们仅将其用于 Windows 的较早版本，所以这不是问题。",
        "translate": ""
    },
    {
        "source": "Even if these functions do not block or wake as we expect (which is unlikely, see all previous points), this implementation would still be memory safe.",
        "suggest": "即使这些函数没有像我们期望的那样阻塞或唤醒 (这不太可能，请参见前面的所有要点)，该实现仍将是内存安全的。",
        "translate": ""
    },
    {
        "source": "The NT Keyed Events API is only used to sleep/block in the right place.",
        "suggest": "NT 键控事件 API 仅在正确的位置用于 sleep/block。",
        "translate": ""
    },
    {
        "source": "Windows Internals, Part 1, ISBN 9780735671300",
        "suggest": "Windows 内部构件，第 1 部分，ISBN 9780735671300",
        "translate": ""
    },
    {
        "source": "Notes about memory ordering:",
        "suggest": "有关内存顺序的注意事项:",
        "translate": ""
    },
    {
        "source": "Memory ordering is only relevant for the relative ordering of operations between different variables.",
        "suggest": "内存排序仅与不同变量之间操作的相对排序有关。",
        "translate": ""
    },
    {
        "source": "Even Ordering::Relaxed guarantees a monotonic/consistent order when looking at just a single atomic variable.",
        "suggest": "仅查看单个原子变量时，甚至 Ordering::Relaxed 都可以保证单调/一致的顺序。",
        "translate": ""
    },
    {
        "source": "So, since this parker is just a single atomic variable, we only need to look at the ordering guarantees we need to provide to the 'outside world'.",
        "suggest": "因此，由于该 Parker 只是单一的原子变量，因此我们只需要查看我们需要提供向外部世界的排序保证。",
        "translate": ""
    },
    {
        "source": "The only memory ordering guarantee that parking and unparking provide, is that things which happened before unpark() are visible on the thread returning from park() afterwards.",
        "suggest": "保留和取消保留的唯一内存排序保证是，在 unpark() 之后发生的线程上可以看到 unpark() 之前发生的事情。",
        "translate": ""
    },
    {
        "source": "Otherwise, it was effectively unparked before unpark() was called while still consuming the 'token'.",
        "suggest": "否则，在仍然消耗 'token' 的同时，在调用 unpark() 之前将其有效地停了下来。",
        "translate": ""
    },
    {
        "source": "In other words, unpark() needs to synchronize with the part of park() that consumes the token and returns.",
        "suggest": "换句话说，unpark() 需要与 park() 消耗 token 并返回的部分进行同步。",
        "translate": ""
    },
    {
        "source": "This is done with a release-acquire synchronization, by using Ordering::Release when writing NOTIFIED (the 'token') in unpark(), and using Ordering::Acquire when reading this state in park() after waking up.",
        "suggest": "通过在 unpark() 中写入 NOTIFIED ('token') 时使用 Ordering::Release，并在唤醒后在 park() 中读取此状态时使用 Ordering::Acquire，可以使用发布 - 获取同步来完成此操作。",
        "translate": ""
    },
    {
        "source": "Assumes this is only called by the thread that owns the Parker, which means that `self.state != PARKED`.",
        "suggest": "假定仅由拥有 Parker 的线程 (称为 `self.state != PARKED`) 调用此方法。",
        "translate": ""
    },
    {
        "source": "Change NOTIFIED=>EMPTY or EMPTY=>PARKED, and directly return in the first case.",
        "suggest": "更改 NOTIFIED => EMPTY 或 EMPTY => PARKED，并在第一种情况下直接返回。",
        "translate": ""
    },
    {
        "source": "Wait for something to happen, assuming it's still set to PARKED.",
        "suggest": "假设它仍然设置为 PARKED，请等待发生的事情。",
        "translate": ""
    },
    {
        "source": "Change NOTIFIED=>EMPTY but leave PARKED alone.",
        "suggest": "更改 NOTIFIED => EMPTY，但不要将 PARKED 留在原处。",
        "translate": ""
    },
    {
        "source": "Actually woken up by unpark().",
        "suggest": "实际上是被 unpark() 唤醒的。",
        "translate": ""
    },
    {
        "source": "Spurious wake up.",
        "suggest": "虚假的醒来。",
        "translate": ""
    },
    {
        "source": "We loop to try again.",
        "suggest": "我们循环播放以重试。",
        "translate": ""
    },
    {
        "source": "Wait for unpark() to produce this event.",
        "suggest": "等待 unpark() 产生此事件。",
        "translate": ""
    },
    {
        "source": "Set the state back to EMPTY (from either PARKED or NOTIFIED).",
        "suggest": "将状态设置回 EMPTY (从 PARKED 或 NOTIFIED)。",
        "translate": ""
    },
    {
        "source": "Note that we don't just write EMPTY, but use swap() to also include an acquire-ordered read to synchronize with unpark()'s release-ordered write.",
        "suggest": "请注意，我们不仅编写 EMPTY，而且还使用 swap() 包括获得顺序的读取，以与 unpark () 的发布顺序的写入同步。",
        "translate": ""
    },
    {
        "source": "Timeout or spurious wake up.",
        "suggest": "超时或虚假唤醒。",
        "translate": ""
    },
    {
        "source": "We return either way, because we can't easily tell if it was the timeout or not.",
        "suggest": "我们以任何一种方式返回，因为我们无法轻易分辨出是否超时。",
        "translate": ""
    },
    {
        "source": "Need to wait for unpark() using NtWaitForKeyedEvent.",
        "suggest": "需要使用 NtWaitForKeyedEvent 等待 unpark()。",
        "translate": ""
    },
    {
        "source": "NtWaitForKeyedEvent uses a unit of 100ns, and uses negative values to indicate a relative time on the monotonic clock.",
        "suggest": "NtWaitForKeyedEvent 使用 100ns 的单元，并使用负值指示单调时钟上的相对时间。",
        "translate": ""
    },
    {
        "source": "This is documented here for the underlying KeWaitForSingleObject function:",
        "suggest": "此处记录了基本的 KeWaitForSingleObject 函数:",
        "translate": ""
    },
    {
        "source": "We were awoken by a timeout, not by unpark(), but the state was set to NOTIFIED, which means we *just* missed an unpark(), which is now blocked on us to wait for it.",
        "suggest": "我们被超时而不是 unpark() 唤醒了，但是状态被设置为 NOTIFIED，这意味着我们 *只是* 错过了 unpark()，现在它被阻止等待它。",
        "translate": ""
    },
    {
        "source": "Wait for it to consume the event and unblock that thread.",
        "suggest": "等待它消耗事件并取消阻塞该线程。",
        "translate": ""
    },
    {
        "source": "Change PARKED=>NOTIFIED, EMPTY=>NOTIFIED, or NOTIFIED=>NOTIFIED, and wake the thread in the first case.",
        "suggest": "更改 PARKED => NOTIFIED，EMPTY => NOTIFIED 或 NOTIFIED => NOTIFIED，并在第一种情况下唤醒线程。",
        "translate": ""
    },
    {
        "source": "Note that even NOTIFIED=>NOTIFIED results in a write.",
        "suggest": "请注意，即使 NOTIFIED => NOTIFIED 也会导致写入。",
        "translate": ""
    },
    {
        "source": "This is on purpose, to make sure every unpark() has a release-acquire ordering with park().",
        "suggest": "这是有目的的，以确保每个 unpark() 都具有对 park() 的发布 - 获取命令。",
        "translate": ""
    },
    {
        "source": "If we run NtReleaseKeyedEvent before the waiting thread runs NtWaitForKeyedEvent, this (shortly) blocks until we can wake it up.",
        "suggest": "如果我们在等待线程运行 NtWaitForKeyedEvent 之前运行 NtReleaseKeyedEvent，则此 (shortly) 会阻塞，直到我们将其唤醒。",
        "translate": ""
    },
    {
        "source": "If the waiting thread wakes up before we run NtReleaseKeyedEvent (e.g. due to a timeout), this blocks until we do wake up a thread.",
        "suggest": "如果等待的线程在我们运行 NtReleaseKeyedEvent 之前被唤醒 (例如，由于超时)，它将阻塞直到我们唤醒一个线程。",
        "translate": ""
    },
    {
        "source": "To prevent this thread from blocking indefinitely in that case, park_impl() will, after seeing the state set to NOTIFIED after waking up, call NtWaitForKeyedEvent again to unblock us.",
        "suggest": "为了防止该线程在这种情况下无限期阻塞，park_impl() 在唤醒后看到状态设置为 NOTIFIED 后，将再次调用 NtWaitForKeyedEvent 解除阻塞。",
        "translate": ""
    },
    {
        "source": "Lost the race to another thread initializing HANDLE before we did.",
        "suggest": "在我们开始之前，这场比赛输给了另一个初始化 HANDLE 的线程。",
        "translate": ""
    },
    {
        "source": "Closing our handle and using theirs instead.",
        "suggest": "关闭我们的句柄并使用它们的句柄。",
        "translate": ""
    },
    {
        "source": "This duration is relative to an arbitrary microsecond epoch from the winapi QueryPerformanceCounter function.",
        "suggest": "此持续时间相对于 winapi QueryPerformanceCounter 函数的任意微秒纪元。",
        "translate": ""
    },
    {
        "source": "High precision timing on windows operates in \"Performance Counter\" units, as returned by the WINAPI QueryPerformanceCounter function.",
        "suggest": "windows 上的高精度计时以 \"Performance Counter\" 为单位运行，这由 WINAPI QueryPerformanceCounter 函数返回。",
        "translate": ""
    },
    {
        "source": "These relate to seconds by a factor of QueryPerformanceFrequency.",
        "suggest": "这些与秒相关的因素是 QueryPerformanceFrequency。",
        "translate": ""
    },
    {
        "source": "In order to keep unit conversions out of normal interval math, we measure in QPC units and immediately convert to nanoseconds.",
        "suggest": "为了使单位转换不超出正常间隔数学范围，我们以 QPC 单位进行测量，并立即转换为纳秒。",
        "translate": ""
    },
    {
        "source": "On windows there's a threshold below which we consider two timestamps equivalent due to measurement error.",
        "suggest": "在 windows 上有一个阈值，由于测量误差，在此阈值以下我们认为两个时间戳等效。",
        "translate": ""
    },
    {
        "source": "For more details + doc link, check the docs on epsilon.",
        "suggest": "有关更多详细信息和文档链接，请查看 epsilon 上的文档。",
        "translate": ""
    },
    {
        "source": "Per microsoft docs, the margin of error for cross-thread time comparisons using QueryPerformanceCounter is 1 \"tick\" -- defined as 1/frequency().",
        "suggest": "根据 Microsoft 文档，使用 QueryPerformanceCounter 进行跨线程时间比较的错误幅度为 1 \"tick\" - 定义为 1/frequency ()。",
        "translate": ""
    },
    {
        "source": "Either the cached result of `QueryPerformanceFrequency` or `0` for uninitialized.",
        "suggest": "`QueryPerformanceFrequency` 或 `0` 的未初始化缓存结果。",
        "translate": ""
    },
    {
        "source": "Storing this as a single `AtomicU64` allows us to use `Relaxed` operations, as we are only interested in the effects on a single memory location.",
        "suggest": "将其存储为单个 `AtomicU64`，使我们能够使用 `Relaxed` 操作，因为我们仅对单个存储位置上的影响感兴趣。",
        "translate": ""
    },
    {
        "source": "If a previous thread has filled in this global state, use that.",
        "suggest": "如果以前的线程已填充到此 γ 状态，请使用该状态。",
        "translate": ""
    },
    {
        "source": "The minimum alignment guaranteed by the architecture.",
        "suggest": "该体系结构保证的最小对齐方式。",
        "translate": ""
    },
    {
        "source": "This value is used to add fast paths for low alignment values.",
        "suggest": "此值用于为低对齐值添加快速路径。",
        "translate": ""
    },
    {
        "source": "Docs for GlobalAlloc::realloc require this to be valid:",
        "suggest": "GlobalAlloc::realloc 的文档要求这是有效的:",
        "translate": ""
    },
    {
        "source": "Implementation of running at_exit routines",
        "suggest": "运行 at_exit 例程的实现",
        "translate": ""
    },
    {
        "source": "Documentation can be found on the `rt::at_exit` function.",
        "suggest": "可以在 `rt::at_exit` 函数上找到文档。",
        "translate": ""
    },
    {
        "source": "NB these are specifically not types from `std::sync` as they currently rely on poisoning and this module needs to operate at a lower level than requiring the thread infrastructure to be in place (useful on the borders of initialization/destruction).",
        "suggest": "注意，这些不是 `std::sync` 的类型，因为它们当前依赖于中毒，并且此模块需要在比要求有线程基础结构就位 (在 initialization/destruction 的边界上有用) 更低的级别上运行。",
        "translate": ""
    },
    {
        "source": "It is UB to attempt to acquire this mutex reentrantly!",
        "suggest": "尝试重新获得此互斥锁是 UB!",
        "translate": ""
    },
    {
        "source": "The maximum number of times the cleanup routines will be run.",
        "suggest": "清除例程将运行的最大次数。",
        "translate": ""
    },
    {
        "source": "While running the at_exit closures new ones may be registered, and this count is the number of times the new closures will be allowed to register successfully.",
        "suggest": "在运行 at_exit 闭包时，可能会注册新的闭包，此计数是允许新闭包成功注册的次数。",
        "translate": ""
    },
    {
        "source": "After this number of iterations all new registrations will return `false`.",
        "suggest": "在此迭代次数之后，所有新注册将返回 `false`。",
        "translate": ""
    },
    {
        "source": "can't re-init after a cleanup",
        "suggest": "清理后无法重新初始化",
        "translate": ""
    },
    {
        "source": "make sure we're not recursively cleaning up",
        "suggest": "确保我们没有递归清理",
        "translate": ""
    },
    {
        "source": "If we never called init, not need to cleanup!",
        "suggest": "如果我们从未调用过 init，则无需清理!",
        "translate": ""
    },
    {
        "source": "We are not holding any lock, so reentrancy is fine.",
        "suggest": "我们没有持有任何锁，所以可以重新入场。",
        "translate": ""
    },
    {
        "source": "We are just moving `f` around, not calling it.",
        "suggest": "我们只是在移动 `f`，而不是调用它。",
        "translate": ""
    },
    {
        "source": "There is no possibility of reentrancy here.",
        "suggest": "这里没有重新进入的可能性。",
        "translate": ""
    },
    {
        "source": "Common code for printing the backtrace in the same way across the different supported platforms.",
        "suggest": "在不同的受支持平台上以相同方式打印回溯的通用代码。",
        "translate": ""
    },
    {
        "source": "Max number of frames to print.",
        "suggest": "要打印的最大帧数。",
        "translate": ""
    },
    {
        "source": "Don't attempt to lock this reentrantly.",
        "suggest": "不要试图重新锁定它。",
        "translate": ""
    },
    {
        "source": "Prints the current backtrace.",
        "suggest": "打印当前回溯。",
        "translate": ""
    },
    {
        "source": "There are issues currently linking libbacktrace into tests, and in general during libstd's own unit tests we're not testing this path.",
        "suggest": "当前将 libbacktrace 链接到测试中存在一些问题，通常在 libstd 自己的单元测试中，我们不测试该路径。",
        "translate": ""
    },
    {
        "source": "In test mode immediately return here to optimize away any references to the libbacktrace symbols",
        "suggest": "在测试模式下，请立即返回此处以优化对 libbacktrace 符号的引用",
        "translate": ""
    },
    {
        "source": "Use a lock to prevent mixed output in multithreading context.",
        "suggest": "使用锁来防止在多线程上下文中混合输出。",
        "translate": ""
    },
    {
        "source": "Some platforms also requires it, like `SymFromAddr` on Windows.",
        "suggest": "某些平台也需要它，例如 Windows 上的 `SymFromAddr`。",
        "translate": ""
    },
    {
        "source": "Always 'fail' to get the cwd when running under Miri - this allows Miri to display backtraces in isolation mode",
        "suggest": "在 Miri 下运行时，总是 'fail' 获取 cwd - 这允许 Miri 在隔离模式下显示回溯",
        "translate": ""
    },
    {
        "source": "Start immediately if we're not using a short backtrace.",
        "suggest": "如果我们不使用简短的回溯，请立即开始。",
        "translate": ""
    },
    {
        "source": "Fixed frame used to clean the backtrace with `RUST_BACKTRACE=1`.",
        "suggest": "固定框架，用于使用 `RUST_BACKTRACE=1` 清洁回溯。",
        "translate": ""
    },
    {
        "source": "Note that this is only inline(never) when backtraces in libstd are enabled, otherwise it's fine to optimize away.",
        "suggest": "请注意，仅在启用 libstd 中的回溯时才使用 inline(never)，否则可以进行优化。",
        "translate": ""
    },
    {
        "source": "prevent this frame from being tail-call optimised away",
        "suggest": "防止该框架被 tail-call 优化掉",
        "translate": ""
    },
    {
        "source": "For now logging is turned off by default, and this function checks to see whether the magical environment variable is present to see if it's turned on.",
        "suggest": "现在，默认情况下，日志记录是默认关闭的，并且此函数检查是否存在不可思议的环境变量以查看其是否已打开。",
        "translate": ""
    },
    {
        "source": "If the `backtrace` feature of this crate isn't enabled quickly return `None` so this can be constant propagated all over the place to turn optimize away callers.",
        "suggest": "如果未启用此 crate 的 `backtrace` 功能，则快速返回 `None`，以便可以在所有位置进行常量传播，以优化调用者。",
        "translate": ""
    },
    {
        "source": "Setting environment variables for Fuchsia components isn't a standard or easily supported workflow.",
        "suggest": "为 Fuchsia 组件设置环境变量不是标准的或易于支持的工作流程。",
        "translate": ""
    },
    {
        "source": "For now, always display backtraces.",
        "suggest": "现在，始终显示回溯。",
        "translate": ""
    },
    {
        "source": "Prints the filename of the backtrace frame.",
        "suggest": "打印回溯帧的文件名。",
        "translate": ""
    },
    {
        "source": "See also `output`.",
        "suggest": "另请参见 `output`。",
        "translate": ""
    },
    {
        "source": "Writes out a valid unicode string with the correct escape sequences",
        "suggest": "用正确的转义序列写出有效的 unicode 字符串",
        "translate": ""
    },
    {
        "source": "For boxed mutexes, a `Condvar` will check it's only ever used with the same mutex, based on its (stable) address.",
        "suggest": "对于 boxed 互斥锁，`Condvar` 将根据其 (stable) 地址检查它是否曾经使用过相同的互斥锁。",
        "translate": ""
    },
    {
        "source": "Stored the address",
        "suggest": "存放地址",
        "translate": ""
    },
    {
        "source": "Lost a race to store the same address",
        "suggest": "输了一个比赛来存储相同的地址",
        "translate": ""
    },
    {
        "source": "Unboxed mutexes may move, so `Condvar` can not require its address to stay constant.",
        "suggest": "未装箱的互斥锁可能会移动，因此 `Condvar` 不能要求其地址保持不变。",
        "translate": ""
    },
    {
        "source": "An OS-based condition variable.",
        "suggest": "基于 OS 的条件变量。",
        "translate": ""
    },
    {
        "source": "Creates a new condition variable for use.",
        "suggest": "创建一个新的条件变量以供使用。",
        "translate": ""
    },
    {
        "source": "Signals one waiter on this condition variable to wake up.",
        "suggest": "在此条件变量上发信号通知一位等待者醒来。",
        "translate": ""
    },
    {
        "source": "Awakens all current waiters on this condition variable.",
        "suggest": "在此条件变量上唤醒所有当前的等待者。",
        "translate": ""
    },
    {
        "source": "Waits for a signal on the specified mutex.",
        "suggest": "在指定的互斥锁上等待信号。",
        "translate": ""
    },
    {
        "source": "Behavior is undefined if the mutex is not locked by the current thread.",
        "suggest": "如果互斥锁没有被当前线程锁定，则行为是不确定的。",
        "translate": ""
    },
    {
        "source": "May panic if used with more than one mutex.",
        "suggest": "如果与多个互斥锁一起使用，则可能为 panic。",
        "translate": ""
    },
    {
        "source": "Waits for a signal on the specified mutex with a timeout duration specified by `dur` (a relative time into the future).",
        "suggest": "等待指定的互斥锁上的信号，其超时持续时间由 `dur` 指定 (进入 future 的相对时间)。",
        "translate": ""
    },
    {
        "source": "Gee, seeing how we're testing the fs module I sure hope that we at least implement this correctly!",
        "suggest": "e，看看我们如何测试 fs 模块，我当然希望我们至少能正确实现它!",
        "translate": ""
    },
    {
        "source": "Platform-independent platform abstraction",
        "suggest": "独立于平台的平台抽象",
        "translate": ""
    },
    {
        "source": "This is the platform-independent portion of the standard library's platform abstraction layer, whereas `std::sys` is the platform-specific portion.",
        "suggest": "这是标准库的平台抽象层的与平台无关的部分，而 `std::sys` 是特定于平台的部分。",
        "translate": ""
    },
    {
        "source": "The relationship between `std::sys_common`, `std::sys` and the rest of `std` is complex, with dependencies going in all directions: `std` depending on `sys_common`, `sys_common` depending on `sys`, and `sys` depending on `sys_common` and `std`.",
        "suggest": "`std::sys_common`，`std::sys` 和 `std` 的剩余部分之间的关系很复杂，依赖性在各个方向上: `std` 取决于 `sys_common`，`sys_common` 取决于 `sys`，`sys` 取决于 `sys_common` 和 `std`。",
        "translate": ""
    },
    {
        "source": "Ideally `sys_common` would be split into two and the dependencies between them all would form a dag, facilitating the extraction of `std::sys` from the standard library.",
        "suggest": "理想情况下，将 `sys_common` 分为两部分，并且它们之间的依赖性都将形成 dag，从而有利于从标准库中提取 `std::sys`。",
        "translate": ""
    },
    {
        "source": "map Ok/Some which might not be Debug",
        "suggest": "映射 Ok/Some，可能不是 Debug",
        "translate": ""
    },
    {
        "source": "is required because `sys/mod.rs` imports `unix/ext/mod.rs` on Windows when generating documentation.",
        "suggest": "是必需的，因为 `sys/mod.rs` 在生成文档时会在 Windows 上导入 `unix/ext/mod.rs`。",
        "translate": ""
    },
    {
        "source": "common error constructors",
        "suggest": "常见错误构造函数",
        "translate": ""
    },
    {
        "source": "A trait for viewing representations from std types",
        "suggest": "trait，用于查看 std 类型的表示",
        "translate": ""
    },
    {
        "source": "A trait for extracting representations from std types",
        "suggest": "trait，用于从 std 类型中提取表示形式",
        "translate": ""
    }
]
