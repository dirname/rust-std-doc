[
    {
        "source": "A trait for creating std types from internal representations",
        "suggest": "trait，用于从内部表示形式创建 std 类型",
        "translate": ""
    },
    {
        "source": "Enqueues a procedure to run when the main thread exits.",
        "suggest": "当主线程退出时，将一个过程排入队列运行。",
        "translate": ""
    },
    {
        "source": "Currently these closures are only run once the main *Rust* thread exits.",
        "suggest": "当前，这些闭包仅在主 *Rust* 线程退出后才运行。",
        "translate": ""
    },
    {
        "source": "Once the `at_exit` handlers begin running, more may be enqueued, but not infinitely so.",
        "suggest": "`at_exit` 处理程序开始运行后，可能会排队，但不是无限地排队。",
        "translate": ""
    },
    {
        "source": "Eventually a handler registration will be forced to fail.",
        "suggest": "最终，处理程序注册将被迫失败。",
        "translate": ""
    },
    {
        "source": "Returns `Ok` if the handler was successfully registered, meaning that the closure will be run once the main thread exits.",
        "suggest": "如果成功注册了处理程序，则返回 `Ok`，这意味着一旦主线程退出，闭包将被运行。",
        "translate": ""
    },
    {
        "source": "Returns `Err` to indicate that the closure could not be registered, meaning that it is not scheduled to be run.",
        "suggest": "返回 `Err` 表示无法注册闭包，这意味着未计划运行该闭包。",
        "translate": ""
    },
    {
        "source": "One-time runtime cleanup.",
        "suggest": "一次性运行时清理。",
        "translate": ""
    },
    {
        "source": "Computes (value*numer)/denom without overflow, as long as both (numer*denom) and the overall result fit into i64 (which is the case for our time conversions).",
        "suggest": "只要 (numer *denom) 和总体结果都适合 i64 (时间转换就是这种情况)，就可以计算 (值* 数值) / 面值而不会溢出。",
        "translate": ""
    },
    {
        "source": "Decompose value as (value/denom*denom + value%denom), substitute into (value*numer)/denom and simplify.",
        "suggest": "将值分解为 (value/denom *denom + value%denom)，代入 (value* numer) /denom 并进行简化。",
        "translate": ""
    },
    {
        "source": "r < denom, so (denom*numer) is the upper bound of (r*numer)",
        "suggest": "r < denom，所以 (denom*numer) 是 (r*numer) 的上限",
        "translate": ""
    },
    {
        "source": "An OS-based mutual exclusion lock, meant for use in static variables.",
        "suggest": "基于 OS 的互斥锁，用于静态变量。",
        "translate": ""
    },
    {
        "source": "This mutex has a const constructor ([`StaticMutex::new`]), does not implement `Drop` to cleanup resources, and causes UB when used reentrantly.",
        "suggest": "此互斥锁具有 const 构造函数 ([`StaticMutex::new`])，未实现 `Drop` 来清理资源，并且在重新使用时会导致 UB。",
        "translate": ""
    },
    {
        "source": "This mutex does not implement poisoning.",
        "suggest": "此互斥锁不会实现中毒。",
        "translate": ""
    },
    {
        "source": "This is a wrapper around `imp::Mutex` that does *not* call `init()` and `destroy()`.",
        "suggest": "这是 `imp::Mutex` 的包装，它不 * 调用 `init()` 和 `destroy()`。",
        "translate": ""
    },
    {
        "source": "Creates a new mutex for use.",
        "suggest": "创建一个新的互斥锁以供使用。",
        "translate": ""
    },
    {
        "source": "Calls raw_lock() and then returns an RAII guard to guarantee the mutex will be unlocked.",
        "suggest": "调用 raw_lock()，然后返回 RAII 防护以确保互斥锁将被解锁。",
        "translate": ""
    },
    {
        "source": "It is undefined behaviour to call this function while locked by the same thread.",
        "suggest": "在同一线程锁定时调用此函数是未定义的行为。",
        "translate": ""
    },
    {
        "source": "An OS-based mutual exclusion lock.",
        "suggest": "基于操作系统的互斥锁。",
        "translate": ""
    },
    {
        "source": "This mutex does *not* have a const constructor, cleans up its resources in its `Drop` implementation, may safely be moved (when not borrowed), and does not cause UB when used reentrantly.",
        "suggest": "此互斥锁没有 * const 构造函数，在 `Drop` 实现中清理其资源，可以安全地移动 (未借用时)，并且在重新使用时不会导致 UB。",
        "translate": ""
    },
    {
        "source": "This is either a wrapper around `Box<imp::Mutex>` or `imp::Mutex`, depending on the platform.",
        "suggest": "根据平台的不同，它可以是 `Box<imp::Mutex>` 或 `imp::Mutex` 的包装。",
        "translate": ""
    },
    {
        "source": "It is boxed on platforms where `imp::Mutex` may not be moved.",
        "suggest": "在 `imp::Mutex` 可能不会移动的平台上，它是 boxed。",
        "translate": ""
    },
    {
        "source": "Creates a new mutex.",
        "suggest": "创建一个新的互斥锁。",
        "translate": ""
    },
    {
        "source": "Locks the mutex blocking the current thread until it is available.",
        "suggest": "锁定互斥锁以阻止当前线程，直到可用为止。",
        "translate": ""
    },
    {
        "source": "Attempts to lock the mutex without blocking, returning whether it was successfully acquired or not.",
        "suggest": "尝试不间断地锁定互斥锁，并返回是否已成功获取它。",
        "translate": ""
    },
    {
        "source": "Unlocks the mutex.",
        "suggest": "解锁互斥锁。",
        "translate": ""
    },
    {
        "source": "Behavior is undefined if the current thread does not actually hold the mutex.",
        "suggest": "如果当前线程实际上没有持有互斥锁，则行为是不确定的。",
        "translate": ""
    },
    {
        "source": "sockaddr and misc bindings",
        "suggest": "sockaddr 和杂项绑定",
        "translate": ""
    },
    {
        "source": "split the string by ':' and convert the second part to u16",
        "suggest": "用 ':' 分割字符串并将第二部分转换为 u16",
        "translate": ""
    },
    {
        "source": "TCP streams",
        "suggest": "TCP 流",
        "translate": ""
    },
    {
        "source": "TCP listeners",
        "suggest": "TCP 侦听器",
        "translate": ""
    },
    {
        "source": "On platforms with Berkeley-derived sockets, this allows to quickly rebind a socket, without needing to wait for the OS to clean up the previous one.",
        "suggest": "在具有源自 Berkeley 的套接字的平台上，这允许快速重新绑定套接字，而无需等待操作系统清理之前的套接字。",
        "translate": ""
    },
    {
        "source": "On Windows, this allows rebinding sockets which are actively in use, which allows “socket hijacking”, so we explicitly don't set it here.",
        "suggest": "在 Windows 上，这允许重新绑定正在使用的套接字，从而允许套接字劫持，因此我们在此处未明确设置。",
        "translate": ""
    },
    {
        "source": "Bind our new socket",
        "suggest": "绑定我们的新套接字",
        "translate": ""
    },
    {
        "source": "Start listening",
        "suggest": "开始监听",
        "translate": ""
    },
    {
        "source": "The underlying OsString/OsStr implementation on Unix and many other systems: just a `Vec<u8>`/`[u8]`.",
        "suggest": "Unix 和许多其他系统上的基础 OsString/OsStr 实现: 只是 `Vec<u8>`/`[u8]`。",
        "translate": ""
    },
    {
        "source": "current implementation relies on `Slice` being layout-compatible with `[u8]`.",
        "suggest": "当前的实现依赖于 `Slice` 与 `[u8]` 在布局上兼容。",
        "translate": ""
    },
    {
        "source": "When attribute privacy is implemented, `Slice` should be annotated as `#[repr(transparent)]`.",
        "suggest": "实现属性隐私时，应将 `Slice` 注解为 `#[repr(transparent)]`。",
        "translate": ""
    },
    {
        "source": "Anyway, `Slice` representation and layout are considered implementation detail, are not documented and must not be relied upon.",
        "suggest": "无论如何，`Slice` 表示形式和布局被视为实现细节，没有文档记录，因此不能依赖。",
        "translate": ""
    },
    {
        "source": "Slice just wraps [u8], and &*self.inner is &[u8], therefore transmuting &[u8] to &Slice is safe.",
        "suggest": "切片仅包裹 [u8]，而 &* self.inner 是 &[u8]，因此将 &[u8] 转换为 &Slice 是安全的。",
        "translate": ""
    },
    {
        "source": "Slice just wraps [u8], and &mut *self.inner is &mut [u8], therefore transmuting &mut [u8] to &mut Slice is safe.",
        "suggest": "切片仅包裹 [u8]，而 &mut *self.inner 是 &mut [u8]，因此将 &mut [u8] 转换为 &mut 切片是安全的。",
        "translate": ""
    },
    {
        "source": "Platform-specific extensions to [`OsString`].",
        "suggest": "[`OsString`] 的特定于平台的扩展。",
        "translate": ""
    },
    {
        "source": "Creates an [`OsString`] from a byte vector.",
        "suggest": "从字节 vector 创建 [`OsString`]。",
        "translate": ""
    },
    {
        "source": "See the module documentation for an example.",
        "suggest": "有关示例，请参见模块文档。",
        "translate": ""
    },
    {
        "source": "Yields the underlying byte vector of this [`OsString`].",
        "suggest": "产生此 [`OsString`] 的基础字节 vector。",
        "translate": ""
    },
    {
        "source": "Platform-specific extensions to [`OsStr`].",
        "suggest": "[`OsStr`] 的特定于平台的扩展。",
        "translate": ""
    },
    {
        "source": "Creates an [`OsStr`] from a byte slice.",
        "suggest": "从字节切片创建 [`OsStr`]。",
        "translate": ""
    },
    {
        "source": "Gets the underlying byte view of the [`OsStr`] slice.",
        "suggest": "获取 [`OsStr`] 切片的基础字节视图。",
        "translate": ""
    },
    {
        "source": "poison the mutex",
        "suggest": "互斥锁中毒",
        "translate": ""
    },
    {
        "source": "for intra-doc links",
        "suggest": "用于文档内链接",
        "translate": ""
    },
    {
        "source": "Note that the Ordering uses to access the `failed` field of `Flag` below is always `Relaxed`, and that's because this isn't actually protecting any data, it's just a flag whether we've panicked or not.",
        "suggest": "请注意，订购用于访问下面的 `Flag` 的 `failed` 字段始终是 `Relaxed`，这是因为这实际上并没有保护任何数据，它只是我们是否恐慌的标志。",
        "translate": ""
    },
    {
        "source": "The actual location that this matters is when a mutex is **locked** which is where we have external synchronization ensuring that we see memory reads/writes to this flag.",
        "suggest": "重要的实际位置是当互斥锁被锁定时，这是我们进行外部同步的地方，确保我们看到内存读/写到这个标志。",
        "translate": ""
    },
    {
        "source": "As a result, if it matters, we should see the correct value for `failed` in all cases.",
        "suggest": "因此，如果有关系，我们应该在所有情况下都可以看到 `failed` 的正确值。",
        "translate": ""
    },
    {
        "source": "A type of error which can be returned whenever a lock is acquired.",
        "suggest": "一种错误类型，每当获取锁时都可以返回该错误。",
        "translate": ""
    },
    {
        "source": "Both [`Mutex`]es and [`RwLock`]s are poisoned whenever a thread fails while the lock is held.",
        "suggest": "每当持有锁的线程发生故障时，[`Mutex`] 和 [`RwLock`] 都会中毒。",
        "translate": ""
    },
    {
        "source": "The precise semantics for when a lock is poisoned is documented on each lock, but once a lock is poisoned then all future acquisitions will return this error.",
        "suggest": "锁中毒的确切语义记录在每个锁上，但是一旦锁中毒，则所有 future 获取都将返回此错误。",
        "translate": ""
    },
    {
        "source": "An enumeration of possible errors associated with a [`TryLockResult`] which can occur while trying to acquire a lock, from the [`try_lock`] method on a [`Mutex`] or the [`try_read`] and [`try_write`] methods on an [`RwLock`].",
        "suggest": "枚举可能与 [`TryLockResult`] 相关的错误，这些错误可能是从 [`Mutex`] 上的 [`try_lock`] 方法或 [`RwLock`] 上的 [`try_read`] 和 [`try_write`] 方法获取锁时发生的。",
        "translate": ""
    },
    {
        "source": "The lock could not be acquired because another thread failed while holding the lock.",
        "suggest": "由于另一个线程在持有锁时失败，因此无法获取该锁。",
        "translate": ""
    },
    {
        "source": "The lock could not be acquired at this time because the operation would otherwise block.",
        "suggest": "此时无法获取该锁，因为否则该操作将阻塞。",
        "translate": ""
    },
    {
        "source": "A type alias for the result of a lock method which can be poisoned.",
        "suggest": "一种类型别名，用于可能导致中毒的锁定方法。",
        "translate": ""
    },
    {
        "source": "The [`Ok`] variant of this result indicates that the primitive was not poisoned, and the `Guard` is contained within.",
        "suggest": "此结果的 [`Ok`] 成员指示该原语未被毒害，并且 `Guard` 被包含在其中。",
        "translate": ""
    },
    {
        "source": "The [`Err`] variant indicates that the primitive was poisoned.",
        "suggest": "[`Err`] 成员指示该原语已中毒。",
        "translate": ""
    },
    {
        "source": "Note that the [`Err`] variant *also* carries the associated guard, and it can be acquired through the [`into_inner`] method.",
        "suggest": "请注意，[`Err`] 成员 *还* 带有关联的防护，可以通过 [`into_inner`] 方法获取它。",
        "translate": ""
    },
    {
        "source": "A type alias for the result of a nonblocking locking method.",
        "suggest": "一种非别名锁定方法结果的类型别名。",
        "translate": ""
    },
    {
        "source": "For more information, see [`LockResult`].",
        "suggest": "有关更多信息，请参见 [`LockResult`]。",
        "translate": ""
    },
    {
        "source": "A `TryLockResult` doesn't necessarily hold the associated guard in the [`Err`] type as the lock may not have been acquired for other reasons.",
        "suggest": "`TryLockResult` 不一定将关联的守卫保持在 [`Err`] 类型，因为可能由于其他原因未获得锁。",
        "translate": ""
    },
    {
        "source": "Creates a `PoisonError`.",
        "suggest": "创建一个 `PoisonError`。",
        "translate": ""
    },
    {
        "source": "This is generally created by methods like [`Mutex::lock`] or [`RwLock::read`].",
        "suggest": "这通常是由 [`Mutex::lock`] 或 [`RwLock::read`] 之类的方法创建的。",
        "translate": ""
    },
    {
        "source": "Consumes this error indicating that a lock is poisoned, returning the underlying guard to allow access regardless.",
        "suggest": "消耗此错误，表明锁已中毒，无论如何都将返回底层防护以允许访问。",
        "translate": ""
    },
    {
        "source": "Reaches into this error indicating that a lock is poisoned, returning a reference to the underlying guard to allow access regardless.",
        "suggest": "到达此错误指示锁定已中毒，并向基础防护返回引用，无论如何允许访问。",
        "translate": ""
    },
    {
        "source": "Reaches into this error indicating that a lock is poisoned, returning a mutable reference to the underlying guard to allow access regardless.",
        "suggest": "达到此错误指示锁定已中毒，将变量引用返回给底层防护以允许访问。",
        "translate": ""
    },
    {
        "source": "Stores a set of changes to an environment",
        "suggest": "存储对环境的一组更改",
        "translate": ""
    },
    {
        "source": "Capture the current environment with these changes applied",
        "suggest": "应用这些更改来捕获当前环境",
        "translate": ""
    },
    {
        "source": "Apply these changes directly to the current environment",
        "suggest": "将这些更改直接应用于当前环境",
        "translate": ""
    },
    {
        "source": "The following functions build up changes",
        "suggest": "以下函数建立了更改",
        "translate": ""
    },
    {
        "source": "An iterator over the command environment variables.",
        "suggest": "命令环境变量上的迭代器。",
        "translate": ""
    },
    {
        "source": "This struct is created by [`Command::get_envs`][crate::process::Command::get_envs].",
        "suggest": "该结构体由 [`Command::get_envs`][crate::process::Command::get_envs] 创建。",
        "translate": ""
    },
    {
        "source": "Simplify this if Arc gets a Arc::get_pin_mut.",
        "suggest": "如果 Arc 得到 Arc::get_pin_mut，请简化此操作。",
        "translate": ""
    },
    {
        "source": "A re-entrant mutual exclusion",
        "suggest": "可重入的相互排斥",
        "translate": ""
    },
    {
        "source": "This mutex will block *other* threads waiting for the lock to become available.",
        "suggest": "此互斥锁将阻止 *其他* 线程，等待该锁可用。",
        "translate": ""
    },
    {
        "source": "The thread which has already locked the mutex can lock it multiple times without blocking, preventing a common source of deadlocks.",
        "suggest": "已经锁定互斥锁的线程可以多次将其锁定而不会阻塞，从而避免了常见的死锁源。",
        "translate": ""
    },
    {
        "source": "The data protected by the mutex can be accessed through this guard via its Deref implementation.",
        "suggest": "可以通过此保护程序的 Deref 实现访问由互斥锁保护的数据。",
        "translate": ""
    },
    {
        "source": "Unlike `MutexGuard`, `ReentrantMutexGuard` does not implement `DerefMut`, because implementation of the trait would violate Rust’s reference aliasing rules.",
        "suggest": "与 `MutexGuard` 不同，`ReentrantMutexGuard` 不实现 `DerefMut`，因为实现 trait 会违反 Rust 的引用别名规则。",
        "translate": ""
    },
    {
        "source": "Use interior mutability (usually `RefCell`) in order to mutate the guarded data.",
        "suggest": "使用内部可变性 (通常为 `RefCell`) 以更改受保护的数据。",
        "translate": ""
    },
    {
        "source": "Creates a new reentrant mutex in an unlocked state.",
        "suggest": "在解锁状态下创建一个新的可重入互斥锁。",
        "translate": ""
    },
    {
        "source": "This function is unsafe because it is required that `init` is called once this mutex is in its final resting place, and only then are the lock/unlock methods safe.",
        "suggest": "该函数是不安全的，因为一旦此互斥锁处于其最终的静止位置，就要求调用 `init`，只有这样 lock/unlock 的方法才是安全的。",
        "translate": ""
    },
    {
        "source": "Initializes this mutex so it's ready for use.",
        "suggest": "初始化此互斥锁，以便可以使用。",
        "translate": ""
    },
    {
        "source": "Unsafe to call more than once, and must be called after this will no longer move in memory.",
        "suggest": "多次调用是不安全的，必须在此之后调用，它将不再在内存中移动。",
        "translate": ""
    },
    {
        "source": "This function will block the caller until it is available to acquire the mutex.",
        "suggest": "此函数将阻止调用方，直到可以获取互斥锁为止。",
        "translate": ""
    },
    {
        "source": "Upon returning, the thread is the only thread with the mutex held.",
        "suggest": "返回时，该线程是唯一具有互斥锁的线程。",
        "translate": ""
    },
    {
        "source": "When the thread calling this method already holds the lock, the call shall succeed without blocking.",
        "suggest": "当调用此方法的线程已持有锁时，调用将成功而不会阻塞。",
        "translate": ""
    },
    {
        "source": "If another user of this mutex panicked while holding the mutex, then this call will return failure if the mutex would otherwise be acquired.",
        "suggest": "如果此互斥锁的另一个用户在握住互斥锁时恐慌，那么如果以其他方式获取互斥锁，则此调用将返回失败。",
        "translate": ""
    },
    {
        "source": "This is actually safe b/c we know that there is no further usage of this mutex (it's up to the user to arrange for a mutex to get dropped, that's not our job)",
        "suggest": "这实际上是安全的 b/c，我们知道此互斥锁没有进一步的用途 (由用户来安排丢弃互斥锁，这不是我们的工作)",
        "translate": ""
    },
    {
        "source": "An OS-based reader-writer lock.",
        "suggest": "基于 OS 的 reader-writer 锁。",
        "translate": ""
    },
    {
        "source": "This structure is entirely unsafe and serves as the lowest layer of a cross-platform binding of system rwlocks.",
        "suggest": "该结构体是完全不安全的，并且充当系统 rwlock 的跨平台绑定的最低层。",
        "translate": ""
    },
    {
        "source": "It is recommended to use the safer types at the top level of this crate instead of this type.",
        "suggest": "建议在此 crate 的顶层使用更安全的类型，而不是此类型。",
        "translate": ""
    },
    {
        "source": "Creates a new reader-writer lock for use.",
        "suggest": "创建一个新的 reader-writer 锁以供使用。",
        "translate": ""
    },
    {
        "source": "Behavior is undefined if the reader-writer lock is moved after it is first used with any of the functions below.",
        "suggest": "如果在第一次将 reader-writer 锁与下面的任何函数一起使用后将其移动，则行为是不确定的。",
        "translate": ""
    },
    {
        "source": "Acquires shared access to the underlying lock, blocking the current thread to do so.",
        "suggest": "获取对基础锁的共享访问，从而阻止当前线程这样做。",
        "translate": ""
    },
    {
        "source": "Behavior is undefined if the rwlock has been moved between this and any previous method call.",
        "suggest": "如果 rwlock 已在此方法和任何以前的方法调用之间移动，则行为是不确定的。",
        "translate": ""
    },
    {
        "source": "Attempts to acquire shared access to this lock, returning whether it succeeded or not.",
        "suggest": "尝试获取对此锁的共享访问权，并返回是否成功。",
        "translate": ""
    },
    {
        "source": "This function does not block the current thread.",
        "suggest": "此函数不会阻止当前线程。",
        "translate": ""
    },
    {
        "source": "Acquires write access to the underlying lock, blocking the current thread to do so.",
        "suggest": "获取对基础锁的写访问权，从而阻止当前线程这样做。",
        "translate": ""
    },
    {
        "source": "Attempts to acquire exclusive access to this lock, returning whether it succeeded or not.",
        "suggest": "尝试获取对此锁的独占访问权，并返回是否成功。",
        "translate": ""
    },
    {
        "source": "Unlocks previously acquired shared access to this lock.",
        "suggest": "解锁先前获取的对此锁的共享访问权限。",
        "translate": ""
    },
    {
        "source": "Behavior is undefined if the current thread does not have shared access.",
        "suggest": "如果当前线程没有共享访问权限，则行为是不确定的。",
        "translate": ""
    },
    {
        "source": "Unlocks previously acquired exclusive access to this lock.",
        "suggest": "解锁先前获得的对此锁的独占访问权。",
        "translate": ""
    },
    {
        "source": "Behavior is undefined if the current thread does not currently have exclusive access.",
        "suggest": "如果当前线程当前没有独占访问权，则行为是不确定的。",
        "translate": ""
    },
    {
        "source": "Destroys OS-related resources with this RWLock.",
        "suggest": "使用此 RWLock 销毁与操作系统相关的资源。",
        "translate": ""
    },
    {
        "source": "Behavior is undefined if there are any currently active users of this lock.",
        "suggest": "如果此锁当前有任何活动用户，则行为是不确定的。",
        "translate": ""
    },
    {
        "source": "the cfg annotations only exist due to dead code warnings.",
        "suggest": "cfg 注解仅因 dead 代码警告而存在。",
        "translate": ""
    },
    {
        "source": "the code itself is portable",
        "suggest": "代码本身是可移植的",
        "translate": ""
    },
    {
        "source": "The lock is automatically unlocked when the returned guard is dropped.",
        "suggest": "当返回的守卫丢弃时，锁会自动解锁。",
        "translate": ""
    },
    {
        "source": "All methods require static references, therefore self cannot be moved between invocations.",
        "suggest": "所有方法都需要静态引用，因此 self 不能在调用之间移动。",
        "translate": ""
    },
    {
        "source": "0 is our sentinel value, so ensure that we'll never see 0 after initialization has run",
        "suggest": "0 是我们的哨兵值，因此请确保在初始化运行后我们永远不会看到 0",
        "translate": ""
    },
    {
        "source": "stack_guard isn't used right now on all platforms",
        "suggest": "目前并非在所有平台上都使用 stack_guard",
        "translate": ""
    },
    {
        "source": "Thread-local destructor",
        "suggest": "线程局部析构函数",
        "translate": ""
    },
    {
        "source": "Besides thread-local \"keys\" (pointer-sized non-addressable thread-local store with an associated destructor), many platforms also provide thread-local destructors that are not associated with any particular data.",
        "suggest": "除了线程本地 \"keys\" (具有关联的析构函数的指针大小的不可寻址线程本地存储) 之外，许多平台还提供与任何特定数据都不关联的线程本地析构函数。",
        "translate": ""
    },
    {
        "source": "These are often more efficient.",
        "suggest": "这些往往效率更高。",
        "translate": ""
    },
    {
        "source": "This module provides a fallback implementation for that interface, based on the less efficient thread-local \"keys\".",
        "suggest": "该模块基于效率较低的线程本地 \"keys\"，为该接口提供了一个回退实现。",
        "translate": ""
    },
    {
        "source": "Each platform provides a `thread_local_dtor` module which will either re-export the fallback, or implement something more efficient.",
        "suggest": "每个平台都提供一个 `thread_local_dtor` 模块，该模块将重新导出回退，或者实现一些更有效的东西。",
        "translate": ""
    },
    {
        "source": "The fallback implementation uses a vanilla OS-based TLS key to track the list of destructors that need to be run for this thread.",
        "suggest": "回退实现使用一个普通的基于操作系统的TLS密钥来跟踪这个线程需要运行的析构函数列表。",
        "translate": ""
    },
    {
        "source": "The key then has its own destructor which runs all the other destructors.",
        "suggest": "然后，键有自己的析构函数，它运行所有其他的析构函数。",
        "translate": ""
    },
    {
        "source": "The destructor for DTORS is a little special in that it has a `while` loop to continuously drain the list of registered destructors.",
        "suggest": "DTORS 的析构函数有点特殊，因为它有一个 `while` 循环来不断地清除已注册的析构函数列表。",
        "translate": ""
    },
    {
        "source": "It *should* be the case that this loop always terminates because we provide the guarantee that a TLS key cannot be set after it is flagged for destruction.",
        "suggest": "在这种情况下，该循环总是会终止，因为我们提供了保证，在将 TLS 密钥标记为要销毁之后，无法设置 TLS 密钥。",
        "translate": ""
    },
    {
        "source": "deallocate this TLS slot.",
        "suggest": "释放此 TLS 插槽。",
        "translate": ""
    },
    {
        "source": "OS-based thread local storage",
        "suggest": "基于操作系统的线程本地存储",
        "translate": ""
    },
    {
        "source": "This module provides an implementation of OS-based thread local storage, using the native OS-provided facilities (think `TlsAlloc` or `pthread_setspecific`).",
        "suggest": "该模块提供了一个基于操作系统的线程本地存储的实现，使用了本地操作系统提供的工具 (想想 `TlsAlloc` 或 `pthread_setspecific`)。",
        "translate": ""
    },
    {
        "source": "The interface of this differs from the other types of thread-local-storage provided in this crate in that OS-based TLS can only get/set pointer-sized data, possibly with an associated destructor.",
        "suggest": "它的接口与此 crate 中提供的其他类型的线程本地存储不同，因为基于操作系统的 TLS 只能获取/设置指针大小的数据，可能带有关联的析构函数。",
        "translate": ""
    },
    {
        "source": "This module also provides two flavors of TLS.",
        "suggest": "该模块还提供了两种 TLS。",
        "translate": ""
    },
    {
        "source": "One is intended for static initialization, and does not contain a `Drop` implementation to deallocate the OS-TLS key.",
        "suggest": "其中一个用于静态初始化，不包含用于释放 OS-TLS 密钥的 `Drop` 实现。",
        "translate": ""
    },
    {
        "source": "The other is a type which does implement `Drop` and hence has a safe interface.",
        "suggest": "另一个是实现了 `Drop` 的类型，因此有一个安全的接口。",
        "translate": ""
    },
    {
        "source": "This module should likely not be used directly unless other primitives are being built on.",
        "suggest": "除非在其他原语的基础上构建，否则不应该直接使用此模块。",
        "translate": ""
    },
    {
        "source": "Types such as `thread_local::spawn::Key` are likely much more useful in practice than this OS-based version which likely requires unsafe code to interoperate with.",
        "suggest": "像 `thread_local::spawn::Key` 这样的类型在实践中可能比此基于 OS 的版本有用得多，后者可能需要不安全的代码才能进行互操作。",
        "translate": ""
    },
    {
        "source": "Using a dynamically allocated TLS key.",
        "suggest": "使用动态分配的 TLS 密钥。",
        "translate": ""
    },
    {
        "source": "Note that this key can be shared among many threads via an `Arc`.",
        "suggest": "请注意，这个键可以通过 `Arc` 在多个线程中共享。",
        "translate": ""
    },
    {
        "source": "Sometimes a statically allocated key is either required or easier to work with, however.",
        "suggest": "有时，静态分配的密钥是必需的，或者更易于使用。",
        "translate": ""
    },
    {
        "source": "A type for TLS keys that are statically allocated.",
        "suggest": "静态分配的 TLS 密钥的类型。",
        "translate": ""
    },
    {
        "source": "This type is entirely `unsafe` to use as it does not protect against use-after-deallocation or use-during-deallocation.",
        "suggest": "使用此类型是完全 `unsafe` 的，因为它不能防止在释放后使用或释放​​期间使用。",
        "translate": ""
    },
    {
        "source": "The actual OS-TLS key is lazily allocated when this is used for the first time.",
        "suggest": "第一次使用时会延迟分配实际的 OS-TLS 密钥。",
        "translate": ""
    },
    {
        "source": "The key is also deallocated when the Rust runtime exits or `destroy` is called, whichever comes first.",
        "suggest": "当 Rust 运行时退出或调用 `destroy` (以先到者为准) 时，也将释放该键。",
        "translate": ""
    },
    {
        "source": "Inner static TLS key (internals).",
        "suggest": "内部静态 TLS 密钥 (internals)。",
        "translate": ""
    },
    {
        "source": "Destructor for the TLS value.",
        "suggest": "TLS 值的析构函数。",
        "translate": ""
    },
    {
        "source": "See `Key::new` for information about when the destructor runs and how it runs.",
        "suggest": "有关析构函数何时运行以及运行方式的信息，请参见 `Key::new`。",
        "translate": ""
    },
    {
        "source": "A type for a safely managed OS-based TLS slot.",
        "suggest": "一种安全管理的基于 OS 的 TLS 插槽的类型。",
        "translate": ""
    },
    {
        "source": "This type allocates an OS TLS key when it is initialized and will deallocate the key when it falls out of scope.",
        "suggest": "初始化时，此类型分配 OS TLS 密钥; 当它离开离开作用域时，将释放该密钥。",
        "translate": ""
    },
    {
        "source": "When compared with `StaticKey`, this type is entirely safe to use.",
        "suggest": "与 `StaticKey` 相比，此类型完全可以安全使用。",
        "translate": ""
    },
    {
        "source": "Implementations will likely, however, contain unsafe code as this type only operates on `*mut u8`, a raw pointer.",
        "suggest": "但是，实现可能会包含不安全的代码，因为此类型仅在 `*mut u8` (裸指针) 上运行。",
        "translate": ""
    },
    {
        "source": "Constant initialization value for static TLS keys.",
        "suggest": "静态 TLS 密钥的常量初始化值。",
        "translate": ""
    },
    {
        "source": "This value specifies no destructor by default.",
        "suggest": "默认情况下，此值不指定析构函数。",
        "translate": ""
    },
    {
        "source": "Gets the value associated with this TLS key",
        "suggest": "获取与此 TLS 密钥关联的值",
        "translate": ""
    },
    {
        "source": "This will lazily allocate a TLS key from the OS if one has not already been allocated.",
        "suggest": "如果尚未分配 TLS 密钥，则会从操作系统延迟分配 TLS 密钥。",
        "translate": ""
    },
    {
        "source": "Sets this TLS key to a new value.",
        "suggest": "将此 TLS 密钥设置为新值。",
        "translate": ""
    },
    {
        "source": "Currently the Windows implementation of TLS is pretty hairy, and it greatly simplifies creation if we just synchronize everything.",
        "suggest": "当前，TLS 的 Windows 实现非常繁琐，如果我们仅同步所有内容，它将大大简化创建过程。",
        "translate": ""
    },
    {
        "source": "Additionally a 0-index of a tls key hasn't been seen on windows, so we just simplify the whole branch.",
        "suggest": "此外，在 windows 上还没有看到 tls 键的 0 索引，因此我们只是简化了整个分支。",
        "translate": ""
    },
    {
        "source": "We never call `INIT_LOCK.init()`, so it is UB to attempt to acquire this mutex reentrantly!",
        "suggest": "我们从不调用 `INIT_LOCK.init()`，因此尝试重新获得此互斥锁是 UB!",
        "translate": ""
    },
    {
        "source": "POSIX allows the key created here to be 0, but the compare_exchange below relies on using 0 as a sentinel value to check who won the race to set the shared TLS key.",
        "suggest": "POSIX 允许在此处创建的密钥为 0，但是下面的 compare_exchange 依靠使用 0 作为标记值来检查谁赢得了设置共享 TLS 密钥的竞争。",
        "translate": ""
    },
    {
        "source": "As far as I know, there is no guaranteed value that cannot be returned as a posix_key_create key, so there is no value we can initialize the inner key with to prove that it has not yet been set.",
        "suggest": "据我所知，没有保证值不能作为 posix_key_create 键返回，因此没有值可以初始化内部键以证明尚未设置。",
        "translate": ""
    },
    {
        "source": "As such, we'll continue using a value of 0, but with some gyrations to make sure we have a non-0 value returned from the creation routine.",
        "suggest": "因此，我们将继续使用 0 值，但要进行一些旋转以确保我们从创建例程返回了 non-0 值。",
        "translate": ""
    },
    {
        "source": "this is clearly a hack, and should be cleaned up.",
        "suggest": "这显然是一个 hack，应该对其进行清理。",
        "translate": ""
    },
    {
        "source": "The CAS succeeded, so we've created the actual key",
        "suggest": "CAS 成功了，所以我们创建了实际的密钥",
        "translate": ""
    },
    {
        "source": "If someone beat us to the punch, use their key instead",
        "suggest": "如果有人超过了我们，请改用他们的秘钥",
        "translate": ""
    },
    {
        "source": "Creates a new managed OS TLS key.",
        "suggest": "创建一个新的托管 OS TLS 密钥。",
        "translate": ""
    },
    {
        "source": "This key will be deallocated when the key falls out of scope.",
        "suggest": "当秘钥离开作用域时，该键将被释放。",
        "translate": ""
    },
    {
        "source": "The argument provided is an optionally-specified destructor for the value of this TLS key.",
        "suggest": "提供的参数是此 TLS 密钥的值的可选指定的析构函数。",
        "translate": ""
    },
    {
        "source": "When a thread exits and the value for this key is non-null the destructor will be invoked.",
        "suggest": "当线程退出并且此键的值不为 null 时，将调用析构函数。",
        "translate": ""
    },
    {
        "source": "The TLS value will be reset to null before the destructor is invoked.",
        "suggest": "在调用析构函数之前，TLS 值将重置为 null。",
        "translate": ""
    },
    {
        "source": "Note that the destructor will not be run when the `Key` goes out of scope.",
        "suggest": "请注意，当 `Key` 离开作用域时，析构函数将不会运行。",
        "translate": ""
    },
    {
        "source": "See StaticKey::get",
        "suggest": "请参见 StaticKey::get",
        "translate": ""
    },
    {
        "source": "See StaticKey::set",
        "suggest": "请参见 StaticKey::set",
        "translate": ""
    },
    {
        "source": "Right now Windows doesn't support TLS key destruction, but this also isn't used anywhere other than tests, so just leak the TLS key.",
        "suggest": "目前，Windows 不支持 TLS 密钥销毁，但是除了测试以外，其他任何地方都没有使用它，因此只需泄漏 TLS 密钥即可。",
        "translate": ""
    },
    {
        "source": "This is done with a release-acquire synchronization, by using Ordering::Release when writing NOTIFIED (the 'token') in unpark(), and using Ordering::Acquire when checking for this state in park().",
        "suggest": "通过在 unpark() 中写入 NOTIFIED ('token') 时使用 Ordering::Release，并在 park() 中检查此状态时使用 Ordering::Acquire，可以实现发布 - 获取同步。",
        "translate": ""
    },
    {
        "source": "Change NOTIFIED=>EMPTY and return in that case.",
        "suggest": "更改 NOTIFIED => EMPTY 并在这种情况下返回。",
        "translate": ""
    },
    {
        "source": "This is not just a store, because we need to establish a release-acquire ordering with unpark().",
        "suggest": "这不仅仅是一个存储，因为我们需要用 `unpark()` 建立一个 `释放-获取` 的顺序。",
        "translate": ""
    },
    {
        "source": "Woke up because of unpark().",
        "suggest": "因为 `unpark()` 而醒来。",
        "translate": ""
    },
    {
        "source": "Parker implementaiton based on a Mutex and Condvar.",
        "suggest": "基于互斥锁和 Condvar 的 Parker 工具。",
        "translate": ""
    },
    {
        "source": "This implementaiton doesn't require `unsafe`, but other implementations may assume this is only called by the thread that owns the Parker.",
        "suggest": "此实现不需要 `unsafe`，但其他实现可能会假定仅由拥有 Parker 的线程调用此方法。",
        "translate": ""
    },
    {
        "source": "If we were previously notified then we consume this notification and return quickly.",
        "suggest": "如果我们之前收到通知，那么我们将消耗此通知并迅速返回。",
        "translate": ""
    },
    {
        "source": "Otherwise we need to coordinate going to sleep",
        "suggest": "否则我们需要协调睡眠",
        "translate": ""
    },
    {
        "source": "We must read here, even though we know it will be `NOTIFIED`.",
        "suggest": "即使我们知道它将是 `NOTIFIED`，也必须在这里读取。",
        "translate": ""
    },
    {
        "source": "This is because `unpark` may have been called again since we read `NOTIFIED` in the `compare_exchange` above.",
        "suggest": "这是因为自从我们在上面的 `compare_exchange` 中读取 `NOTIFIED` 以来，可能已经再次调用 `unpark`。",
        "translate": ""
    },
    {
        "source": "We must perform an acquire operation that synchronizes with that `unpark` to observe any writes it made before the call to unpark.",
        "suggest": "我们必须执行与该 `unpark` 同步的获取操作，以观察它在取消驻留之前进行的所有写操作。",
        "translate": ""
    },
    {
        "source": "To do that we must read from the write it made to `state`.",
        "suggest": "为此，我们必须从对 `state` 的写入中读取。",
        "translate": ""
    },
    {
        "source": "should consume this notification, so prohibit spurious wakeups in next park.",
        "suggest": "应该使用此通知，因此禁止在下一个公园中虚假唤醒。",
        "translate": ""
    },
    {
        "source": "got a notification",
        "suggest": "收到通知",
        "translate": ""
    },
    {
        "source": "spurious wakeup, go back to sleep",
        "suggest": "虚假唤醒，回去睡觉",
        "translate": ""
    },
    {
        "source": "Like `park` above we have a fast path for an already-notified thread, and afterwards we start coordinating for a sleep.",
        "suggest": "像上面的 `park` 一样，我们为已通知的线程提供了一条快速路径，然后我们开始协调睡眠。",
        "translate": ""
    },
    {
        "source": "return quickly.",
        "suggest": "快速返回。",
        "translate": ""
    },
    {
        "source": "We must read again here, see `park`.",
        "suggest": "我们必须在这里再次读取，请参见 `park`。",
        "translate": ""
    },
    {
        "source": "Wait with a timeout, and if we spuriously wake up or otherwise wake up from a notification we just want to unconditionally set the state back to empty, either consuming a notification or un-flagging ourselves as parked.",
        "suggest": "等待超时，如果我们虚假地唤醒或以其他方式从通知中醒来，我们只是想无条件地将状态设置为空，既可以使用通知，也可以不标记自己为停止状态。",
        "translate": ""
    },
    {
        "source": "got a notification, hurray!",
        "suggest": "收到通知，欢呼!",
        "translate": ""
    },
    {
        "source": "no notification, alas",
        "suggest": "没有通知，alas",
        "translate": ""
    },
    {
        "source": "To ensure the unparked thread will observe any writes we made before this call, we must perform a release operation that `park` can synchronize with.",
        "suggest": "为了确保未驻留线程可以观察到我们在此调用之前所做的任何写操作，我们必须执行 `park` 可以与之同步的释放操作。",
        "translate": ""
    },
    {
        "source": "To do that we must write `NOTIFIED` even if `state` is already `NOTIFIED`.",
        "suggest": "为此，即使 `state` 已经是 `NOTIFIED`，我们也必须编写 `NOTIFIED`。",
        "translate": ""
    },
    {
        "source": "That is why this must be a swap rather than a compare-and-swap that returns if it reads `NOTIFIED` on failure.",
        "suggest": "这就是为什么这必须是交换操作，而不是如果失败读取 `NOTIFIED` 时返回的比较交换。",
        "translate": ""
    },
    {
        "source": "no one was waiting",
        "suggest": "没有人在等",
        "translate": ""
    },
    {
        "source": "already unparked",
        "suggest": "已经停止",
        "translate": ""
    },
    {
        "source": "gotta go wake someone up",
        "suggest": "要去叫醒某人",
        "translate": ""
    },
    {
        "source": "There is a period between when the parked thread sets `state` to `PARKED` (or last checked `state` in the case of a spurious wake up) and when it actually waits on `cvar`.",
        "suggest": "从暂停的线程将 `state` 设置为 `PARKED` (或在虚假唤醒的情况下最后检查的 `state`) 到它实际等待 `cvar` 之间存在一段时间。",
        "translate": ""
    },
    {
        "source": "If we were to notify during this period it would be ignored and then when the parked thread went to sleep it would never wake up.",
        "suggest": "如果我们在此期间进行通知，它将被忽略，然后当驻留线程进入睡眠状态时，它将永远不会醒来。",
        "translate": ""
    },
    {
        "source": "Fortunately, it has `lock` locked at this stage so we can acquire `lock` to wait until it is ready to receive the notification.",
        "suggest": "幸运的是，它在此阶段已锁定 `lock`，因此我们可以获取 `lock` 以等待它准备好接收通知。",
        "translate": ""
    },
    {
        "source": "Releasing `lock` before the call to `notify_one` means that when the parked thread wakes it doesn't get woken only to have to wait for us to release `lock`.",
        "suggest": "在调用 `notify_one` 之前释放 `lock` 意味着，当驻留线程唤醒时，不必等待我们释放 `lock` 即可唤醒它。",
        "translate": ""
    },
    {
        "source": "Other platforms should use the appropriate platform-specific mechanism for aborting the process.",
        "suggest": "其他平台应该使用适当的特定于平台的机制来中止进程。",
        "translate": ""
    },
    {
        "source": "If no platform-specific mechanism is available, crate::intrinsics::abort() may be used instead.",
        "suggest": "如果没有特定于平台的机制，则可以改用 crate::intrinsics:: 终止 ()。",
        "translate": ""
    },
    {
        "source": "The above implementations cover all targets currently supported by libstd.",
        "suggest": "上面的实现涵盖了 libstd 当前支持的所有目标。",
        "translate": ""
    },
    {
        "source": "stack overflow detection not enabled on all platforms",
        "suggest": "并非在所有平台上都启用栈溢出检测",
        "translate": ""
    },
    {
        "source": "not surrogate",
        "suggest": "不代理",
        "translate": ""
    },
    {
        "source": "not surrogate, < 3 bytes",
        "suggest": "不代理，小于 3 个字节",
        "translate": ""
    },
    {
        "source": "Implementation of [the WTF-8 encoding](https://simonsapin.github.io/wtf-8/).",
        "suggest": "[WTF-8 编码](https://simonsapin.github.io/wtf-8/) 的实现。",
        "translate": ""
    },
    {
        "source": "This library uses Rust’s type system to maintain [well-formedness](https://simonsapin.github.io/wtf-8/#well-formed), like the `String` and `&str` types do for UTF-8.",
        "suggest": "该库使用 Rust 的类型系统来维护 [well-formedness](https://simonsapin.github.io/wtf-8/#well-formed)，就像 `String` 和 `&str` 类型用于 UTF-8 一样。",
        "translate": ""
    },
    {
        "source": "Since [WTF-8 must not be used for interchange](https://simonsapin.github.io/wtf-8/#intended-audience), this library deliberately does not provide access to the underlying bytes of WTF-8 strings, nor can it decode WTF-8 from arbitrary bytes.",
        "suggest": "从 [WTF-8 不得用于互换](https://simonsapin.github.io/wtf-8/#intended-audience) 开始，该库故意不提供对 WTF-8 字符串基础字节的访问，也不能从任意字节解码 WTF-8。",
        "translate": ""
    },
    {
        "source": "strings can be obtained from UTF-8, UTF-16, or code points.",
        "suggest": "可以从 UTF-8，UTF-16 或代码点获得字符串。",
        "translate": ""
    },
    {
        "source": "this module is imported from @SimonSapin's repo and has tons of dead code on unix (it's mostly used on windows), so don't worry about dead code here.",
        "suggest": "该模块是从 @SimonSapin 的 repo 导入的，并且在 unix 上具有大量无效代码 (主要在 windows 上使用)，因此在这里不必担心无效代码。",
        "translate": ""
    },
    {
        "source": "A Unicode code point: from U+0000 to U+10FFFF.",
        "suggest": "Unicode 代码点: 从 U+0000 到 U+10FFFF。",
        "translate": ""
    },
    {
        "source": "Compares with the `char` type, which represents a Unicode scalar value:",
        "suggest": "与表示 Unicode 标量值的 `char` 类型进行比较:",
        "translate": ""
    },
    {
        "source": "a code point that is not a surrogate (U+D800 to U+DFFF).",
        "suggest": "一个非代理的代码点 (U+D800 至 U+DFFF)。",
        "translate": ""
    },
    {
        "source": "Format the code point as `U+` followed by four to six hexadecimal digits.",
        "suggest": "将代码点的格式设置为 `U+`，后跟 4 至 6 个十六进制数字。",
        "translate": ""
    },
    {
        "source": "Unsafely creates a new `CodePoint` without checking the value.",
        "suggest": "不检查值不安全地创建新的 `CodePoint`。",
        "translate": ""
    },
    {
        "source": "Only use when `value` is known to be less than or equal to 0x10FFFF.",
        "suggest": "仅在已知 `value` 小于或等于 0x10FFFF 时使用。",
        "translate": ""
    },
    {
        "source": "Creates a new `CodePoint` if the value is a valid code point.",
        "suggest": "如果该值是有效的代码点，则创建一个新的 `CodePoint`。",
        "translate": ""
    },
    {
        "source": "Returns `None` if `value` is above 0x10FFFF.",
        "suggest": "如果 `value` 高于 0x10FFFF，则返回 `None`。",
        "translate": ""
    },
    {
        "source": "Creates a new `CodePoint` from a `char`.",
        "suggest": "从 `char` 创建一个新的 `CodePoint`。",
        "translate": ""
    },
    {
        "source": "Since all Unicode scalar values are code points, this always succeeds.",
        "suggest": "由于所有 Unicode 标量值都是代码点，因此这始终会成功。",
        "translate": ""
    },
    {
        "source": "Returns the numeric value of the code point.",
        "suggest": "返回代码点的数值。",
        "translate": ""
    },
    {
        "source": "Optionally returns a Unicode scalar value for the code point.",
        "suggest": "(可选) 返回代码点的 Unicode 标量值。",
        "translate": ""
    },
    {
        "source": "Returns `None` if the code point is a surrogate (from U+D800 to U+DFFF).",
        "suggest": "如果代码点是代理 (从 U+D800 到 U+DFFF)，则返回 `None`。",
        "translate": ""
    },
    {
        "source": "Returns a Unicode scalar value for the code point.",
        "suggest": "返回代码点的 Unicode 标量值。",
        "translate": ""
    },
    {
        "source": "Returns `'\\u{FFFD}'` (the replacement character “”) if the code point is a surrogate (from U+D800 to U+DFFF).",
        "suggest": "如果代码点是代理 (从 U+D800 到 U+DFFF)，则返回 `'\\u{FFFD}'` (替换字符 ``)。",
        "translate": ""
    },
    {
        "source": "An owned, growable string of well-formed WTF-8 data.",
        "suggest": "格式良好的 WTF-8 数据的拥有的，可增长的字符串。",
        "translate": ""
    },
    {
        "source": "Similar to `String`, but can additionally contain surrogate code points if they’re not in a surrogate pair.",
        "suggest": "与 `String` 相似，但是如果它们不在代理对中，则可以另外包含代理代码点。",
        "translate": ""
    },
    {
        "source": "Format the string with double quotes, and surrogates as `\\u` followed by four hexadecimal digits.",
        "suggest": "用双引号将字符串格式设置，并代之以 `\\u`，后跟四个十六进制数字。",
        "translate": ""
    },
    {
        "source": "Example: `\"a\\u{D800}\"` for a string with code points [U+0061, U+D800]",
        "suggest": "示例: `\"a\\u{D800}\"` 用于代码点为 [U+0061, U+D800] 的字符串",
        "translate": ""
    },
    {
        "source": "Creates a new, empty WTF-8 string.",
        "suggest": "创建一个新的空 WTF-8 字符串。",
        "translate": ""
    },
    {
        "source": "Creates a new, empty WTF-8 string with pre-allocated capacity for `capacity` bytes.",
        "suggest": "创建一个新的空 WTF-8 字符串，该字符串具有预分配的 `capacity` 字节容量。",
        "translate": ""
    },
    {
        "source": "Creates a WTF-8 string from a UTF-8 `String`.",
        "suggest": "从 UTF-8 `String` 创建 WTF-8 字符串。",
        "translate": ""
    },
    {
        "source": "This takes ownership of the `String` and does not copy.",
        "suggest": "这将获得 `String` 的所有权，并且不会复制。",
        "translate": ""
    },
    {
        "source": "Since WTF-8 is a superset of UTF-8, this always succeeds.",
        "suggest": "由于 WTF-8 是 UTF-8 的超集，因此它总是成功。",
        "translate": ""
    },
    {
        "source": "Creates a WTF-8 string from a UTF-8 `&str` slice.",
        "suggest": "从 UTF-8 `&str` 切片创建 WTF-8 字符串。",
        "translate": ""
    },
    {
        "source": "This copies the content of the slice.",
        "suggest": "这将复制切片的内容。",
        "translate": ""
    },
    {
        "source": "Creates a WTF-8 string from a potentially ill-formed UTF-16 slice of 16-bit code units.",
        "suggest": "从可能格式不正确的 16 位代码单元的 UTF-16 切片创建 WTF-8 字符串。",
        "translate": ""
    },
    {
        "source": "This is lossless: calling `.encode_wide()` on the resulting string will always return the original code units.",
        "suggest": "这是无损的: 在结果字符串上调用 `.encode_wide()` 将始终返回原始代码单元。",
        "translate": ""
    },
    {
        "source": "Surrogates are known to be in the code point range.",
        "suggest": "已知代理在代码点范围内。",
        "translate": ""
    },
    {
        "source": "Skip the WTF-8 concatenation check, surrogate pairs are already decoded by decode_utf16",
        "suggest": "跳过 WTF-8 并置检查，代理对已经被 decode_utf16 解码",
        "translate": ""
    },
    {
        "source": "Copied from String::push This does **not** include the WTF-8 concatenation check.",
        "suggest": "从 String::push 复制这不包括 WTF-8 串联检查。",
        "translate": ""
    },
    {
        "source": "Reserves capacity for at least `additional` more bytes to be inserted in the given `Wtf8Buf`.",
        "suggest": "为给定的 `Wtf8Buf` 保留至少 `additional` 字节的容量。",
        "translate": ""
    },
    {
        "source": "Returns the number of bytes that this string buffer can hold without reallocating.",
        "suggest": "返回此字符串缓冲区无需重新分配即可容纳的字节数。",
        "translate": ""
    },
    {
        "source": "Append a UTF-8 slice at the end of the string.",
        "suggest": "在字符串的末尾附加 UTF-8 切片。",
        "translate": ""
    },
    {
        "source": "Append a WTF-8 slice at the end of the string.",
        "suggest": "在字符串的末尾附加 WTF-8 切片。",
        "translate": ""
    },
    {
        "source": "This replaces newly paired surrogates at the boundary with a supplementary code point, like concatenating ill-formed UTF-16 strings effectively would.",
        "suggest": "这样可以用一个补充代码点替换边界上新配对的代理，就像有效地合并格式不正确的 UTF-16 字符串一样。",
        "translate": ""
    },
    {
        "source": "Replace newly paired surrogates by a supplementary code point.",
        "suggest": "用补充代码点替换新配对的代理。",
        "translate": ""
    },
    {
        "source": "4 bytes for the supplementary code point",
        "suggest": "4 个字节的补充代码点",
        "translate": ""
    },
    {
        "source": "Append a Unicode scalar value at the end of the string.",
        "suggest": "在字符串末尾附加 Unicode 标量值。",
        "translate": ""
    },
    {
        "source": "Append a code point at the end of the string.",
        "suggest": "在字符串末尾附加一个代码点。",
        "translate": ""
    },
    {
        "source": "No newly paired surrogates at the boundary.",
        "suggest": "边界上没有新配对的代理人。",
        "translate": ""
    },
    {
        "source": "Shortens a string to the specified length.",
        "suggest": "将字符串缩短到指定的长度。",
        "translate": ""
    },
    {
        "source": "Panics if `new_len` > current length, or if `new_len` is not a code point boundary.",
        "suggest": "如果 `new_len` > 当前长度，或者 `new_len` 不是代码点边界，则为 Panics。",
        "translate": ""
    },
    {
        "source": "Consumes the WTF-8 string and tries to convert it to UTF-8.",
        "suggest": "消耗 WTF-8 字符串，并尝试将其转换为 UTF-8。",
        "translate": ""
    },
    {
        "source": "This does not copy the data.",
        "suggest": "这不会复制数据。",
        "translate": ""
    },
    {
        "source": "If the contents are not well-formed UTF-8 (that is, if the string contains surrogates), the original WTF-8 string is returned instead.",
        "suggest": "如果内容格式不正确的 UTF-8 (即，如果字符串包含替代)，则返回原始 WTF-8 字符串。",
        "translate": ""
    },
    {
        "source": "Consumes the WTF-8 string and converts it lossily to UTF-8.",
        "suggest": "消耗 WTF-8 字符串并将其有损地转换为 UTF-8。",
        "translate": ""
    },
    {
        "source": "This does not copy the data (but may overwrite parts of it in place).",
        "suggest": "这不会复制数据 (但可能会覆盖其部分内容)。",
        "translate": ""
    },
    {
        "source": "Surrogates are replaced with `\"\\u{FFFD}\"` (the replacement character “”)",
        "suggest": "代理替换为 `\"\\u{FFFD}\"` (替换字符 ``)",
        "translate": ""
    },
    {
        "source": "Converts this `Wtf8Buf` into a boxed `Wtf8`.",
        "suggest": "将此 `Wtf8Buf` 转换为 boxed `Wtf8`。",
        "translate": ""
    },
    {
        "source": "Converts a `Box<Wtf8>` into a `Wtf8Buf`.",
        "suggest": "将 `Box<Wtf8>` 转换为 `Wtf8Buf`。",
        "translate": ""
    },
    {
        "source": "Creates a new WTF-8 string from an iterator of code points.",
        "suggest": "从代码点的迭代器创建新的 WTF-8 字符串。",
        "translate": ""
    },
    {
        "source": "This replaces surrogate code point pairs with supplementary code points, like concatenating ill-formed UTF-16 strings effectively would.",
        "suggest": "这将替代代码点对替换为补充代码点，就像有效地合并格式不正确的 UTF-16 字符串一样。",
        "translate": ""
    },
    {
        "source": "Append code points from an iterator to the string.",
        "suggest": "将代码点从迭代器追加到字符串。",
        "translate": ""
    },
    {
        "source": "Lower bound of one byte per code point (ASCII only)",
        "suggest": "每个代码点一个字节的下限 (仅 ASCII)",
        "translate": ""
    },
    {
        "source": "A borrowed slice of well-formed WTF-8 data.",
        "suggest": "借用的格式良好的 WTF-8 数据切片。",
        "translate": ""
    },
    {
        "source": "Similar to `&str`, but can additionally contain surrogate code points if they’re not in a surrogate pair.",
        "suggest": "与 `&str` 相似，但是如果它们不在代理对中，则可以另外包含代理代码点。",
        "translate": ""
    },
    {
        "source": "Format the slice with double quotes, and surrogates as `\\u` followed by four hexadecimal digits.",
        "suggest": "用双引号对切片进行格式设置，并代之以 `\\u`，后跟四个十六进制数字。",
        "translate": ""
    },
    {
        "source": "Example: `\"a\\u{D800}\"` for a slice with code points [U+0061, U+D800]",
        "suggest": "示例: 代码点为 [U+0061, U+D800] 的切片的 `\"a\\u{D800}\"`",
        "translate": ""
    },
    {
        "source": "Creates a WTF-8 slice from a UTF-8 `&str` slice.",
        "suggest": "从 UTF-8 `&str` 切片创建 WTF-8 切片。",
        "translate": ""
    },
    {
        "source": "Creates a WTF-8 slice from a WTF-8 byte slice.",
        "suggest": "从 WTF-8 字节切片创建 WTF-8 切片。",
        "translate": ""
    },
    {
        "source": "Since the byte slice is not checked for valid WTF-8, this functions is marked unsafe.",
        "suggest": "由于未检查字节切片的有效 WTF-8，因此将该函数标记为不安全。",
        "translate": ""
    },
    {
        "source": "Creates a mutable WTF-8 slice from a mutable WTF-8 byte slice.",
        "suggest": "从可变 WTF-8 字节切片创建可变 WTF-8 切片。",
        "translate": ""
    },
    {
        "source": "Returns the length, in WTF-8 bytes.",
        "suggest": "返回长度，以 WTF-8 字节为单位。",
        "translate": ""
    },
    {
        "source": "Returns the code point at `position` if it is in the ASCII range, or `b'\\xFF' otherwise.",
        "suggest": "如果它在 ASCII 范围内，则返回 `position` 处的代码点，否则返回 'b'\\xFF'。",
        "translate": ""
    },
    {
        "source": "Panics if `position` is beyond the end of the string.",
        "suggest": "如果 `position` 超出字符串的末尾，则为 Panics。",
        "translate": ""
    },
    {
        "source": "Returns an iterator for the string’s code points.",
        "suggest": "返回字符串的代码点的迭代器。",
        "translate": ""
    },
    {
        "source": "Tries to convert the string to UTF-8 and return a `&str` slice.",
        "suggest": "尝试将字符串转换为 UTF-8 并返回 `&str` 切片。",
        "translate": ""
    },
    {
        "source": "Returns `None` if the string contains surrogates.",
        "suggest": "如果字符串包含代理，则返回 `None`。",
        "translate": ""
    },
    {
        "source": "Well-formed WTF-8 is also well-formed UTF-8 if and only if it contains no surrogate.",
        "suggest": "格式良好的 WTF-8 且仅当不包含替代项时才是格式良好的 UTF-8。",
        "translate": ""
    },
    {
        "source": "Lossily converts the string to UTF-8.",
        "suggest": "将字符串错误地转换为 UTF-8。",
        "translate": ""
    },
    {
        "source": "Returns a UTF-8 `&str` slice if the contents are well-formed in UTF-8.",
        "suggest": "如果内容在 UTF-8 中格式正确，则返回 UTF-8 `&str` 切片。",
        "translate": ""
    },
    {
        "source": "Surrogates are replaced with `\"\\u{FFFD}\"` (the replacement character “”).",
        "suggest": "代理替换为 `\"\\u{FFFD}\"` (替换字符 ``)。",
        "translate": ""
    },
    {
        "source": "This only copies the data if necessary (if it contains any surrogate).",
        "suggest": "仅在必要时复制数据 (如果它包含任何替代)。",
        "translate": ""
    },
    {
        "source": "Converts the WTF-8 string to potentially ill-formed UTF-16 and return an iterator of 16-bit code units.",
        "suggest": "将 WTF-8 字符串转换为可能格式不正确的 UTF-16，并返回一个 16 位代码单元的迭代器。",
        "translate": ""
    },
    {
        "source": "This is lossless:",
        "suggest": "这是无损的:",
        "translate": ""
    },
    {
        "source": "calling `Wtf8Buf::from_ill_formed_utf16` on the resulting code units would always return the original WTF-8 string.",
        "suggest": "在结果代码单元上调用 `Wtf8Buf::from_ill_formed_utf16` 将始终返回原始 WTF-8 字符串。",
        "translate": ""
    },
    {
        "source": "Boxes this `Wtf8`.",
        "suggest": "`Wtf8` 的 Boxes。",
        "translate": ""
    },
    {
        "source": "Creates a boxed, empty `Wtf8`.",
        "suggest": "创建一个 boxed，空 `Wtf8`。",
        "translate": ""
    },
    {
        "source": "Returns a slice of the given string for the byte range [`begin`..`end`).",
        "suggest": "返回给定字符串在字节范围 [`begin ...`end`) 中的片段。",
        "translate": ""
    },
    {
        "source": "Panics when `begin` and `end` do not point to code point boundaries, or point beyond the end of the string.",
        "suggest": "当 `begin` 和 `end` 不指向代码点边界或指向字符串末尾时，则为 Panics。",
        "translate": ""
    },
    {
        "source": "is_code_point_boundary checks that the index is in [0, .len()]",
        "suggest": "is_code_point_boundary 检查索引是否在 [0, .len()] 中",
        "translate": ""
    },
    {
        "source": "Returns a slice of the given string from byte `begin` to its end.",
        "suggest": "返回给定字符串从字节 `begin` 到结尾的片段。",
        "translate": ""
    },
    {
        "source": "Panics when `begin` is not at a code point boundary, or is beyond the end of the string.",
        "suggest": "当 `begin` 不在代码点边界或不在字符串末尾时，则为 Panics。",
        "translate": ""
    },
    {
        "source": "Returns a slice of the given string from its beginning to byte `end`.",
        "suggest": "返回给定字符串从其开头到字节 `end` 的片段。",
        "translate": ""
    },
    {
        "source": "Panics when `end` is not at a code point boundary, or is beyond the end of the string.",
        "suggest": "当 `end` 不在代码点边界或不在字符串末尾时，则为 Panics。",
        "translate": ""
    },
    {
        "source": "The first byte is assumed to be 0xED",
        "suggest": "假定第一个字节为 0xED",
        "translate": ""
    },
    {
        "source": "Copied from core::str::StrPrelude::is_char_boundary",
        "suggest": "从 core::str::StrPrelude::is_char_boundary 复制",
        "translate": ""
    },
    {
        "source": "Copied from core::str::raw::slice_unchecked",
        "suggest": "从 core::str::raw::slice_unchecked 复制",
        "translate": ""
    },
    {
        "source": "memory layout of an &[u8] and &Wtf8 are the same",
        "suggest": "&[u8] and &Wtf8 的内存布局相同",
        "translate": ""
    },
    {
        "source": "Copied from core::str::raw::slice_error_fail",
        "suggest": "从 core::str::raw::slice_error_fail 复制",
        "translate": ""
    },
    {
        "source": "Iterator for the code points of a WTF-8 string.",
        "suggest": "WTF-8 字符串的代码点的迭代器。",
        "translate": ""
    },
    {
        "source": "Created with the method `.code_points()`.",
        "suggest": "使用方法 `.code_points()` 创建。",
        "translate": ""
    },
    {
        "source": "Generates a wide character sequence for potentially ill-formed UTF-16.",
        "suggest": "为潜在的格式不正确的 UTF-16 生成宽字符序列。",
        "translate": ""
    },
    {
        "source": "Copied from libunicode/u_str.rs",
        "suggest": "从 libunicode/u_str.rs 复制",
        "translate": ""
    },
    {
        "source": "every code point gets either one u16 or two u16, so this iterator is between 1 or 2 times as long as the underlying iterator.",
        "suggest": "每个代码点获得一个 u16 或两个 u16，因此此迭代器的长度是基础迭代器的 1 到 2 倍。",
        "translate": ""
    },
    {
        "source": "Returns the number of hardware threads available to the program.",
        "suggest": "返回程序可用的硬件线程数。",
        "translate": ""
    },
    {
        "source": "This value should be considered only a hint.",
        "suggest": "此值应仅视为提示。",
        "translate": ""
    },
    {
        "source": "If interpreted as the number of actual hardware threads, it may undercount on Windows systems with more than 64 hardware threads.",
        "suggest": "如果将其解释为实际的硬件线程数，则在具有 64 个以上的硬件线程的 Windows 系统上，它可能会被低估。",
        "translate": ""
    },
    {
        "source": "If interpreted as the available concurrency for that process, it may overcount on Windows systems when limited by a process wide affinity mask or job object limitations, and it may overcount on Linux systems when limited by a process wide affinity mask or affected by cgroups limits.",
        "suggest": "如果将其解释为该进程的可用并发性，则在受进程范围的亲和力掩码或作业 object 限制的情况下，它可能在 Windows 系统上计数过多，而在受到进程范围的亲和力掩码的限制或 cgroups 限制的影响下，它在 Linux 系统上可能计数过多。",
        "translate": ""
    },
    {
        "source": "If the number of hardware threads is not known for the target platform.",
        "suggest": "目标平台的硬件线程数是否未知。",
        "translate": ""
    },
    {
        "source": "The process lacks permissions to view the number of hardware threads available.",
        "suggest": "该进程缺乏查看可用硬件线程数的权限。",
        "translate": ""
    },
    {
        "source": "Fallback approach in case of errors or no hardware threads.",
        "suggest": "在出现错误或没有硬件线程的情况下的后备方法。",
        "translate": ""
    },
    {
        "source": "Handle errors if any.",
        "suggest": "处理错误 (如果有)。",
        "translate": ""
    },
    {
        "source": "implement on vxWorks, Redox, HermitCore, Haiku, l4re",
        "suggest": "在 vxWorks，Redox，HermitCore，Haiku，l4re 上实现",
        "translate": ""
    },
    {
        "source": "Note that this test will deadlock if TLS destructors aren't run (this requires the destructor to be run to pass the test).",
        "suggest": "请注意，如果未运行 TLS 析构函数，则此测试将死锁 (这需要运行析构函数才能通过测试)。",
        "translate": ""
    },
    {
        "source": "each thread starts out with the initial value of 1",
        "suggest": "每个线程以 1 的初始值开始",
        "translate": ""
    },
    {
        "source": "wait for the thread to complete and bail out on panic",
        "suggest": "等待线程完成并在 panic 上退出",
        "translate": ""
    },
    {
        "source": "we retain our original value of 2 despite the child thread",
        "suggest": "尽管有子线程，我们仍保留原始值 2",
        "translate": ""
    },
    {
        "source": "Thread local storage",
        "suggest": "线程本地存储",
        "translate": ""
    },
    {
        "source": "A thread local storage key which owns its contents.",
        "suggest": "拥有其内容的线程本地存储密钥。",
        "translate": ""
    },
    {
        "source": "This key uses the fastest possible implementation available to it for the target platform.",
        "suggest": "该密钥使用可用于目标平台的最快速度的实现。",
        "translate": ""
    },
    {
        "source": "It is instantiated with the [`thread_local!`] macro and the primary method is the [`with`] method.",
        "suggest": "它用 [`thread_local!`] 宏实例化，主要方法是 [`with`] 方法。",
        "translate": ""
    },
    {
        "source": "The [`with`] method yields a reference to the contained value which cannot be sent across threads or escape the given closure.",
        "suggest": "[`with`] 方法产生对所包含值的引用，该引用不能跨线程发送或转义给定的闭包。",
        "translate": ""
    },
    {
        "source": "Initialization and Destruction",
        "suggest": "初始化与销毁",
        "translate": ""
    },
    {
        "source": "Initialization is dynamically performed on the first call to [`with`] within a thread, and values that implement [`Drop`] get destructed when a thread exits.",
        "suggest": "初始化是在线程中对 [`with`] 的第一次调用中动态执行的，并且当线程退出时，实现 [`Drop`] 的值将被销毁。",
        "translate": ""
    },
    {
        "source": "Some caveats apply, which are explained below.",
        "suggest": "一些注意事项适用，下面将进行说明。",
        "translate": ""
    },
    {
        "source": "A `LocalKey`'s initializer cannot recursively depend on itself, and using a `LocalKey` in this way will cause the initializer to infinitely recurse on the first call to `with`.",
        "suggest": "LocalKey 的初始化不能递归地依赖于它自己，以这种方式使用 `LocalKey` 会使初始化在第一次调用 `with` 时无限递归。",
        "translate": ""
    },
    {
        "source": "Note that a \"best effort\" is made to ensure that destructors for types stored in thread local storage are run, but not all platforms can guarantee that destructors will be run for all types in thread local storage.",
        "suggest": "请注意，使用 \"best effort\" 可以确保运行线程本地存储中存储的类型的析构函数，但并非所有平台都可以保证将针对线程本地存储中的所有类型运行析构函数。",
        "translate": ""
    },
    {
        "source": "For example, there are a number of known caveats where destructors are not run:",
        "suggest": "例如，有许多已知的警告未运行析构函数:",
        "translate": ""
    },
    {
        "source": "On Unix systems when pthread-based TLS is being used, destructors will not be run for TLS values on the main thread when it exits.",
        "suggest": "在 Unix 系统上，当使用基于 pthread 的 TLS 时，主线程退出时，不会为主线程上的 TLS 值运行析构函数。",
        "translate": ""
    },
    {
        "source": "Note that the application will exit immediately after the main thread exits as well.",
        "suggest": "请注意，应用程序也将在主线程退出后立即退出。",
        "translate": ""
    },
    {
        "source": "On all platforms it's possible for TLS to re-initialize other TLS slots during destruction.",
        "suggest": "在所有平台上，TLS 都有可能在销毁期间重新初始化其他 TLS 插槽。",
        "translate": ""
    },
    {
        "source": "Some platforms ensure that this cannot happen infinitely by preventing re-initialization of any slot that has been destroyed, but not all platforms have this guard.",
        "suggest": "某些平台通过防止重新初始化已销毁的任何插槽来确保不会无限发生这种情况，但并非所有平台都具有此保护措施。",
        "translate": ""
    },
    {
        "source": "Those platforms that do not guard typically have a synthetic limit after which point no more destructors are run.",
        "suggest": "那些不受约束的平台通常具有综合限制，在此之后，将不再运行析构函数。",
        "translate": ""
    },
    {
        "source": "This outer `LocalKey<T>` type is what's going to be stored in statics, but actual data inside will sometimes be tagged with #[thread_local].",
        "suggest": "这种外部 `LocalKey<T>` 类型将存储在静态变量中，但是内部的实际数据有时会用 #[thread_local] 标记。",
        "translate": ""
    },
    {
        "source": "It's not valid for a true static to reference a #[thread_local] static, so we get around that by exposing an accessor through a layer of function indirection (this thunk).",
        "suggest": "引用 #[thread_local] 静态变量对真实的静态变量是无效的，因此我们通过在函数间接层 (此重击) 中公开一个访问器来解决此问题。",
        "translate": ""
    },
    {
        "source": "Note that the thunk is itself unsafe because the returned lifetime of the slot where data lives, `'static`, is not actually valid.",
        "suggest": "请注意，该重击本身是不安全的，因为返回的数据所在的插槽 `'static` 的生命周期实际上是无效的。",
        "translate": ""
    },
    {
        "source": "The lifetime here is actually slightly shorter than the currently running thread!",
        "suggest": "此处的生命周期实际上比当前正在运行的线程短一些!",
        "translate": ""
    },
    {
        "source": "Although this is an extra layer of indirection, it should in theory be trivially devirtualizable by LLVM because the value of `inner` never changes and the constant should be readonly within a crate.",
        "suggest": "尽管这是一个间接的额外层，但是从理论上讲，LLVM 应该可以对其进行虚拟化，因为 `inner` 的值永远不会更改，并且常量在 crate 内应为只读。",
        "translate": ""
    },
    {
        "source": "This mainly only runs into problems when TLS statics are exported across crates.",
        "suggest": "仅当在 crates 上导出 TLS 静态信息时，这才主要遇到问题。",
        "translate": ""
    },
    {
        "source": "Declare a new thread local storage key of type [`std::thread::LocalKey`].",
        "suggest": "声明一个新的 [`std::thread::LocalKey`] 类型的线程本地存储密钥。",
        "translate": ""
    },
    {
        "source": "The macro wraps any number of static declarations and makes them thread local.",
        "suggest": "宏可以包装任意数量的静态声明，并使它们成为局部线程。",
        "translate": ""
    },
    {
        "source": "Publicity and attributes for each static are allowed.",
        "suggest": "允许每个静态的公开和属性。",
        "translate": ""
    },
    {
        "source": "See [`LocalKey` documentation][`std::thread::LocalKey`] for more information.",
        "suggest": "有关更多信息，请参见 [`LocalKey` 文档][`std::thread::LocalKey`]。",
        "translate": ""
    },
    {
        "source": "empty (base case for the recursion)",
        "suggest": "空 (递归的基本情况)",
        "translate": ""
    },
    {
        "source": "process multiple declarations",
        "suggest": "处理多个声明",
        "translate": ""
    },
    {
        "source": "handle a single declaration",
        "suggest": "处理一个声明",
        "translate": ""
    },
    {
        "source": "remove the #[allow(...)] marker when macros don't raise warning for missing/extraneous unsafe blocks anymore.",
        "suggest": "当宏不再对丢失/额外不安全块发出警告时，请删除 #[allow(...)] 标记。",
        "translate": ""
    },
    {
        "source": "An error returned by [`LocalKey::try_with`](struct.LocalKey.html#method.try_with).",
        "suggest": "[`LocalKey::try_with`](struct.LocalKey.html#method.try_with) 返回的错误。",
        "translate": ""
    },
    {
        "source": "Acquires a reference to the value in this TLS key.",
        "suggest": "获取对此 TLS 密钥中的值的引用。",
        "translate": ""
    },
    {
        "source": "This will lazily initialize the value if this thread has not referenced this key yet.",
        "suggest": "如果此线程尚未引用此键，则将延迟地初始化该值。",
        "translate": ""
    },
    {
        "source": "This function will `panic!()` if the key currently has its destructor running, and it **may** panic if the destructor has previously been run for this thread.",
        "suggest": "如果该键当前正在运行其析构函数，则此函数将为 `panic!()`; 如果先前已为此线程运行了析构函数，则它可能 panic。",
        "translate": ""
    },
    {
        "source": "If the key has been destroyed (which may happen if this is called in a destructor), this function will return an [`AccessError`].",
        "suggest": "如果密钥已被销毁 (如果在析构函数中调用它可能会发生这种情况)，此函数将返回 [`AccessError`]。",
        "translate": ""
    },
    {
        "source": "This function will still `panic!()` if the key is uninitialized and the key's initializer panics.",
        "suggest": "如果未初始化密钥并且密钥的初始化 panics，则此函数仍将 `panic!()`。",
        "translate": ""
    },
    {
        "source": "The caller must ensure no reference is ever handed out to the inner cell nor mutable reference to the Option<T> inside said cell.",
        "suggest": "调用者必须确保绝不向内部单元传递引用，也不要向所述单元内部的 Option<T> 传递引用。",
        "translate": ""
    },
    {
        "source": "This make it safe to hand a reference, though the lifetime of 'static is itself unsafe, making the get method unsafe.",
        "suggest": "尽管'static 的生命周期本身是不安全的，这使 get 方法变得不安全，但这使引用变得安全。",
        "translate": ""
    },
    {
        "source": "The caller must ensure that no reference is active: this method needs unique access.",
        "suggest": "调用者必须确保没有激活引用: 此方法需要唯一的访问权限。",
        "translate": ""
    },
    {
        "source": "Execute the initialization up front, *then* move it into our slot, just in case initialization fails.",
        "suggest": "预先执行初始化，然后将其移动到我们的插槽中，以防万一初始化失败。",
        "translate": ""
    },
    {
        "source": "note that this can in theory just be `*ptr = Some(value)`, but due to the compiler will currently codegen that pattern with something like:",
        "suggest": "请注意，从理论上讲，它只能是 `*ptr = Some(value)`，但是由于编译器当前将使用类似以下内容的代码生成该模式:",
        "translate": ""
    },
    {
        "source": "Due to this pattern it's possible for the destructor of the value in `ptr` (e.g., if this is being recursively initialized) to re-access TLS, in which case there will be a `&` and `&mut` pointer to the same value (an aliasing violation).",
        "suggest": "由于这种模式，`ptr` 中的值的析构函数有可能重新访问 TLS (例如，如果正在递归初始化)，在这种情况下，将有一个指向相同值的 `&` 和 `&mut` 指针 (违反别名)。",
        "translate": ""
    },
    {
        "source": "To avoid setting the \"I'm running a destructor\" flag we just use `mem::replace` which should sequence the operations a little differently and make this safe to call.",
        "suggest": "为了避免设置 \"I'm running a destructor\" 标志，我们只使用 `mem::replace`，它应该对操作的顺序稍有不同，从而可以安全地进行调用。",
        "translate": ""
    },
    {
        "source": "The precondition also ensures that we are the only one accessing `self` at the moment so replacing is fine.",
        "suggest": "前提条件还确保了我们是目前唯一访问 `self` 的计算机，因此可以很好地进行替换。",
        "translate": ""
    },
    {
        "source": "With the call to `mem::replace` it is guaranteed there is a `Some` behind `ptr`, not a `None` so `unreachable_unchecked` will never be reached.",
        "suggest": "通过调用 `mem::replace`，可以确保 `ptr` 后面有一个 `Some`，而不是 `None`，因此将永远无法到达 `unreachable_unchecked`。",
        "translate": ""
    },
    {
        "source": "After storing `Some` we want to get a reference to the contents of what we just stored.",
        "suggest": "存储 `Some` 之后，我们想对刚刚存储的内容进行引用。",
        "translate": ""
    },
    {
        "source": "While we could use `unwrap` here and it should always work it empirically doesn't seem to always get optimized away, which means that using something like `try_with` can pull in panicking code and cause a large size bloat.",
        "suggest": "尽管我们可以在这里使用 `unwrap`，并且它应该始终有效，但是根据经验，似乎并没有总是对其进行优化，这意味着使用 `try_with` 之类的东西可能会拉入恐慌代码并造成较大的膨胀。",
        "translate": ""
    },
    {
        "source": "The other methods hand out references while taking &self.",
        "suggest": "其他方法在取 &self 时分发引用。",
        "translate": ""
    },
    {
        "source": "As such, callers of this method must ensure no `&` and `&mut` are available and used at the same time.",
        "suggest": "因此，此方法的调用者必须确保没有 `&` 和 `&mut` 同时可用和使用。",
        "translate": ""
    },
    {
        "source": "See doc comment for this method.",
        "suggest": "有关此方法，请参见文档注释。",
        "translate": ""
    },
    {
        "source": "On some platforms like wasm32 there's no threads, so no need to generate thread locals and we can instead just use plain statics!",
        "suggest": "在诸如 wasm32 的某些平台上，没有线程，因此无需生成线程本地变量，而我们可以只使用纯静态变量!",
        "translate": ""
    },
    {
        "source": "This data structure has been carefully constructed so that the fast path only contains one branch on x86.",
        "suggest": "此数据结构体经过精心构造，因此快速路径仅包含 x86 上的一个分支。",
        "translate": ""
    },
    {
        "source": "That optimization is necessary to avoid duplicated tls lookups on OSX.",
        "suggest": "为了避免在 OSX 上重复查找 tls，必须进行优化。",
        "translate": ""
    },
    {
        "source": "LLVM issue:",
        "suggest": "LLVM 问题:",
        "translate": ""
    },
    {
        "source": "If `LazyKeyInner::get` returns `None`, that indicates either:",
        "suggest": "如果 `LazyKeyInner::get` 返回 `None`，则表明:",
        "translate": ""
    },
    {
        "source": "The value has never been initialized",
        "suggest": "该值从未初始化",
        "translate": ""
    },
    {
        "source": "The value is being recursively initialized",
        "suggest": "该值正在递归初始化",
        "translate": ""
    },
    {
        "source": "The value has already been destroyed or is being destroyed To determine which kind of `None`, check `dtor_state`.",
        "suggest": "该值已被销毁或正在被销毁。要确定哪种 `None`，请检查 `dtor_state`。",
        "translate": ""
    },
    {
        "source": "This is very optimizer friendly for the fast path - initialized but not yet dropped.",
        "suggest": "这对快速路径非常优化，它非常友好 - 已初始化但尚未丢弃。",
        "translate": ""
    },
    {
        "source": "Metadata to keep track of the state of the destructor.",
        "suggest": "跟踪析构函数状态的元数据。",
        "translate": ""
    },
    {
        "source": "Remember that this variable is thread-local, not global.",
        "suggest": "请记住，此变量是线程局部的，而不是局部的。",
        "translate": ""
    },
    {
        "source": "See the definitions of `LazyKeyInner::get` and `try_initialize` for more informations.",
        "suggest": "有关更多信息，请参见 `LazyKeyInner::get` 和 `try_initialize` 的定义。",
        "translate": ""
    },
    {
        "source": "The caller must ensure no mutable references are ever active to the inner cell or the inner T when this is called.",
        "suggest": "调用方必须确保在调用此内部 cell 或内部 T 时永远不会对它起作用。",
        "translate": ""
    },
    {
        "source": "The `try_initialize` is dependant on the passed `init` function for this.",
        "suggest": "`try_initialize` 为此而依赖于传递的 `init` 函数。",
        "translate": ""
    },
    {
        "source": "is only called once per fast thread local variable, except in corner cases where thread_local dtors reference other thread_local's, or it is being recursively initialized.",
        "suggest": "每个快速线程局部变量仅被调用一次，除非在 thread_local dtors 引用其他 thread_local 或正在递归初始化的极端情况下。",
        "translate": ""
    },
    {
        "source": "Inlining this function can cause two `tlv_get_addr` calls to be performed for every call to `Key::get`.",
        "suggest": "内联此函数可能导致对 `Key::get` 的每次调用都要执行两个 `tlv_get_addr` 调用。",
        "translate": ""
    },
    {
        "source": "See comment above (this function doc).",
        "suggest": "请参见上面的注释 (此函数文档)。",
        "translate": ""
    },
    {
        "source": "See comment above (his function doc).",
        "suggest": "请参见上面的注释 (他的函数 doc)。",
        "translate": ""
    },
    {
        "source": "dtor registration happens before initialization.",
        "suggest": "dtor 注册发生在初始化之前。",
        "translate": ""
    },
    {
        "source": "Passing `self` as a pointer while using `destroy_value<T>` is safe because the function will build a pointer to a Key<T>, which is the type of self and so find the correct size.",
        "suggest": "使用 `destroy_value<T>` 时将 `self` 作为指针传递是安全的，因为函数将建立指向 Key<T> 的指针，Key<T> 是 self 的类型，因此可以找到正确的大小。",
        "translate": ""
    },
    {
        "source": "recursively initialized",
        "suggest": "递归初始化",
        "translate": ""
    },
    {
        "source": "The pointer `ptr` has been built just above and comes from `try_register_dtor` where it is originally a Key<T> coming from `self`, making it non-NUL and of the correct type.",
        "suggest": "指针 `ptr` 刚好在上面构建，并且来自 `try_register_dtor`，它最初是 `self` 的 Key<T>，使其成为非 NUL 且类型正确。",
        "translate": ""
    },
    {
        "source": "Right before we run the user destructor be sure to set the `Option<T>` to `None`, and `dtor_state` to `RunningOrHasRun`.",
        "suggest": "在运行用户析构函数之前，请确保将 `Option<T>` 设置为 `None`，将 `dtor_state` 设置为 `RunningOrHasRun`。",
        "translate": ""
    },
    {
        "source": "This causes future calls to `get` to run `try_initialize_drop` again, which will now fail, and return `None`.",
        "suggest": "这将导致对 `get` 的 future 调用再次运行 `try_initialize_drop`，该操作现在将失败，并返回 `None`。",
        "translate": ""
    },
    {
        "source": "OS-TLS key that we'll use to key off.",
        "suggest": "我们将用于注销的 OS-TLS 密钥。",
        "translate": ""
    },
    {
        "source": "It is a requirement for the caller to ensure that no mutable reference is active when this method is called.",
        "suggest": "要求调用者确保在调用此方法时没有激活任何可变引用。",
        "translate": ""
    },
    {
        "source": "See the documentation for this method.",
        "suggest": "请参见此方法的文档。",
        "translate": ""
    },
    {
        "source": "the check ensured the pointer is safe (its destructor is not running) + it is coming from a trusted source (self).",
        "suggest": "检查确保指针是安全的 (其析构函数未运行) + 它来自受信任的源 (self)。",
        "translate": ""
    },
    {
        "source": "At this point we are sure we have no value and so initializing (or trying to) is safe.",
        "suggest": "在这一点上，我们确定我们没有任何值，因此初始化 (或尝试进行) 是安全的。",
        "translate": ""
    },
    {
        "source": "is only called once per os thread local variable, except in corner cases where thread_local dtors reference other thread_local's, or it is being recursively initialized.",
        "suggest": "每个 os 线程局部变量仅被调用一次，除非在 thread_local dtors 引用其他 thread_local 或正在递归初始化的特殊情况下。",
        "translate": ""
    },
    {
        "source": "No mutable references are ever handed out meaning getting the value is ok.",
        "suggest": "没有派发任何可变引用，这意味着获得值是可以的。",
        "translate": ""
    },
    {
        "source": "destructor is running",
        "suggest": "析构函数正在运行",
        "translate": ""
    },
    {
        "source": "If the lookup returned null, we haven't initialized our own local copy, so do that now.",
        "suggest": "如果查找返回 null，则表明我们尚未初始化自己的本地副本，因此请立即进行初始化。",
        "translate": ""
    },
    {
        "source": "At this point we are sure there is no value inside ptr so setting it will not affect anyone else.",
        "suggest": "在这一点上，我们确定 ptr 内没有任何值，因此设置它不会影响任何其他人。",
        "translate": ""
    },
    {
        "source": "recursive initialization",
        "suggest": "递归初始化",
        "translate": ""
    },
    {
        "source": "ptr has been ensured as non-NUL just above an so can be dereferenced safely.",
        "suggest": "已确保 ptr 为非 NUL 且正好位于 a 以上，因此可以安全地解引用。",
        "translate": ""
    },
    {
        "source": "The OS TLS ensures that this key contains a NULL value when this destructor starts to run.",
        "suggest": "当此析构函数开始运行时，操作系统 TLS 确保该密钥包含 NULL 值。",
        "translate": ""
    },
    {
        "source": "We set it back to a sentinel value of 1 to ensure that any future calls to `get` for this thread will return `None`.",
        "suggest": "我们将其设置回哨兵值 1，以确保对该线程的 `get` 的任何 future 调用都将返回 `None`。",
        "translate": ""
    },
    {
        "source": "Note that to prevent an infinite loop we reset it back to null right before we return from the destructor ourselves.",
        "suggest": "请注意，为防止无限循环，我们在自己从析构函数返回之前就将其重置为 null。",
        "translate": ""
    },
    {
        "source": "some work here",
        "suggest": "这里一些工作",
        "translate": ""
    },
    {
        "source": "thread code",
        "suggest": "线程代码",
        "translate": ""
    },
    {
        "source": "caller has to ensure `join()` is called, otherwise it is possible to access freed memory if `x` gets dropped before the thread closure is executed!",
        "suggest": "调用者必须确保已调用 `join()`，否则，如果在执行线程闭包之前 `x` 被丢弃，则可以访问释放的内存!",
        "translate": ""
    },
    {
        "source": "Some expensive computation.",
        "suggest": "一些昂贵的计算。",
        "translate": ""
    },
    {
        "source": "Let's sleep for 2 seconds:",
        "suggest": "让我们睡 2 秒钟:",
        "translate": ""
    },
    {
        "source": "We want to wait until the flag is set.",
        "suggest": "我们要等到标志被设置。",
        "translate": ""
    },
    {
        "source": "We *could* just spin, but using park/unpark is more efficient.",
        "suggest": "我们可以旋转，但是使用 park/unpark 效率更高。",
        "translate": ""
    },
    {
        "source": "We *could* get here spuriously, i.e., way before the 10ms below are over!",
        "suggest": "我们可以伪装地到达这里，即在下面的 10ms 结束之前!",
        "translate": ""
    },
    {
        "source": "But that is no problem, we are in a loop until the flag is set anyway.",
        "suggest": "但这没问题，我们一直处于循环状态，直到仍然设置了标志。",
        "translate": ""
    },
    {
        "source": "Let some time pass for the thread to be spawned.",
        "suggest": "花费一些时间来生成线程。",
        "translate": ""
    },
    {
        "source": "Set the flag, and let the thread wake up.",
        "suggest": "设置标志，并让线程唤醒。",
        "translate": ""
    },
    {
        "source": "There is no race condition here, if `unpark` happens first, `park` will return immediately.",
        "suggest": "这里没有竞态条件，如果 `unpark` 首先出现，则 `park` 将立即返回。",
        "translate": ""
    },
    {
        "source": "Hence there is no risk of a deadlock.",
        "suggest": "因此，没有死锁的风险。",
        "translate": ""
    },
    {
        "source": "Here we sleep to make sure that the first thread returns before.",
        "suggest": "在这里我们睡觉以确保第一个线程在此之前返回。",
        "translate": ""
    },
    {
        "source": "This will be called, even though the JoinHandle is dropped.",
        "suggest": "即使 JoinHandle 被丢弃，也将调用它。",
        "translate": ""
    },
    {
        "source": "We make sure that the new thread has time to run, before the main thread returns.",
        "suggest": "我们确保在主线程返回之前，新线程有时间运行。",
        "translate": ""
    },
    {
        "source": "Native threads.",
        "suggest": "原生线程。",
        "translate": ""
    },
    {
        "source": "The threading model",
        "suggest": "线程模型",
        "translate": ""
    },
    {
        "source": "An executing Rust program consists of a collection of native OS threads, each with their own stack and local state.",
        "suggest": "一个正在执行的 Rust 程序由一组原生操作系统线程组成​​，每个线程都有自己的栈和本地状态。",
        "translate": ""
    },
    {
        "source": "Threads can be named, and provide some built-in support for low-level synchronization.",
        "suggest": "线程可以被命名，并为底层同步提供一些内置支持。",
        "translate": ""
    },
    {
        "source": "Communication between threads can be done through [channels], Rust's message-passing types, along with [other forms of thread synchronization](../../std/sync/index.html) and shared-memory data structures.",
        "suggest": "线程之间的通信可以通过 [channels]、Rust 的消息传递类型、以及 [其他形式的线程同步](../../std/sync/index.html) 和共享内存数据结构来完成。",
        "translate": ""
    },
    {
        "source": "In particular, types that are guaranteed to be threadsafe are easily shared between threads using the atomically-reference-counted container,",
        "suggest": "特别是，保证线程安全的类型很容易在使用原子引用计数容器的线程之间共享，",
        "translate": ""
    },
    {
        "source": "Fatal logic errors in Rust cause *thread panic*, during which a thread will unwind the stack, running destructors and freeing owned resources.",
        "suggest": "Rust 中的致命逻辑错误导致 *线程 panic*，在此期间，线程将展开栈，运行析构函数并释放所拥有的资源。",
        "translate": ""
    },
    {
        "source": "While not meant as a 'try/catch' mechanism, panics in Rust can nonetheless be caught (unless compiling with `panic=abort`) with [`catch_unwind`](../../std/panic/fn.catch_unwind.html) and recovered from, or alternatively be resumed with [`resume_unwind`](../../std/panic/fn.resume_unwind.html).",
        "suggest": "尽管不是 'try/catch' 机制，但仍可以使用 [`catch_unwind`](../../std/panic/fn.catch_unwind.html) 捕获 Rust 中的 panics (除非使用 `panic=abort` 进行编译) 并从中恢复，或者使用 [`resume_unwind`](../../std/panic/fn.resume_unwind.html) 恢复。",
        "translate": ""
    },
    {
        "source": "If the panic is not caught the thread will exit, but the panic may optionally be detected from a different thread with [`join`].",
        "suggest": "如果未捕获到 panic，则线程将退出，但是可以选择使用 [`join`] 从其他线程中检测到 panic。",
        "translate": ""
    },
    {
        "source": "If the main thread panics without the panic being caught, the application will exit with a non-zero exit code.",
        "suggest": "如果主线程 panic 而没有捕获 panic，应用程序将以非零退出码退出。",
        "translate": ""
    },
    {
        "source": "When the main thread of a Rust program terminates, the entire program shuts down, even if other threads are still running.",
        "suggest": "当 Rust 程序的主线程终止时，整个程序将关闭，即使其他线程仍在运行也不例外。",
        "translate": ""
    },
    {
        "source": "However, this module provides convenient facilities for automatically waiting for the termination of a child thread (i.e., join).",
        "suggest": "但是，该模块为自动等待子线程的终止 (即 join) 提供了便利的功能。",
        "translate": ""
    },
    {
        "source": "Spawning a thread",
        "suggest": "生成一个线程",
        "translate": ""
    },
    {
        "source": "A new thread can be spawned using the [`thread::spawn`][`spawn`] function:",
        "suggest": "可以使用 [`thread::spawn`][`spawn`] 函数来生成一个新线程:",
        "translate": ""
    },
    {
        "source": "In this example, the spawned thread is \"detached\" from the current thread.",
        "suggest": "在这个例子中，衍生的线程是从当前线程分离出来的。",
        "translate": ""
    },
    {
        "source": "This means that it can outlive its parent (the thread that spawned it), unless this parent is the main thread.",
        "suggest": "这意味着它可以比它的父线程 (产生它的线程) 活得长，除非这个父线程是主线程。",
        "translate": ""
    },
    {
        "source": "The parent thread can also wait on the completion of the child thread;",
        "suggest": "父线程也可以等待子线程的完成。",
        "translate": ""
    },
    {
        "source": "a call to [`spawn`] produces a [`JoinHandle`], which provides a `join` method for waiting:",
        "suggest": "调用 [`spawn`] 会产生一个 [`JoinHandle`]，它提供了一个用于等待的 `join` 方法:",
        "translate": ""
    },
    {
        "source": "The [`join`] method returns a [`thread::Result`] containing [`Ok`] of the final value produced by the child thread, or [`Err`] of the value given to a call to [`panic!`] if the child panicked.",
        "suggest": "[`join`] 方法返回一个 [`thread::Result`]，其中包含子线程产生的最终值 [`Ok`]，或者如果子进程 panic，则返回给调用 [`panic!`] 的值的 [`Err`]。",
        "translate": ""
    },
    {
        "source": "Configuring threads",
        "suggest": "配置线程",
        "translate": ""
    },
    {
        "source": "A new thread can be configured before it is spawned via the [`Builder`] type, which currently allows you to set the name and stack size for the child thread:",
        "suggest": "一个新线程可以在通过 [`Builder`] 类型生成之前进行配置，它目前允许您设置子线程的名称和堆栈大小:",
        "translate": ""
    },
    {
        "source": "The `Thread` type",
        "suggest": "`Thread` 的类型",
        "translate": ""
    },
    {
        "source": "Threads are represented via the [`Thread`] type, which you can get in one of two ways:",
        "suggest": "线程是通过 [`Thread`] 类型来表示的，您可以通过以下两种方式之一获得该类型:",
        "translate": ""
    },
    {
        "source": "By spawning a new thread, e.g., using the [`thread::spawn`][`spawn`] function, and calling [`thread`][`JoinHandle::thread`] on the [`JoinHandle`].",
        "suggest": "通过生成一个新线程，例如使用 [`thread::spawn`][`spawn`] 函数，并在 [`JoinHandle`] 上调用 [`thread`][`JoinHandle::thread`]。",
        "translate": ""
    },
    {
        "source": "By requesting the current thread, using the [`thread::current`] function.",
        "suggest": "通过使用 [`thread::current`] 函数来请求当前线程。",
        "translate": ""
    },
    {
        "source": "The [`thread::current`] function is available even for threads not spawned by the APIs of this module.",
        "suggest": "[`thread::current`] 函数甚至可用于不是由该模块的 API 生成的线程。",
        "translate": ""
    },
    {
        "source": "Thread-local storage",
        "suggest": "线程本地存储",
        "translate": ""
    },
    {
        "source": "This module also provides an implementation of thread-local storage for Rust programs.",
        "suggest": "该模块还为 Rust 程序提供了线程本地存储的实现。",
        "translate": ""
    },
    {
        "source": "Thread-local storage is a method of storing data into a global variable that each thread in the program will have its own copy of.",
        "suggest": "线程本地存储是一种将数据存储到全局变量的方法，程序中的每个线程都有自己的副本。",
        "translate": ""
    },
    {
        "source": "Threads do not share this data, so accesses do not need to be synchronized.",
        "suggest": "线程不共享此数据，因此不需要同步访问。",
        "translate": ""
    },
    {
        "source": "A thread-local key owns the value it contains and will destroy the value when the thread exits.",
        "suggest": "线程本地键拥有它所包含的值，并在线程退出时销毁该值。",
        "translate": ""
    },
    {
        "source": "It is created with the [`thread_local!`] macro and can contain any value that is `'static` (no borrowed pointers).",
        "suggest": "它是使用 [`thread_local!`] 宏创建的，可以包含 `'static` 的任何值 (没有借用指针)。",
        "translate": ""
    },
    {
        "source": "It provides an accessor function, [`with`], that yields a shared reference to the value to the specified closure.",
        "suggest": "它提供了一个访问器函数 [`with`]，该访问器函数产生对指定闭包的值的共享引用。",
        "translate": ""
    },
    {
        "source": "Thread-local keys allow only shared access to values, as there would be no way to guarantee uniqueness if mutable borrows were allowed.",
        "suggest": "线程本地键只允许共享访问值，因为如果允许可变借用，就无法保证惟一性。",
        "translate": ""
    },
    {
        "source": "Most values will want to make use of some form of **interior mutability** through the [`Cell`] or [`RefCell`] types.",
        "suggest": "大多数值都希望通过 [`Cell`] 或 [`RefCell`] 类型使用某种形式的 **内部可变性**。",
        "translate": ""
    },
    {
        "source": "Naming threads",
        "suggest": "命名线程",
        "translate": ""
    },
    {
        "source": "Threads are able to have associated names for identification purposes.",
        "suggest": "出于识别目的，线程可以有关联的名称。",
        "translate": ""
    },
    {
        "source": "By default, spawned threads are unnamed.",
        "suggest": "默认情况下，生成的线程是未命名的。",
        "translate": ""
    },
    {
        "source": "To specify a name for a thread, build the thread with [`Builder`] and pass the desired thread name to [`Builder::name`].",
        "suggest": "要为线程指定名称，请使用 [`Builder`] 构建该线程，然后将所需的线程名称传递给 [`Builder::name`]。",
        "translate": ""
    },
    {
        "source": "To retrieve the thread name from within the thread, use [`Thread::name`].",
        "suggest": "要从线程内检索线程名，请使用 [`Thread::name`]。",
        "translate": ""
    },
    {
        "source": "A couple examples of where the name of a thread gets used:",
        "suggest": "下面是使用线程名的几个例子:",
        "translate": ""
    },
    {
        "source": "If a panic occurs in a named thread, the thread name will be printed in the panic message.",
        "suggest": "如果在命名线程中出现 panic，则线程名将显示在 panic 消息中。",
        "translate": ""
    },
    {
        "source": "The thread name is provided to the OS where applicable (e.g., `pthread_setname_np` in unix-like platforms).",
        "suggest": "线程名在适用的情况下提供给操作系统 (例如，在类 Unix 平台中为 `pthread_setname_np`)。",
        "translate": ""
    },
    {
        "source": "Stack size",
        "suggest": "栈大小",
        "translate": ""
    },
    {
        "source": "The default stack size for spawned threads is 2 MiB, though this particular stack size is subject to change in the future.",
        "suggest": "衍生线程的默认栈大小为 2 MiB，尽管这个特定的堆栈大小会在将来发生改变。",
        "translate": ""
    },
    {
        "source": "There are two ways to manually specify the stack size for spawned threads:",
        "suggest": "有两种方法可以手动指定衍生线程的栈大小:",
        "translate": ""
    },
    {
        "source": "Build the thread with [`Builder`] and pass the desired stack size to [`Builder::stack_size`].",
        "suggest": "使用 [`Builder`] 构建线程，并将所需的栈大小传递给 [`Builder::stack_size`]。",
        "translate": ""
    },
    {
        "source": "Set the `RUST_MIN_STACK` environment variable to an integer representing the desired stack size (in bytes).",
        "suggest": "将 `RUST_MIN_STACK` 环境变量设置为代表所需栈大小 (以字节为单位) 的整数。",
        "translate": ""
    },
    {
        "source": "Note that setting [`Builder::stack_size`] will override this.",
        "suggest": "请注意，设置 [`Builder::stack_size`] 将覆盖此设置。",
        "translate": ""
    },
    {
        "source": "Note that the stack size of the main thread is *not* determined by Rust.",
        "suggest": "注意，主线程的栈大小不是由 Rust 决定的。",
        "translate": ""
    },
    {
        "source": "The types used by the thread_local!",
        "suggest": "thread_local 使用的类型!",
        "translate": ""
    },
    {
        "source": "macro to access TLS keys.",
        "suggest": "访问 TLS 密钥的宏。",
        "translate": ""
    },
    {
        "source": "Note that there are two types, the \"OS\" type and the \"fast\" type.",
        "suggest": "注意，有两种类型，\"OS\" 类型和 \"fast\" 类型。",
        "translate": ""
    },
    {
        "source": "The OS thread local key type is accessed via platform-specific API calls and is slow, while the fast key type is accessed via code generated via LLVM, where TLS keys are set up by the elf linker.",
        "suggest": "OS 线程本地密钥类型是通过平台特定的 API 调用访问的，速度很慢，而快速密钥类型是通过 LLVM 生成的代码访问的，其中 TLS 密钥是由 elf 链接器设置的。",
        "translate": ""
    },
    {
        "source": "Note that the OS TLS type is always available: on macOS the standard library is compiled with support for older platform versions where fast TLS was not available;",
        "suggest": "请注意，OS TLS 类型始终可用: 在 macOS 上，标准库的编译是对较早的平台版本 (不提供快速 TLS 的支持) 的支持;",
        "translate": ""
    },
    {
        "source": "end-user code is compiled with fast TLS where available, but both are needed.",
        "suggest": "最终用户代码在可用的情况下使用快速 TLS 进行编译，但两者都是必需的。",
        "translate": ""
    },
    {
        "source": "Thread factory, which can be used in order to configure the properties of a new thread.",
        "suggest": "线程工厂，可用于配置新线程的属性。",
        "translate": ""
    },
    {
        "source": "Methods can be chained on it in order to configure it.",
        "suggest": "可以在其上链接方法以对其进行配置。",
        "translate": ""
    },
    {
        "source": "The two configurations available are:",
        "suggest": "有两种配置可供选择:",
        "translate": ""
    },
    {
        "source": "specifies an [associated name for the thread][naming-threads]",
        "suggest": "指定一个 [线程的关联名][naming-threads]",
        "translate": ""
    },
    {
        "source": "specifies the [desired stack size for the thread][stack-size]",
        "suggest": "指定 [线程所需的栈大小][stack-size]",
        "translate": ""
    },
    {
        "source": "The [`spawn`] method will take ownership of the builder and create an [`io::Result`] to the thread handle with the given configuration.",
        "suggest": "[`spawn`] 方法将获取构建器的所有权，并使用给定的配置为线程句柄创建 [`io::Result`]。",
        "translate": ""
    },
    {
        "source": "The [`thread::spawn`] free function uses a `Builder` with default configuration and [`unwrap`]s its return value.",
        "suggest": "[`thread::spawn`] 自由函数使用默认配置的 `Builder`，并返回其值 [`unwrap`]。",
        "translate": ""
    },
    {
        "source": "You may want to use [`spawn`] instead of [`thread::spawn`], when you want to recover from a failure to launch a thread, indeed the free function will panic where the `Builder` method will return a [`io::Result`].",
        "suggest": "当您想从启动线程失败中恢复时，您可能想使用 [`spawn`] 而不是 [`thread::spawn`]，实际上，实际上自由函数会在 `Builder` 方法返回 [`io::Result`] 时 panic。",
        "translate": ""
    },
    {
        "source": "A name for the thread-to-be, for identification in panic messages",
        "suggest": "未来线程的名称，以在 panic 消息中进行标识",
        "translate": ""
    },
    {
        "source": "The size of the stack for the spawned thread in bytes",
        "suggest": "衍生线程的栈大小 (以字节为单位)",
        "translate": ""
    },
    {
        "source": "Generates the base configuration for spawning a thread, from which configuration methods can be chained.",
        "suggest": "生成用于生成线程的基本配置，从中可以链接配置方法。",
        "translate": ""
    },
    {
        "source": "Names the thread-to-be.",
        "suggest": "命名未来线程。",
        "translate": ""
    },
    {
        "source": "Currently the name is used for identification only in panic messages.",
        "suggest": "当前，该名称仅用于 panic 消息中的标识。",
        "translate": ""
    },
    {
        "source": "The name must not contain null bytes (`\\0`).",
        "suggest": "该名称不能包含空字节 (`\\0`)。",
        "translate": ""
    },
    {
        "source": "For more information about named threads, see [this module-level documentation][naming-threads].",
        "suggest": "有关命名线程的更多信息，请参见 [模块级文档][naming-threads]。",
        "translate": ""
    },
    {
        "source": "Sets the size of the stack (in bytes) for the new thread.",
        "suggest": "设置新线程的栈大小 (以字节为单位)。",
        "translate": ""
    },
    {
        "source": "The actual stack size may be greater than this value if the platform specifies a minimal stack size.",
        "suggest": "如果平台指定最小栈大小，则实际栈大小可能大于这个值。",
        "translate": ""
    },
    {
        "source": "For more information about the stack size for threads, see [this module-level documentation][stack-size].",
        "suggest": "有关线程的栈大小的更多信息，请参见 [模块级文档][stack-size]。",
        "translate": ""
    },
    {
        "source": "Spawns a new thread by taking ownership of the `Builder`, and returns an [`io::Result`] to its [`JoinHandle`].",
        "suggest": "通过获取 `Builder` 的所有权产生一个新线程，并向其 [`JoinHandle`] 返回一个 [`io::Result`]。",
        "translate": ""
    },
    {
        "source": "The spawned thread may outlive the caller (unless the caller thread is the main thread; the whole process is terminated when the main thread finishes).",
        "suggest": "衍生的线程可能比调用者活得长 (除非调用者线程是主线程; 当主线程结束时，整个进程将终止)。",
        "translate": ""
    },
    {
        "source": "The join handle can be used to block on termination of the child thread, including recovering its panics.",
        "suggest": "join 句柄可用于阻塞子线程的终止，包括恢复其 panic。",
        "translate": ""
    },
    {
        "source": "For a more complete documentation see [`thread::spawn`][`spawn`].",
        "suggest": "有关更完整的文档，请参见 [`thread::spawn`][`spawn`]。",
        "translate": ""
    },
    {
        "source": "Unlike the [`spawn`] free function, this method yields an [`io::Result`] to capture any failure to create the thread at the OS level.",
        "suggest": "与 [`spawn`] 自由函数不同，此方法产生 [`io::Result`] 来捕获在操作系统级别创建线程的任何失败。",
        "translate": ""
    },
    {
        "source": "Panics if a thread name was set and it contained null bytes.",
        "suggest": "如果设置了线程名称并且它包含空字节，则会出现 panic。",
        "translate": ""
    },
    {
        "source": "Spawns a new thread without any lifetime restrictions by taking ownership of the `Builder`, and returns an [`io::Result`] to its [`JoinHandle`].",
        "suggest": "通过获取 `Builder` 的所有权来产生不受任何生命周期限制的新线程，并将 [`io::Result`] 返回其 [`JoinHandle`]。",
        "translate": ""
    },
    {
        "source": "This method is identical to [`thread::Builder::spawn`][`Builder::spawn`], except for the relaxed lifetime bounds, which render it unsafe.",
        "suggest": "此方法与 [`thread::Builder::spawn`][`Builder::spawn`] 相同，不同之处在于宽松的生命周期界限使其不安全。",
        "translate": ""
    },
    {
        "source": "The caller has to ensure that no references in the supplied thread closure or its return type can outlive the spawned thread's lifetime.",
        "suggest": "调用者必须确保所提供的线程闭包或其返回类型中的引用不能超过新建线程的生命周期。",
        "translate": ""
    },
    {
        "source": "This can be guaranteed in two ways:",
        "suggest": "可以通过两种方式保证这一点:",
        "translate": ""
    },
    {
        "source": "ensure that [`join`][`JoinHandle::join`] is called before any referenced data is dropped",
        "suggest": "确保在丢弃任何引用数据之前已调用 [`join`][`JoinHandle::join`]",
        "translate": ""
    },
    {
        "source": "use only types with `'static` lifetime bounds, i.e., those with no or only `'static` references (both [`thread::Builder::spawn`][`Builder::spawn`] and [`thread::spawn`][`spawn`] enforce this property statically)",
        "suggest": "仅使用具有 `'static` 生命周期界限的类型，即没有 `'static` 引用或仅具有 `'static` 引用的类型 ([`thread::Builder::spawn`][`Builder::spawn`] 和 [`thread::spawn`][`spawn`] 都静态地强制执行此属性)",
        "translate": ""
    },
    {
        "source": "the stack guard passed is the one for the current thread.",
        "suggest": "传递的堆栈守卫是当前线程的守卫。",
        "translate": ""
    },
    {
        "source": "This means the current thread's stack and the new thread's stack are properly set and protected from each other.",
        "suggest": "这意味着当前线程的栈和新线程的栈已被正确设置并相互保护。",
        "translate": ""
    },
    {
        "source": "`their_packet` as been built just above and moved by the closure (it is an Arc<...>) and `my_packet` will be stored in the same `JoinInner` as this closure meaning the mutation will be safe (not modify it and affect a value far away).",
        "suggest": "`their_packet` 正好在其上方构建并由闭包 (它是 Arc<...>) 移动，并且 `my_packet` 将与该闭包存储在同一 `JoinInner` 中，这意味着该可变的是安全的 (不对其进行修改并影响一个远的值)。",
        "translate": ""
    },
    {
        "source": "takes a closure with a `'static` lifetime, since it's passed through FFI or otherwise used with low-level threading primitives that have no notion of or way to enforce lifetimes.",
        "suggest": "使用 `'static` 生命周期的闭包，因为它是通过 FFI 传递的，或者与不具有强制生命周期概念或方法的强制线程原语一起使用。",
        "translate": ""
    },
    {
        "source": "As mentioned in the `Safety` section of this function's documentation, the caller of this function needs to guarantee that the passed-in lifetime is sufficiently long for the lifetime of the thread.",
        "suggest": "如本函数文档的 `Safety` 部分所述，此函数的调用者需要确保传入的生命周期对于线程的生命周期足够长。",
        "translate": ""
    },
    {
        "source": "Similarly, the `sys` implementation must guarantee that no references to the closure exist after the thread has terminated, which is signaled by `Thread::join` returning.",
        "suggest": "同样，`sys` 实现必须保证在线程终止后，对闭包的引用不存在，这由 `Thread::join` 返回表示。",
        "translate": ""
    },
    {
        "source": "Free functions",
        "suggest": "自由函数",
        "translate": ""
    },
    {
        "source": "Spawns a new thread, returning a [`JoinHandle`] for it.",
        "suggest": "产生一个新线程，为其返回 [`JoinHandle`]。",
        "translate": ""
    },
    {
        "source": "The join handle will implicitly *detach* the child thread upon being dropped.",
        "suggest": "连接子句柄在被丢弃后将隐式分离子线程。",
        "translate": ""
    },
    {
        "source": "In this case, the child thread may outlive the parent (unless the parent thread is the main thread; the whole process is terminated when the main thread finishes).",
        "suggest": "在这种情况下，子线程可能会超过父线程 (除非父线程是主线程; 当主线程结束时，整个进程被终止)。",
        "translate": ""
    },
    {
        "source": "Additionally, the join handle provides a [`join`] method that can be used to join the child thread.",
        "suggest": "此外，联接句柄提供了 [`join`] 方法，可用于联接子线程。",
        "translate": ""
    },
    {
        "source": "If the child thread panics, [`join`] will return an [`Err`] containing the argument given to [`panic!`].",
        "suggest": "如果子线程 panics，则 [`join`] 将返回包含给 [`panic!`] 的参数的 [`Err`]。",
        "translate": ""
    },
    {
        "source": "This will create a thread using default parameters of [`Builder`], if you want to specify the stack size or the name of the thread, use this API instead.",
        "suggest": "这将使用 [`Builder`] 的默认参数创建一个线程，如果要指定栈大小或线程名称，请改用此 API。",
        "translate": ""
    },
    {
        "source": "As you can see in the signature of `spawn` there are two constraints on both the closure given to `spawn` and its return value, let's explain them:",
        "suggest": "如您在 `spawn` 的签名中所见，给 `spawn` 的闭包及其返回值都有两个约束，让我们对其进行解释:",
        "translate": ""
    },
    {
        "source": "The `'static` constraint means that the closure and its return value must have a lifetime of the whole program execution.",
        "suggest": "`'static` 约束意味着闭包及其返回值必须具有整个程序执行的生命周期。",
        "translate": ""
    },
    {
        "source": "The reason for this is that threads can `detach` and outlive the lifetime they have been created in.",
        "suggest": "这样做的原因是，线程可以 `detach` 并使它们在其中创建的生命周期更长。",
        "translate": ""
    },
    {
        "source": "Indeed if the thread, and by extension its return value, can outlive their caller, we need to make sure that they will be valid afterwards, and since we *can't* know when it will return we need to have them valid as long as possible, that is until the end of the program, hence the `'static` lifetime.",
        "suggest": "确实，如果线程及其扩展值可以超过调用者的生命周期，我们需要确保它们之后才有效，并且由于我们 *无法* 知道何时返回，因此需要使它们有效尽可能直到程序结束，因此是 `'static` 生命周期。",
        "translate": ""
    },
    {
        "source": "The [`Send`] constraint is because the closure will need to be passed *by value* from the thread where it is spawned to the new thread.",
        "suggest": "[`Send`] 约束是因为闭包将需要从产生它的线程中传递 *by value* 到新线程。",
        "translate": ""
    },
    {
        "source": "Its return value will need to be passed from the new thread to the thread where it is `join`ed.",
        "suggest": "它的返回值需要从新线程传递到 `join` 线程。",
        "translate": ""
    },
    {
        "source": "As a reminder, the [`Send`] marker trait expresses that it is safe to be passed from thread to thread.",
        "suggest": "提醒一下，[`Send`] 标记 trait 表示从线程传递到线程是安全的。",
        "translate": ""
    },
    {
        "source": "[`Sync`] expresses that it is safe to have a reference be passed from thread to thread.",
        "suggest": "[`Sync`] 表示在每个线程之间传递引用是安全的。",
        "translate": ""
    },
    {
        "source": "Panics if the OS fails to create a thread;",
        "suggest": "如果操作系统无法创建线程，则为 Panics; 否则为 0。",
        "translate": ""
    },
    {
        "source": "use [`Builder::spawn`] to recover from such errors.",
        "suggest": "使用 [`Builder::spawn`] 从此类错误中恢复。",
        "translate": ""
    },
    {
        "source": "Creating a thread.",
        "suggest": "创建一个线程。",
        "translate": ""
    },
    {
        "source": "As mentioned in the module documentation, threads are usually made to communicate using [`channels`], here is how it usually looks.",
        "suggest": "如模块文档中所述，线程通常是使用 [`channels`] 进行通信的，这是它通常的外观。",
        "translate": ""
    },
    {
        "source": "This example also shows how to use `move`, in order to give ownership of values to a thread.",
        "suggest": "此示例还显示了如何使用 `move`，以便将值的所有权授予线程。",
        "translate": ""
    },
    {
        "source": "A thread can also return a value through its [`JoinHandle`], you can use this to make asynchronous computations (futures might be more appropriate though).",
        "suggest": "线程也可以通过其 [`JoinHandle`] 返回一个值，您可以使用它进行异步计算 (不过 futures 可能更合适)。",
        "translate": ""
    },
    {
        "source": "Gets a handle to the thread that invokes it.",
        "suggest": "获取调用它的线程的句柄。",
        "translate": ""
    },
    {
        "source": "Getting a handle to the current thread with `thread::current()`:",
        "suggest": "使用 `thread::current()` 获取当前线程的句柄:",
        "translate": ""
    },
    {
        "source": "Cooperatively gives up a timeslice to the OS scheduler.",
        "suggest": "合作地将一个时间片交给操作系统调度程序。",
        "translate": ""
    },
    {
        "source": "This is used when the programmer knows that the thread will have nothing to do for some time, and thus avoid wasting computing time.",
        "suggest": "当程序员知道线程将在一段时间内不执行任何操作，从而避免浪费计算时间时，可以使用这个方法。",
        "translate": ""
    },
    {
        "source": "For example when polling on a resource, it is common to check that it is available, and if not to yield in order to avoid busy waiting.",
        "suggest": "例如，在对资源进行轮询时，通常会检查该资源是否可用，如果资源不可用，就放弃访问以避免繁忙的等待。",
        "translate": ""
    },
    {
        "source": "Thus the pattern of `yield`ing after a failed poll is rather common when implementing low-level shared resources or synchronization primitives.",
        "suggest": "所以，在实现共享资源或同步原语时，轮询失败后的 `yield` 模式相当常见。",
        "translate": ""
    },
    {
        "source": "However programmers will usually prefer to use [`channel`]s, [`Condvar`]s, [`Mutex`]es or [`join`] for their synchronization routines, as they avoid thinking about thread scheduling.",
        "suggest": "但是，程序员通常会更喜欢使用 [`channel`]，[`Condvar`]，[`Mutex`] 或 [`join`] 作为他们的同步例程，因为他们避免考虑线程调度。",
        "translate": ""
    },
    {
        "source": "Note that [`channel`]s for example are implemented using this primitive.",
        "suggest": "注意，例如 [`channel`] 是使用此原语实现的。",
        "translate": ""
    },
    {
        "source": "Indeed when you call `send` or `recv`, which are blocking, they will yield if the channel is not available.",
        "suggest": "的确，当您调用阻塞的 `send` 或 `recv` 时，如果通道不可用，它们就会让步。",
        "translate": ""
    },
    {
        "source": "A common use of this feature is to poison shared resources when writing unsafe code, by checking `panicking` when the `drop` is called.",
        "suggest": "此功能的一个常见用途是在编写不安全代码时毒害共享资源，方法是在调用 `drop` 时检查 `panic`。",
        "translate": ""
    },
    {
        "source": "This is usually not needed when writing safe code, as [`Mutex`es][Mutex] already poison themselves when a thread panics while holding the lock.",
        "suggest": "编写安全代码时通常不需要这样做，因为当线程在持有锁时 panic，[`Mutex`][Mutex] 已经中毒了。",
        "translate": ""
    },
    {
        "source": "This can also be used in multithreaded applications, in order to send a message to other threads warning that a thread has panicked (e.g., for monitoring purposes).",
        "suggest": "这也可以在多线程应用程序中使用，以便向其他线程发送消息，警告某个线程已发生 panic (例如，出于监视目的)。",
        "translate": ""
    },
    {
        "source": "Puts the current thread to sleep for at least the specified amount of time.",
        "suggest": "使当前线程休眠至少指定的时间。",
        "translate": ""
    },
    {
        "source": "The thread may sleep longer than the duration specified due to scheduling specifics or platform-dependent functionality.",
        "suggest": "由于调度细节或平台相关的功能，线程的睡眠时间可能比指定的持续时间更长。",
        "translate": ""
    },
    {
        "source": "It will never sleep less.",
        "suggest": "它永远不会少睡。",
        "translate": ""
    },
    {
        "source": "This function is blocking, and should not be used in `async` functions.",
        "suggest": "该函数正在阻塞，因此不应在 `async` 函数中使用。",
        "translate": ""
    },
    {
        "source": "On Unix platforms, the underlying syscall may be interrupted by a spurious wakeup or signal handler.",
        "suggest": "在 Unix 平台上，底层的系统调用可能会由于虚假唤醒或信号处理程序而中断。",
        "translate": ""
    },
    {
        "source": "To ensure the sleep occurs for at least the specified duration, this function may invoke that system call multiple times.",
        "suggest": "为了确保至少在指定的持续时间内发生睡眠，此函数可以多次调用该系统。",
        "translate": ""
    },
    {
        "source": "Platforms which do not support nanosecond precision for sleeping will have `dur` rounded up to the nearest granularity of time they can sleep for.",
        "suggest": "不支持纳秒级睡眠精度的平台会将 `dur` 舍入为最接近的睡眠时间粒度。",
        "translate": ""
    },
    {
        "source": "Currently, specifying a zero duration on Unix platforms returns immediately without invoking the underlying [`nanosleep`] syscall, whereas on Windows platforms the underlying [`Sleep`] syscall is always invoked.",
        "suggest": "当前，在 Unix 平台上指定零时长会立即返回，而不会调用基础 [`nanosleep`] 系统调用，而在 Windows 平台上，始终会调用基础 [`Sleep`] 系统调用。",
        "translate": ""
    },
    {
        "source": "If the intention is to yield the current time-slice you may want to use [`yield_now`] instead.",
        "suggest": "如果要产生当前时间切片，则可能需要使用 [`yield_now`]。",
        "translate": ""
    },
    {
        "source": "Blocks unless or until the current thread's token is made available.",
        "suggest": "阻塞，除非或直到当前线程的 token 可用为止。",
        "translate": ""
    },
    {
        "source": "A call to `park` does not guarantee that the thread will remain parked forever, and callers should be prepared for this possibility.",
        "suggest": "对 `park` 的调用不能保证线程将永远保持驻留状态，因此调用者应为此做好准备。",
        "translate": ""
    },
    {
        "source": "park and unpark",
        "suggest": "park 和 unpark",
        "translate": ""
    },
    {
        "source": "Every thread is equipped with some basic low-level blocking support, via the [`thread::park`][`park`] function and [`thread::Thread::unpark`][`unpark`] method.",
        "suggest": "每个线程都通过 [`thread::park`][`park`] 函数和 [`thread::Thread::unpark`][`unpark`] 方法提供了一些基本的阻塞支持。",
        "translate": ""
    },
    {
        "source": "blocks the current thread, which can then be resumed from another thread by calling the [`unpark`] method on the blocked thread's handle.",
        "suggest": "阻塞当前线程，然后可以通过在阻塞线程的句柄上调用 [`unpark`] 方法从另一个线程恢复该线程。",
        "translate": ""
    },
    {
        "source": "Conceptually, each [`Thread`] handle has an associated token, which is initially not present:",
        "suggest": "从概念上讲，每个 [`Thread`] 句柄都有一个关联的 token，该 token 最初不存在:",
        "translate": ""
    },
    {
        "source": "The [`thread::park`][`park`] function blocks the current thread unless or until the token is available for its thread handle, at which point it atomically consumes the token.",
        "suggest": "[`thread::park`][`park`] 函数会阻塞当前线程，除非或直到 token 可用于其线程句柄为止，否则该原子将自动消耗 token。",
        "translate": ""
    },
    {
        "source": "It may also return *spuriously*, without consuming the token.",
        "suggest": "它也可能虚假地返回，而不消耗 token。",
        "translate": ""
    },
    {
        "source": "does the same, but allows specifying a maximum time to block the thread for.",
        "suggest": "这样做是一样的，但是允许指定最长的时间来阻止线程。",
        "translate": ""
    },
    {
        "source": "The [`unpark`] method on a [`Thread`] atomically makes the token available if it wasn't already.",
        "suggest": "[`Thread`] 上的 [`unpark`] 方法原子地使 token (如果尚未提供) 可用。",
        "translate": ""
    },
    {
        "source": "Because the token is initially absent, [`unpark`] followed by [`park`] will result in the second call returning immediately.",
        "suggest": "由于最初不存在 token，因此 [`unpark`] 后跟 [`park`] 将导致第二个调用立即返回。",
        "translate": ""
    },
    {
        "source": "In other words, each [`Thread`] acts a bit like a spinlock that can be locked and unlocked using `park` and `unpark`.",
        "suggest": "换句话说，每个 [`Thread`] 的行为都类似于自旋锁，可以使用 `park` 和 `unpark` 进行锁定和解锁。",
        "translate": ""
    },
    {
        "source": "Notice that being unblocked does not imply any synchronization with someone that unparked this thread, it could also be spurious.",
        "suggest": "请注意，被取消阻止并不意味着与取消该线程的某个人进行任何同步，这也可能是虚假的。",
        "translate": ""
    },
    {
        "source": "For example, it would be a valid, but inefficient, implementation to make both [`park`] and [`unpark`] return immediately without doing anything.",
        "suggest": "例如，将 [`park`] 和 [`unpark`] 都立即返回而无需执行任何操作将是有效但效率低下的实现。",
        "translate": ""
    },
    {
        "source": "The API is typically used by acquiring a handle to the current thread, placing that handle in a shared data structure so that other threads can find it, and then `park`ing in a loop.",
        "suggest": "通常通过获取当前线程的句柄，将该句柄放置在共享数据结构体中，以便其他线程可以找到它，然后 `park` 在循环中来使用该 API。",
        "translate": ""
    },
    {
        "source": "When some desired condition is met, another thread calls [`unpark`] on the handle.",
        "suggest": "当满足某些所需条件时，另一个线程将在句柄上调用 [`unpark`]。",
        "translate": ""
    },
    {
        "source": "The motivation for this design is twofold:",
        "suggest": "这种设计的动机是双重的:",
        "translate": ""
    },
    {
        "source": "It avoids the need to allocate mutexes and condvars when building new synchronization primitives;",
        "suggest": "在构建新的同步原语时，它无需分配互斥锁和 condvar。",
        "translate": ""
    },
    {
        "source": "the threads already provide basic blocking/signaling.",
        "suggest": "线程已经提供了基本的 blocking/signaling。",
        "translate": ""
    },
    {
        "source": "It can be implemented very efficiently on many platforms.",
        "suggest": "它可以在许多平台上非常有效地实现。",
        "translate": ""
    },
    {
        "source": "park_timeout is called on the parker owned by this thread.",
        "suggest": "在该线程所拥有的 parker 上调用 park_timeout。",
        "translate": ""
    },
    {
        "source": "Use [`park_timeout`].",
        "suggest": "使用 [`park_timeout`]。",
        "translate": ""
    },
    {
        "source": "Blocks unless or until the current thread's token is made available or the specified duration has been reached (may wake spuriously).",
        "suggest": "除非直到当前线程的 token 可用或达到指定的持续时间 (否则可能会虚假唤醒)，否则将阻塞。",
        "translate": ""
    },
    {
        "source": "The semantics of this function are equivalent to [`park`] except that the thread will be blocked for roughly no longer than `dur`.",
        "suggest": "该函数的语义与 [`park`] 等效，除了线程被阻塞的时间不超过 `dur`。",
        "translate": ""
    },
    {
        "source": "This method should not be used for precise timing due to anomalies such as preemption or platform differences that may not cause the maximum amount of time waited to be precisely `ms` long.",
        "suggest": "由于诸如抢占或平台差异之类的异常可能不会导致等待的最大时间恰好为 `ms` 长，因此该方法不应用于精确的计时。",
        "translate": ""
    },
    {
        "source": "See the [park documentation][`park`] for more detail.",
        "suggest": "有关更多详细信息，请参见 [park 文档][`park`]。",
        "translate": ""
    },
    {
        "source": "The semantics of this function are equivalent to [`park`][park] except that the thread will be blocked for roughly no longer than `dur`.",
        "suggest": "该函数的语义与 [`park`][park] 等效，除了线程被阻塞的时间不超过 `dur`。",
        "translate": ""
    },
    {
        "source": "This method should not be used for precise timing due to anomalies such as preemption or platform differences that may not cause the maximum amount of time waited to be precisely `dur` long.",
        "suggest": "由于诸如抢占或平台差异之类的异常可能不会导致等待的最大时间恰好为 `dur` 长，因此该方法不应用于精确的计时。",
        "translate": ""
    },
    {
        "source": "See the [park documentation][park] for more details.",
        "suggest": "有关更多详细信息，请参见 [park 文档][park]。",
        "translate": ""
    },
    {
        "source": "Waiting for the complete expiration of the timeout:",
        "suggest": "等待超时完全到期:",
        "translate": ""
    },
    {
        "source": "A unique identifier for a running thread.",
        "suggest": "正在运行的线程的唯一标识符。",
        "translate": ""
    },
    {
        "source": "A `ThreadId` is an opaque object that has a unique value for each thread that creates one.",
        "suggest": "`ThreadId` 是不透明的 object，对于创建一个线程的每个线程，它具有唯一的值。",
        "translate": ""
    },
    {
        "source": "`ThreadId`s are not guaranteed to correspond to a thread's system-designated identifier.",
        "suggest": "不能保证 ThreadId 与线程的系统指定标识符相对应。",
        "translate": ""
    },
    {
        "source": "A `ThreadId` can be retrieved from the [`id`] method on a [`Thread`].",
        "suggest": "可以从 [`Thread`] 上的 [`id`] 方法中检索 `ThreadId`。",
        "translate": ""
    },
    {
        "source": "Generate a new unique thread ID.",
        "suggest": "生成一个新的唯一线程 ID。",
        "translate": ""
    },
    {
        "source": "If we somehow use up all our bits, panic so that we're not covering up subtle bugs of IDs being reused.",
        "suggest": "如果我们以某种方式用尽了所有位 panic，那么我们就不会掩盖正在重用的 ID 的细微错误。",
        "translate": ""
    },
    {
        "source": "This returns a numeric identifier for the thread identified by this `ThreadId`.",
        "suggest": "这将返回此 `ThreadId` 标识的线程的数字标识符。",
        "translate": ""
    },
    {
        "source": "As noted in the documentation for the type itself, it is essentially an opaque ID, but is guaranteed to be unique for each thread.",
        "suggest": "如类型本身的文档中所述，它本质上是一个不透明的 ID，但可以保证每个线程都是唯一的。",
        "translate": ""
    },
    {
        "source": "The returned value is entirely opaque -- only equality testing is stable.",
        "suggest": "返回的值是完全不透明的 - 仅相等测试是稳定的。",
        "translate": ""
    },
    {
        "source": "Note that it is not guaranteed which values new threads will return, and this may change across Rust versions.",
        "suggest": "请注意，不能保证新线程将返回哪些值，并且在 Rust 版本之间可能会改变。",
        "translate": ""
    },
    {
        "source": "The internal representation of a `Thread` handle",
        "suggest": "`Thread` 句柄的内部表示",
        "translate": ""
    },
    {
        "source": "Guaranteed to be UTF-8",
        "suggest": "保证为 UTF-8",
        "translate": ""
    },
    {
        "source": "A handle to a thread.",
        "suggest": "线程的句柄。",
        "translate": ""
    },
    {
        "source": "Threads are represented via the `Thread` type, which you can get in one of two ways:",
        "suggest": "线程通过 `Thread` 类型表示，您可以通过以下两种方式之一来获取:",
        "translate": ""
    },
    {
        "source": "There is usually no need to create a `Thread` struct yourself, one should instead use a function like `spawn` to create new threads, see the docs of [`Builder`] and [`spawn`] for more details.",
        "suggest": "通常不需要自己创建 `Thread` 结构体，而应使用 `spawn` 之类的函数来创建新线程，有关更多详细信息，请参见 [`Builder`] 和 [`spawn`] 的文档。",
        "translate": ""
    },
    {
        "source": "Used only internally to construct a thread object without spawning Panics if the name contains nuls.",
        "suggest": "如果名称包含 nul，则仅在内部用于构造线程 object，而不会产生 Panics。",
        "translate": ""
    },
    {
        "source": "Atomically makes the handle's token available if it is not already.",
        "suggest": "通过原子方式使句柄的 token 可用 (如果尚不可用)。",
        "translate": ""
    },
    {
        "source": "Every thread is equipped with some basic low-level blocking support, via the [`park`][park] function and the `unpark()` method.",
        "suggest": "每个线程都通过 [`park`][park] 函数和 `unpark()` 方法提供了一些基本的阻塞支持。",
        "translate": ""
    },
    {
        "source": "These can be used as a more CPU-efficient implementation of a spinlock.",
        "suggest": "这些可用作自旋锁的 CPU 效率更高的实现。",
        "translate": ""
    },
    {
        "source": "Gets the thread's unique identifier.",
        "suggest": "获取线程的唯一标识符。",
        "translate": ""
    },
    {
        "source": "Gets the thread's name.",
        "suggest": "获取线程的名称。",
        "translate": ""
    },
    {
        "source": "Threads by default have no name specified:",
        "suggest": "默认情况下，线程未指定名称:",
        "translate": ""
    },
    {
        "source": "Thread with a specified name:",
        "suggest": "具有指定名称的线程:",
        "translate": ""
    },
    {
        "source": "A specialized [`Result`] type for threads.",
        "suggest": "线程专用的 [`Result`] 类型。",
        "translate": ""
    },
    {
        "source": "Indicates the manner in which a thread exited.",
        "suggest": "指示线程退出的方式。",
        "translate": ""
    },
    {
        "source": "The value contained in the `Result::Err` variant is the value the thread panicked with;",
        "suggest": "`Result::Err` 成员中包含的值是被恐慌的线程的值;",
        "translate": ""
    },
    {
        "source": "that is, the argument the `panic!` macro was called with.",
        "suggest": "也就是说，调用了 `panic!` 宏的参数。",
        "translate": ""
    },
    {
        "source": "Unlike with normal errors, this value doesn't implement the [`Error`](crate::error::Error) trait.",
        "suggest": "与正常错误不同，此值不实现 [`Error`](crate::error::Error) trait。",
        "translate": ""
    },
    {
        "source": "Thus, a sensible way to handle a thread panic is to either:",
        "suggest": "因此，处理线程 panic 的明智方法是:",
        "translate": ""
    },
    {
        "source": "propagate the panic with [`std::panic::resume_unwind`]",
        "suggest": "用 [`std::panic::resume_unwind`] 传播 panic",
        "translate": ""
    },
    {
        "source": "or in case the thread is intended to be a subsystem boundary that is supposed to isolate system-level failures, match on the `Err` variant and handle the panic in an appropriate way",
        "suggest": "或如果线程打算作为子系统边界来隔离系统级故障，在 `Err` 成员上进行匹配并以适当的方式处理 panic",
        "translate": ""
    },
    {
        "source": "A thread that completes without panicking is considered to exit successfully.",
        "suggest": "没有恐慌地完成的线程被认为已成功退出。",
        "translate": ""
    },
    {
        "source": "Matching on the result of a joined thread:",
        "suggest": "匹配已连接线程的结果:",
        "translate": ""
    },
    {
        "source": "This packet is used to communicate the return value between the child thread and the parent thread.",
        "suggest": "该数据包用于在子线程和父线程之间传递返回值。",
        "translate": ""
    },
    {
        "source": "Memory is shared through the `Arc` within and there's no need for a mutex here because synchronization happens with `join()` (the parent thread never reads this packet until the child has exited).",
        "suggest": "内存是通过内部的 `Arc` 共享的，这里不需要互斥锁，因为与 `join()` 进行了同步 (父线程在子级退出之前永远不会读取此数据包)。",
        "translate": ""
    },
    {
        "source": "This packet itself is then stored into a `JoinInner` which in turns is placed in `JoinHandle` and `JoinGuard`.",
        "suggest": "然后将此数据包本身存储到 `JoinInner` 中，该 `JoinInner` 依次放置在 `JoinHandle` 和 `JoinGuard` 中。",
        "translate": ""
    },
    {
        "source": "Due to the usage of `UnsafeCell` we need to manually worry about impls like Send and Sync.",
        "suggest": "由于使用了 `UnsafeCell`，我们需要手动担心诸如发送和同步之类的冲动。",
        "translate": ""
    },
    {
        "source": "The type `T` should already always be Send (otherwise the thread could not have been created) and this type is inherently Sync because no methods take &self.",
        "suggest": "`T` 类型应该已经始终是 Send (否则无法创建线程)，并且此类型固有地是 Sync，因为没有方法采用 &self。",
        "translate": ""
    },
    {
        "source": "Regardless, however, we add inheriting impls for Send/Sync to this type to ensure it's Send/Sync and that future modifications will still appropriately classify it.",
        "suggest": "但是，无论如何，我们都将 Send/Sync 的继承的 impls 添加到此类型，以确保它是 Send/Sync，并且 future 修改仍将其适当地分类。",
        "translate": ""
    },
    {
        "source": "Inner representation for JoinHandle",
        "suggest": "JoinHandle 的内部表示",
        "translate": ""
    },
    {
        "source": "An owned permission to join on a thread (block on its termination).",
        "suggest": "拥有加入线程的权限 (在线程终止时阻止)。",
        "translate": ""
    },
    {
        "source": "A `JoinHandle` *detaches* the associated thread when it is dropped, which means that there is no longer any handle to thread and no way to `join` on it.",
        "suggest": "`JoinHandle` 在被丢弃时会 *分离* 相关的线程，这意味着不再有线程句柄，也无法在其上访问 `join`。",
        "translate": ""
    },
    {
        "source": "Due to platform restrictions, it is not possible to [`Clone`] this handle: the ability to join a thread is a uniquely-owned permission.",
        "suggest": "由于平台的限制，无法使用 [`Clone`] 此句柄: 加入线程的能力是唯一拥有的权限。",
        "translate": ""
    },
    {
        "source": "This `struct` is created by the [`thread::spawn`] function and the [`thread::Builder::spawn`] method.",
        "suggest": "该 `struct` 由 [`thread::spawn`] 函数和 [`thread::Builder::spawn`] 方法创建。",
        "translate": ""
    },
    {
        "source": "Creation from [`thread::spawn`]:",
        "suggest": "从 [`thread::spawn`] 创建:",
        "translate": ""
    },
    {
        "source": "Creation from [`thread::Builder::spawn`]:",
        "suggest": "从 [`thread::Builder::spawn`] 创建:",
        "translate": ""
    },
    {
        "source": "Child being detached and outliving its parent:",
        "suggest": "子节点离开父节点并活的更久",
        "translate": ""
    },
    {
        "source": "Extracts a handle to the underlying thread.",
        "suggest": "提取基础线程的句柄。",
        "translate": ""
    },
    {
        "source": "Waits for the associated thread to finish.",
        "suggest": "等待关联的线程完成。",
        "translate": ""
    },
    {
        "source": "In terms of [atomic memory orderings],  the completion of the associated thread synchronizes with this function returning.",
        "suggest": "就 [atomic memory orderings] 而言，关联线程的完成与此函数返回同步。",
        "translate": ""
    },
    {
        "source": "In other words, all operations performed by that thread are ordered before all operations that happen after `join` returns.",
        "suggest": "换句话说，在 `join` 返回之后发生的所有操作之前，将对该线程执行的所有操作进行排序。",
        "translate": ""
    },
    {
        "source": "If the child thread panics, [`Err`] is returned with the parameter given to [`panic!`].",
        "suggest": "如果子线程 panics，则使用给 [`panic!`] 的参数返回 [`Err`]。",
        "translate": ""
    },
    {
        "source": "This function may panic on some platforms if a thread attempts to join itself or otherwise may create a deadlock with joining threads.",
        "suggest": "如果某个线程尝试加入自身，则该函数在某些平台上可能为 panic，否则可能会在加入线程时产生死锁。",
        "translate": ""
    },
    {
        "source": "These tests are dangerous.",
        "suggest": "这些测试很危险。",
        "translate": ""
    },
    {
        "source": "If something is buggy, they will hang,",
        "suggest": "如果是 buggy，它们会挂起，",
        "translate": ""
    },
    {
        "source": "instead of exiting cleanly.",
        "suggest": "而不是干净地离开。",
        "translate": ""
    },
    {
        "source": "This might wedge the buildbots.",
        "suggest": "这可能会影响构建机器人。",
        "translate": ""
    },
    {
        "source": "If the child refcounts the parent thread, this will stack overflow when climbing the thread tree to dereference each ancestor.",
        "suggest": "如果子线程引用父线程，则在爬树线程树以引用每个祖先时，这将栈溢出。",
        "translate": ""
    },
    {
        "source": "(See #1789) (well, it would if the constant were 8000+ - I lowered it to be more valgrind-friendly.",
        "suggest": "(请参见 #1789) (好吧，如果常量为 8000+，我将其降低为对 valgrind 更友好。",
        "translate": ""
    },
    {
        "source": "try this at home, instead..!)",
        "suggest": "在家里尝试一下吧..! )",
        "translate": ""
    },
    {
        "source": "the corresponding test for stderr is in ui/thread-stderr, due to the test harness apparently interfering with stderr configuration.",
        "suggest": "由于测试工具显然干扰了 stderr 的配置，因此 stderr 的相应测试在 ui/thread-stderr 中进行。",
        "translate": ""
    },
    {
        "source": "checked_add_duration will not panic on overflow",
        "suggest": "发生溢出时，checked_add_duration 不会为 panic",
        "translate": ""
    },
    {
        "source": "in case `Instant` can store `>= now + max_duration`.",
        "suggest": "如果 `Instant` 可以存储 `>= now + max_duration`。",
        "translate": ""
    },
    {
        "source": "checked_add_duration calculates the right time and will work for another year",
        "suggest": "checked_add_duration 计算正确的时间并将再工作一年",
        "translate": ""
    },
    {
        "source": "Changing the order of instant math shouldn't change the results, especially when the expression reduces to X + identity.",
        "suggest": "更改即时数学的顺序不应更改结果，尤其是当表达式简化为 X + 身份时。",
        "translate": ""
    },
    {
        "source": "in case `SystemTime` can store `>= UNIX_EPOCH + max_duration`.",
        "suggest": "如果 `SystemTime` 可以存储 `>= UNIX_EPOCH + max_duration`。",
        "translate": ""
    },
    {
        "source": "Right now for CI this test is run in an emulator, and apparently the aarch64 emulator's sense of time is that we're still living in the",
        "suggest": "现在，对于 CI 而言，该测试是在仿真器中运行的，显然 aarch64 仿真器的时间感是我们仍然生活在",
        "translate": ""
    },
    {
        "source": "70s. This is also true for riscv (also qemu)",
        "suggest": "70 年代。riscv (也 qemu) 也是如此",
        "translate": ""
    },
    {
        "source": "Otherwise let's assume that we're all running computers later than",
        "suggest": "否则，我们假设所有计算机的运行时间都晚于",
        "translate": ""
    },
    {
        "source": "let's assume that we're all running computers earlier than 2090.",
        "suggest": "假设我们都在运行 2090 年之前的计算机。",
        "translate": ""
    },
    {
        "source": "Should give us ~70 years to fix this!",
        "suggest": "应该给我们 ~70 年来解决这个问题!",
        "translate": ""
    },
    {
        "source": "we sleep for 2 seconds",
        "suggest": "我们睡了 2 秒钟",
        "translate": ""
    },
    {
        "source": "it prints '2'",
        "suggest": "它打印 '2'",
        "translate": ""
    },
    {
        "source": "an error occurred!",
        "suggest": "发生错误!",
        "translate": ""
    },
    {
        "source": "A measurement of a monotonically nondecreasing clock.",
        "suggest": "单调非递减时钟的度量。",
        "translate": ""
    },
    {
        "source": "Opaque and useful only with `Duration`.",
        "suggest": "不透明，仅对 `Duration` 有用。",
        "translate": ""
    },
    {
        "source": "Instants are always guaranteed to be no less than any previously measured instant when created, and are often useful for tasks such as measuring benchmarks or timing how long an operation takes.",
        "suggest": "创建时始终保证瞬时不小于任何先前测量的瞬时，并且对于执行诸如测量基准或计时操作花费多长时间等任务通常很有用。",
        "translate": ""
    },
    {
        "source": "Note, however, that instants are not guaranteed to be **steady**.",
        "suggest": "但是请注意，不能保证瞬间稳定。",
        "translate": ""
    },
    {
        "source": "In other words, each tick of the underlying clock may not be the same length (e.g.",
        "suggest": "换句话说，基础时钟的每个刻度可能不一样长 (例如",
        "translate": ""
    },
    {
        "source": "some seconds may be longer than others).",
        "suggest": "几秒钟可能比其他更长)。",
        "translate": ""
    },
    {
        "source": "An instant may jump forwards or experience time dilation (slow down or speed up), but it will never go backwards.",
        "suggest": "瞬间可能会向前跳跃或经历时间膨胀 (减速或加速)，但永远不会向后退。",
        "translate": ""
    },
    {
        "source": "Instants are opaque types that can only be compared to one another.",
        "suggest": "即时消息是不透明的类型，只能相互比较。",
        "translate": ""
    },
    {
        "source": "There is no method to get \"the number of seconds\" from an instant.",
        "suggest": "没有方法可以立即获取 \"the number of seconds\"。",
        "translate": ""
    },
    {
        "source": "Instead, it only allows measuring the duration between two instants (or comparing two instants).",
        "suggest": "相反，它仅允许测量两个瞬间之间的持续时间 (或比较两个瞬间)。",
        "translate": ""
    },
    {
        "source": "The size of an `Instant` struct may vary depending on the target operating system.",
        "suggest": "`Instant` 结构体的大小可能会因目标操作系统而异。",
        "translate": ""
    },
    {
        "source": "OS-specific behaviors",
        "suggest": "特定于操作系统的行为",
        "translate": ""
    },
    {
        "source": "An `Instant` is a wrapper around system-specific types and it may behave differently depending on the underlying operating system.",
        "suggest": "`Instant` 是系统特定类型的包装，并且其行为可能取决于基础操作系统。",
        "translate": ""
    },
    {
        "source": "For example, the following snippet is fine on Linux but panics on macOS:",
        "suggest": "例如，以下代码段在 Linux 上很好，但在 macOS 上为 panics:",
        "translate": ""
    },
    {
        "source": "Underlying System calls",
        "suggest": "底层系统调用",
        "translate": ""
    },
    {
        "source": "Currently, the following system calls are being used to get the current time using `now()`:",
        "suggest": "当前，正在使用以下系统调用来使用 `now()` 获取当前时间:",
        "translate": ""
    },
    {
        "source": "**Disclaimer:** These system calls might change over time.",
        "suggest": "**免责声明:** 这些系统调用可能会随时间变化。",
        "translate": ""
    },
    {
        "source": "mathematical operations like [`add`] may panic if the underlying",
        "suggest": "如果 [`add`] 的数学运算可能是 panic",
        "translate": ""
    },
    {
        "source": "structure cannot represent the new point in time.",
        "suggest": "结构体不能代表新的时间点。",
        "translate": ""
    },
    {
        "source": "A measurement of the system clock, useful for talking to external entities like the file system or other processes.",
        "suggest": "系统时钟的度量，对于与文件系统或其他进程之类的外部实体进行通信很有用。",
        "translate": ""
    },
    {
        "source": "Distinct from the [`Instant`] type, this time measurement **is not monotonic**.",
        "suggest": "与 [`Instant`] 类型不同，这次的测量 **不是单调的**。",
        "translate": ""
    },
    {
        "source": "This means that you can save a file to the file system, then save another file to the file system, **and the second file has a `SystemTime` measurement earlier than the first**.",
        "suggest": "这意味着您可以将文件保存到文件系统，然后再将另一个文件保存到文件系统，**并且第二个文件的 `SystemTime` 测量值比第一个文件早**。",
        "translate": ""
    },
    {
        "source": "In other words, an operation that happens after another operation in real time may have an earlier `SystemTime`!",
        "suggest": "换句话说，在另一个实时操作之后实时发生的操作可能具有更早的 `SystemTime`!",
        "translate": ""
    },
    {
        "source": "Consequently, comparing two `SystemTime` instances to learn about the duration between them returns a [`Result`] instead of an infallible [`Duration`] to indicate that this sort of time drift may happen and needs to be handled.",
        "suggest": "因此，比较两个 `SystemTime` 实例以了解它们之间的持续时间将返回 [`Result`] 而不是绝对的 [`Duration`]，以指示这种时间漂移可能发生并且需要处理。",
        "translate": ""
    },
    {
        "source": "Although a `SystemTime` cannot be directly inspected, the [`UNIX_EPOCH`] constant is provided in this module as an anchor in time to learn information about a `SystemTime`.",
        "suggest": "尽管无法直接检查 `SystemTime`，但此模块中提供了 [`UNIX_EPOCH`] 常量作为及时了解有关 `SystemTime` 信息的锚点。",
        "translate": ""
    },
    {
        "source": "By calculating the duration from this fixed point in time, a `SystemTime` can be converted to a human-readable time, or perhaps some other string representation.",
        "suggest": "通过从该固定时间点计算持续时间，可以将 `SystemTime` 转换为人类可读的时间，或者转换为其他字符串表示形式。",
        "translate": ""
    },
    {
        "source": "The size of a `SystemTime` struct may vary depending on the target operating system.",
        "suggest": "`SystemTime` 结构体的大小可能会因目标操作系统而异。",
        "translate": ""
    },
    {
        "source": "An error returned from the `duration_since` and `elapsed` methods on `SystemTime`, used to learn how far in the opposite direction a system time lies.",
        "suggest": "`SystemTime` 的 `duration_since` 和 `elapsed` 方法返回的错误，用于了解系统时间在相反方向上的距离。",
        "translate": ""
    },
    {
        "source": "Returns an instant corresponding to \"now\".",
        "suggest": "返回对应于 \"now\" 的瞬间。",
        "translate": ""
    },
    {
        "source": "And here we come upon a sad state of affairs.",
        "suggest": "在这里，我们遇到了一种悲惨的状况。",
        "translate": ""
    },
    {
        "source": "The whole point of `Instant` is that it's monotonically increasing.",
        "suggest": "`Instant` 的全部要点是它是单调递增的。",
        "translate": ""
    },
    {
        "source": "We've found in the wild, however, that it's not actually monotonically increasing for one reason or another.",
        "suggest": "但是，我们发现在野外它实际上并不是由于一个或另一个原因而单调增加。",
        "translate": ""
    },
    {
        "source": "These appear to be OS and hardware level bugs, and there's not really a whole lot we can do about them.",
        "suggest": "这些似乎是操作系统和硬件级别的错误，我们实际上并不能做很多事情。",
        "translate": ""
    },
    {
        "source": "Here's a taste of what we've found:",
        "suggest": "以下是我们发现的内容:",
        "translate": ""
    },
    {
        "source": "linux arm64 and s390x",
        "suggest": "linux arm64 和 s390x",
        "translate": ""
    },
    {
        "source": "windows, x86, vm (?)",
        "suggest": "windows，x86，VM (?)",
        "translate": ""
    },
    {
        "source": "It seems that this just happens a lot in the wild.",
        "suggest": "似乎这在野外经常发生。",
        "translate": ""
    },
    {
        "source": "We're seeing panics across various platforms where consecutive calls to `Instant::now`, such as via the `elapsed` function, are panicking as they're going backwards.",
        "suggest": "我们正在各种平台上看到 panics，在这些平台上，通过 `elapsed` 函数对 `Instant::now` 的连续调用在向后倒退时会感到恐慌。",
        "translate": ""
    },
    {
        "source": "Placed here is a last-ditch effort to try to fix things up.",
        "suggest": "此处放置的是最后一滴尝试以解决问题的方法。",
        "translate": ""
    },
    {
        "source": "We keep a global \"latest now\" instance which is returned instead of what the OS says if the OS goes backwards.",
        "suggest": "我们保留一个 \"latest now\" 实例，如果 OS 向后运行，则返回该实例，而不是 OS 所说的。",
        "translate": ""
    },
    {
        "source": "To hopefully mitigate the impact of this, a few platforms are excluded as \"these at least haven't gone backwards yet\".",
        "suggest": "为了希望减轻这种影响，\"these at least haven't gone backwards yet\" 排除了一些平台。",
        "translate": ""
    },
    {
        "source": "Returns the amount of time elapsed from another instant to this one.",
        "suggest": "返回从另一个时刻到该时刻所经过的时间。",
        "translate": ""
    },
    {
        "source": "This function will panic if `earlier` is later than `self`.",
        "suggest": "如果 `earlier` 晚于 `self`，则此函数将为 panic。",
        "translate": ""
    },
    {
        "source": "Returns the amount of time elapsed from another instant to this one, or None if that instant is later than this one.",
        "suggest": "返回从另一个时刻到该时刻所经过的时间; 如果该时刻晚于该时刻，则返回 None。",
        "translate": ""
    },
    {
        "source": "Returns the amount of time elapsed from another instant to this one, or zero duration if that instant is later than this one.",
        "suggest": "返回从另一时刻到该时刻所经过的时间，如果该时刻晚于该时刻，则返回零持续时间。",
        "translate": ""
    },
    {
        "source": "Returns the amount of time elapsed since this instant was created.",
        "suggest": "返回自创建此瞬间以来经过的时间。",
        "translate": ""
    },
    {
        "source": "This function may panic if the current time is earlier than this instant, which is something that can happen if an `Instant` is produced synthetically.",
        "suggest": "如果当前时间早于此时刻，则此函数可能为 panic，如果 `Instant` 是综合生成的，则可能会发生这种情况。",
        "translate": ""
    },
    {
        "source": "Returns `Some(t)` where `t` is the time `self + duration` if `t` can be represented as `Instant` (which means it's inside the bounds of the underlying data structure), `None` otherwise.",
        "suggest": "如果 `t` 可以表示为 `Instant` (表示它在基础数据结构体的边界之内)，则返回 `Some(t)`，其中 `t` 是 `self + duration` 的时间，否则返回 `None`。",
        "translate": ""
    },
    {
        "source": "Returns `Some(t)` where `t` is the time `self - duration` if `t` can be represented as `Instant` (which means it's inside the bounds of the underlying data structure), `None` otherwise.",
        "suggest": "如果 `t` 可以表示为 `Instant` (表示它在基础数据结构体的边界之内)，则返回 `Some(t)`，其中 `t` 是 `self - duration` 的时间，否则返回 `None`。",
        "translate": ""
    },
    {
        "source": "This function may panic if the resulting point in time cannot be represented by the underlying data structure.",
        "suggest": "如果结果时间点不能由基础数据结构体表示，则此函数可能为 panic。",
        "translate": ""
    },
    {
        "source": "See [`Instant::checked_add`] for a version without panic.",
        "suggest": "没有 panic 的版本，请参见 [`Instant::checked_add`]。",
        "translate": ""
    },
    {
        "source": "An anchor in time which can be used to create new `SystemTime` instances or learn about where in time a `SystemTime` lies.",
        "suggest": "时间锚，可用于创建新的 `SystemTime` 实例或了解 `SystemTime` 的时间。",
        "translate": ""
    },
    {
        "source": "This constant is defined to be \"1970-01-01 00:00:00 UTC\" on all systems with respect to the system clock.",
        "suggest": "相对于系统时钟，此常量在所有系统上均定义为 \"1970-01-01 00:00:00 UTC\"。",
        "translate": ""
    },
    {
        "source": "Using `duration_since` on an existing `SystemTime` instance can tell how far away from this point in time a measurement lies, and using `UNIX_EPOCH + duration` can be used to create a `SystemTime` instance to represent another fixed point in time.",
        "suggest": "在现有的 `SystemTime` 实例上使用 `duration_since` 可以告诉您测量距离该时间点有多远，并且可以使用 `UNIX_EPOCH + duration` 创建一个 `SystemTime` 实例来表示另一个固定的时间点。",
        "translate": ""
    },
    {
        "source": "Returns the system time corresponding to \"now\".",
        "suggest": "返回与 \"now\" 相对应的系统时间。",
        "translate": ""
    },
    {
        "source": "Returns the amount of time elapsed from an earlier point in time.",
        "suggest": "返回从较早的时间点过去的时间量。",
        "translate": ""
    },
    {
        "source": "This function may fail because measurements taken earlier are not guaranteed to always be before later measurements (due to anomalies such as the system clock being adjusted either forwards or backwards).",
        "suggest": "此函数可能会失败，因为不能保证早先进行的测量总是在以后进行之前 (由于异常，例如向前或向后调整系统时钟)。",
        "translate": ""
    },
    {
        "source": "can be used to measure elapsed time without this risk of failure.",
        "suggest": "可以用来测量经过的时间，而不会出现这种失败的风险。",
        "translate": ""
    },
    {
        "source": "If successful, [`Ok`]`(`[`Duration`]`)` is returned where the duration represents the amount of time elapsed from the specified measurement to this one.",
        "suggest": "如果成功，则返回 [`Ok`]`(`[`Duration`]`)`，其中持续时间表示从指定的度量到此度量所经过的时间。",
        "translate": ""
    },
    {
        "source": "Returns an [`Err`] if `earlier` is later than `self`, and the error contains how far from `self` the time is.",
        "suggest": "如果 `earlier` 晚于 `self`，则返回 [`Err`]，并且该错误包含时间与 `self` 的距离。",
        "translate": ""
    },
    {
        "source": "Returns the difference between the clock time when this system time was created, and the current clock time.",
        "suggest": "返回创建此系统时间时的时钟时间与当前时钟时间之间的差。",
        "translate": ""
    },
    {
        "source": "This function may fail as the underlying system clock is susceptible to drift and updates (e.g., the system clock could go backwards), so this function may not always succeed.",
        "suggest": "由于底层系统时钟易于漂移和更新 (例如，系统时钟可能倒退)，因此该函数可能会失败，因此此函数可能并不总是成功。",
        "translate": ""
    },
    {
        "source": "If successful, [`Ok`]`(`[`Duration`]`)` is returned where the duration represents the amount of time elapsed from this time measurement to the current time.",
        "suggest": "如果成功，则返回 [`Ok`]`(`[`Duration`]`)`，其中持续时间表示从该时间测量到当前时间所经过的时间。",
        "translate": ""
    },
    {
        "source": "To measure elapsed time reliably, use [`Instant`] instead.",
        "suggest": "为了可靠地测量经过时间，请改用 [`Instant`]。",
        "translate": ""
    },
    {
        "source": "Returns an [`Err`] if `self` is later than the current system time, and the error contains how far from the current system time `self` is.",
        "suggest": "如果 `self` 晚于当前系统时间，则返回 [`Err`]，并且错误包含距当前系统时间 `self` 多远的时间。",
        "translate": ""
    },
    {
        "source": "Returns `Some(t)` where `t` is the time `self + duration` if `t` can be represented as `SystemTime` (which means it's inside the bounds of the underlying data structure), `None` otherwise.",
        "suggest": "如果 `t` 可以表示为 `SystemTime` (表示它在基础数据结构体的边界之内)，则返回 `Some(t)`，其中 `t` 是 `self + duration` 的时间，否则返回 `None`。",
        "translate": ""
    },
    {
        "source": "Returns `Some(t)` where `t` is the time `self - duration` if `t` can be represented as `SystemTime` (which means it's inside the bounds of the underlying data structure), `None` otherwise.",
        "suggest": "如果 `t` 可以表示为 `SystemTime` (表示它在基础数据结构体的边界之内)，则返回 `Some(t)`，其中 `t` 是 `self - duration` 的时间，否则返回 `None`。",
        "translate": ""
    },
    {
        "source": "See [`SystemTime::checked_add`] for a version without panic.",
        "suggest": "没有 panic 的版本，请参见 [`SystemTime::checked_add`]。",
        "translate": ""
    },
    {
        "source": "Using `duration_since` on an existing [`SystemTime`] instance can tell how far away from this point in time a measurement lies, and using `UNIX_EPOCH + duration` can be used to create a [`SystemTime`] instance to represent another fixed point in time.",
        "suggest": "在现有的 [`SystemTime`] 实例上使用 `duration_since` 可以告诉您测量距离该时间点有多远，并且可以使用 `UNIX_EPOCH + duration` 创建一个 [`SystemTime`] 实例来表示另一个固定的时间点。",
        "translate": ""
    },
    {
        "source": "Returns the positive duration which represents how far forward the second system time was from the first.",
        "suggest": "返回正时长，它表示第二个系统时间与第一个系统时间相距多远。",
        "translate": ""
    },
    {
        "source": "A `SystemTimeError` is returned from the [`SystemTime::duration_since`] and [`SystemTime::elapsed`] methods whenever the second system time represents a point later in time than the `self` of the method call.",
        "suggest": "每当第二个系统时间表示的时间晚于调用方法的 `self` 的时间点时，就会从 [`SystemTime::duration_since`] 和 [`SystemTime::elapsed`] 方法返回 `SystemTimeError`。",
        "translate": ""
    },
    {
        "source": "When HOME is not set, some platforms return `None`, but others return `Some` with a default.",
        "suggest": "如果未设置 HOME，则某些平台将返回 `None`，而其他平台将返回默认值 `Some`。",
        "translate": ""
    },
    {
        "source": "Just check that it is not \"/home/MountainView\".",
        "suggest": "只要检查一下它是否不是 \"/home/MountainView\"。",
        "translate": ""
    },
    {
        "source": "These tests just check that the macros are available in libstd.",
        "suggest": "这些测试只是检查宏在 libstd 中是否可用。",
        "translate": ""
    },
    {
        "source": "the below is the set of features we can test at runtime, but don't actually use to gate anything and are thus not part of the X86_ALLOWED_FEATURES list",
        "suggest": "以下是我们可以在运行时测试的功能集，但实际上并未使用任何功能，因此不属于 X86_ALLOWED_FEATURES 列表",
        "translate": ""
    },
    {
        "source": "this is a synonym for lzcnt but we test it anyways",
        "suggest": "这是 lzcnt 的同义词，但我们还是要对其进行测试",
        "translate": ""
    },
    {
        "source": "the below is in alphabetical order and matches the order of X86_ALLOWED_FEATURES in rustc_codegen_ssa's target_features.rs",
        "suggest": "下面是按字母顺序排列的，并且与 rustc_codegen_ssa 的 target_features.rs 中的 X86_ALLOWED_FEATURES 的顺序匹配",
        "translate": ""
    },
    {
        "source": "Implementation of the `#[assert_instr]` macro",
        "suggest": "`#[assert_instr]` 宏的实现",
        "translate": ""
    },
    {
        "source": "This macro is used when testing the `stdarch` crate and is used to generate test cases to assert that functions do indeed contain the instructions that we're expecting them to contain.",
        "suggest": "在测试 `stdarch` crate 时使用此宏，并用于生成测试用例以断言函数确实包含我们期望它们包含的指令。",
        "translate": ""
    },
    {
        "source": "The procedural macro here is relatively simple, it simply appends a `#[test]` function to the original token stream which asserts that the function itself contains the relevant instruction.",
        "suggest": "这里的过程宏相对简单，它只是将 `#[test]` 函数附加到原始 token 流中，断言该函数本身包含相关指令。",
        "translate": ""
    },
    {
        "source": "Disable assert_instr for x86 targets compiled with avx enabled, which causes LLVM to generate different intrinsics that the ones we are testing for.",
        "suggest": "对于启用了 avx 的 x86 目标，请禁用 assert_instr，这将导致 LLVM 生成我们要测试的内联函数。",
        "translate": ""
    },
    {
        "source": "If instruction tests are disabled avoid emitting this shim at all, just return the original item without our attribute.",
        "suggest": "如果禁用了指令测试，则完全不要发出此填充码，只需返回没有我们属性的原始项即可。",
        "translate": ""
    },
    {
        "source": "These name has to be unique enough for us to find it in the disassembly later on:",
        "suggest": "这些名称必须足够独特，以便我们稍后在反汇编中找到它:",
        "translate": ""
    },
    {
        "source": "Use an ABI on Windows that passes SIMD values in registers, like what happens on Unix (I think?) by default.",
        "suggest": "在 Windows 上使用 ABI 来传递寄存器中的 SIMD 值，就像默认情况下在 Unix 上发生的事情 (我认为是) 一样。",
        "translate": ""
    },
    {
        "source": "The compiler in optimized mode by default runs a pass called \"mergefunc\" where it'll merge functions that look identical.",
        "suggest": "默认情况下，处于优化模式的编译器运行一个名为 \"mergefunc\" 的过程，在此过程中它将合并看起来相同的函数。",
        "translate": ""
    },
    {
        "source": "Turns out some intrinsics produce identical code and they're folded together, meaning that one just jumps to another.",
        "suggest": "事实证明，某些内联函数会生成相同的代码，并将它们折叠在一起，这意味着一个内联函数会跳转到另一个。",
        "translate": ""
    },
    {
        "source": "This messes up our inspection of the disassembly of this function and we're not a huge fan of that.",
        "suggest": "这弄乱了我们对该函数的反汇编的检查，我们不是对此的忠实拥护者。",
        "translate": ""
    },
    {
        "source": "To thwart this pass and prevent functions from being merged we generate some code that's hopefully very tight in terms of codegen but is otherwise unique to prevent code from being folded.",
        "suggest": "为了阻止此传递并防止函数被合并，我们生成了一些代码，希望这些代码在代码生成方面非常严格，但在其他方面还是独一无二的，以防止代码被折叠。",
        "translate": ""
    },
    {
        "source": "This is avoided on Wasm32 right now since these functions aren't inlined which breaks our tests since each intrinsic looks like it calls functions.",
        "suggest": "现在在 Wasm32 上避免了这种情况，因为没有内联这些函数，因为每个内联函数看起来都像调用函数一样，这破坏了我们的测试。",
        "translate": ""
    },
    {
        "source": "Turns out functions aren't similar enough to get merged on wasm32 anyway.",
        "suggest": "事实证明，函数的相似性还不足以在 wasm32 上进行合并。",
        "translate": ""
    },
    {
        "source": "This bug is tracked at rust-lang/rust#74320.",
        "suggest": "在 rust-lang/rust#74320 处跟踪此错误。",
        "translate": ""
    },
    {
        "source": "Used to tell our `#[assert_instr]` annotations that all simd intrinsics are available to test their codegen, since some are gated behind an extra `-Ctarget-feature=+unimplemented-simd128` that doesn't have any equivalent in `#[target_feature]` right now.",
        "suggest": "用来告诉我们的 `#[assert_instr]` 批注，所有 simd 内联函数都可以用来测试其代码生成，因为其中一些是封闭在当前 `#[target_feature]` 中没有任何等效项的额外 `-Ctarget-feature=+unimplemented-simd128` 后面的。",
        "translate": ""
    },
    {
        "source": "Rust's core library architecture-specific intrinsics",
        "suggest": "Rust 的核心库体系结构特定的内联函数",
        "translate": ""
    },
    {
        "source": "The `core::arch` module implements architecture-dependent intrinsics (e.g. SIMD).",
        "suggest": "`core::arch` 模块实现了与体系结构相关的内联函数 (例如 SIMD)。",
        "translate": ""
    },
    {
        "source": "is available as part of `libcore` and it is re-exported by `libstd`.",
        "suggest": "可作为 `libcore` 的一部分获得，并由 `libstd` 重导出。",
        "translate": ""
    },
    {
        "source": "Prefer using it via `core::arch` or `std::arch` than via this crate.",
        "suggest": "与通过此 crate 相比，更喜欢通过 `core::arch` 或 `std::arch` 使用它。",
        "translate": ""
    },
    {
        "source": "Unstable features are often available in nightly Rust via the `feature(stdsimd)`.",
        "suggest": "不稳定的特性通常可通过 `feature(stdsimd)` 在每晚的 Rust 中获得。",
        "translate": ""
    },
    {
        "source": "Using `core::arch` via this crate requires nightly Rust, and it can (and does) break often.",
        "suggest": "通过此 crate 使用 `core::arch` 需要每晚执行 Rust，并且它可能 (并且确实) 经常中断。",
        "translate": ""
    },
    {
        "source": "The only cases in which you should consider using it via this crate are:",
        "suggest": "您应该考虑通过此 crate 使用它的唯一情况是:",
        "translate": ""
    },
    {
        "source": "if you need to re-compile `core::arch` yourself, e.g., with particular target-features enabled that are not enabled for `libcore`/`libstd`.",
        "suggest": "如果您需要自己重新编译 `core::arch`，例如，启用了 `libcore`/`libstd` 未启用的特定目标功能。",
        "translate": ""
    },
    {
        "source": "if you need to re-compile it for a non-standard target, please prefer using `xargo` and re-compiling `libcore`/`libstd` as appropriate instead of using this crate.",
        "suggest": "如果您需要针对非标准目标重新编译它，请优先使用 `xargo` 并根据需要重新编译 `libcore`/`libstd`，而不要使用此 crate。",
        "translate": ""
    },
    {
        "source": "using some features that might not be available even behind unstable Rust features.",
        "suggest": "使用某些即使在不稳定的 Rust 功能之后也可能无法使用的功能。",
        "translate": ""
    },
    {
        "source": "We try to keep these to a minimum.",
        "suggest": "我们尝试将这些限制降至最低。",
        "translate": ""
    },
    {
        "source": "If you need to use some of these features, please open an issue so that we can expose them in nightly Rust and you can use them from there.",
        "suggest": "如果您需要使用其中一些功能，请打开一个问题，以便我们可以在每晚的 Rust 中公开它们，然后从那里开始使用它们。",
        "translate": ""
    },
    {
        "source": "is primarily distributed under the terms of both the MIT license and the Apache License (Version 2.0), with portions covered by various BSD-like licenses.",
        "suggest": "主要根据 MIT 许可证和 Apache 许可证 (版本 2.0) 的条款进行分发，部分内容由各种类似 BSD 的许可证涵盖。",
        "translate": ""
    },
    {
        "source": "See LICENSE-APACHE, and LICENSE-MIT for details.",
        "suggest": "有关详细信息，请参见 LICENSE-APACHE 和 LICENSE-MIT。",
        "translate": ""
    },
    {
        "source": "Unless you explicitly state otherwise, any contribution intentionally submitted for inclusion in `core_arch` by you, as defined in the Apache-2.0 license, shall be dual licensed as above, without any additional terms or conditions.",
        "suggest": "除非您明确声明，否则您有意提交的任何捐赠 (按照 Apache-2.0 许可的定义) 都应包含在 `core_arch` 中，并且应具有上述双重许可权利，且无任何其他条款或条件。",
        "translate": ""
    },
    {
        "source": "single round checksum for quad words (64 bits).",
        "suggest": "四字 (64 位) 的单轮校验和。",
        "translate": ""
    },
    {
        "source": "CRC32-C single round checksum for quad words (64 bits).",
        "suggest": "四字 (64 位) 的 CRC32-C 单回合校验和。",
        "translate": ""
    },
    {
        "source": "The reference for NEON is [ARM's NEON Intrinsics Reference][arm_ref].",
        "suggest": "NEON 的引用为 [ARM's NEON Intrinsics Reference][arm_ref]。",
        "translate": ""
    },
    {
        "source": "The [ARM's NEON Intrinsics Online Database][arm_dat] is also useful.",
        "suggest": "[ARM 的 NEON Intrinsics 在线数据库][arm_dat] 也很有用。",
        "translate": ""
    },
    {
        "source": "Generates the trap instruction `BRK 1`",
        "suggest": "生成陷阱指令 `BRK 1`",
        "translate": ""
    },
    {
        "source": "This code is automatically generated.",
        "suggest": "此代码是自动生成的。",
        "translate": ""
    },
    {
        "source": "DO NOT MODIFY.",
        "suggest": "请勿修改。",
        "translate": ""
    },
    {
        "source": "Instead, modify `crates/stdarch-gen/neon.spec` and run the following command to re-generate this file:",
        "suggest": "而是，修改 `crates/stdarch-gen/neon.spec` 并运行以下命令以重新生成此文件:",
        "translate": ""
    },
    {
        "source": "Compare bitwise Equal (vector)",
        "suggest": "比较按位等于 (vector)",
        "translate": ""
    },
    {
        "source": "Floating-point compare equal",
        "suggest": "浮点比较相等",
        "translate": ""
    },
    {
        "source": "Compare signed greater than",
        "suggest": "比较有符号大于",
        "translate": ""
    },
    {
        "source": "Compare unsigned highe",
        "suggest": "比较无符号的高",
        "translate": ""
    },
    {
        "source": "Floating-point compare greater than",
        "suggest": "浮点比较大于",
        "translate": ""
    },
    {
        "source": "Compare signed less than",
        "suggest": "比较有符号少于",
        "translate": ""
    },
    {
        "source": "Compare unsigned less than",
        "suggest": "比较无符号小于",
        "translate": ""
    },
    {
        "source": "Floating-point compare less than",
        "suggest": "浮点比较小于",
        "translate": ""
    },
    {
        "source": "Compare signed less than or equal",
        "suggest": "比较有符号的小于或等于",
        "translate": ""
    },
    {
        "source": "Compare unsigned less than or equal",
        "suggest": "比较无符号小于或等于",
        "translate": ""
    },
    {
        "source": "Floating-point compare less than or equal",
        "suggest": "浮点比较小于或等于",
        "translate": ""
    },
    {
        "source": "Compare signed greater than or equal",
        "suggest": "比较有符号大于或等于",
        "translate": ""
    },
    {
        "source": "Compare unsigned greater than or equal",
        "suggest": "比较无符号大于或等于",
        "translate": ""
    },
    {
        "source": "Floating-point compare greater than or equal",
        "suggest": "浮点比较大于或等于",
        "translate": ""
    },
    {
        "source": "Maximum (vector)",
        "suggest": "最大 (vector)",
        "translate": ""
    },
    {
        "source": "Minimum (vector)",
        "suggest": "最小 (vector)",
        "translate": ""
    },
    {
        "source": "ASIMD intrinsics",
        "suggest": "ASIMD 内联函数",
        "translate": ""
    },
    {
        "source": "replace neon with asimd",
        "suggest": "用 asimd 替换霓虹灯",
        "translate": ""
    },
    {
        "source": "ARM-specific 64-bit wide vector of one packed `f64`.",
        "suggest": "一个包装的 `f64` 的特定于分区的 64 位宽 vector。",
        "translate": ""
    },
    {
        "source": "check this!",
        "suggest": "检查一下!",
        "translate": ""
    },
    {
        "source": "ARM-specific 128-bit wide vector of two packed `f64`.",
        "suggest": "两个包装的 `f64` 的特定于分区的 128 位宽的 vector。",
        "translate": ""
    },
    {
        "source": "ARM-specific type containing two `int8x16_t` vectors.",
        "suggest": "包含两个 `int8x16_t` vectors 的特定于分区的类型。",
        "translate": ""
    },
    {
        "source": "ARM-specific type containing three `int8x16_t` vectors.",
        "suggest": "包含三个 `int8x16_t` vectors 的特定于分区的类型。",
        "translate": ""
    },
    {
        "source": "ARM-specific type containing four `int8x16_t` vectors.",
        "suggest": "包含四个 `int8x16_t` vectors 的特定于分区的类型。",
        "translate": ""
    },
    {
        "source": "ARM-specific type containing two `uint8x16_t` vectors.",
        "suggest": "包含两个 `uint8x16_t` vectors 的特定于分区的类型。",
        "translate": ""
    },
    {
        "source": "ARM-specific type containing three `uint8x16_t` vectors.",
        "suggest": "包含三个 `uint8x16_t` vectors 的特定于分区的类型。",
        "translate": ""
    },
    {
        "source": "ARM-specific type containing four `uint8x16_t` vectors.",
        "suggest": "包含四个 `uint8x16_t` vectors 的特定于分区的类型。",
        "translate": ""
    },
    {
        "source": "ARM-specific type containing two `poly8x16_t` vectors.",
        "suggest": "包含两个 `poly8x16_t` vectors 的特定于分区的类型。",
        "translate": ""
    },
    {
        "source": "ARM-specific type containing three `poly8x16_t` vectors.",
        "suggest": "包含三个 `poly8x16_t` vectors 的特定于分区的类型。",
        "translate": ""
    },
    {
        "source": "ARM-specific type containing four `poly8x16_t` vectors.",
        "suggest": "包含四个 `poly8x16_t` vectors 的特定于分区的类型。",
        "translate": ""
    },
    {
        "source": "absolute value",
        "suggest": "绝对值",
        "translate": ""
    },
    {
        "source": "Load multiple single-element structures to one, two, three, or four registers.",
        "suggest": "将多个单一元素结构加载到一个，两个，三个或四个寄存器中。",
        "translate": ""
    },
    {
        "source": "Absolute Value (wrapping).",
        "suggest": "绝对值 (wrapping)。",
        "translate": ""
    },
    {
        "source": "Signed saturating Accumulate of Unsigned value.",
        "suggest": "有符号的饱和无符号值的累加。",
        "translate": ""
    },
    {
        "source": "Unsigned saturating Accumulate of Signed value.",
        "suggest": "无符号饱和的有符号值的累加。",
        "translate": ""
    },
    {
        "source": "Add pairwise",
        "suggest": "逐对添加",
        "translate": ""
    },
    {
        "source": "Add across vector",
        "suggest": "跨 vector 加",
        "translate": ""
    },
    {
        "source": "Polynomial multiply long",
        "suggest": "多项式乘长",
        "translate": ""
    },
    {
        "source": "Vector add.",
        "suggest": "Vector add。",
        "translate": ""
    },
    {
        "source": "Horizontal vector max.",
        "suggest": "水平 vector 最大值。",
        "translate": ""
    },
    {
        "source": "Horizontal vector min.",
        "suggest": "水平 vector 最小值",
        "translate": ""
    },
    {
        "source": "Folding minimum of adjacent pairs",
        "suggest": "相邻对的最小折叠",
        "translate": ""
    },
    {
        "source": "Folding maximum of adjacent pairs",
        "suggest": "相邻对的最大折叠",
        "translate": ""
    },
    {
        "source": "Vector combine",
        "suggest": "Vector 结合",
        "translate": ""
    },
    {
        "source": "Table look-up",
        "suggest": "查表",
        "translate": ""
    },
    {
        "source": "Extended table look-up",
        "suggest": "扩展表查询",
        "translate": ""
    },
    {
        "source": "Floating-point Convert to Unsigned fixed-point, rounding toward Zero (vector)",
        "suggest": "浮点转换为无符号定点，四舍五入为 (vector)",
        "translate": ""
    },
    {
        "source": "Shift Left and Insert (immediate)",
        "suggest": "左移并插入 (immediate)",
        "translate": ""
    },
    {
        "source": "Shift Right and Insert (immediate)",
        "suggest": "右移并插入 (immediate)",
        "translate": ""
    },
    {
        "source": "I've a hard time writing a test for this as the documentation from arm is a bit thin as to waht exactly it does",
        "suggest": "我很难为此编写测试，因为 arm 的文档确实有点薄",
        "translate": ""
    },
    {
        "source": "poly32x4 does not exist, and neither does vcombine_p32",
        "suggest": "poly32x4 不存在，vcombine_p32 也不存在",
        "translate": ""
    },
    {
        "source": "See [`prefetch`](fn._prefetch.html).",
        "suggest": "请参见 [`prefetch`](fn._prefetch.html)。",
        "translate": ""
    },
    {
        "source": "Fetch the cache line that contains address `p` using the given `rw` and `locality`.",
        "suggest": "使用给定的 `rw` 和 `locality` 获取包含地址 `p` 的缓存行。",
        "translate": ""
    },
    {
        "source": "The `rw` must be one of:",
        "suggest": "`rw` 必须是以下之一:",
        "translate": ""
    },
    {
        "source": "the prefetch is preparing for a read.",
        "suggest": "预取正在准备读取。",
        "translate": ""
    },
    {
        "source": "the prefetch is preparing for a write.",
        "suggest": "预取正在准备写操作。",
        "translate": ""
    },
    {
        "source": "The `locality` must be one of:",
        "suggest": "`locality` 必须是以下之一:",
        "translate": ""
    },
    {
        "source": "Streaming or non-temporal prefetch, for data that is used only once.",
        "suggest": "流或非时间预取，用于仅使用一次的数据。",
        "translate": ""
    },
    {
        "source": "Fetch into level 3 cache.",
        "suggest": "提取到 3 级缓存中。",
        "translate": ""
    },
    {
        "source": "Fetch into level 2 cache.",
        "suggest": "提取到 2 级缓存中。",
        "translate": ""
    },
    {
        "source": "Fetch into level 1 cache.",
        "suggest": "提取到 1 级缓存中。",
        "translate": ""
    },
    {
        "source": "The prefetch memory instructions signal to the memory system that memory accesses from a specified address are likely to occur in the near future.",
        "suggest": "预取存储器指令向存储器系统发送信号，表明从指定地址进行的存储器访问可能发生在 future 附近。",
        "translate": ""
    },
    {
        "source": "The memory system can respond by taking actions that are expected to speed up the memory access when they do occur, such as preloading the specified address into one or more caches.",
        "suggest": "内存系统可以通过采取某些措施来做出响应，这些措施可以在确实发生时加快内存访问的速度，例如将指定地址预加载到一个或多个高速缓存中。",
        "translate": ""
    },
    {
        "source": "Because these signals are only hints, it is valid for a particular CPU to treat any or all prefetch instructions as a NOP.",
        "suggest": "因为这些信号只是提示，所以对于特定的 CPU，将任何或所有预取指令视为 NOP 是有效的。",
        "translate": ""
    },
    {
        "source": "We use the `llvm.prefetch` instrinsic with `cache type` = 1 (data cache).",
        "suggest": "我们将 `llvm.prefetch` 内部使用 `cache type` =1 (数据缓存)。",
        "translate": ""
    },
    {
        "source": "and `strategy` are based on the function parameters.",
        "suggest": "和 `strategy` 基于函数参数。",
        "translate": ""
    },
    {
        "source": "ARM's Transactional Memory Extensions (TME).",
        "suggest": "分支的事务性内存扩展 (TME)。",
        "translate": ""
    },
    {
        "source": "This CPU feature is available on Aarch64 - A architecture profile.",
        "suggest": "Aarch64 - 体系结构配置文件上提供了此 CPU 功能。",
        "translate": ""
    },
    {
        "source": "This feature is in the non-neon feature set.",
        "suggest": "此功能在非霓虹灯功能集中。",
        "translate": ""
    },
    {
        "source": "TME specific vendor documentation can be found [TME Intrinsics Introduction][tme_intrinsics_intro].",
        "suggest": "可以在 [TME Intrinsics 介绍][tme_intrinsics_intro] 上找到 TME 特定的供应商文档。",
        "translate": ""
    },
    {
        "source": "The reference is [ACLE Q4 2019][acle_q4_2019_ref].",
        "suggest": "引用的是 [ACLE Q4 2019][acle_q4_2019_ref]。",
        "translate": ""
    },
    {
        "source": "ACLE has a section for TME extensions and state masks for aborts and failure codes.",
        "suggest": "ACLE 有一个用于 TME 扩展的部分，以及用于中止和故障代码的状态掩码的部分。",
        "translate": ""
    },
    {
        "source": "also describes possible failure code scenarios.",
        "suggest": "还介绍了可能的故障代码方案。",
        "translate": ""
    },
    {
        "source": "Transaction successfully started.",
        "suggest": "事务成功开始。",
        "translate": ""
    },
    {
        "source": "Extraction mask for failure reason",
        "suggest": "故障原因的提取码",
        "translate": ""
    },
    {
        "source": "Transaction retry is possible.",
        "suggest": "事务重试是可能的。",
        "translate": ""
    },
    {
        "source": "Transaction executed a TCANCEL instruction",
        "suggest": "事务执行了 TCANCEL 指令",
        "translate": ""
    },
    {
        "source": "Transaction aborted because a conflict occurred",
        "suggest": "事务因发生冲突而中止",
        "translate": ""
    },
    {
        "source": "Fallback error type for any other reason",
        "suggest": "后备错误类型 (由于任何其他原因)",
        "translate": ""
    },
    {
        "source": "Transaction aborted because a non-permissible operation was attempted",
        "suggest": "事务中止，因为尝试了不允许的操作",
        "translate": ""
    },
    {
        "source": "Transaction aborted due to read or write set limit was exceeded",
        "suggest": "事务由于超出读或写集限制而中止",
        "translate": ""
    },
    {
        "source": "Transaction aborted due to transactional nesting level was exceeded",
        "suggest": "由于超出了事务嵌套级别，事务中止了",
        "translate": ""
    },
    {
        "source": "Transaction aborted due to a debug trap.",
        "suggest": "事务由于调试陷阱而中止。",
        "translate": ""
    },
    {
        "source": "Transaction failed from interrupt",
        "suggest": "事务因中断而失败",
        "translate": ""
    },
    {
        "source": "Indicates a TRIVIAL version of TM is available",
        "suggest": "表示 TM 的试用版可用",
        "translate": ""
    },
    {
        "source": "Starts a new transaction.",
        "suggest": "开始新的事务。",
        "translate": ""
    },
    {
        "source": "When the transaction starts successfully the return value is 0.",
        "suggest": "事务成功启动后，返回值为 0。",
        "translate": ""
    },
    {
        "source": "If the transaction fails, all state modifications are discarded and a cause of the failure is encoded in the return value.",
        "suggest": "如果事务失败，则将丢弃所有状态修改，并将失败原因编码在返回值中。",
        "translate": ""
    },
    {
        "source": "Commits the current transaction.",
        "suggest": "提交当前事务。",
        "translate": ""
    },
    {
        "source": "For a nested transaction, the only effect is that the transactional nesting depth is decreased.",
        "suggest": "对于嵌套事务，唯一的效果是减少了事务嵌套深度。",
        "translate": ""
    },
    {
        "source": "For an outer transaction, the state modifications performed transactionally are committed to the architectural state.",
        "suggest": "对于外部事务，将事务执行的状态修改提交给体系结构状态。",
        "translate": ""
    },
    {
        "source": "Cancels the current transaction and discards all state modifications that were performed transactionally.",
        "suggest": "取消当前事务，并放弃所有通过事务执行的状态修改。",
        "translate": ""
    },
    {
        "source": "Tests if executing inside a transaction.",
        "suggest": "测试是否在事务内执行。",
        "translate": ""
    },
    {
        "source": "If no transaction is currently executing, the return value is 0.",
        "suggest": "如果当前没有事务在执行，则返回值为 0。",
        "translate": ""
    },
    {
        "source": "Otherwise, this intrinsic returns the depth of the transaction.",
        "suggest": "否则，此内联函数将返回事务的深度。",
        "translate": ""
    },
    {
        "source": "The reference is [ARMv8-A Reference Manual][armv8].",
        "suggest": "引用的是 [ARMv8-A 参考手册][armv8]。",
        "translate": ""
    },
    {
        "source": "Reverse the order of the bytes.",
        "suggest": "颠倒字节顺序。",
        "translate": ""
    },
    {
        "source": "Count Leading Zeros.",
        "suggest": "计算前导零。",
        "translate": ""
    },
    {
        "source": "Reverse the bit order.",
        "suggest": "反转位顺序。",
        "translate": ""
    },
    {
        "source": "Counts the leading most significant bits set.",
        "suggest": "计算前导最高有效位集。",
        "translate": ""
    },
    {
        "source": "When all bits of the operand are set it returns the size of the operand in bits.",
        "suggest": "设置操作数的所有位后，它将返回操作数的大小 (以位为单位)。",
        "translate": ""
    },
    {
        "source": "Access types available on all architectures",
        "suggest": "所有架构上可用的访问类型",
        "translate": ""
    },
    {
        "source": "Full system is the required shareability domain, reads and writes are the required access types",
        "suggest": "完整的系统是必需的可共享性域，读写是必需的访问类型",
        "translate": ""
    },
    {
        "source": "Reference: ARM11 MPCore Processor Technical Reference Manual (ARM DDI 0360E) Section 3.5 \"Summary of CP15 instructions\"",
        "suggest": "引用: ARM11 MPCore 处理器技术引用手册 (ARM DDI 0360E) 3.5 \"Summary of CP15 instructions\" 节",
        "translate": ""
    },
    {
        "source": "Reference: Section 7.4 \"Hints\" of ACLE",
        "suggest": "引用: ACLE 的 7.4 \"Hints\" 部分",
        "translate": ""
    },
    {
        "source": "Dedicated instructions",
        "suggest": "专用说明",
        "translate": ""
    },
    {
        "source": "Generates a DMB (data memory barrier) instruction or equivalent CP15 instruction.",
        "suggest": "生成 DMB (数据存储屏障) 指令或等效的 CP15 指令。",
        "translate": ""
    },
    {
        "source": "DMB ensures the observed ordering of memory accesses.",
        "suggest": "DMB 确保观察到的内存访问顺序。",
        "translate": ""
    },
    {
        "source": "Memory accesses of the specified type issued before the DMB are guaranteed to be observed (in the specified scope) before memory accesses issued after the DMB.",
        "suggest": "确保在 DMB 之后发出的内存访问之前 (指定的作用域中) 观察到 DMB 之前发出的指定类型的内存访问。",
        "translate": ""
    },
    {
        "source": "For example, DMB should be used between storing data, and updating a flag variable that makes that data available to another core.",
        "suggest": "例如，应在存储数据和更新标志变量之间使用 DMB，该标志变量使该数据可用于另一个内核。",
        "translate": ""
    },
    {
        "source": "The __dmb() intrinsic also acts as a compiler memory barrier of the appropriate type.",
        "suggest": "__dmb() 内联函数还充当适当类型的编译器内存屏障。",
        "translate": ""
    },
    {
        "source": "Generates a DSB (data synchronization barrier) instruction or equivalent CP15 instruction.",
        "suggest": "生成 DSB (数据同步屏障) 指令或等效的 CP15 指令。",
        "translate": ""
    },
    {
        "source": "DSB ensures the completion of memory accesses.",
        "suggest": "DSB 确保完成内存访问。",
        "translate": ""
    },
    {
        "source": "A DSB behaves as the equivalent DMB and has additional properties.",
        "suggest": "DSB 的行为等同于 DMB，并具有其他属性。",
        "translate": ""
    },
    {
        "source": "After a DSB instruction completes, all memory accesses of the specified type issued before the DSB are guaranteed to have completed.",
        "suggest": "DSB 指令完成后，保证在 DSB 之前发出的所有指定类型的内存访问都已完成。",
        "translate": ""
    },
    {
        "source": "The __dsb() intrinsic also acts as a compiler memory barrier of the appropriate type.",
        "suggest": "__dsb() 内联函数还充当适当类型的编译器内存屏障。",
        "translate": ""
    },
    {
        "source": "Generates an ISB (instruction synchronization barrier) instruction or equivalent CP15 instruction.",
        "suggest": "生成一个 ISB (指令同步屏障) 指令或等效的 CP15 指令。",
        "translate": ""
    },
    {
        "source": "This instruction flushes the processor pipeline fetch buffers, so that following instructions are fetched from cache or memory.",
        "suggest": "此指令刷新处理器管道提取缓冲区，以便从高速缓存或内存中提取后续指令。",
        "translate": ""
    },
    {
        "source": "An ISB is needed after some system maintenance operations.",
        "suggest": "在进行一些系统维护操作后，需要一个 ISB。",
        "translate": ""
    },
    {
        "source": "An ISB is also needed before transferring control to code that has been loaded or modified in memory, for example by an overlay mechanism or just-in-time code generator.",
        "suggest": "在将控制权转移到已在内存中加载或修改的代码之前 (例如通过覆盖机制或即时代码生成器)，还需要 ISB。",
        "translate": ""
    },
    {
        "source": "(Note that if instruction and data caches are separate, privileged cache maintenance operations would be needed in order to unify the caches.)",
        "suggest": "(请注意，如果指令缓存和数据缓存是分开的，则需要权限缓存维护操作来统一缓存。)",
        "translate": ""
    },
    {
        "source": "The only supported argument for the __isb() intrinsic is 15, corresponding to the SY (full system) scope of the ISB instruction.",
        "suggest": "__isb() 内联函数唯一支持的参数是 15，对应于 ISB 指令的 SY (完整系统) 作用域。",
        "translate": ""
    },
    {
        "source": "we put these in a module to prevent weirdness with glob re-exports",
        "suggest": "我们将它们放在一个模块中，以防止全局重导出怪异",
        "translate": ""
    },
    {
        "source": "See Section 7.3  Memory barriers of ACLE",
        "suggest": "请参见第 7.3 节 `ACLE 的存储屏障`",
        "translate": ""
    },
    {
        "source": "Access types available on v7 and v8 but not on v7(E)-M or v8-M",
        "suggest": "v7 和 v8 上可用的访问类型，但在 v7(E)-M 或 v8-M 上不可用",
        "translate": ""
    },
    {
        "source": "Full system is the required shareability domain, writes are the required access type",
        "suggest": "完整的系统是必需的共享域，写入是必需的访问类型",
        "translate": ""
    },
    {
        "source": "Inner Shareable is the required shareability domain, reads and writes are the required access types",
        "suggest": "内部共享是必需的共享域，读写是必需的访问类型",
        "translate": ""
    },
    {
        "source": "Inner Shareable is the required shareability domain, writes are the required access type",
        "suggest": "内部共享是必需的共享域，写入是必需的访问类型",
        "translate": ""
    },
    {
        "source": "Non-shareable is the required shareability domain, reads and writes are the required access types",
        "suggest": "不可共享是必需的共享域，读写是必需的访问类型",
        "translate": ""
    },
    {
        "source": "Non-shareable is the required shareability domain, writes are the required access type",
        "suggest": "不可共享是必需的共享域，写入是必需的访问类型",
        "translate": ""
    },
    {
        "source": "Outer Shareable is the required shareability domain, reads and writes are the required access types",
        "suggest": "外部共享是必需的共享域，读写是必需的访问类型",
        "translate": ""
    },
    {
        "source": "Outer Shareable is the required shareability domain, writes are the required access type",
        "suggest": "外部共享是必需的共享域，写入是必需的访问类型",
        "translate": ""
    },
    {
        "source": "Full system is the required shareability domain, reads are the required access type",
        "suggest": "完整的系统是必需的共享域，读取是必需的访问类型",
        "translate": ""
    },
    {
        "source": "Inner Shareable is the required shareability domain, reads are the required access type",
        "suggest": "内部共享是必需的共享域，读取是必需的访问类型",
        "translate": ""
    },
    {
        "source": "Non-shareable is the required shareability domain, reads are the required access type",
        "suggest": "不可共享是必需的共享域，读取是必需的访问类型",
        "translate": ""
    },
    {
        "source": "Outher Shareable is the required shareability domain, reads are the required access type",
        "suggest": "外部共享是必需的共享域，读取是必需的访问类型",
        "translate": ""
    },
    {
        "source": "Section 8.3 \"16-bit multiplications\"",
        "suggest": "8.3 \"16位乘法\" 部分",
        "translate": ""
    },
    {
        "source": "Intrinsics that could live here:",
        "suggest": "可以在这里生存的内联函数:",
        "translate": ""
    },
    {
        "source": "ARM-specific 32-bit wide vector of two packed `i16`.",
        "suggest": "两个包装的 `i16` 的特定于分区的 32 位宽 vector。",
        "translate": ""
    },
    {
        "source": "ARM-specific 32-bit wide vector of two packed `u16`.",
        "suggest": "两个包装的 `u16` 的特定于分区的 32 位宽 vector。",
        "translate": ""
    },
    {
        "source": "Insert a SMULBB instruction",
        "suggest": "插入 SMULBB 指令",
        "translate": ""
    },
    {
        "source": "Returns the equivalent of a\\[0\\] * b\\[0\\] where \\[0\\] is the lower 16 bits and \\[1\\] is the upper 16 bits.",
        "suggest": "返回 a\\[0\\] * b\\[0\\] 的等效项，其中 \\[0\\] 是低 16 位，而 \\[1\\] 是高 16 位。",
        "translate": ""
    },
    {
        "source": "Insert a SMULTB instruction",
        "suggest": "插入 SMULTB 指令",
        "translate": ""
    },
    {
        "source": "Returns the equivalent of a\\[0\\] * b\\[1\\] where \\[0\\] is the lower 16 bits and \\[1\\] is the upper 16 bits.",
        "suggest": "返回 a\\[0\\] * b\\[1\\] 的等效项，其中 \\[0\\] 是低 16 位，而 \\[1\\] 是高 16 位。",
        "translate": ""
    },
    {
        "source": "Returns the equivalent of a\\[1\\] * b\\[0\\] where \\[0\\] is the lower 16 bits and \\[1\\] is the upper 16 bits.",
        "suggest": "返回 a\\[1\\] * b\\[0\\] 的等效项，其中 \\[0\\] 是低 16 位，而 \\[1\\] 是高 16 位。",
        "translate": ""
    },
    {
        "source": "Insert a SMULTT instruction",
        "suggest": "插入 SMULTT 指令",
        "translate": ""
    },
    {
        "source": "Returns the equivalent of a\\[1\\] * b\\[1\\] where \\[0\\] is the lower 16 bits and \\[1\\] is the upper 16 bits.",
        "suggest": "返回 a\\[1\\] * b\\[1\\] 的等效项，其中 \\[0\\] 是低 16 位，而 \\[1\\] 是高 16 位。",
        "translate": ""
    },
    {
        "source": "Insert a SMULWB instruction",
        "suggest": "插入 SMULWB 指令",
        "translate": ""
    },
    {
        "source": "Multiplies the 32-bit signed first operand with the low halfword (as a 16-bit signed integer) of the second operand.",
        "suggest": "将 32 位带符号的第一个操作数与第二个操作数的低半字 (作为 16 位带符号的整数) 相乘。",
        "translate": ""
    },
    {
        "source": "Return the top 32 bits of the 48-bit product",
        "suggest": "返回 48 位乘积的高 32 位",
        "translate": ""
    },
    {
        "source": "Insert a SMULWT instruction",
        "suggest": "插入 SMULWT 指令",
        "translate": ""
    },
    {
        "source": "Multiplies the 32-bit signed first operand with the high halfword (as a 16-bit signed integer) of the second operand.",
        "suggest": "将 32 位带符号的第一个操作数与第二个操作数的高半字 (作为 16 位带符号的整数) 相乘。",
        "translate": ""
    },
    {
        "source": "Signed saturating addition",
        "suggest": "带符号的饱和加法",
        "translate": ""
    },
    {
        "source": "Returns the 32-bit saturating signed equivalent of a + b.",
        "suggest": "返回 a + b 的 32 位饱和有符号数。",
        "translate": ""
    },
    {
        "source": "Sets the Q flag if saturation occurs.",
        "suggest": "如果发生饱和，则设置 Q 标志。",
        "translate": ""
    },
    {
        "source": "Signed saturating subtraction",
        "suggest": "有符号的饱和减法",
        "translate": ""
    },
    {
        "source": "Returns the 32-bit saturating signed equivalent of a - b.",
        "suggest": "返回 a - b 的 32 位饱和有符号等效项。",
        "translate": ""
    },
    {
        "source": "Insert a QADD instruction",
        "suggest": "插入 QADD 指令",
        "translate": ""
    },
    {
        "source": "Returns the 32-bit saturating signed equivalent of a + a Sets the Q flag if saturation occurs.",
        "suggest": "返回 a + a 的 32 位饱和有符号等效项如果发生饱和，则设置 Q 标志。",
        "translate": ""
    },
    {
        "source": "Insert a SMLABB instruction",
        "suggest": "插入 SMLABB 指令",
        "translate": ""
    },
    {
        "source": "Returns the equivalent of a\\[0\\] * b\\[0\\] + c where \\[0\\] is the lower 16 bits and \\[1\\] is the upper 16 bits.",
        "suggest": "返回 a\\[0\\] * b\\[0\\] + c 的等效项，其中 \\[0\\] 是低 16 位，而 \\[1\\] 是高 16 位。",
        "translate": ""
    },
    {
        "source": "Sets the Q flag if overflow occurs on the addition.",
        "suggest": "如果加法发生溢出，则设置 Q 标志。",
        "translate": ""
    },
    {
        "source": "Insert a SMLABT instruction",
        "suggest": "插入 SMLABT 指令",
        "translate": ""
    },
    {
        "source": "Returns the equivalent of a\\[0\\] * b\\[1\\] + c where \\[0\\] is the lower 16 bits and \\[1\\] is the upper 16 bits.",
        "suggest": "返回 a\\[0\\] * b\\[1\\] + c 的等效项，其中 \\[0\\] 是低 16 位，而 \\[1\\] 是高 16 位。",
        "translate": ""
    },
    {
        "source": "Insert a SMLATB instruction",
        "suggest": "插入 SMLATB 指令",
        "translate": ""
    },
    {
        "source": "Returns the equivalent of a\\[1\\] * b\\[0\\] + c where \\[0\\] is the lower 16 bits and \\[1\\] is the upper 16 bits.",
        "suggest": "返回 a\\[1\\] * b\\[0\\] + c 的等效项，其中 \\[0\\] 是低 16 位，而 \\[1\\] 是高 16 位。",
        "translate": ""
    },
    {
        "source": "Insert a SMLATT instruction",
        "suggest": "插入 SMLATT 指令",
        "translate": ""
    },
    {
        "source": "Returns the equivalent of a\\[1\\] * b\\[1\\] + c where \\[0\\] is the lower 16 bits and \\[1\\] is the upper 16 bits.",
        "suggest": "返回 a\\[1\\] * b\\[1\\] + c 的等效项，其中 \\[0\\] 是低 16 位，而 \\[1\\] 是高 16 位。",
        "translate": ""
    },
    {
        "source": "Insert a SMLAWB instruction",
        "suggest": "插入 SMLAWB 指令",
        "translate": ""
    },
    {
        "source": "Returns the equivalent of (a * b\\[0\\] + (c << 16)) >> 16 where \\[0\\] is the lower 16 bits and \\[1\\] is the upper 16 bits.",
        "suggest": "返回 (a * b\\[0\\] + (c <<16) ) >> 16 的等效项，其中 \\[0\\] 是低 16 位，而 \\[1\\] 是高 16 位。",
        "translate": ""
    },
    {
        "source": "Insert a SMLAWT instruction",
        "suggest": "插入 SMLAWT 指令",
        "translate": ""
    },
    {
        "source": "Returns the equivalent of (a * b\\[1\\] + (c << 16)) >> 16 where \\[0\\] is the lower 16 bits and \\[1\\] is the upper 16 bits.",
        "suggest": "返回 (a * b\\[1\\] + (c <<16) ) >> 16 的等效项，其中 \\[0\\] 是低 16 位，而 \\[1\\] 是高 16 位。",
        "translate": ""
    },
    {
        "source": "Reference: Section 5.4.4 \"LDREX / STREX\" of ACLE",
        "suggest": "引用: ACLE 的 5.4.4 \"LDREX / STREX\" 部分",
        "translate": ""
    },
    {
        "source": "Removes the exclusive lock created by LDREX",
        "suggest": "删除由 LDREX 创建的排他锁",
        "translate": ""
    },
    {
        "source": "Supported: v6, v6K, v7-M, v7-A, v7-R Not supported: v5, v6-M",
        "suggest": "支持: v6，v6K，v7-M，v7-A，v7-R 不支持: v5，v6-M",
        "translate": ""
    },
    {
        "source": "there's no dedicated CLREX instruction in v6 (<v6k);",
        "suggest": "v6 (<v6k) 中没有专用的 CLREX 指令;",
        "translate": ""
    },
    {
        "source": "to clear the exclusive monitor users have to do a dummy STREX operation",
        "suggest": "清除独占监视器用户必须执行虚拟 STREX 操作",
        "translate": ""
    },
    {
        "source": "excludes v6-M",
        "suggest": "不包括 v6-M",
        "translate": ""
    },
    {
        "source": "Executes a exclusive LDR instruction for 8 bit value.",
        "suggest": "对 8 位值执行排他的 LDR 指令。",
        "translate": ""
    },
    {
        "source": "Supported: v6K, v7-M, v7-A, v7-R Not supported: v5, v6, v6-M",
        "suggest": "支持: v6K，v7-M，v7-A，v7-R 不支持: v5，v6，v6-M",
        "translate": ""
    },
    {
        "source": "includes v7-M but excludes v6-M",
        "suggest": "包括 v7-M，但不包括 v6-M",
        "translate": ""
    },
    {
        "source": "Executes a exclusive LDR instruction for 16 bit value.",
        "suggest": "对 16 位值执行排他的 LDR 指令。",
        "translate": ""
    },
    {
        "source": "Supported: v6K, v7-M, v7-A, v7-R, v8 Not supported: v5, v6, v6-M",
        "suggest": "支持: v6K，v7-M，v7-A，v7-R，v8 不支持: v5，v6，v6-M",
        "translate": ""
    },
    {
        "source": "Executes a exclusive LDR instruction for 32 bit value.",
        "suggest": "对 32 位值执行排他的 LDR 指令。",
        "translate": ""
    },
    {
        "source": "Supported: v6, v7-M, v6K, v7-A, v7-R, v8 Not supported: v5, v6-M",
        "suggest": "支援: v6，v7-M，v6K，v7-A，v7-R，v8 不支援: v5，v6-M",
        "translate": ""
    },
    {
        "source": "Executes a exclusive STR instruction for 8 bit values",
        "suggest": "对 8 位值执行独占 STR 指令",
        "translate": ""
    },
    {
        "source": "Returns `0` if the operation succeeded, or `1` if it failed",
        "suggest": "如果操作成功，则返回 `0`; 如果操作失败，则返回 `1`",
        "translate": ""
    },
    {
        "source": "supported: v6K, v7-M, v7-A, v7-R Not supported: v5, v6, v6-M",
        "suggest": "支持: v6K，v7-M，v7-A，v7-R 不支持: v5，v6，v6-M",
        "translate": ""
    },
    {
        "source": "Executes a exclusive STR instruction for 16 bit values",
        "suggest": "对 16 位值执行独占 STR 指令",
        "translate": ""
    },
    {
        "source": "Executes a exclusive STR instruction for 32 bit values",
        "suggest": "对 32 位值执行独占 STR 指令",
        "translate": ""
    },
    {
        "source": "Section 7.4 \"Hints\" of ACLE",
        "suggest": "ACLE 的 7.4 \"Hints\" 部分",
        "translate": ""
    },
    {
        "source": "Section 7.7 \"NOP\" of ACLE",
        "suggest": "ACLE 的 7.7 \"NOP\" 部分",
        "translate": ""
    },
    {
        "source": "Generates a WFI (wait for interrupt) hint instruction, or nothing.",
        "suggest": "生成 WFI (等待中断) 提示指令，或不执行任何操作。",
        "translate": ""
    },
    {
        "source": "The WFI instruction allows (but does not require) the processor to enter a low-power state until one of a number of asynchronous events occurs.",
        "suggest": "WFI 指令允许 (但不要求) 处理器进入低功耗状态，直到发生许多异步事件之一。",
        "translate": ""
    },
    {
        "source": "Section 10.1 of ACLE says that the supported arches are: 8, 6K, 6-M LLVM says \"instruction requires: armv6k\"",
        "suggest": "ACLE 的 10.1 部分说受支持的 arches是: 8、6K，6-M LLVM 说 \"instruction requires: armv6k\"",
        "translate": ""
    },
    {
        "source": "Generates a WFE (wait for event) hint instruction, or nothing.",
        "suggest": "生成 WFE (等待事件) 提示指令，否则不生成任何内容。",
        "translate": ""
    },
    {
        "source": "The WFE instruction allows (but does not require) the processor to enter a low-power state until some event occurs such as a SEV being issued by another processor.",
        "suggest": "WFE 指令允许 (但不要求) 处理器进入低功耗状态，直到发生某些事件 (例如，另一处理器发出 SEV)。",
        "translate": ""
    },
    {
        "source": "Generates a SEV (send a global event) hint instruction.",
        "suggest": "生成 SEV (发送事件) 提示指令。",
        "translate": ""
    },
    {
        "source": "This causes an event to be signaled to all processors in a multiprocessor system.",
        "suggest": "这导致事件被发送到多处理器系统中的所有处理器。",
        "translate": ""
    },
    {
        "source": "It is a NOP on a uniprocessor system.",
        "suggest": "它是单处理器系统上的 NOP。",
        "translate": ""
    },
    {
        "source": "Section 10.1 of ACLE says that the supported arches are: 8, 6K, 6-M, 7-M LLVM says \"instruction requires: armv6k\"",
        "suggest": "ACLE 的 10.1 部分说受支持的 arches是: 8，6K，6-M，7-M LLVM 说 \"instruction requires: armv6k\"",
        "translate": ""
    },
    {
        "source": "Generates a send a local event hint instruction.",
        "suggest": "生成发送本地事件提示指令。",
        "translate": ""
    },
    {
        "source": "This causes an event to be signaled to only the processor executing this instruction.",
        "suggest": "这导致仅将信号通知执行该指令的处理器。",
        "translate": ""
    },
    {
        "source": "In a multiprocessor system, it is not required to affect the other processors.",
        "suggest": "在多处理器系统中，不需要影响其他处理器。",
        "translate": ""
    },
    {
        "source": "LLVM says \"instruction requires: armv8\"",
        "suggest": "LLVM 说 \"instruction requires: armv8\"",
        "translate": ""
    },
    {
        "source": "32-bit ARMv8",
        "suggest": "32 位 ARMv8",
        "translate": ""
    },
    {
        "source": "Generates a YIELD hint instruction.",
        "suggest": "生成一条 YIELD 提示指令。",
        "translate": ""
    },
    {
        "source": "This enables multithreading software to indicate to the hardware that it is performing a task, for example a spin-lock, that could be swapped out to improve overall system performance.",
        "suggest": "这使多线程软件能够向硬件指示其正在执行任务 (例如自旋锁)，可以将其换出以提高整体系统性能。",
        "translate": ""
    },
    {
        "source": "Generates a DBG instruction.",
        "suggest": "生成 DBG 指令。",
        "translate": ""
    },
    {
        "source": "This provides a hint to debugging and related systems.",
        "suggest": "这为调试和相关系统提供了提示。",
        "translate": ""
    },
    {
        "source": "The argument must be a constant integer from 0 to 15 inclusive.",
        "suggest": "参数必须是 0 到 15 (含) 之间的常量整数。",
        "translate": ""
    },
    {
        "source": "See implementation documentation for the effect (if any) of this instruction and the meaning of the argument.",
        "suggest": "有关此指令的效果 (如果有) 和参数的含义，请参见实现文档。",
        "translate": ""
    },
    {
        "source": "This is available only when compliling for AArch32.",
        "suggest": "仅当符合 AArch32 时才可用。",
        "translate": ""
    },
    {
        "source": "Section 10.1 of ACLE says that the supported arches are: 7, 7-M \"The DBG hint instruction is added in ARMv7.",
        "suggest": "ACLE 的 10.1 部分说，支持的 arches是: 7、7-M` 在 ARMv7 中添加了 DBG 提示指令。",
        "translate": ""
    },
    {
        "source": "It is UNDEFINED in the ARMv6 base architecture, and executes as a NOP instruction in ARMv6K and ARMv6T2.\" - ARM Architecture Reference Manual ARMv7-A and ARMv7-R edition (ARM DDI 0406C.c) sections D12.4.1 \"ARM instruction set support\" and D12.4.2",
        "suggest": "它在 ARMv6 基本体系结构中是未定义的，并且在 ARMv6K 和 ARMv6T2 中作为 NOP 指令执行。`-ARM 体系结构引用手册 ARMv7-A 和 ARMv7-R 版 (ARM DDI 0406C.c) 的 D12.4.1 \"ARM instruction set support\" 和 D12.4.2 节",
        "translate": ""
    },
    {
        "source": "Generates an unspecified no-op instruction.",
        "suggest": "生成未指定的无操作指令。",
        "translate": ""
    },
    {
        "source": "Note that not all architectures provide a distinguished NOP instruction.",
        "suggest": "请注意，并非所有体系结构都提供专有的 NOP 指令。",
        "translate": ""
    },
    {
        "source": "On those that do, it is unspecified whether this intrinsic generates it or another instruction.",
        "suggest": "在执行此操作的对象上，不确定此内联函数是生成它还是其他指令。",
        "translate": ""
    },
    {
        "source": "It is not guaranteed that inserting this instruction will increase execution time.",
        "suggest": "不保证插入该指令会增加执行时间。",
        "translate": ""
    },
    {
        "source": "from LLVM 7.0.1's lib/Target/ARM/{ARMInstrThumb,ARMInstrInfo,ARMInstrThumb2}.td",
        "suggest": "来自 LLVM 7.0.1 的 lib/Target/ 分支 /{ARMInstrThumb,ARMInstrInfo,ARMInstrThumb2}.td",
        "translate": ""
    }
]
