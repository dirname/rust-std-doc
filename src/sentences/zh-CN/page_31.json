[
    {
        "source": "it must not be used to read or write other allocated objects.",
        "suggest": "它不得用于读取或写入其他分配的对象。",
        "translate": ""
    },
    {
        "source": "The return value may change depending on the compiler version and unsafe code might not rely on the result of this function for soundness.",
        "suggest": "返回值可能会根据编译器版本而改变，并且不安全的代码可能不依赖于这个函数的结果来保证稳健性。",
        "translate": ""
    },
    {
        "source": "For trait objects, the metadata must come from a pointer to the same underlying erased type.",
        "suggest": "对于 trait 对象，元数据必须来自指向相同底层 erased 类型的指针。",
        "translate": ""
    },
    {
        "source": "Read a usize value from a byte buffer:",
        "suggest": "从字节缓冲区读取 usize 值:",
        "translate": ""
    },
    {
        "source": "Write a usize value to a byte buffer:",
        "suggest": "将 usize 值写入字节缓冲区:",
        "translate": ""
    },
    {
        "source": "gcdpow has an upper-bound that’s at most the number of bits in a usize.",
        "suggest": "gcdpow 有一个上限，最多是 usize 中的位数。",
        "translate": ""
    },
    {
        "source": "Important: don't try to access the value of `ptr` without initializing it first!",
        "suggest": "重要提示: 不要尝试访问 `ptr` 的值而不先初始化它!",
        "translate": ""
    },
    {
        "source": "The pointer is not null but isn't valid either!",
        "suggest": "指针不为空，但也无效!",
        "translate": ""
    },
    {
        "source": "NEVER DO THAT!!!",
        "suggest": "永远不要这样做! ! !",
        "translate": ""
    },
    {
        "source": "*Incorrect* usage of this function:",
        "suggest": "此函数的不正确用法:",
        "translate": ""
    },
    {
        "source": "Save clones of the raw `Result` values to inspect",
        "suggest": "保存原始 `Result` 值的克隆以进行检查",
        "translate": ""
    },
    {
        "source": "Challenge: explain how this captures only the `Err` values",
        "suggest": "挑战: 解释这如何仅捕获 `Err` 值",
        "translate": ""
    },
    {
        "source": "In addition to working with pattern matching, [`Result`] provides a wide variety of different methods.",
        "suggest": "除了使用模式匹配，[`Result`] 还提供了多种不同的方法。",
        "translate": ""
    },
    {
        "source": "The [`is_ok`] and [`is_err`] methods return [`true`] if the [`Result`] is [`Ok`] or [`Err`], respectively.",
        "suggest": "如果 [`Result`] 分别为 [`Ok`] 或 [`Err`]，则 [`is_ok`] 和 [`is_err`] 方法返回 [`true`]。",
        "translate": ""
    },
    {
        "source": "converts from `&Result<T, E>` to `Result<&T, &E>`",
        "suggest": "从 `&Result<T, E>` 转换为 `Result<&T, &E>`",
        "translate": ""
    },
    {
        "source": "converts from `&mut Result<T, E>` to `Result<&mut T, &mut E>`",
        "suggest": "从 `&mut Result<T, E>` 转换为 `Result<&mut T, &mut E>`",
        "translate": ""
    },
    {
        "source": "converts from `&Result<T, E>` to `Result<&T::Target, &E>`",
        "suggest": "从 `&Result<T, E>` 转换为 `Result<&T::Target, &E>`",
        "translate": ""
    },
    {
        "source": "converts from `&mut Result<T, E>` to",
        "suggest": "从 `&mut Result<T, E>` 转换为",
        "translate": ""
    },
    {
        "source": "Extracting contained values",
        "suggest": "提取包含的值",
        "translate": ""
    },
    {
        "source": "These methods extract the contained value in a [`Result<T, E>`] when it is the [`Ok`] variant.",
        "suggest": "当它是 [`Ok`] 成员时，这些方法提取 [`Result<T, E>`] 中包含的值。",
        "translate": ""
    },
    {
        "source": "If the [`Result`] is [`Err`]:",
        "suggest": "如果 [`Result`] 是 [`Err`]:",
        "translate": ""
    },
    {
        "source": "The panicking methods [`expect`] and [`unwrap`] require `E` to implement the [`Debug`] trait.",
        "suggest": "panicking 方法 [`expect`] 和 [`unwrap`] 需要 `E` 来实现 [`Debug`] trait。",
        "translate": ""
    },
    {
        "source": "These methods extract the contained value in a [`Result<T, E>`] when it is the [`Err`] variant.",
        "suggest": "当它是 [`Err`] 成员时，这些方法提取 [`Result<T, E>`] 中包含的值。",
        "translate": ""
    },
    {
        "source": "They require `T` to implement the [`Debug`] trait.",
        "suggest": "他们需要 `T` 来实现 [`Debug`] trait。",
        "translate": ""
    },
    {
        "source": "If the [`Result`] is [`Ok`]:",
        "suggest": "如果 [`Result`] 是 [`Ok`]:",
        "translate": ""
    },
    {
        "source": "These methods transform [`Result`] to [`Option`]:",
        "suggest": "这些方法将 [`Result`] 转换为 [`Option`]:",
        "translate": ""
    },
    {
        "source": "transforms [`Result<T, E>`] into [`Option<E>`], mapping [`Err(e)`] to [`Some(e)`] and [`Ok(v)`] to [`None`]",
        "suggest": "将 [`Result<T, E>`] 转换为 [`Option<E>`]，将 [`Err(e)`] 映射到 [`Some(e)`]，将 [`Ok(v)`] 映射到 [`None`]",
        "translate": ""
    },
    {
        "source": "transforms [`Result<T, E>`] into [`Option<T>`], mapping [`Ok(v)`] to [`Some(v)`] and [`Err(e)`] to [`None`]",
        "suggest": "将 [`Result<T, E>`] 转换为 [`Option<T>`]，将 [`Ok(v)`] 映射到 [`Some(v)`]，将 [`Err(e)`] 映射到 [`None`]",
        "translate": ""
    },
    {
        "source": "transposes a [`Result`] of an [`Option`] into an [`Option`] of a [`Result`]",
        "suggest": "将 [`Option`] 的 [`Result`] 转换为 [`Result`] 的 [`Option`]",
        "translate": ""
    },
    {
        "source": "Do NOT add link reference definitions for `err` or `ok`, because they will generate numerous incorrect URLs for `Err` and `Ok` elsewhere, due to case folding.",
        "suggest": "不要为 `err` 或 `ok` 添加链接引用定义，因为由于大小写折叠，它们会在其他地方为 `Err` 和 `Ok` 生成大量不正确的 URL。",
        "translate": ""
    },
    {
        "source": "This method transforms the contained value of the [`Ok`] variant:",
        "suggest": "此方法转换 [`Ok`] 成员的包含值:",
        "translate": ""
    },
    {
        "source": "transforms [`Result<T, E>`] into [`Result<U, E>`] by applying the provided function to the contained value of [`Ok`] and leaving [`Err`] values unchanged",
        "suggest": "通过将提供的函数应用于 [`Ok`] 的包含值并保持 [`Err`] 值不变，将 [`Result<T, E>`] 转换为 [`Result<U, E>`]",
        "translate": ""
    },
    {
        "source": "This method transforms the contained value of the [`Err`] variant:",
        "suggest": "此方法转换 [`Err`] 成员的包含值:",
        "translate": ""
    },
    {
        "source": "transforms [`Result<T, E>`] into [`Result<T, F>`] by applying the provided function to the contained value of [`Err`] and leaving [`Ok`] values unchanged",
        "suggest": "通过将提供的函数应用于 [`Err`] 的包含值并保持 [`Ok`] 值不变，将 [`Result<T, E>`] 转换为 [`Result<T, F>`]",
        "translate": ""
    },
    {
        "source": "These methods transform a [`Result<T, E>`] into a value of a possibly different type `U`:",
        "suggest": "这些方法将 [`Result<T, E>`] 转换为可能不同类型 `U` 的值:",
        "translate": ""
    },
    {
        "source": "applies the provided function to the contained value of [`Ok`], or returns the provided default value if the [`Result`] is",
        "suggest": "将提供的函数应用于 [`Ok`] 的包含值，如果 [`Result`] 是，则返回提供的默认值",
        "translate": ""
    },
    {
        "source": "applies the provided function to the contained value of [`Ok`], or applies the provided fallback function to the contained value of [`Err`]",
        "suggest": "将提供的函数应用于 [`Ok`] 的包含值，或将提供的回退函数应用于 [`Err`] 的包含值",
        "translate": ""
    },
    {
        "source": "These methods treat the [`Result`] as a boolean value, where [`Ok`] acts like [`true`] and [`Err`] acts like [`false`].",
        "suggest": "这些方法将 [`Result`] 视为布尔值，其中 [`Ok`] 的作用类似于 [`true`]，而 [`Err`] 的作用类似于 [`false`]。",
        "translate": ""
    },
    {
        "source": "There are two categories of these methods: ones that take a [`Result`] as input, and ones that take a function as input (to be lazily evaluated).",
        "suggest": "这些方法有两类: 一类以 [`Result`] 作为输入，一类以函数作为输入 (延迟评估)。",
        "translate": ""
    },
    {
        "source": "The [`and`] and [`or`] methods take another [`Result`] as input, and produce a [`Result`] as output.",
        "suggest": "[`and`] 和 [`or`] 方法将另一个 [`Result`] 作为输入，并生成一个 [`Result`] 作为输出。",
        "translate": ""
    },
    {
        "source": "The [`and`] method can produce a [`Result<U, E>`] value having a different inner type `U` than [`Result<T, E>`].",
        "suggest": "[`and`] 方法可以生成具有与 [`Result<T, E>`] 不同的内部类型 `U` 的 [`Result<U, E>`] 值。",
        "translate": ""
    },
    {
        "source": "The [`or`] method can produce a [`Result<T, F>`] value having a different error type `F` than [`Result<T, E>`].",
        "suggest": "[`or`] 方法可以生成具有与 [`Result<T, E>`] 不同的错误类型 `F` 的 [`Result<T, F>`] 值。",
        "translate": ""
    },
    {
        "source": "The [`and_then`] method can produce a [`Result<U, E>`] value having a different inner type `U` than [`Result<T, E>`].",
        "suggest": "[`and_then`] 方法可以生成具有与 [`Result<T, E>`] 不同的内部类型 `U` 的 [`Result<U, E>`] 值。",
        "translate": ""
    },
    {
        "source": "The [`or_else`] method can produce a [`Result<T, F>`] value having a different error type `F` than [`Result<T, E>`].",
        "suggest": "[`or_else`] 方法可以生成具有与 [`Result<T, E>`] 不同的错误类型 `F` 的 [`Result<T, F>`] 值。",
        "translate": ""
    },
    {
        "source": "If `T` and `E` both implement [`PartialOrd`] then [`Result<T, E>`] will derive its [`PartialOrd`] implementation.",
        "suggest": "如果 `T` 和 `E` 都实现 [`PartialOrd`]，那么 [`Result<T, E>`] 将派生其 [`PartialOrd`] 实现。",
        "translate": ""
    },
    {
        "source": "With this order, an [`Ok`] compares as less than any [`Err`], while two [`Ok`] or two [`Err`] compare as their contained values would in `T` or `E` respectively.",
        "suggest": "按照此顺序，一个 [`Ok`] 的比较小于任何 [`Err`]，而两个 [`Ok`] 或两个 [`Err`] 的比较与其包含的值分别在 `T` 或 `E` 中进行比较。",
        "translate": ""
    },
    {
        "source": "If `T` and `E` both also implement [`Ord`], then so does [`Result<T, E>`].",
        "suggest": "如果 `T` 和 `E` 都实现了 [`Ord`]，那么 [`Result<T, E>`] 也实现了。",
        "translate": ""
    },
    {
        "source": "Iterating over `Result`",
        "suggest": "迭代 `Result`",
        "translate": ""
    },
    {
        "source": "A [`Result`] can be iterated over.",
        "suggest": "可以对 [`Result`] 进行迭代。",
        "translate": ""
    },
    {
        "source": "The iterator will either produce a single value (when the [`Result`] is [`Ok`]), or produce no values (when the [`Result`] is [`Err`]).",
        "suggest": "迭代器将产生单个值 (当 [`Result`] 为 [`Ok`] 时)，或不产生任何值 (当 [`Result`] 为 [`Err`] 时)。",
        "translate": ""
    },
    {
        "source": "For example, [`into_iter`] acts like [`once(v)`] if the [`Result`] is [`Ok(v)`], and like [`empty()`] if the [`Result`] is [`Err`].",
        "suggest": "例如，如果 [`Result`] 是 [`Ok(v)`]，则 [`into_iter`] 的作用类似于 [`once(v)`]; 如果 [`Result`] 是 [`Err`]，则它的作用类似于 [`empty()`]。",
        "translate": ""
    },
    {
        "source": "Iterators over [`Result<T, E>`] come in three types:",
        "suggest": "[`Result<T, E>`] 上的迭代器分为三种类型:",
        "translate": ""
    },
    {
        "source": "consumes the [`Result`] and produces the contained value",
        "suggest": "消耗 [`Result`] 并生成包含的值",
        "translate": ""
    },
    {
        "source": "See [Iterating over `Option`] for examples of how this can be useful.",
        "suggest": "有关这如何有用的示例，请参见 [迭代 `Option`][Iterating over `Option`]。",
        "translate": ""
    },
    {
        "source": "You might want to use an iterator chain to do multiple instances of an operation that can fail, but would like to ignore failures while continuing to process the successful results.",
        "suggest": "您可能希望使用迭代器链来执行可能失败的操作的多个实例，但希望在继续处理成功结果的同时忽略失败。",
        "translate": ""
    },
    {
        "source": "In this example, we take advantage of the iterable nature of [`Result`] to select only the [`Ok`] values using [`flatten`][Iterator::flatten].",
        "suggest": "在本例中，我们利用 [`Result`] 的可迭代特性，使用 [`flatten`][Iterator::flatten] 仅选择 [`Ok`] 值。",
        "translate": ""
    },
    {
        "source": "Collecting into `Result`",
        "suggest": "收集到 `Result`",
        "translate": ""
    },
    {
        "source": "implements the [`FromIterator`][impl-FromIterator] trait, which allows an iterator over [`Result`] values to be collected into a [`Result`] of a collection of each contained value of the original [`Result`] values, or [`Err`] if any of the elements was [`Err`].",
        "suggest": "实现 [`FromIterator`][impl-FromIterator] trait，它允许将 [`Result`] 值上的迭代器收集到原始 [`Result`] 值的每个包含值的集合的 [`Result`] 中，或者如果任何元素是 [`Err`]，则为 [`Err`]。",
        "translate": ""
    },
    {
        "source": "also implements the [`Product`][impl-Product] and [`Sum`][impl-Sum] traits, allowing an iterator over [`Result`] values to provide the [`product`][Iterator::product] and [`sum`][Iterator::sum] methods.",
        "suggest": "还实现了 [`Product`][impl-Product] 和 [`Sum`][impl-Sum] traits，允许对 [`Result`] 值的迭代器提供 [`product`][Iterator::product] 和 [`sum`][Iterator::sum] 方法。",
        "translate": ""
    },
    {
        "source": "By construction, `advance` does not exceed `self.len()`.",
        "suggest": "通过构造，`advance` 不超过 `self.len()`。",
        "translate": ""
    },
    {
        "source": "If the predicate doesn't match anything, we yield one slice.",
        "suggest": "如果谓词不匹配任何内容，我们将产生一个切片。",
        "translate": ""
    },
    {
        "source": "If it matches every element, we yield `len() + 1` empty slices.",
        "suggest": "如果它匹配每个元素，我们会产生 `len() + 1` 个空切片。",
        "translate": ""
    },
    {
        "source": "If it matches every element, we yield `len()` one-element slices, or a single empty slice.",
        "suggest": "如果它匹配每个元素，我们会产生 `len()` 单元素切片，或者单个空的切片。",
        "translate": ""
    },
    {
        "source": "the caller guarantees that `i` is in bounds, which means that `start` must be in bounds of the underlying `self.v` slice, and we made sure that `len` is also in bounds of `self.v`.",
        "suggest": "调用者保证 `i` 在边界内，这意味着 `start` 必须在底层 `self.v` 的边界内，并且我们确保 `len` 在 `self.v` 的边界内。",
        "translate": ""
    },
    {
        "source": "Sorts the slice, but might not preserve the order of equal elements.",
        "suggest": "对三个元素进行排序，但可能不保留相等元素的顺序。",
        "translate": ""
    },
    {
        "source": "Sorts the slice with a comparator function, but might not preserve the order of equal elements.",
        "suggest": "使用比较器函数对三元进行排序，但可能不保留相等元素的顺序。",
        "translate": ""
    },
    {
        "source": "Sorts the slice with a key extraction function, but might not preserve the order of equal elements.",
        "suggest": "使用键提取函数对三个元素进行排序，但可能不保留相等元素的顺序。",
        "translate": ""
    },
    {
        "source": "callers must ensure `mid - left` is valid for reading and writing.",
        "suggest": "调用者必须确保 `mid - left` 对读写有效。",
        "translate": ""
    },
    {
        "source": "see previous comment.",
        "suggest": "参见上一个注释。",
        "translate": ""
    },
    {
        "source": "callers must ensure `[left, left+mid+right)` are all valid for reading and writing.",
        "suggest": "调用者必须确保 `[left, left+mid+right)` 对读取和写入都是有效的。",
        "translate": ""
    },
    {
        "source": "start with `right` so `mid-left <= x+i = x+right = mid-left+right < mid+right`",
        "suggest": "以 `right` 开头，所以 `mid-left <= x+i = x+right = mid-left+right < mid+right`",
        "translate": ""
    },
    {
        "source": "is always true",
        "suggest": "始终为 true",
        "translate": ""
    },
    {
        "source": "if `i < left`, `right` is added so `i < left+right` and on the next iteration `left` is removed from `i` so it doesn't go further",
        "suggest": "如果 `i < left`，`right` 被添加，所以 `i < left+right` 和在下一次迭代中 `left` 从 `i` 中删除，所以它不会更进一步",
        "translate": ""
    },
    {
        "source": "if `i >= left`, `left` is removed immediately and so it doesn't go further.",
        "suggest": "如果 `i >= left`，`left` 立即被删除，所以它不会更进一步。",
        "translate": ""
    },
    {
        "source": "overflows cannot happen for `i` since the function's safety contract ask for `mid+right-1 = x+left+right` to be valid for writing",
        "suggest": "`i` 不会发生溢出，因为函数的安全保证要求 `mid+right-1 = x+left+right` 对写入有效",
        "translate": ""
    },
    {
        "source": "underflows cannot happen because `i` must be bigger or equal to `left` for a substraction of `left` to happen.",
        "suggest": "下溢不会发生，因为 `i` 必须大于或等于 `left` 才能发生 `left` 的减法。",
        "translate": ""
    },
    {
        "source": "So `x+i` is valid for reading and writing if the caller respected the contract",
        "suggest": "因此，如果调用方遵守契约，则 `x+i` 对读和写是有效的",
        "translate": ""
    },
    {
        "source": "tmp has been read from a valid source and x is valid for writing according to the caller.",
        "suggest": "tmp 已从有效来源读取，并且 x 可根据调用者的情况进行写入。",
        "translate": ""
    },
    {
        "source": "`gcd` is at most equal to `right` so all values in `1..gcd` are valid for reading and writing as per the function's safety contract, see [long-safety-expl] above",
        "suggest": "`gcd` 至多等于 `right`，因此 `1..gcd` 中的所有值都可以根据函数的安全保证进行读写，参见上面的 [long-safety-expl]",
        "translate": ""
    },
    {
        "source": "Here `start < gcd` so `start < right` so `i < right+right`: `right` being the greatest common divisor of `(left+right, right)` means that `left = right` so `i < left+right` so `x+i = mid-left+i` is always valid for reading and writing according to the function's safety contract.",
        "suggest": "这里 `start < gcd` so `start < right` so `i < right+right`: `right` 是 `(left+right, right)` 的最大公约数意味着 `left = right` so `i < left+right` so `x+i = mid-left+i` 根据函数的安全保证对于读写总是有效的。",
        "translate": ""
    },
    {
        "source": "see [long-safety-expl] and [safety-expl-addition]",
        "suggest": "请参见 [long-safety-expl] 和 [safety-expl-addition]",
        "translate": ""
    },
    {
        "source": "The `else if` condition about the sizes ensures `[mid-left; left]` will fit in `buf` without overflow and `buf` was created just above and so cannot be overlapped with any value of `[mid-left; left]`",
        "suggest": "关于大小的 `else if` 条件确保 `[mid-left; left]` 将适合 `buf` 而不会溢出，而 `buf` 是在上面创建的，因此不能与 `[mid-left; left]` 的任何值重叠",
        "translate": ""
    },
    {
        "source": "[mid-left, mid+right) are all valid for reading and writing and we don't care about overlaps here.",
        "suggest": "[mid-left, mid+right) 都适用于读取和写入，我们不关心这里的重叠。",
        "translate": ""
    },
    {
        "source": "The `if` condition about `left <= right` ensures writing `left` elements to `dim = mid-left+right` is valid because:",
        "suggest": "关于 `left <= right` 的 `if` 条件确保将 `left` 元素写入 `dim = mid-left+right` 是有效的，因为:",
        "translate": ""
    },
    {
        "source": "is valid and `left` elements were written in it in 1)",
        "suggest": "有效且 `left` 元素写入其中 1)",
        "translate": ""
    },
    {
        "source": "and we write `[dim, dim+left)`",
        "suggest": "我们写 `[dim, dim+left)`",
        "translate": ""
    },
    {
        "source": "same reasoning as above but with `left` and `right` reversed",
        "suggest": "与上述相同的推理，但 `left` 和 `right` 颠倒了",
        "translate": ""
    },
    {
        "source": "so `[mid-right, mid+right)` is valid for reading and writing Substracting `right` from `mid` each turn is counterbalanced by the addition and check after it.",
        "suggest": "所以 `[mid-right, mid+right)` 对读写有效 从 `mid` 中减去 `right` 每圈被加法抵消并在它之后检查。",
        "translate": ""
    },
    {
        "source": "`[mid-left, mid+left)` is valid for reading and writing because `left < right` so `mid+left < mid+right`.",
        "suggest": "`[mid-left, mid+left)` 对读写有效，因为 `left < right` 所以 `mid+left < mid+right`。",
        "translate": ""
    },
    {
        "source": "Adding `left` to `mid` each turn is counterbalanced by the substraction and check after it.",
        "suggest": "将 `left` 添加到 `mid` 每一圈都会被减法抵消并在它之后检查。",
        "translate": ""
    },
    {
        "source": "The use of `ptr::read` is valid because there is at least one element in both `offsets_l` and `offsets_r`, so `left!` is a valid pointer to read from.",
        "suggest": "`ptr::read` 的使用是有效的，因为在 `offsets_l` 和 `offsets_r` 中至少有一个元素，所以 `left!` 是一个有效的读取指针。",
        "translate": ""
    },
    {
        "source": "The uses of `left!` involve calls to `offset` on `l`, which points to the beginning of `v`.",
        "suggest": "`left!` 的使用涉及在 `l` 上调用 `offset`，它指向 `v` 的开头。",
        "translate": ""
    },
    {
        "source": "All the offsets pointed-to by `start_l` are at most `block_l`, so these `offset` calls are safe as all reads are within the block.",
        "suggest": "`start_l` 指向的所有偏移量最多为 `block_l`，因此这些 `offset` 调用是安全的，因为所有读取都在块内。",
        "translate": ""
    },
    {
        "source": "The same argument applies for the uses of `right!`.",
        "suggest": "相同的参数也适用于 `right!` 的用法。",
        "translate": ""
    },
    {
        "source": "The calls to `start_l.offset` are valid because there are at most `count-1` of them, plus the final one at the end of the unsafe block, where `count` is the minimum number of collected offsets in `offsets_l` and `offsets_r`, so there is no risk of there not being enough elements.",
        "suggest": "对 `start_l.offset` 的调用是有效的，因为它们最多有 `count-1` 个，加上不安全块末尾的最后一个，其中 `count` 是 `offsets_l` 和 `offsets_r` 中收集的最小偏移量，因此不存在不存在的风险足够的元素。",
        "translate": ""
    },
    {
        "source": "The same reasoning applies to the calls to `start_r.offset`.",
        "suggest": "同样的推理适用于对 `start_r.offset` 的调用。",
        "translate": ""
    },
    {
        "source": "The calls to `copy_nonoverlapping` are safe because `left!` and `right!` are guaranteed not to overlap, and are valid because of the reasoning above.",
        "suggest": "对 `copy_nonoverlapping` 的调用是安全的，因为 `left!` 和 `right!` 保证不重叠，并且由于上述推理是有效的。",
        "translate": ""
    },
    {
        "source": "if `!is_done` then the slice width is guaranteed to be at least `2*BLOCK` wide.",
        "suggest": "如果 `!is_done` 那么至少保证宽度为 `2*BLOCK` 宽。",
        "translate": ""
    },
    {
        "source": "There are at most `BLOCK` elements in `offsets_l` because of its size, so the `offset` operation is safe.",
        "suggest": "由于 `offsets_l` 的大小，`offsets_l` 中最多有 `BLOCK` 个元素，所以 `offset` 操作是安全的。",
        "translate": ""
    },
    {
        "source": "Otherwise, the debug assertions in the `is_done` case guarantee that `width(l, r) == block_l + block_r`, namely, that the block sizes have been adjusted to account for the smaller number of remaining elements.",
        "suggest": "否则，`is_done` 情况下的调试断言保证 `width(l, r) == block_l + block_r`，即块大小已被调整以考虑较少数量的剩余元素。",
        "translate": ""
    },
    {
        "source": "Same argument as [block-width-guarantee].",
        "suggest": "与 [block-width-guarantee] 的参数相同。",
        "translate": ""
    },
    {
        "source": "Either this is a full block `2*BLOCK`-wide, or `block_r` has been adjusted for the last handful of elements.",
        "suggest": "这是一个完整的 `2*BLOCK` 块，或者 `block_r` 已针对最后少数元素进行了调整。",
        "translate": ""
    },
    {
        "source": "It's important to remember that [`char`] represents a Unicode Scalar Value, and might not match your idea of what a 'character' is.",
        "suggest": "请务必记住，[`char`] 表示 Unicode 标量值，可能与您对 'character' 的概念不符。",
        "translate": ""
    },
    {
        "source": "Remember, [`char`]s might not match your intuition about characters:",
        "suggest": "请记住，[`char`] 可能与您对字符的直觉不符:",
        "translate": ""
    },
    {
        "source": "Needed in case of an empty haystack, see #85462",
        "suggest": "在 haystack 为空时需要，请参见 #85462",
        "translate": ""
    },
    {
        "source": "A stream that was created from iterator.",
        "suggest": "从迭代器创建的流。",
        "translate": ""
    },
    {
        "source": "This stream is created by the [`from_iter`] function.",
        "suggest": "这个流是由 [`from_iter`] 函数创建的。",
        "translate": ""
    },
    {
        "source": "See it documentation for more.",
        "suggest": "有关更多信息，请参见它的文档。",
        "translate": ""
    },
    {
        "source": "Converts an iterator into a stream.",
        "suggest": "将迭代器转换为流。",
        "translate": ""
    },
    {
        "source": "The atomic types in this module might not be available on all platforms.",
        "suggest": "此模块中的原子类型可能并非在所有平台上都可用。",
        "translate": ""
    },
    {
        "source": "To see why, remember that the compiler is free to swap the stores to `IMPORTANT_VARIABLE` and `IS_READY` since they are both `Ordering::Relaxed`.",
        "suggest": "要了解原因，请记住编译器可以自由地将存储交换为 `IMPORTANT_VARIABLE` 和 `IS_READY`，因为它们都是 `Ordering::Relaxed`。",
        "translate": ""
    },
    {
        "source": "takes self *by value*, consuming `poll_some_string`",
        "suggest": "按值获取 self，消耗 `poll_some_string`",
        "translate": ""
    },
    {
        "source": "Maps a `Poll<T>` to `Poll<U>` by applying a function to a contained value.",
        "suggest": "通过将函数应用于包含的值，Maps 从 `Poll<T>` 到 `Poll<U>`。",
        "translate": ""
    },
    {
        "source": "Converts a `Poll<`[`String`]`>` into an `Poll<`[`usize`]`>`, consuming the original:",
        "suggest": "将 `Poll<`[`String`]`>` 转换为 `Poll<`[`usize`]`>`，消耗原始值:",
        "translate": ""
    },
    {
        "source": "Returns `true` if the poll is a [`Poll::Ready`] value.",
        "suggest": "如果轮询是 [`Poll::Ready`] 值，则返回 `true`。",
        "translate": ""
    },
    {
        "source": "Returns `true` if the poll is a [`Pending`] value.",
        "suggest": "如果轮询是 [`Pending`] 值，则返回 `true`。",
        "translate": ""
    },
    {
        "source": "Maps a `Poll<Result<T, E>>` to `Poll<Result<U, E>>` by applying a function to a contained `Poll::Ready(Ok)` value, leaving all other variants untouched.",
        "suggest": "通过对包含的 `Poll::Ready(Ok)` 值应用函数，Maps 将 `Poll<Result<T, E>>` 变为 `Poll<Result<U, E>>`，让所有其他成员保持不变。",
        "translate": ""
    },
    {
        "source": "Maps a `Poll::Ready<Result<T, E>>` to `Poll::Ready<Result<T, F>>` by applying a function to a contained `Poll::Ready(Err)` value, leaving all other variants untouched.",
        "suggest": "通过对包含的 `Poll::Ready(Err)` 值应用函数，Maps 将 `Poll::Ready<Result<T, E>>` 变为 `Poll::Ready<Result<T, F>>`，让所有其他成员保持不变。",
        "translate": ""
    },
    {
        "source": "Maps a `Poll<Option<Result<T, E>>>` to `Poll<Option<Result<U, E>>>` by applying a function to a contained `Poll::Ready(Some(Ok))` value, leaving all other variants untouched.",
        "suggest": "通过对包含的 `Poll::Ready(Some(Ok))` 值应用函数，Maps 将 `Poll<Option<Result<T, E>>>` 变为 `Poll<Option<Result<U, E>>>`，让所有其他成员保持不变。",
        "translate": ""
    },
    {
        "source": "Maps a `Poll::Ready<Option<Result<T, E>>>` to `Poll::Ready<Option<Result<T, F>>>` by applying a function to a contained `Poll::Ready(Some(Err))` value, leaving all other variants untouched.",
        "suggest": "通过对包含的 `Poll::Ready(Some(Err))` 值应用函数，Maps 将 `Poll::Ready<Option<Result<T, E>>>` 变为 `Poll::Ready<Option<Result<T, F>>>`，让所有其他成员保持不变。",
        "translate": ""
    },
    {
        "source": "There are multiple ways to create a new [`Duration`]:",
        "suggest": "有多种方法可以创建新的 [`Duration`]:",
        "translate": ""
    },
    {
        "source": "The checked version of [`from_secs_f64`].",
        "suggest": "[`from_secs_f64`] 的检查版本。",
        "translate": ""
    },
    {
        "source": "This constructor will return an `Err` if `secs` is not finite, negative or overflows `Duration`.",
        "suggest": "如果 `secs` 不是有限、负数或溢出 `Duration`，则此构造函数将返回 `Err`。",
        "translate": ""
    },
    {
        "source": "The checked version of [`from_secs_f32`].",
        "suggest": "[`from_secs_f32`] 的检查版本。",
        "translate": ""
    },
    {
        "source": "An error which can be returned when converting a floating-point value of seconds into a [`Duration`].",
        "suggest": "将秒的浮点值转换为 [`Duration`] 时可能返回的错误。",
        "translate": ""
    },
    {
        "source": "This error is used as the error type for [`Duration::try_from_secs_f32`] and [`Duration::try_from_secs_f64`].",
        "suggest": "此错误用作 [`Duration::try_from_secs_f32`] 和 [`Duration::try_from_secs_f64`] 的错误类型。",
        "translate": ""
    },
    {
        "source": "Value is not a finite value (either infinity or NaN).",
        "suggest": "值不是有限值 (无穷大或 NaN)。",
        "translate": ""
    },
    {
        "source": "Value is too large to store in a `Duration`.",
        "suggest": "值太大而无法存储在 `Duration` 中。",
        "translate": ""
    },
    {
        "source": "Value is less than `0.0`.",
        "suggest": "值小于 `0.0`。",
        "translate": ""
    },
    {
        "source": "Used to test that iterator adapters don't poll their inner iterators after exhausting them.",
        "suggest": "用于测试迭代器适配器在耗尽它们后不会轮询它们的内部迭代器。",
        "translate": ""
    },
    {
        "source": "test clone and clone_from implementations",
        "suggest": "测试 clone 和 clone_from 实现",
        "translate": ""
    },
    {
        "source": "From int to float",
        "suggest": "从 int 到 float",
        "translate": ""
    },
    {
        "source": "Upper bounded",
        "suggest": "上界",
        "translate": ""
    },
    {
        "source": "Both bounded",
        "suggest": "两边都有界",
        "translate": ""
    },
    {
        "source": "Lower bounded",
        "suggest": "下界",
        "translate": ""
    },
    {
        "source": "These test near-halfway cases for single-precision floats.",
        "suggest": "这些测试单精度浮点数的接近一半的情况。",
        "translate": ""
    },
    {
        "source": "These are examples of the above tests, with digits from the exponent shifted to the mantissa.",
        "suggest": "这些是上述测试的示例，从指数到尾数的数字。",
        "translate": ""
    },
    {
        "source": "Let's check the lines to see if anything is different in table...",
        "suggest": "让我们检查一下这些行，看看表中是否有任何不同...",
        "translate": ""
    },
    {
        "source": "These test near-halfway cases for double-precision floats.",
        "suggest": "这些测试双精度浮点数的接近一半的情况。",
        "translate": ""
    },
    {
        "source": "Regression test for #31109.",
        "suggest": "#31109 的回归测试。",
        "translate": ""
    },
    {
        "source": "Ensure the test produces a valid float with the expected bit pattern.",
        "suggest": "确保测试产生具有预期位模式的有效浮点数。",
        "translate": ""
    },
    {
        "source": "Regression test for #31407.",
        "suggest": "#31407 的回归测试。",
        "translate": ""
    },
    {
        "source": "Check large numbers of digits to ensure we have cases where significant digits (above Decimal::MAX_DIGITS) occurs.",
        "suggest": "检查大量数字以确保我们有出现有效数字 (Decimal::MAX_DIGITS 以上) 的情况。",
        "translate": ""
    },
    {
        "source": "This tests the `Integer::{log,log2,log10}` methods.",
        "suggest": "这将测试 `Integer::{log,log2,log10}` 方法。",
        "translate": ""
    },
    {
        "source": "These tests are in a separate file because there's both a large number of them, and not all tests can be run on Android.",
        "suggest": "这些测试位于一个单独的文件中，因为它们的数量都很大，而且并非所有测试都可以在 Android 上运行。",
        "translate": ""
    },
    {
        "source": "This is because in Android `log2` uses an imprecise approximation:https://github.com/rust-lang/rust/blob/4825e12fc9c79954aa0fe18f5521efa6c19c7539/src/libstd/sys/unix/android.rs#L27-L53",
        "suggest": "这是因为在 Android 中 `log2` 使用了一个不精确的近似值: https://github.com/android-lsys3#",
        "translate": ""
    },
    {
        "source": "Guard against Android's imprecise f32::log2 implementation.",
        "suggest": "防范 Android 不精确的 f32::log2 实现。",
        "translate": ""
    },
    {
        "source": "Validate cases that fail on Android's imprecise float log2 implementation.",
        "suggest": "验证在 Android 的不精确浮点 log2 实现上失败的案例。",
        "translate": ""
    },
    {
        "source": "also check `x.log(10)`",
        "suggest": "还要检查 `x.log(10)`",
        "translate": ""
    },
    {
        "source": "We try our best to populate the message but as this function may already be called as part of a failed allocation, it might not be possible to do so.",
        "suggest": "我们尽最大努力填充消息，但由于此函数可能已经作为失败分配的一部分被调用，因此可能无法这样做。",
        "translate": ""
    },
    {
        "source": "See also https://llvm.org/docs/WritingAnLLVMBackend.html#defining-a-register.",
        "suggest": "另请参见 https://llvm.org/docs/WritingAnLLVMBackend.html#defining-a-register。",
        "translate": ""
    },
    {
        "source": "Note that panics should be impossible beyond this point, but this is defensively trying to avoid any accidental panicking reaching the `extern \"C\"` (which should `abort` but might not at the moment, so this is also potentially preventing UB).",
        "suggest": "请注意，在此之后 panics 应该是不可能的，但这是防御性地尝试避免任何意外的 panicking 到达 `extern \"C\"` (应该是 `abort`，但目前可能不会，因此这也可能会阻止 UB)。",
        "translate": ""
    },
    {
        "source": "Simplified version of panic payloads, ignoring types other than `&'static str` and `String`.",
        "suggest": "panic 有效载荷的简化版本，忽略 `&'static str` 和 `String` 以外的类型。",
        "translate": ""
    },
    {
        "source": "For example, `quote!(a + b)` will produce an expression, that, when evaluated, constructs the `TokenStream` `[Ident(\"a\"), Punct('+', Alone), Ident(\"b\")]`.",
        "suggest": "例如，`quote!(a + b)` 将产生一个表达式，当求值时，它构造 `TokenStream` `[Ident(\"a\"), Punct('+', Alone), Ident(\"b\")]`。",
        "translate": ""
    },
    {
        "source": "The 1-indexed column (number of bytes in UTF-8 encoding) in the source file on which the span starts or ends (inclusive).",
        "suggest": "跨度开始或结束 (inclusive) 的源文件中的 1 索引列 (UTF-8 编码中的字节数)。",
        "translate": ""
    },
    {
        "source": "If the code span associated with this `SourceFile` was generated by an external macro, this macro, this might not be an actual path on the filesystem.",
        "suggest": "如果与此 `SourceFile` 关联的代码跨度是由外部宏生成的，则此宏可能不是文件系统上的实际路径。",
        "translate": ""
    },
    {
        "source": "Also note that even if `is_real` returns `true`, if `--remap-path-prefix` was passed on the command line, the path as given might not actually be valid.",
        "suggest": "另请注意，即使 `is_real` 返回 `true`，如果 `--remap-path-prefix` 在命令行上传递，给定的路径实际上可能无效。",
        "translate": ""
    },
    {
        "source": "Implicit delimiters might not survive roundtrip of a token stream through a string.",
        "suggest": "隐式定界符可能无法通过字符串在 token 流的往返中存活下来。",
        "translate": ""
    },
    {
        "source": "A `Punct` is a single punctuation character such as `+`, `-` or `#`.",
        "suggest": "`Punct` 是单个标点符号，例如 `+`、`-` 或 `#`。",
        "translate": ""
    },
    {
        "source": "Describes whether a `Punct` is followed immediately by another `Punct` ([`Spacing::Joint`]) or by a different token or whitespace ([`Spacing::Alone`]).",
        "suggest": "描述 `Punct` 后面是紧跟另一个 `Punct` ([`Spacing::Joint`]) 还是不同的 token 或空格 ([`Spacing::Alone`])。",
        "translate": ""
    },
    {
        "source": "A `Punct` is not immediately followed by another `Punct`.",
        "suggest": "一个 `Punct` 后面不会紧跟另一个 `Punct`。",
        "translate": ""
    },
    {
        "source": "`+` is `Alone` in `+ =`, `+ident` and `+()`.",
        "suggest": "`+` 在 `+ =`、`+ident` 和 `+()` 中为 `Alone`。",
        "translate": ""
    },
    {
        "source": "A `Punct` is immediately followed by another `Punct`.",
        "suggest": "`Punct` 紧随其后的是另一个 `Punct`。",
        "translate": ""
    },
    {
        "source": "`+` is `Joint` in `+=` and `++`.",
        "suggest": "`+` 是 `+=` 和 `++` 中的 `Joint`。",
        "translate": ""
    },
    {
        "source": "Additionally, single quote `'` can join with identifiers to form lifetimes:",
        "suggest": "此外，单引号 `'` 可以与标识符连接以形成生命周期:",
        "translate": ""
    },
    {
        "source": "Literals created from negative numbers might not survive round-trips through `TokenStream` or strings and may be broken into two tokens (`-` and positive literal).",
        "suggest": "从负数创建的字面量可能无法通过 `TokenStream` 或字符串进行往返，并且可能会分解为两个 tokens (`-` 和正字面量)。",
        "translate": ""
    },
    {
        "source": "Literals created from negative numbers might not survive rountrips through `TokenStream` or strings and may be broken into two tokens (`-` and positive literal).",
        "suggest": "由负数创建的字面量可能无法通过 `TokenStream` 或字符串进行往返，并且可能会分解为两个 tokens (`-` 和正字面量)。",
        "translate": ""
    },
    {
        "source": "Tracked access to additional files.",
        "suggest": "跟踪对其他文件的访问。",
        "translate": ""
    },
    {
        "source": "Track a file explicitly.",
        "suggest": "明确跟踪文件。",
        "translate": ""
    },
    {
        "source": "Commonly used for tracking asset preprocessing.",
        "suggest": "通常用于跟踪资源预处理。",
        "translate": ""
    },
    {
        "source": "Sometimes libraries might not be available at runtime or something may go wrong which would cause a backtrace to not be captured.",
        "suggest": "有时库可能在运行时不可用，或者可能出现问题，从而导致无法捕获回溯。",
        "translate": ""
    },
    {
        "source": "The `Backtrace::capture` function might not actually capture a backtrace by default.",
        "suggest": "默认情况下，`Backtrace::capture` 函数实际上可能不会捕获回溯。",
        "translate": ""
    },
    {
        "source": "Also note that the state of environment variables is cached once the first backtrace is created, so altering `RUST_LIB_BACKTRACE` or `RUST_BACKTRACE` at runtime might not actually change how backtraces are captured.",
        "suggest": "另请注意，一旦创建第一个回溯，环境变量的状态就会被缓存，因此在运行时更改 `RUST_LIB_BACKTRACE` 或 `RUST_BACKTRACE` 可能实际上不会改变回溯的捕获方式。",
        "translate": ""
    },
    {
        "source": "This next line must infer the hasher type parameter.",
        "suggest": "下一行必须推断 hasher 类型参数。",
        "translate": ""
    },
    {
        "source": "If you make a change that causes this line to no longer infer, that's a problem!",
        "suggest": "如果您进行更改导致此行不再推断，那就是一个问题!",
        "translate": ""
    },
    {
        "source": "The `IntoKeys` iterator produces keys in arbitrary order, so the keys must be sorted to test them against a sorted array.",
        "suggest": "`IntoKeys` 迭代器以任意顺序生成键，因此必须对键进行排序以针对排序数组测试它们。",
        "translate": ""
    },
    {
        "source": "The `IntoValues` iterator produces values in arbitrary order, so the values must be sorted to test them against a sorted array.",
        "suggest": "`IntoValues` 迭代器以任意顺序生成值，因此必须对这些值进行排序以针对已排序数组对其进行测试。",
        "translate": ""
    },
    {
        "source": "A `HashMap` with a known list of items can be initialized from an array:",
        "suggest": "可以从数组初始化具有已知项列表的 `HashMap`:",
        "translate": ""
    },
    {
        "source": "implements an [`Entry API`](#method.entry), which allows for complex methods of getting, setting, updating and removing keys and their values:",
        "suggest": "实现了一个 [`Entry API`](#method.entry)，它允许使用复杂的方法来获取、设置、更新和删除键及其值:",
        "translate": ""
    },
    {
        "source": "as what is currently the most convenient built-in way to construct a HashMap, a simple usage of this function must not *require* the user to provide a type annotation in order to infer the third type parameter (the hasher parameter, conventionally \"S\").",
        "suggest": "作为目前构建 HashMap 的最方便的内置方式，这个函数的简单用法不能*要求*用户提供类型注解以推断第三个类型参数 (散列参数，通常为 \"S\") .",
        "translate": ""
    },
    {
        "source": "To that end, this impl is defined using RandomState as the concrete type of S, rather than being generic over `S: BuildHasher + Default`.",
        "suggest": "为此，这个 impl 使用 RandomState 作为 S 的具体类型来定义，而不是 `S: BuildHasher + Default` 上的泛型。",
        "translate": ""
    },
    {
        "source": "It is expected that users who want to specify a hasher will manually use `with_capacity_and_hasher`.",
        "suggest": "预计想要指定哈希器的用户将手动使用 `with_capacity_and_hasher`。",
        "translate": ""
    },
    {
        "source": "If type parameter defaults worked on impls, and if type parameter defaults could be mixed with const generics, then perhaps this could be generalized.",
        "suggest": "如果类型参数默认值适用于 impls，并且如果类型参数默认值可以与 const 泛型混合，那么这也许可以推广。",
        "translate": ""
    },
    {
        "source": "See also the equivalent impl on HashSet.",
        "suggest": "另请参见 HashSet 上的等效实现。",
        "translate": ""
    },
    {
        "source": "A `HashSet` with a known list of items can be initialized from an array:",
        "suggest": "可以从数组初始化具有已知项列表的 `HashSet`:",
        "translate": ""
    },
    {
        "source": "as what is currently the most convenient built-in way to construct a HashSet, a simple usage of this function must not *require* the user to provide a type annotation in order to infer the third type parameter (the hasher parameter, conventionally \"S\").",
        "suggest": "作为目前构建 HashSet 的最方便的内置方式，这个函数的简单用法不能*要求*用户提供类型注解以推断第三个类型参数 (散列参数，通常为 \"S\") .",
        "translate": ""
    },
    {
        "source": "See also the equivalent impl on HashMap.",
        "suggest": "另请参见 HashMap 上的等效实现。",
        "translate": ""
    },
    {
        "source": "This function will return an error if the environment variable isn't set.",
        "suggest": "如果未设置环境变量，此函数将返回错误。",
        "translate": ""
    },
    {
        "source": "This function may return an error if the environment variable's name contains the equal sign character (`=`) or the NUL character.",
        "suggest": "如果环境变量的名称包含等号字符 (`=`) 或 NUL 字符，此函数可能会返回错误。",
        "translate": ""
    },
    {
        "source": "This function will return an error if the environment variable's value is not valid Unicode.",
        "suggest": "如果环境变量的值不是有效的 Unicode，此函数将返回错误。",
        "translate": ""
    },
    {
        "source": "Fetches the environment variable `key` from the current process, returning [`None`] if the variable isn't set or there's another error.",
        "suggest": "从当前进程中获取环境变量 `key`，如果变量未设置或存在另一个错误，则返回 [`None`]。",
        "translate": ""
    },
    {
        "source": "This function returns an error if the environment variable isn't set.",
        "suggest": "如果未设置环境变量，此函数将返回错误。",
        "translate": ""
    },
    {
        "source": "This function may return an error if the environment variable's value contains the NUL character.",
        "suggest": "如果环境变量的值包含 NUL 字符，此函数可能会返回错误。",
        "translate": ""
    },
    {
        "source": "Sets the environment variable `key` to the value `value` for the currently running process.",
        "suggest": "将环境变量 `key` 设置为当前正在运行的进程的值 `value`。",
        "translate": ""
    },
    {
        "source": "This function may panic if `key` is empty, contains an ASCII equals sign `'='` or the NUL character `'\\0'`, or when `value` contains the NUL character.",
        "suggest": "如果 `key` 为空，包含 ASCII 等号 `'='` 或 NUL 字符 `'\\0'`，或者当 `value` 包含 NUL 字符时，此函数可能 panic。",
        "translate": ""
    },
    {
        "source": "If the executable is renamed while it is running, platforms may return the path at the time it was loaded instead of the new path.",
        "suggest": "如果可执行文件在运行时被重命名，平台可能会返回加载时的路径而不是新路径。",
        "translate": ""
    },
    {
        "source": "The first element is traditionally the path of the executable, but it can be set to arbitrary text, and might not even exist.",
        "suggest": "第一个元素传统上是可执行文件的路径，但它可以设置为任意文本，甚至可能不存在。",
        "translate": ""
    },
    {
        "source": "simple values",
        "suggest": "简单值",
        "translate": ""
    },
    {
        "source": "boundary values",
        "suggest": "边界值",
        "translate": ""
    },
    {
        "source": "as long as t is finite, a/b can be infinite",
        "suggest": "只要 t 是有限的，a/b 就可以是无限的",
        "translate": ""
    },
    {
        "source": "non-finite t is not NaN if a/b different",
        "suggest": "如果 a/b 不同，则非有限 t 不是 NaN",
        "translate": ""
    },
    {
        "source": "just a few basic values",
        "suggest": "只是一些基本值",
        "translate": ""
    },
    {
        "source": "near 0",
        "suggest": "接近 0",
        "translate": ""
    },
    {
        "source": "near 0.5",
        "suggest": "接近 0.5",
        "translate": ""
    },
    {
        "source": "near 1",
        "suggest": "接近 1",
        "translate": ""
    },
    {
        "source": "Returns NaN if `self` is a negative number other than `-0.0`.",
        "suggest": "如果 `self` 是 `-0.0` 以外的负数，则返回 NaN。",
        "translate": ""
    },
    {
        "source": "The result might not be correctly rounded owing to implementation details;",
        "suggest": "由于实现细节，结果可能无法正确四舍五入;",
        "translate": ""
    },
    {
        "source": "Linear interpolation between `start` and `end`.",
        "suggest": "`start` 和 `end` 之间的线性插值。",
        "translate": ""
    },
    {
        "source": "This enables linear interpolation between `start` and `end`, where start is represented by `self == 0.0` and `end` is represented by `self == 1.0`.",
        "suggest": "这可以在 `start` 和 `end` 之间启用线性插值，其中开始由 `self == 0.0` 表示，`end` 由 `self == 1.0` 表示。",
        "translate": ""
    },
    {
        "source": "This is the basis of all \"transition\", \"easing\", or \"step\" functions;",
        "suggest": "这是所有 \"transition\"、\"easing\" 或 \"step\" 函数的基础;",
        "translate": ""
    },
    {
        "source": "if you change `self` from 0.0 to 1.0 at a given rate, the result will change from `start` to `end` at a similar rate.",
        "suggest": "如果您以给定的速率将 `self` 从 0.0 更改为 1.0，结果将以相似的速率从 `start` 更改为 `end`。",
        "translate": ""
    },
    {
        "source": "Values below 0.0 or above 1.0 are allowed, allowing you to extrapolate values outside the range from `start` to `end`.",
        "suggest": "允许低于 0.0 或高于 1.0 的值，允许您推断 `start` 到 `end` 范围之外的值。",
        "translate": ""
    },
    {
        "source": "This also is useful for transition functions which might move slightly past the end or start for a desired effect.",
        "suggest": "这对于可能稍微移动到结尾或开始以获得所需效果的过渡函数也很有用。",
        "translate": ""
    },
    {
        "source": "Mathematically, the values returned are equivalent to `start + self * (end - start)`, although we make a few specific guarantees that are useful specifically to linear interpolation.",
        "suggest": "在数学上，返回的值等同于 `start + self * (end - start)`，尽管我们做出了一些特别对线性插值有用的特定保证。",
        "translate": ""
    },
    {
        "source": "These guarantees are:",
        "suggest": "这些保证是:",
        "translate": ""
    },
    {
        "source": "If `start` and `end` are [finite], the value at 0.0 is always `start` and the value at 1.0 is always `end`.",
        "suggest": "如果 `start` 和 `end` 为 [finite]，则 0.0 处的值始终为 `start`，1.0 处的值始终为 `end`。",
        "translate": ""
    },
    {
        "source": "If `start` and `end` are [finite], the values will always move in the direction from `start` to `end` (monotonicity)",
        "suggest": "如果 `start` 和 `end` 为 [finite]，则值将始终沿 `start` 到 `end` (monotonicity) 的方向移动",
        "translate": ""
    },
    {
        "source": "If `self` is [finite] and `start == end`, the value at any point will always be `start == end`.",
        "suggest": "如果 `self` 是 [finite] 和 `start == end`，则任何一点的值将始终为 `start == end`。",
        "translate": ""
    },
    {
        "source": "implements an [`as_ptr`][`CStr::as_ptr`] method through the [`Deref`] trait.",
        "suggest": "通过 [`Deref`] trait 实现 [`as_ptr`][`CStr::as_ptr`] 方法。",
        "translate": ""
    },
    {
        "source": "An incorrectly formatted [`Vec`] will produce an error.",
        "suggest": "格式不正确的 [`Vec`] 会产生错误。",
        "translate": ""
    },
    {
        "source": "Converts a [`CString`] into an [`Arc`]`<CStr>` without copying or allocating.",
        "suggest": "无需复制或分配即可将 [`CString`] 转换为 [`Arc`]`<CStr>`。",
        "translate": ""
    },
    {
        "source": "Converts a [`CString`] into an [`Rc`]`<CStr>` without copying or allocating.",
        "suggest": "无需复制或分配即可将 [`CString`] 转换为 [`Rc`]`<CStr>`。",
        "translate": ""
    },
    {
        "source": "It can be converted into a UTF-8 Rust string slice in a similar way to [`OsString`].",
        "suggest": "可以用类似 [`OsString`] 的方式转换成 UTF-8 Rust 字符串 小提琴。",
        "translate": ""
    },
    {
        "source": "Converts a [`String`] into an [`OsString`].",
        "suggest": "将 [`String`] 转换为 [`OsString`]。",
        "translate": ""
    },
    {
        "source": "Converts an [`OsString`] into a [`Box`]`<OsStr>` without copying or allocating.",
        "suggest": "无需复制或分配即可将 [`OsString`] 转换为 [`Box`]`<OsStr>`。",
        "translate": ""
    },
    {
        "source": "Converts an [`OsString`] into an [`Arc`]`<OsStr>` without copying or allocating.",
        "suggest": "无需复制或分配即可将 [`OsString`] 转换为 [`Arc`]`<OsStr>`。",
        "translate": ""
    },
    {
        "source": "Converts an [`OsString`] into an [`Rc`]`<OsStr>` without copying or allocating.",
        "suggest": "无需复制或分配即可将 [`OsString`] 转换为 [`Rc`]`<OsStr>`。",
        "translate": ""
    },
    {
        "source": "Symlinks get normalized by Windows, so we might not get the same path back for absolute paths",
        "suggest": "Windows 对符号链接进行了标准化，因此对于绝对路径，我们可能无法返回相同的路径",
        "translate": ""
    },
    {
        "source": "This function is similar to [`sync_all`], except that it might not synchronize file metadata to the filesystem.",
        "suggest": "该函数与 [`sync_all`] 类似，不同之处在于它可能不会将文件元数据同步到文件系统。",
        "translate": ""
    },
    {
        "source": "In addition to the `impl`s here, `File` also has `impl`s for `AsFd`/`From<OwnedFd>`/`Into<OwnedFd>` and `AsRawFd`/`IntoRawFd`/`FromRawFd`, on Unix and WASI, and `AsHandle`/`From<OwnedHandle>`/`Into<OwnedHandle>` and `AsRawHandle`/`IntoRawHandle`/`FromRawHandle` on Windows.",
        "suggest": "除了这里的 impl 之外，`File` 还有 `AsFd`/`From<OwnedFd>`/`Into<OwnedFd>` 和 `AsRawFd`/`IntoRawFd`/`FromRawFd`、Unix 和 WASI 以及 Windows 上的 `AsHandle`/`From<OwnedHandle>`/`Into<OwnedHandle>` 和 `AsRawHandle`/`IntoRawHandle`/`FromRawHandle` 的 impl。",
        "translate": ""
    },
    {
        "source": "The mapping to [`io::ErrorKind`]s is not part of the compatibility contract of the function.",
        "suggest": "映射到 [`io::ErrorKind`] 不是函数兼容性契约的一部分。",
        "translate": ""
    },
    {
        "source": "The following errors don't match any existing [`io::ErrorKind`] at the moment:",
        "suggest": "以下错误目前与任何现有的 [`io::ErrorKind`] 都不匹配:",
        "translate": ""
    },
    {
        "source": "Returns `true` if this metadata is for a symbolic link.",
        "suggest": "如果此元数据用于符号链接，则返回 `true`。",
        "translate": ""
    },
    {
        "source": "This field might not be available on all platforms, and will return an `Err` on platforms where it is not available.",
        "suggest": "此字段可能并非在所有平台上都可用，并且在它不可用的平台上将返回 `Err`。",
        "translate": ""
    },
    {
        "source": "This field might not be available on all platforms, and will return an `Err` on platforms or filesystems where it is not available.",
        "suggest": "此字段可能并非在所有平台上都可用，并且会在它不可用的平台或文件系统上返回 `Err`。",
        "translate": ""
    },
    {
        "source": "This function currently corresponds the `CreateHardLink` function on Windows.",
        "suggest": "该函数目前对应于 Windows 上的 `CreateHardLink` 函数。",
        "translate": ""
    },
    {
        "source": "On most Unix systems, it corresponds to the `linkat` function with no flags.",
        "suggest": "在大多数 Unix 系统上，它对应于没有标志的 `linkat` 函数。",
        "translate": ""
    },
    {
        "source": "On Android, VxWorks, and Redox, it instead corresponds to the `link` function.",
        "suggest": "在 Android、VxWorks 和 Redox 上，它对应于 `link` 函数。",
        "translate": ""
    },
    {
        "source": "On MacOS, it uses the `linkat` function if it is available, but on very old systems where `linkat` is not available, `link` is selected at runtime instead.",
        "suggest": "在 MacOS 上，它使用 `linkat` 函数 (如果可用)，但在 `linkat` 不可用的非常旧的系统上，`link` 在运行时被选择。",
        "translate": ""
    },
    {
        "source": "Entries for the current and parent directories (typically `.` and `..`) are skipped.",
        "suggest": "当前目录和父目录 (通常为 `.` 和 `..`) 的条目将被跳过。",
        "translate": ""
    },
    {
        "source": "forget(self) prevents double dropping inner",
        "suggest": "forget(self) 防止双重丢弃内部",
        "translate": ""
    },
    {
        "source": "Error returned for the buffered data from `BufWriter::into_parts`, when the underlying writer has previously panicked.",
        "suggest": "当底层 writer 之前有 panicked 时，为来自 `BufWriter::into_parts` 的缓冲数据返回错误。",
        "translate": ""
    },
    {
        "source": "Returns the remaining slice.",
        "suggest": "返回剩余的三个。",
        "translate": ""
    },
    {
        "source": "Returns `true` if the remaining slice is empty.",
        "suggest": "如果剩余的 3 为空，则返回 `true`。",
        "translate": ""
    },
    {
        "source": "Will print \"Uncategorized\".",
        "suggest": "将打印 \"Uncategorized\"。",
        "translate": ""
    },
    {
        "source": "The remote host is not reachable.",
        "suggest": "远程主机不可访问。",
        "translate": ""
    },
    {
        "source": "The network containing the remote host is not reachable.",
        "suggest": "无法访问包含远程主机的网络。",
        "translate": ""
    },
    {
        "source": "The system's networking is down.",
        "suggest": "系统的网络已关闭。",
        "translate": ""
    },
    {
        "source": "A filesystem object is, unexpectedly, not a directory.",
        "suggest": "出乎意料的是，文件系统 object 不是目录。",
        "translate": ""
    },
    {
        "source": "For example, a filesystem path was specified where one of the intermediate directory components was, in fact, a plain file.",
        "suggest": "例如，指定了一个文件系统路径，其中一个中间目录组件实际上是一个普通文件。",
        "translate": ""
    },
    {
        "source": "The filesystem object is, unexpectedly, a directory.",
        "suggest": "文件系统 object 出乎意料地是一个目录。",
        "translate": ""
    },
    {
        "source": "A directory was specified when a non-directory was expected.",
        "suggest": "当需要一个非目录时指定了一个目录。",
        "translate": ""
    },
    {
        "source": "A non-empty directory was specified where an empty directory was expected.",
        "suggest": "在需要空目录的地方指定了一个非空目录。",
        "translate": ""
    },
    {
        "source": "The filesystem or storage medium is read-only, but a write operation was attempted.",
        "suggest": "文件系统或存储介质是只读的，但尝试了写入操作。",
        "translate": ""
    },
    {
        "source": "Loop in the filesystem or IO subsystem;",
        "suggest": "在文件系统或 IO 子系统中循环;",
        "translate": ""
    },
    {
        "source": "often, too many levels of symbolic links.",
        "suggest": "通常，太多级别的符号链接。",
        "translate": ""
    },
    {
        "source": "There was a loop (or excessively long chain) resolving a filesystem object or file IO object.",
        "suggest": "有一个循环 (或过长的链) 解析文件系统 object 或文件 IO object。",
        "translate": ""
    },
    {
        "source": "On Unix this is usually the result of a symbolic link loop;",
        "suggest": "在 Unix 上，这通常是符号链接循环的结果;",
        "translate": ""
    },
    {
        "source": "or, of exceeding the system-specific limit on the depth of symlink traversal.",
        "suggest": "或者，超过系统特定的符号链接遍历深度限制。",
        "translate": ""
    },
    {
        "source": "Stale network file handle.",
        "suggest": "陈旧的网络文件句柄。",
        "translate": ""
    },
    {
        "source": "With some network filesystems, notably NFS, an open file (or directory) can be invalidated by problems with the network or server.",
        "suggest": "对于某些网络文件系统，尤其是 NFS，打开的文件 (或目录) 可能会因网络或服务器问题而失效。",
        "translate": ""
    },
    {
        "source": "The underlying storage (typically, a filesystem) is full.",
        "suggest": "底层存储 (通常是文件系统) 已满。",
        "translate": ""
    },
    {
        "source": "This does not include out of quota errors.",
        "suggest": "这不包括超出配额的错误。",
        "translate": ""
    },
    {
        "source": "Seek on unseekable file.",
        "suggest": "Seek 在不可搜索的文件上。",
        "translate": ""
    },
    {
        "source": "Seeking was attempted on an open file handle which is not suitable for seeking - for example, on Unix, a named pipe opened with `File::open`.",
        "suggest": "尝试在不适合搜索的打开文件句柄上进行搜索 - 例如，在 Unix 上，使用 `File::open` 打开的命名管道。",
        "translate": ""
    },
    {
        "source": "Filesystem quota was exceeded.",
        "suggest": "超出了文件系统配额。",
        "translate": ""
    },
    {
        "source": "File larger than allowed or supported.",
        "suggest": "文件大于允许或支持。",
        "translate": ""
    },
    {
        "source": "This might arise from a hard limit of the underlying filesystem or file access API, or from an administratively imposed resource limitation.",
        "suggest": "这可能源于底层文件系统或文件访问 API 的硬限制，或源于管理强加的资源限制。",
        "translate": ""
    },
    {
        "source": "Simple disk full, and out of quota, have their own errors.",
        "suggest": "简单的磁盘已满，超出配额，都有自己的错误。",
        "translate": ""
    },
    {
        "source": "Resource is busy.",
        "suggest": "资源繁忙。",
        "translate": ""
    },
    {
        "source": "Executable file is busy.",
        "suggest": "可执行文件正忙。",
        "translate": ""
    },
    {
        "source": "An attempt was made to write to a file which is also in use as a running program.",
        "suggest": "试图写入一个文件，该文件也用作正在运行的程序。",
        "translate": ""
    },
    {
        "source": "(Not all operating systems detect this situation.)",
        "suggest": "(并非所有操作系统都检测到这种情况。)",
        "translate": ""
    },
    {
        "source": "Deadlock (avoided).",
        "suggest": "死锁 (avoided)。",
        "translate": ""
    },
    {
        "source": "A file locking operation would result in deadlock.",
        "suggest": "文件锁定操作会导致死锁。",
        "translate": ""
    },
    {
        "source": "This situation is typically detected, if at all, on a best-effort basis.",
        "suggest": "这种情况通常是在尽力而为的基础上检测到的。",
        "translate": ""
    },
    {
        "source": "Cross-device or cross-filesystem (hard) link or rename.",
        "suggest": "跨设备或跨文件系统 (hard) 链接或重命名。",
        "translate": ""
    },
    {
        "source": "Too many (hard) links to the same filesystem object.",
        "suggest": "太多 (hard) 链接到同一个文件系统 object。",
        "translate": ""
    },
    {
        "source": "The filesystem does not support making so many hardlinks to the same file.",
        "suggest": "文件系统不支持对同一个文件建立如此多的硬链接。",
        "translate": ""
    },
    {
        "source": "Filename too long.",
        "suggest": "文件名太长。",
        "translate": ""
    },
    {
        "source": "The limit might be from the underlying filesystem or API, or an administratively imposed resource limit.",
        "suggest": "该限制可能来自底层文件系统或 API，或者是管理上强加的资源限制。",
        "translate": ""
    },
    {
        "source": "Program argument list too long.",
        "suggest": "程序参数列表太长。",
        "translate": ""
    },
    {
        "source": "When trying to run an external program, a system or process limit on the size of the arguments would have been exceeded.",
        "suggest": "尝试运行外部程序时，会超出系统或进程对参数大小的限制。",
        "translate": ""
    },
    {
        "source": "ErrorKinds which are primarily categorisations for OS error codes should be added above.",
        "suggest": "ErrorKinds 主要是 OS 错误代码的分类应在上面添加。",
        "translate": ""
    },
    {
        "source": "error kinds which do not correspond simply to (sets of) OS error codes, should be added just above this comment.",
        "suggest": "不简单地对应于 (组) 操作系统错误代码的错误类型，应添加在此注释的正上方。",
        "translate": ""
    },
    {
        "source": "and `Uncategorised` should remain at the end:",
        "suggest": "并且 `Uncategorised` 应该保留在最后:",
        "translate": ""
    },
    {
        "source": "A custom error that does not fall under any other I/O error kind.",
        "suggest": "不属于任何其他 I/O 错误类型的自定义错误。",
        "translate": ""
    },
    {
        "source": "This can be used to construct your own [`Error`]s that do not match any [`ErrorKind`].",
        "suggest": "这可用于构建您自己的不匹配任何 [`ErrorKind`] 的 [`Error`]。",
        "translate": ""
    },
    {
        "source": "This [`ErrorKind`] is not used by the standard library.",
        "suggest": "标准库不使用此 [`ErrorKind`]。",
        "translate": ""
    },
    {
        "source": "Errors from the standard library that do not fall under any of the I/O error kinds cannot be `match`ed on, and will only match a wildcard (`_`) pattern.",
        "suggest": "标准库中不属于任何 I/O 错误类型的错误无法 `匹配`，并且只会匹配通配符 (`_`) 模式。",
        "translate": ""
    },
    {
        "source": "New [`ErrorKind`]s might be added in the future for some of those.",
        "suggest": "可能会在 future 中为其中一些添加新的 [`ErrorKind`]。",
        "translate": ""
    },
    {
        "source": "Any I/O error from the standard library that's not part of this list.",
        "suggest": "标准库中不属于此列表的任何 I/O 错误。",
        "translate": ""
    },
    {
        "source": "Errors that are `Uncategorized` now may move to a different or a new [`ErrorKind`] variant in the future.",
        "suggest": "现在 `Uncategorized` 的错误可能会转移到 future 中的不同或新 [`ErrorKind`] 成员。",
        "translate": ""
    },
    {
        "source": "It is not recommended to match an error against `Uncategorized`;",
        "suggest": "不建议针对 `Uncategorized` 匹配错误;",
        "translate": ""
    },
    {
        "source": "use a wildcard match (`_`) instead.",
        "suggest": "改用通配符匹配 (`_`)。",
        "translate": ""
    },
    {
        "source": "Strictly alphabetical, please.",
        "suggest": "请严格按字母顺序排列。",
        "translate": ""
    },
    {
        "source": "(Sadly rustfmt cannot do this yet.)",
        "suggest": "(遗憾的是 rustfmt 还不能做到这一点。)",
        "translate": ""
    },
    {
        "source": "Mark 3 bytes as read.",
        "suggest": "将 3 个字节标记为已读。",
        "translate": ""
    },
    {
        "source": "work with line",
        "suggest": "与行一起工作",
        "translate": ""
    },
    {
        "source": "Correspondingly, however, *callers* of this method must not assume any guarantees about how the implementation uses `buf`.",
        "suggest": "然而，相应地，此方法的*调用者*不得对实现如何使用 `buf` 做出任何保证。",
        "translate": ""
    },
    {
        "source": "Creates a \"by reference\" adapter for this instance of `Read`.",
        "suggest": "为这个 `Read` 实例创建一个 \"by reference\" 适配器。",
        "translate": ""
    },
    {
        "source": "The returned adapter also implements `Read` and will simply borrow this current reader.",
        "suggest": "返回的适配器也实现了 `Read`，并且将简单地借用当前的 reader。",
        "translate": ""
    },
    {
        "source": "Creates an adapter which will chain this stream with another.",
        "suggest": "创建一个适配器，将这个流与另一个链接起来。",
        "translate": ""
    },
    {
        "source": "Creates an adapter which will read at most `limit` bytes from it.",
        "suggest": "创建一个适配器，最多从中读取 `limit` 个字节。",
        "translate": ""
    },
    {
        "source": "Also see [`IoSliceMut::advance_slices`] to advance the cursors of multiple buffers.",
        "suggest": "另请参见 [`IoSliceMut::advance_slices`] 以推进多个缓冲区的游标。",
        "translate": ""
    },
    {
        "source": "Advance the internal cursor of the slices.",
        "suggest": "前进切片的内部游标。",
        "translate": ""
    },
    {
        "source": "It is semantically a wrapper around a `&[u8]`, but is guaranteed to be ABI compatible with the `iovec` type on Unix platforms and `WSABUF` on Windows.",
        "suggest": "它在语义上是 `&[u8]` 的包装器，但保证与 Unix 平台上的 `iovec` 类型和 Windows 上的 `WSABUF` 类型的 ABI 兼容。",
        "translate": ""
    },
    {
        "source": "Also see [`IoSlice::advance_slices`] to advance the cursors of multiple buffers.",
        "suggest": "另请参见 [`IoSlice::advance_slices`] 以推进多个缓冲区的游标。",
        "translate": ""
    },
    {
        "source": "The [`flush`] method is useful for adapters and explicit buffers themselves for ensuring that all buffered data has been pushed out to the 'true sink'.",
        "suggest": "[`flush`] 方法对于适配器和显式缓冲区本身很有用，以确保所有缓冲数据都已被推送到 `真正的 sink`。",
        "translate": ""
    },
    {
        "source": "This function will attempt to write the entire contents of `buf`, but the entire write might not succeed, or the write may also generate an error.",
        "suggest": "这个函数会尝试写入 `buf` 的全部内容，但是整个写入可能不会成功，或者写入也会产生错误。",
        "translate": ""
    },
    {
        "source": "Creates a \"by reference\" adapter for this instance of `Write`.",
        "suggest": "为这个 `Write` 实例创建一个 \"by reference\" 适配器。",
        "translate": ""
    },
    {
        "source": "The returned adapter also implements `Write` and will simply borrow this current writer.",
        "suggest": "返回的适配器也实现了 `Write`，并将简单地借用当前的 writer。",
        "translate": ""
    },
    {
        "source": "Check if the underlying `Read` has any data left to be read.",
        "suggest": "检查底层 `Read` 是否有任何数据可供读取。",
        "translate": ""
    },
    {
        "source": "This function may fill the buffer to check for data, so this functions returns `Result<bool>`, not `bool`.",
        "suggest": "这个函数可能会填充缓冲区来检查数据，所以这个函数返回的是 `Result<bool>`，而不是 `bool`。",
        "translate": ""
    },
    {
        "source": "Default implementation calls `fill_buf` and checks that returned slice is empty (which means that there is no data left, since EOF is reached).",
        "suggest": "默认实现调用 `fill_buf` 并检查返回的 4 为空 (这意味着没有数据剩余，因为达到了 EOF)。",
        "translate": ""
    },
    {
        "source": "Adapter to chain together two readers.",
        "suggest": "将两个 readers 链接在一起的适配器。",
        "translate": ""
    },
    {
        "source": "Reader adapter which limits the bytes read from an underlying reader.",
        "suggest": "Reader 适配器限制从底层 reader 读取的字节数。",
        "translate": ""
    },
    {
        "source": "Helper trait to make lock testing function generic.",
        "suggest": "帮助 trait 使锁测试函数通用。",
        "translate": ""
    },
    {
        "source": "Tests locking on stdio handles by starting two threads and checking that they block each other appropriately.",
        "suggest": "通过启动两个线程并检查它们是否适当地相互阻塞来测试标准输入输出句柄的锁定。",
        "translate": ""
    },
    {
        "source": "State enum to track different phases of the test, primarily when each lock is acquired and released.",
        "suggest": "状态枚举以跟踪测试的不同阶段，主要是在获取和释放每个锁时。",
        "translate": ""
    },
    {
        "source": "Logging vector to be checked to make sure lock acquisitions and releases happened in the correct order.",
        "suggest": "记录要检查的 vector 以确保锁定获取和释放以正确的顺序发生。",
        "translate": ""
    },
    {
        "source": "notify of acquisition",
        "suggest": "获取通知",
        "translate": ""
    },
    {
        "source": "wait for release command",
        "suggest": "等待释放命令",
        "translate": ""
    },
    {
        "source": "wait for th2 acquire",
        "suggest": "等待 th2 获取",
        "translate": ""
    },
    {
        "source": "wait for start command",
        "suggest": "等待启动命令",
        "translate": ""
    },
    {
        "source": "wait for th1 acquire",
        "suggest": "等待 th1 获取",
        "translate": ""
    },
    {
        "source": "block th2",
        "suggest": "堵塞 th2",
        "translate": ""
    },
    {
        "source": "release th1",
        "suggest": "发布 th1",
        "translate": ""
    },
    {
        "source": "block th1",
        "suggest": "堵塞 th1",
        "translate": ""
    },
    {
        "source": "release th2",
        "suggest": "发布 th2",
        "translate": ""
    },
    {
        "source": "Constructs a new locked handle to the standard input of the current process.",
        "suggest": "为当前进程的标准输入创建一个新的锁定句柄。",
        "translate": ""
    },
    {
        "source": "Each handle returned is a guard granting locked access to a shared global buffer whose access is synchronized via a mutex.",
        "suggest": "返回的每个句柄都是一个保护，授予对共享缓冲区的锁定访问权限，该缓冲区的访问通过互斥锁同步。",
        "translate": ""
    },
    {
        "source": "If you need more explicit control over locking, for example, in a multi-threaded program, use the [`io::stdin`] function to obtain an unlocked handle, along with the [`Stdin::lock`] method.",
        "suggest": "如果您需要对锁定进行更明确的控制，例如，在多线程程序中，请使用 [`io::stdin`] 函数以及 [`Stdin::lock`] 方法获取解锁句柄。",
        "translate": ""
    },
    {
        "source": "The lock is released when the returned guard goes out of scope.",
        "suggest": "当返回的守卫作用域解除锁定。",
        "translate": ""
    },
    {
        "source": "The mutex locked by this handle is not reentrant.",
        "suggest": "该句柄锁定的互斥锁不可重入。",
        "translate": ""
    },
    {
        "source": "Even in a single-threaded program, calling other code that accesses [`Stdin`] could cause a deadlock or panic, if this locked handle is held across that call.",
        "suggest": "即使在单线程程序中，调用其他访问 [`Stdin`] 的代码也可能导致死锁或 panic，如果此锁定句柄跨该调用持有。",
        "translate": ""
    },
    {
        "source": "Locks this handle with any lifetime.",
        "suggest": "使用任何生命周期锁定此句柄。",
        "translate": ""
    },
    {
        "source": "This depends on the implementation detail that the underlying `Mutex` is static.",
        "suggest": "这取决于底层 `Mutex` 是静态的实现细节。",
        "translate": ""
    },
    {
        "source": "Consumes this handle to the standard input stream, locking the shared global buffer associated with the stream and returning a readable guard.",
        "suggest": "将此句柄用于标准输入流，锁定与流相关联的共享缓冲区并返回可读保护。",
        "translate": ""
    },
    {
        "source": "It is often simpler to directly get a locked handle using the [`stdin_locked`] function instead, unless nearby code also needs to use an unlocked handle.",
        "suggest": "使用 [`stdin_locked`] 函数直接获取锁定句柄通常更简单，除非附近的代码也需要使用解锁句柄。",
        "translate": ""
    },
    {
        "source": "Consumes this handle and returns an iterator over input lines.",
        "suggest": "使用这个句柄并在输入行上返回一个迭代器。",
        "translate": ""
    },
    {
        "source": "For detailed semantics of this method, see the documentation on [`BufRead::lines`].",
        "suggest": "有关此方法的详细语义，请参见 [`BufRead::lines`] 上的文档。",
        "translate": ""
    },
    {
        "source": "Consumes this handle and returns an iterator over input bytes, split at the specified byte value.",
        "suggest": "使用此句柄并返回输入字节的迭代器，在指定的字节值处拆分。",
        "translate": ""
    },
    {
        "source": "For detailed semantics of this method, see the documentation on [`BufRead::split`].",
        "suggest": "有关此方法的详细语义，请参见 [`BufRead::split`] 上的文档。",
        "translate": ""
    },
    {
        "source": "Constructs a new locked handle to the standard output of the current process.",
        "suggest": "为当前进程的标准输出创建一个新的锁定句柄。",
        "translate": ""
    },
    {
        "source": "If you need more explicit control over locking, for example, in a multi-threaded program, use the [`io::stdout`] function to obtain an unlocked handle, along with the [`Stdout::lock`] method.",
        "suggest": "如果您需要对锁定进行更明确的控制，例如，在多线程程序中，请使用 [`io::stdout`] 函数以及 [`Stdout::lock`] 方法获取解锁句柄。",
        "translate": ""
    },
    {
        "source": "This depends on the implementation detail that the underlying `ReentrantMutex` is static.",
        "suggest": "这取决于底层 `ReentrantMutex` 是静态的实现细节。",
        "translate": ""
    },
    {
        "source": "Consumes this handle to the standard output stream, locking the shared global buffer associated with the stream and returning a writable guard.",
        "suggest": "将此句柄用于标准输出流，锁定与流关联的共享缓冲区并返回可写保护。",
        "translate": ""
    },
    {
        "source": "It is often simpler to directly get a locked handle using the [`io::stdout_locked`] function instead, unless nearby code also needs to use an unlocked handle.",
        "suggest": "使用 [`io::stdout_locked`] 函数直接获取锁定句柄通常更简单，除非附近的代码也需要使用解锁句柄。",
        "translate": ""
    },
    {
        "source": "Constructs a new locked handle to the standard error of the current process.",
        "suggest": "为当前进程的标准错误创建一个新的锁定句柄。",
        "translate": ""
    },
    {
        "source": "Locks and consumes this handle to the standard error stream, returning a writable guard.",
        "suggest": "锁定并使用此句柄到标准错误流，返回可写保护。",
        "translate": ""
    },
    {
        "source": "Reading the fields of a union is always unsafe",
        "suggest": "读取 union 的字段总是不安全的",
        "translate": ""
    },
    {
        "source": "Like [`struct`]s and [`enum`]s, a module and its content are private by default, inaccessible to code outside of the module.",
        "suggest": "像 [`struct`] 和 [`enum`] 一样，模块及其内容默认是私有的，模块外部的代码无法访问。",
        "translate": ""
    },
    {
        "source": "More information on mutable references and pointers can be found in the [Reference].",
        "suggest": "可以在 [Reference] 中找到更多关于资源 0 引用和指针的信息。",
        "translate": ""
    },
    {
        "source": "See the Reference for more information on [trait objects][ref-trait-obj] and [object safety][ref-obj-safety].",
        "suggest": "有关 [trait objects][ref-trait-obj] 和 [object safety][ref-obj-safety] 的更多信息，请参见引用。",
        "translate": ""
    },
    {
        "source": "Create a new cell with its contents set to `value`.",
        "suggest": "创建一个新的 cell，其内容设置为 `value`。",
        "translate": ""
    },
    {
        "source": "This conversion creates a [`SocketAddr::V4`] for an [`IpAddr::V4`] and creates a [`SocketAddr::V6`] for an [`IpAddr::V6`].",
        "suggest": "此转换为 [`IpAddr::V4`] 创建 [`SocketAddr::V4`]，并为 [`IpAddr::V6`] 创建 [`SocketAddr::V6`]。",
        "translate": ""
    },
    {
        "source": "The returned iterator might not actually yield any values depending on the outcome of any resolution performed.",
        "suggest": "根据执行的任何解析的结果，返回的迭代器实际上可能不会产生任何值。",
        "translate": ""
    },
    {
        "source": "An IPv6 multicast address with global scope (`ff0e::`).",
        "suggest": "具有全局作用域 (`ff0e::`) 的 IPv6 多播地址。",
        "translate": ""
    },
    {
        "source": "Will print \"Global scope\".",
        "suggest": "将打印 \"Global scope\"。",
        "translate": ""
    },
    {
        "source": "Embedding IPv4 Addresses",
        "suggest": "嵌入 IPv4 地址",
        "translate": ""
    },
    {
        "source": "To assist in the transition from IPv4 to IPv6 two types of IPv6 addresses that embed an IPv4 address were defined:",
        "suggest": "为了帮助从 IPv4 过渡到 IPv6，定义了两种类型的 IPv6 地址，它们嵌入了 IPv4 地址:",
        "translate": ""
    },
    {
        "source": "IPv4-compatible and IPv4-mapped addresses.",
        "suggest": "IPv4 兼容地址和 IPv4 映射地址。",
        "translate": ""
    },
    {
        "source": "Of these IPv4-compatible addresses have been officially deprecated.",
        "suggest": "其中这些与 IPv4 兼容的地址已被正式弃用。",
        "translate": ""
    },
    {
        "source": "Both types of addresses are not assigned any special meaning by this implementation, other than what the relevant standards prescribe.",
        "suggest": "除了相关标准规定的内容外，此实现并未为这两种类型的地址分配任何特殊含义。",
        "translate": ""
    },
    {
        "source": "This means that an address like `::ffff:127.0.0.1`, while representing an IPv4 loopback address, is not itself an IPv6 loopback address;",
        "suggest": "这意味着像 `::ffff:127.0.0.1` 这样的地址，虽然代表 IPv4 回环地址，但它本身并不是 IPv6 回环地址;",
        "translate": ""
    },
    {
        "source": "only `::1` is.",
        "suggest": "只有 `::1` 是。",
        "translate": ""
    },
    {
        "source": "To handle these so called \"IPv4-in-IPv6\" addresses, they have to first be converted to their canonical IPv4 address.",
        "suggest": "要处理这些所谓的 \"IPv4-in-IPv6\" 地址，必须首先将它们转换为规范的 IPv4 地址。",
        "translate": ""
    },
    {
        "source": "IPv4-Compatible IPv6 Addresses",
        "suggest": "兼容 IPv4 的 IPv6 地址",
        "translate": ""
    },
    {
        "source": "IPv4-compatible IPv6 addresses are defined in [IETF RFC 4291 Section 2.5.5.1], and have been officially deprecated.",
        "suggest": "IPv4 兼容的 IPv6 地址在 [IETF RFC 4291 Section 2.5.5.1] 中定义，并已被正式弃用。",
        "translate": ""
    },
    {
        "source": "The RFC describes the format of an \"IPv4-Compatible IPv6 address\" as follows:",
        "suggest": "RFC 描述了 \"IPv4-Compatible IPv6 address\" 的格式如下:",
        "translate": ""
    },
    {
        "source": "So `::a.b.c.d` would be an IPv4-compatible IPv6 address representing the IPv4 address `a.b.c.d`.",
        "suggest": "因此 `::a.b.c.d` 将是表示 IPv4 地址 `a.b.c.d` 的 IPv4 兼容 IPv6 地址。",
        "translate": ""
    },
    {
        "source": "To convert from an IPv4 address to an IPv4-compatible IPv6 address, use [`Ipv4Addr::to_ipv6_compatible`].",
        "suggest": "要将 IPv4 地址转换为与 IPv4 兼容的 IPv6 地址，请使用 [`Ipv4Addr::to_ipv6_compatible`]。",
        "translate": ""
    },
    {
        "source": "Use [`Ipv6Addr::to_ipv4`] to convert an IPv4-compatible IPv6 address to the canonical IPv4 address.",
        "suggest": "使用 [`Ipv6Addr::to_ipv4`] 将兼容 IPv4 的 IPv6 地址转换为规范的 IPv4 地址。",
        "translate": ""
    },
    {
        "source": "IPv4-Mapped IPv6 Addresses",
        "suggest": "IPv4 映射的 IPv6 地址",
        "translate": ""
    },
    {
        "source": "IPv4-mapped IPv6 addresses are defined in [IETF RFC 4291 Section 2.5.5.2].",
        "suggest": "IPv4 映射的 IPv6 地址在 [IETF RFC 4291 Section 2.5.5.2] 中定义。",
        "translate": ""
    },
    {
        "source": "The RFC describes the format of an \"IPv4-Mapped IPv6 address\" as follows:",
        "suggest": "RFC 描述了 \"IPv4-Mapped IPv6 address\" 的格式如下:",
        "translate": ""
    },
    {
        "source": "So `::ffff:a.b.c.d` would be an IPv4-mapped IPv6 address representing the IPv4 address `a.b.c.d`.",
        "suggest": "因此 `::ffff:a.b.c.d` 将是表示 IPv4 地址 `a.b.c.d` 的 IPv4 映射 IPv6 地址。",
        "translate": ""
    },
    {
        "source": "To convert from an IPv4 address to an IPv4-mapped IPv6 address, use [`Ipv4Addr::to_ipv6_mapped`].",
        "suggest": "要将 IPv4 地址转换为 IPv4 映射的 IPv6 地址，请使用 [`Ipv4Addr::to_ipv6_mapped`]。",
        "translate": ""
    },
    {
        "source": "Use [`Ipv6Addr::to_ipv4`] to convert an IPv4-mapped IPv6 address to the canonical IPv4 address.",
        "suggest": "使用 [`Ipv6Addr::to_ipv4`] 将 IPv4 映射的 IPv6 地址转换为规范的 IPv4 地址。",
        "translate": ""
    },
    {
        "source": "Scope of an [IPv6 multicast address] as defined in [IETF RFC 7346 section 2].",
        "suggest": "[IETF RFC 7346 section 2] 中定义的 [IPv6 multicast address] 的作用域。",
        "translate": ""
    },
    {
        "source": "Stability Guarantees",
        "suggest": "稳定性保证",
        "translate": ""
    },
    {
        "source": "Not all possible values for a multicast scope have been assigned.",
        "suggest": "并非多播作用域的所有可能值都已分配。",
        "translate": ""
    },
    {
        "source": "Future RFCs may introduce new scopes, which will be added as variants to this enum;",
        "suggest": "Future RFC 可能会引入新的作用域，它将作为成员添加到此枚举中;",
        "translate": ""
    },
    {
        "source": "because of this the enum is marked as `#[non_exhaustive]`.",
        "suggest": "因此，枚举被标记为 `#[non_exhaustive]`。",
        "translate": ""
    },
    {
        "source": "Interface-Local scope.",
        "suggest": "Interface-Local 作用域。",
        "translate": ""
    },
    {
        "source": "Link-Local scope.",
        "suggest": "Link-Local 作用域。",
        "translate": ""
    },
    {
        "source": "Realm-Local scope.",
        "suggest": "Realm-Local 作用域。",
        "translate": ""
    },
    {
        "source": "Admin-Local scope.",
        "suggest": "Admin-Local 作用域。",
        "translate": ""
    },
    {
        "source": "Site-Local scope.",
        "suggest": "Site-Local 作用域。",
        "translate": ""
    },
    {
        "source": "Organization-Local scope.",
        "suggest": "Organization-Local 作用域。",
        "translate": ""
    },
    {
        "source": "Global scope.",
        "suggest": "Global 作用域。",
        "translate": ""
    },
    {
        "source": "Converts this address to an `IpAddr::V4` if it is an IPv4-mapped IPv6 addresses, otherwise it return `self` as-is.",
        "suggest": "如果它是 IPv4 映射的 IPv6 地址，则将此地址转换为 `IpAddr::V4`，否则按原样返回 `self`。",
        "translate": ""
    },
    {
        "source": "addresses reserved for future protocols, except `192.0.0.9/32` and `192.0.0.10/32` which are globally routable",
        "suggest": "为 future 协议保留的地址，但全局可路由的 `192.0.0.9/32` 和 `192.0.0.10/32` 除外",
        "translate": ""
    },
    {
        "source": "addresses reserved for future protocols (`192.0.0.0/24`)",
        "suggest": "为 future 协议 (`192.0.0.0/24`) 保留的地址",
        "translate": ""
    },
    {
        "source": "Converts this address to an [IPv4-compatible] [`IPv6` address].",
        "suggest": "将此地址转换为 [IPv4-compatible] [`IPv6` address]。",
        "translate": ""
    },
    {
        "source": "Note that IPv4-compatible addresses have been officially deprecated.",
        "suggest": "请注意，与 IPv4 兼容的地址已被正式弃用。",
        "translate": ""
    },
    {
        "source": "If you don't explicitly need an IPv4-compatible address for legacy reasons, consider using `to_ipv6_mapped` instead.",
        "suggest": "如果出于遗留原因，您没有明确需要与 IPv4 兼容的地址，请考虑改用 `to_ipv6_mapped`。",
        "translate": ""
    },
    {
        "source": "Converts this address to an [IPv4-mapped] [`IPv6` address].",
        "suggest": "将此地址转换为 [IPv4-mapped] [`IPv6` address]。",
        "translate": ""
    },
    {
        "source": "Returns [`true`] if this is the [loopback address] (`::1`), as defined in [IETF RFC 4291 section 2.5.3].",
        "suggest": "如果这是 [loopback address] (`::1`)，如 [IETF RFC 4291 section 2.5.3] 中所定义，则返回 [`true`]。",
        "translate": ""
    },
    {
        "source": "Contrary to IPv4, in IPv6 there is only one loopback address.",
        "suggest": "与 IPv4 相反，IPv6 只有一个回环地址。",
        "translate": ""
    },
    {
        "source": "Converts this address to an [`IPv4` address] if it's an [IPv4-mapped] address, as defined in [IETF RFC 4291 section 2.5.5.2], otherwise returns [`None`].",
        "suggest": "如果它是 [IPv4-mapped] 地址 (如 [IETF RFC 4291 section 2.5.5.2] 中所定义)，则将此地址转换为 [`IPv4` address]，否则返回 [`None`]。",
        "translate": ""
    },
    {
        "source": "Converts this address to an [`IPv4` address] if it is either an [IPv4-compatible] address as defined in [IETF RFC 4291 section 2.5.5.1], or an [IPv4-mapped] address as defined in [IETF RFC 4291 section 2.5.5.2], otherwise returns [`None`].",
        "suggest": "如果此地址是 [IETF RFC 4291 section 2.5.5.1] 中定义的 [IPv4-compatible] 地址或 [IETF RFC 4291 section 2.5.5.2] 中定义的 [IPv4-mapped] 地址，则将此地址转换为 [`IPv4` address]，否则返回 [`None`]。",
        "translate": ""
    },
    {
        "source": "and `::ffff:a.b.c.d` become `a.b.c.d` All addresses *not* starting with either all zeroes or `::ffff` will return `None`.",
        "suggest": "并且 `::ffff:a.b.c.d` 变为 `a.b.c.d` 所有地址*不*以全零或 `::ffff` 开头将返回 `None`。",
        "translate": ""
    },
    {
        "source": "Converts this address to an `IpAddr::V4` if it is an IPv4-mapped addresses, otherwise it returns self wrapped in an `IpAddr::V6`.",
        "suggest": "如果此地址是 IPv4 映射地址，则将此地址转换为 `IpAddr::V4`，否则返回自包装在 `IpAddr::V6` 中。",
        "translate": ""
    },
    {
        "source": "Sets the value of the `SO_LINGER` option on this socket.",
        "suggest": "设置此套接字上 `SO_LINGER` 选项的值。",
        "translate": ""
    },
    {
        "source": "This value controls how the socket is closed when data remains to be sent.",
        "suggest": "此值控制当数据仍有待发送时如何关闭套接字。",
        "translate": ""
    },
    {
        "source": "If `SO_LINGER` is set, the socket will remain open for the specified duration as the system attempts to send pending data.",
        "suggest": "如果设置了 `SO_LINGER`，则当系统尝试发送挂起的数据时，套接字将在指定的持续时间内保持打开状态。",
        "translate": ""
    },
    {
        "source": "Otherwise, the system may close the socket immediately, or wait for a default timeout.",
        "suggest": "否则，系统可能会立即关闭套接字，或等待默认超时。",
        "translate": ""
    },
    {
        "source": "Gets the value of the `SO_LINGER` option on this socket.",
        "suggest": "获取此套接字上 `SO_LINGER` 选项的值。",
        "translate": ""
    },
    {
        "source": "For more information about this option, see [`TcpStream::set_linger`].",
        "suggest": "有关此选项的更多信息，请参见 [`TcpStream::set_linger`]。",
        "translate": ""
    },
    {
        "source": "In addition to the `impl`s here, `TcpStream` also has `impl`s for `AsFd`/`From<OwnedFd>`/`Into<OwnedFd>` and `AsRawFd`/`IntoRawFd`/`FromRawFd`, on Unix and WASI, and `AsSocket`/`From<OwnedSocket>`/`Into<OwnedSocket>` and `AsRawSocket`/`IntoRawSocket`/`FromRawSocket` on Windows.",
        "suggest": "除了这里的 impl 之外，`TcpStream` 还有 `AsFd`/`From<OwnedFd>`/`Into<OwnedFd>` 和 `AsRawFd`/`IntoRawFd`/`FromRawFd`、Unix 和 WASI 以及 Windows 上的 `AsSocket`/`From<OwnedSocket>`/`Into<OwnedSocket>` 和 `AsRawSocket`/`IntoRawSocket`/`FromRawSocket` 的 impl。",
        "translate": ""
    },
    {
        "source": "In addition to the `impl`s here, `TcpListener` also has `impl`s for `AsFd`/`From<OwnedFd>`/`Into<OwnedFd>` and `AsRawFd`/`IntoRawFd`/`FromRawFd`, on Unix and WASI, and `AsSocket`/`From<OwnedSocket>`/`Into<OwnedSocket>` and `AsRawSocket`/`IntoRawSocket`/`FromRawSocket` on Windows.",
        "suggest": "除了这里的 impl 之外，`TcpListener` 还有 `AsFd`/`From<OwnedFd>`/`Into<OwnedFd>` 和 `AsRawFd`/`IntoRawFd`/`FromRawFd`、Unix 和 WASI 以及 Windows 上的 `AsSocket`/`From<OwnedSocket>`/`Into<OwnedSocket>` 和 `AsRawSocket`/`IntoRawSocket`/`FromRawSocket` 的 impl。",
        "translate": ""
    },
    {
        "source": "Note that this might not have any effect on IPv6 sockets.",
        "suggest": "请注意，这可能对 IPv6 套接字没有任何影响。",
        "translate": ""
    },
    {
        "source": "Note that this might not have any affect on IPv4 sockets.",
        "suggest": "请注意，这可能不会对 IPv4 套接字产生任何影响。",
        "translate": ""
    },
    {
        "source": "In addition to the `impl`s here, `UdpSocket` also has `impl`s for `AsFd`/`From<OwnedFd>`/`Into<OwnedFd>` and `AsRawFd`/`IntoRawFd`/`FromRawFd`, on Unix and WASI, and `AsSocket`/`From<OwnedSocket>`/`Into<OwnedSocket>` and `AsRawSocket`/`IntoRawSocket`/`FromRawSocket` on Windows.",
        "suggest": "除了这里的 impl 之外，`UdpSocket` 还有 `AsFd`/`From<OwnedFd>`/`Into<OwnedFd>` 和 `AsRawFd`/`IntoRawFd`/`FromRawFd`、Unix 和 WASI 以及 Windows 上的 `AsSocket`/`From<OwnedSocket>`/`Into<OwnedSocket>` 和 `AsRawSocket`/`IntoRawSocket`/`FromRawSocket` 的 impl。",
        "translate": ""
    },
    {
        "source": "Definitions for the ESP-IDF framework.",
        "suggest": "ESP-IDF 框架的定义。",
        "translate": ""
    },
    {
        "source": "Raw type definitions for the ESP-IDF framework.",
        "suggest": "ESP-IDF 框架的原始类型定义。",
        "translate": ""
    },
    {
        "source": "Owned and borrowed Unix-like file descriptors.",
        "suggest": "拥有和借用类 Unix 文件描述符。",
        "translate": ""
    },
    {
        "source": "`AsRawFd`, etc.",
        "suggest": "`AsRawFd` 等等",
        "translate": ""
    },
    {
        "source": "`AsFd`, etc.",
        "suggest": "`AsFd` 等等",
        "translate": ""
    },
    {
        "source": "Implementations for `AsRawFd` etc. for network types.",
        "suggest": "`AsRawFd` 等网络类型的实现。",
        "translate": ""
    },
    {
        "source": "A borrowed file descriptor.",
        "suggest": "借用的文件描述符。",
        "translate": ""
    },
    {
        "source": "This has a lifetime parameter to tie it to the lifetime of something that owns the file descriptor.",
        "suggest": "它有一个生命周期参数，将它与拥有文件描述符的事物的生命周期联系起来。",
        "translate": ""
    },
    {
        "source": "This uses `repr(transparent)` and has the representation of a host file descriptor, so it can be used in FFI in places where a file descriptor is passed as an argument, it is not captured or consumed, and it never has the value `-1`.",
        "suggest": "这使用 `repr(transparent)` 并具有主机文件描述符的表示形式，因此它可以在 FFI 中用于文件描述符作为参数传递的地方，它不会被捕获或消耗，并且它永远不会有值 `-1`。",
        "translate": ""
    },
    {
        "source": "An owned file descriptor.",
        "suggest": "拥有所有权的文件描述符。",
        "translate": ""
    },
    {
        "source": "This closes the file descriptor on drop.",
        "suggest": "这将在关闭文件描述符时丢弃。",
        "translate": ""
    },
    {
        "source": "This uses `repr(transparent)` and has the representation of a host file descriptor, so it can be used in FFI in places where a file descriptor is passed as a consumed argument or returned as an owned value, and it never has the value `-1`.",
        "suggest": "这使用 `repr(transparent)` 并具有主机文件描述符的表示形式，因此它可以在 FFI 中用于文件描述符作为消耗参数传递或作为拥有值返回的地方，并且它永远不会有值 `-1`。",
        "translate": ""
    },
    {
        "source": "Return a `BorrowedFd` holding the given raw file descriptor.",
        "suggest": "返回包含给定原始文件描述符的 `BorrowedFd`。",
        "translate": ""
    },
    {
        "source": "The resource pointed to by `fd` must remain open for the duration of the returned `BorrowedFd`, and it must not have the value `-1`.",
        "suggest": "`fd` 指向的资源在返回的 `BorrowedFd` 期间必须保持打开状态，并且它不能具有值 `-1`。",
        "translate": ""
    },
    {
        "source": "The resource pointed to by `fd` must be open and suitable for assuming ownership.",
        "suggest": "`fd` 指向的资源必须是开放的并且适合承担所有权。",
        "translate": ""
    },
    {
        "source": "The resource must not require any cleanup other than `close`.",
        "suggest": "除了 `close` 之外，资源不得需要任何清理。",
        "translate": ""
    },
    {
        "source": "A trait to borrow the file descriptor from an underlying object.",
        "suggest": "一个 trait 来借用来自底层 object 的文件描述符。",
        "translate": ""
    },
    {
        "source": "platforms have a corresponding `AsHandle` and `AsSocket` set of traits.",
        "suggest": "平台有相应的 `AsHandle` 和 `AsSocket` 集 traits。",
        "translate": ""
    },
    {
        "source": "Borrows the file descriptor.",
        "suggest": "借用文件描述符。",
        "translate": ""
    },
    {
        "source": "Safety: `OwnedFd` and `BorrowedFd` have the same validity invariants, and the `BorrowdFd` is bounded by the lifetime of `&self`.",
        "suggest": "安全性: `OwnedFd` 和 `BorrowedFd` 具有相同的有效性不可变变量，`BorrowdFd` 受 `&self` 的生命周期限制。",
        "translate": ""
    },
    {
        "source": "Raw Unix-like file descriptors.",
        "suggest": "原始的类 Unix 文件描述符。",
        "translate": ""
    },
    {
        "source": "A trait to extract the raw file descriptor from an underlying object.",
        "suggest": "trait 从底层 object 中提取原始文件描述符。",
        "translate": ""
    },
    {
        "source": "This is only available on unix and WASI platforms and must be imported in order to call the method.",
        "suggest": "这仅在 unix 和 WASI 平台上可用，必须导入才能调用该方法。",
        "translate": ""
    },
    {
        "source": "The file descriptor will be closed when `pidfd` is dropped.",
        "suggest": "当 `pidfd` 关闭时，文件描述符将被关闭。",
        "translate": ""
    },
    {
        "source": "Linux-specific extensions to primitives in the `std::process` module.",
        "suggest": "`std::process` 模块中原语的 Linux 特定扩展。",
        "translate": ""
    },
    {
        "source": "This type represents a file descriptor that refers to a process.",
        "suggest": "此类型表示引用进程的文件描述符。",
        "translate": ""
    },
    {
        "source": "A `PidFd` can be obtained by setting the corresponding option on [`Command`] with [`create_pidfd`].",
        "suggest": "`PidFd` 可以通过设置 [`Command`] 和 [`create_pidfd`] 上的相应选项来获得。",
        "translate": ""
    },
    {
        "source": "Subsequently, the created pidfd can be retrieved from the [`Child`] by calling [`pidfd`] or [`take_pidfd`].",
        "suggest": "随后，可以通过调用 [`pidfd`] 或 [`take_pidfd`] 从 [`Child`] 中检索创建的 pidfd。",
        "translate": ""
    },
    {
        "source": "Refer to the man page of [`pidfd_open(2)`] for further details.",
        "suggest": "有关详细信息，请参见 [`pidfd_open(2)`] 的手册页。",
        "translate": ""
    },
    {
        "source": "Os-specific extensions for [`Child`]",
        "suggest": "[`Child`] 的操作系统特定扩展",
        "translate": ""
    },
    {
        "source": "Obtains a reference to the [`PidFd`] created for this [`Child`], if available.",
        "suggest": "获取对为此 [`Child`] 创建的 [`PidFd`] 的引用 (如果可用)。",
        "translate": ""
    },
    {
        "source": "A pidfd will only be available if its creation was requested with [`create_pidfd`] when the corresponding [`Command`] was created.",
        "suggest": "只有在创建相应的 [`Command`] 时使用 [`create_pidfd`] 请求创建 pidfd 时，pidfd 才可用。",
        "translate": ""
    },
    {
        "source": "Even if requested, a pidfd may not be available due to an older version of Linux being in use, or if some other error occurred.",
        "suggest": "即使请求，pidfd 也可能不可用，因为正在使用旧版本的 Linux，或者如果发生了一些其他错误。",
        "translate": ""
    },
    {
        "source": "Takes ownership of the [`PidFd`] created for this [`Child`], if available.",
        "suggest": "拥有为此 [`Child`] 创建的 [`PidFd`] (如果可用) 的所有权。",
        "translate": ""
    },
    {
        "source": "Os-specific extensions for [`Command`]",
        "suggest": "[`Command`] 的操作系统特定扩展",
        "translate": ""
    },
    {
        "source": "Sets whether a [`PidFd`](struct@PidFd) should be created for the [`Child`] spawned by this [`Command`].",
        "suggest": "设置是否应为此 [`Command`] 生成的 [`Child`] 创建 [`PidFd`](struct@PidFd)。",
        "translate": ""
    },
    {
        "source": "By default, no pidfd will be created.",
        "suggest": "默认情况下，不会创建 pidfd。",
        "translate": ""
    },
    {
        "source": "The pidfd can be retrieved from the child with [`pidfd`] or [`take_pidfd`].",
        "suggest": "可以使用 [`pidfd`] 或 [`take_pidfd`] 从子节点那里检索 pidfd。",
        "translate": ""
    },
    {
        "source": "A pidfd will only be created if it is possible to do so in a guaranteed race-free manner (e.g.",
        "suggest": "pidfd 只会在有可能以保证无竞争的方式 (例如",
        "translate": ""
    },
    {
        "source": "if the `clone3` system call is supported).",
        "suggest": "如果支持 `clone3` 系统调用)。",
        "translate": ""
    },
    {
        "source": "Otherwise, [`pidfd`] will return an error.",
        "suggest": "否则，[`pidfd`] 将返回错误。",
        "translate": ""
    },
    {
        "source": "Equivalent to C's `size_t` type, from `stddef.h` (or `cstddef` for C++).",
        "suggest": "相当于 C 的 `size_t` 类型，来自 `stddef.h` (或 `cstddef` for C++)。",
        "translate": ""
    },
    {
        "source": "This type is currently always [`usize`], however in the future there may be platforms where this is not the case.",
        "suggest": "此类型当前始终为 [`usize`]，但在 future 中可能存在并非如此的平台。",
        "translate": ""
    },
    {
        "source": "Equivalent to C's `ssize_t` type, from `stddef.h` (or `cstddef` for C++).",
        "suggest": "相当于 C 的 `ssize_t` 类型，来自 `stddef.h` (或 `cstddef` for C++)。",
        "translate": ""
    },
    {
        "source": "This type is currently always [`isize`], however in the future there may be platforms where this is not the case.",
        "suggest": "此类型当前始终为 [`isize`]，但在 future 中可能存在并非如此的平台。",
        "translate": ""
    },
    {
        "source": "this file is currently reused in other `std::os::{platform}::ffi` modules to reduce duplication.",
        "suggest": "该文件目前在其他 `std::os::{platform}::ffi` 模块中重复使用以减少重复。",
        "translate": ""
    },
    {
        "source": "Keep this in mind when applying changes to this file that only apply to `unix`.",
        "suggest": "将此文件应用到仅适用于 `unix` 的更改时，请记住这一点。",
        "translate": ""
    },
    {
        "source": "Sealed Unix-specific extension methods for [`fs::DirEntry`].",
        "suggest": "[`fs::DirEntry`] 的密封 Unix 特定扩展方法。",
        "translate": ""
    },
    {
        "source": "Returns a reference to the underlying `OsStr` of this entry's filename.",
        "suggest": "返回指向此条目文件名的基础 `OsStr` 的引用。",
        "translate": ""
    },
    {
        "source": "and `BorrowedFd` use `rustc_layout_scalar_valid_range_start` and `rustc_layout_scalar_valid_range_end`, with values that depend on the bit width of `RawFd`.",
        "suggest": "和 `BorrowedFd` 使用 `rustc_layout_scalar_valid_range_start` 和 `rustc_layout_scalar_valid_range_end`，其值取决于 `RawFd` 的位宽。",
        "translate": ""
    },
    {
        "source": "If this ever changes, those values will need to be updated.",
        "suggest": "如果这种情况发生变化，则需要更新这些值。",
        "translate": ""
    },
    {
        "source": "Owned and borrowed file descriptors.",
        "suggest": "拥有和借用的文件描述符。",
        "translate": ""
    },
    {
        "source": "Just like raw pointers, raw file descriptors point to resources with dynamic lifetimes, and they can dangle if they outlive their resources or be forged if they're created from invalid values.",
        "suggest": "就像裸指针针一样，原始文件描述符指向具有动态生命周期的资源，如果它们比它们的资源生命周期更长，它们可以悬垂，如果它们是由无效值创建的，则它们可以被伪造。",
        "translate": ""
    },
    {
        "source": "This module provides three types for representing file descriptors, with different ownership properties: raw, borrowed, and owned, which are analogous to types used for representing pointers:",
        "suggest": "该模块提供了三种用于表示文件描述符的类型，具有不同的所有权属性: 原始、借用和拥有，类似于用于表示指针的类型:",
        "translate": ""
    },
    {
        "source": "Like raw pointers, `RawFd` values are primitive values.",
        "suggest": "和裸指针一样，`RawFd` 值是原始值。",
        "translate": ""
    },
    {
        "source": "And in new code, they should be considered unsafe to do I/O on (analogous to dereferencing them).",
        "suggest": "并且在新代码中，他们应该被认为是不安全的 (类似于解引用他们)。",
        "translate": ""
    },
    {
        "source": "Rust did not always provide this guidance, so existing code in the Rust ecosystem often doesn't mark `RawFd` usage as unsafe.",
        "suggest": "Rust 并不总是提供此指导，因此 Rust 生态系统中的现有代码通常不会将 `RawFd` 的使用标记为不安全。",
        "translate": ""
    },
    {
        "source": "Once the `io_safety` feature is stable, libraries will be encouraged to migrate, either by adding `unsafe` to APIs that dereference `RawFd` values, or by using to `BorrowedFd` or `OwnedFd` instead.",
        "suggest": "一旦 `io_safety` 特性稳定，将鼓励库迁移，通过将 `unsafe` 添加到解引用 `RawFd` 值的 API，或者使用 `BorrowedFd` 或 `OwnedFd` 代替。",
        "translate": ""
    },
    {
        "source": "Like references, `BorrowedFd` values are tied to a lifetime, to ensure that they don't outlive the resource they point to.",
        "suggest": "与引用一样，`BorrowedFd` 值与生命周期相关联，以确保它们的生命周期不会超过它们指向的资源。",
        "translate": ""
    },
    {
        "source": "These are safe to use.",
        "suggest": "这些可以安全使用。",
        "translate": ""
    },
    {
        "source": "`BorrowedFd` values may be used in APIs which provide safe access to any system call except for:",
        "suggest": "`BorrowedFd` 值可用于提供对任何系统调用的安全访问的 API 中，除了:",
        "translate": ""
    },
    {
        "source": "because that would end the dynamic lifetime of the resource without ending the lifetime of the file descriptor.",
        "suggest": "因为这将结束资源的动态生命周期而不结束文件描述符的生命周期。",
        "translate": ""
    },
    {
        "source": "in the second argument, because this argument is closed and assigned a new resource, which may break the assumptions other code using that file descriptor.",
        "suggest": "在第二个 Parameter 中，因为这个 Parameter 被关闭并分配了一个新资源，这可能会破坏使用该文件描述符的其他代码的假设。",
        "translate": ""
    },
    {
        "source": "This list doesn't include `mmap`, since `mmap` does do a proper borrow of its file descriptor argument.",
        "suggest": "此列表不包括 `mmap`，因为 `mmap` 确实对其文件描述符参数进行了适当的借用。",
        "translate": ""
    },
    {
        "source": "That said, `mmap` is unsafe for other reasons: it operates on raw pointers, and it can have undefined behavior if the underlying storage is mutated.",
        "suggest": "也就是说，`mmap` 是不安全的还有其他原因: 它在裸体疗法上运行，如果底层存储发生可变，它可能会有未定义的行为。",
        "translate": ""
    },
    {
        "source": "Mutations may come from other processes, or from the same process if the API provides `BorrowedFd` access, since as mentioned earlier, `BorrowedFd` values may be used in APIs which provide safe access to any system call.",
        "suggest": "可变的可能来自其他进程，或者来自同一进程，如果 API 提供 `BorrowedFd` 访问，因为如前所述，`BorrowedFd` 值可能用于提供对任何系统调用的安全访问的 API。",
        "translate": ""
    },
    {
        "source": "Consequently, code using `mmap` and presenting a safe API must take full responsibility for ensuring that safe Rust code cannot evoke undefined behavior through it.",
        "suggest": "因此，使用 `mmap` 并提供安全 API 的代码必须全权负责确保安全的 Rust 代码不会通过它引起未定义的行为。",
        "translate": ""
    },
    {
        "source": "Like boxes, `OwnedFd` values conceptually own the resource they point to, and free (close) it when they are dropped.",
        "suggest": "与 box 一样，`OwnedFd` 在概念上拥有它们指向的资源，并在它们被丢弃时释放 X1X。",
        "translate": ""
    },
    {
        "source": "Create an `AncillaryData::ScmRights` variant.",
        "suggest": "创建一个 `AncillaryData::ScmRights` 成员。",
        "translate": ""
    },
    {
        "source": "Create an `AncillaryData::ScmCredentials` variant.",
        "suggest": "创建一个 `AncillaryData::ScmCredentials` 成员。",
        "translate": ""
    },
    {
        "source": "When this closure is run, aspects such as the stdio file descriptors and working directory have successfully been changed, so output to these locations might not appear where intended.",
        "suggest": "运行此闭包时，标准输入输出文件描述符和工作目录等方面已成功更改，因此这些位置的输出可能不会出现在预期的位置。",
        "translate": ""
    },
    {
        "source": "Making an `ExitStatus` always succeeds and never panics.",
        "suggest": "创建 `ExitStatus` 总是会成功的，并且从不 panics。",
        "translate": ""
    },
    {
        "source": "WASI-specific extensions to general I/O primitives.",
        "suggest": "对通用 I/O 原语的 WASI 特定扩展。",
        "translate": ""
    },
    {
        "source": "WASI-specific networking functionality",
        "suggest": "WASI 特定的网络功能",
        "translate": ""
    },
    {
        "source": "On Windows, this struct gets augmented with an implementation of the [`OsStringExt`] trait, which has an [`OsStringExt::from_wide`] method.",
        "suggest": "在 Windows 上，此结构体通过 [`OsStringExt`] trait 的实现得到了增强，该实现具有 [`OsStringExt::from_wide`] 方法。",
        "translate": ""
    },
    {
        "source": "Owned and borrowed OS handles.",
        "suggest": "拥有和借用的操作系统句柄。",
        "translate": ""
    },
    {
        "source": "A borrowed handle.",
        "suggest": "借来的句柄。",
        "translate": ""
    },
    {
        "source": "This has a lifetime parameter to tie it to the lifetime of something that owns the handle.",
        "suggest": "它有一个生命周期参数，将它与拥有句柄的事物的生命周期联系起来。",
        "translate": ""
    },
    {
        "source": "This uses `repr(transparent)` and has the representation of a host handle, so it can be used in FFI in places where a handle is passed as an argument, it is not captured or consumed, and it is never null.",
        "suggest": "这使用 `repr(transparent)` 并具有主机句柄的表示，因此它可以在 FFI 中用于将句柄作为参数传递的地方，它不会被捕获或消耗，并且永远不会为空。",
        "translate": ""
    },
    {
        "source": "Note that it *may* have the value `INVALID_HANDLE_VALUE` (-1), which is sometimes a valid handle value.",
        "suggest": "请注意，它*可能*具有值 `INVALID_HANDLE_VALUE` (-1)，有时这是一个有效的句柄值。",
        "translate": ""
    },
    {
        "source": "See [here] for the full story.",
        "suggest": "有关完整故事，请参见 [here]。",
        "translate": ""
    },
    {
        "source": "An owned handle.",
        "suggest": "拥有所有权的句柄。",
        "translate": ""
    },
    {
        "source": "This closes the handle on drop.",
        "suggest": "这将会丢弃时关闭句柄。",
        "translate": ""
    },
    {
        "source": "This uses `repr(transparent)` and has the representation of a host handle, so it can be used in FFI in places where a handle is passed as a consumed argument or returned as an owned value, and is never null.",
        "suggest": "这使用 `repr(transparent)` 并具有主机句柄的表示形式，因此它可以在 FFI 中用于句柄作为消耗参数传递或作为拥有值返回的地方，并且永远不会为空。",
        "translate": ""
    },
    {
        "source": "For APIs like `CreateFileW` which report errors with `INVALID_HANDLE_VALUE` instead of null, use [`HandleOrInvalid`] instead of `Option<OwnedHandle>`.",
        "suggest": "对于像 `CreateFileW` 这样的 API 使用 `INVALID_HANDLE_VALUE` 而不是 null 报告错误，请使用 [`HandleOrInvalid`] 而不是 `Option<OwnedHandle>`。",
        "translate": ""
    },
    {
        "source": "uses [`CloseHandle`] to close its handle on drop.",
        "suggest": "使用 [`CloseHandle`] 在丢弃时关闭句柄。",
        "translate": ""
    },
    {
        "source": "As such, it must not be used with handles to open registry keys which need to be closed with [`RegCloseKey`] instead.",
        "suggest": "因此，它不能与句柄一起使用来打开需要用 [`RegCloseKey`] 关闭的注册表项。",
        "translate": ""
    },
    {
        "source": "FFI type for handles in return values or out parameters, where `INVALID_HANDLE_VALUE` is used as a sentry value to indicate errors, such as in the return value of `CreateFileW`.",
        "suggest": "返回值或输出参数句柄的 FFI 类型，其中 `INVALID_HANDLE_VALUE` 用作哨兵值以指示错误，例如在 `CreateFileW` 的返回值中。",
        "translate": ""
    },
    {
        "source": "This uses `repr(transparent)` and has the representation of a host handle, so that it can be used in such FFI declarations.",
        "suggest": "这使用 `repr(transparent)` 并具有主机句柄的表示，因此它可以用于此类 FFI 声明。",
        "translate": ""
    },
    {
        "source": "The only thing you can usefully do with a `HandleOrInvalid` is to convert it into an `OwnedHandle` using its [`TryFrom`] implementation;",
        "suggest": "您可以对 `HandleOrInvalid` 做的唯一有用的事情是使用其 [`TryFrom`] 实现将其转换为 `OwnedHandle`;",
        "translate": ""
    },
    {
        "source": "this conversion takes care of the check for `INVALID_HANDLE_VALUE`.",
        "suggest": "此转换负责检查 `INVALID_HANDLE_VALUE`。",
        "translate": ""
    },
    {
        "source": "This ensures that such FFI calls cannot start using the handle without checking for `INVALID_HANDLE_VALUE` first.",
        "suggest": "这可确保此类 FFI 调用在未先检查 `INVALID_HANDLE_VALUE` 的情况下无法开始使用句柄。",
        "translate": ""
    },
    {
        "source": "If this holds a valid handle, it will close the handle on drop.",
        "suggest": "如果它持有一个有效的句柄，它将关闭 丢弃 上的句柄。",
        "translate": ""
    },
    {
        "source": "The Windows [`HANDLE`] type may be transferred across and shared between thread boundaries (despite containing a `*mut void`, which in general isn't `Send` or `Sync`).",
        "suggest": "Windows [`HANDLE`] 类型可以跨线程边界传输和共享 (尽管包含 `*mut void`，它通常不是 `Send` 或 `Sync`)。",
        "translate": ""
    },
    {
        "source": "Return a `BorrowedHandle` holding the given raw handle.",
        "suggest": "返回一个 `BorrowedHandle` 持有给定的原始句柄。",
        "translate": ""
    },
    {
        "source": "The resource pointed to by `handle` must be a valid open handle, it must remain open for the duration of the returned `BorrowedHandle`, and it must not be null.",
        "suggest": "`handle` 指向的资源必须是有效的打开句柄，它必须在返回的 `BorrowedHandle` 期间保持打开状态，并且不能为空。",
        "translate": ""
    },
    {
        "source": "In theory, we ought to be able to assume that the pointer here is never null, use `OwnedHandle` rather than `Option<OwnedHandle>`, and obviate the the panic path here.",
        "suggest": "理论上，我们应该能够假设这里的指针永远不会为空，使用 `OwnedHandle` 而不是 `Option<OwnedHandle>`，并消除这里的 panic 路径。",
        "translate": ""
    },
    {
        "source": "Unfortunately, Win32 documentation doesn't explicitly guarantee this anywhere.",
        "suggest": "不幸的是，Win32 文档并没有在任何地方明确保证这一点。",
        "translate": ""
    },
    {
        "source": "APIs like [`CreateFileW`] itself have `HANDLE` arguments where a null handle indicates an absent value, which wouldn't work if null were a valid handle value, so it seems very unlikely that it could ever return null.",
        "suggest": "像 [`CreateFileW`] 这样的 API 本身有 `HANDLE` 参数，其中 null 句柄表示不存在的值，如果 null 是有效的句柄值，这将不起作用，因此它似乎不太可能返回 null。",
        "translate": ""
    },
    {
        "source": "But who knows?",
        "suggest": "但谁知道呢?",
        "translate": ""
    },
    {
        "source": "Constructs a new instance of `Self` from the given raw handle.",
        "suggest": "从给定的原始句柄构造 `Self` 的新实例。",
        "translate": ""
    },
    {
        "source": "Use `HandleOrInvalid` instead of `Option<OwnedHandle>` for APIs that use `INVALID_HANDLE_VALUE` to indicate failure.",
        "suggest": "对于使用 `INVALID_HANDLE_VALUE` 指示失败的 API，使用 `HandleOrInvalid` 而不是 `Option<OwnedHandle>`。",
        "translate": ""
    },
    {
        "source": "The resource pointed to by `handle` must be open and suitable for assuming ownership.",
        "suggest": "`handle` 指向的资源必须是开放的并且适合承担所有权。",
        "translate": ""
    },
    {
        "source": "The resource must not require any cleanup other than `CloseHandle`.",
        "suggest": "除了 `CloseHandle` 之外，资源不得需要任何清理。",
        "translate": ""
    },
    {
        "source": "In particular, it must not be used with handles to open registry keys which need to be closed with [`RegCloseKey`] instead.",
        "suggest": "特别是，它不能与句柄一起使用来打开需要用 [`RegCloseKey`] 关闭的注册表项。",
        "translate": ""
    },
    {
        "source": "Constructs a new instance of `Self` from the given `RawHandle` returned from a Windows API that uses `INVALID_HANDLE_VALUE` to indicate failure, such as `CreateFileW`.",
        "suggest": "根据从 Windows API 返回的给定 `RawHandle` 构造 `Self` 的新实例，该 API 使用 `INVALID_HANDLE_VALUE` 指示失败，例如 `CreateFileW`。",
        "translate": ""
    },
    {
        "source": "Use `Option<OwnedHandle>` instead of `HandleOrInvalid` for APIs that use null to indicate failure.",
        "suggest": "对于使用 null 表示失败的 API，使用 `Option<OwnedHandle>` 而不是 `HandleOrInvalid`。",
        "translate": ""
    },
    {
        "source": "The resource pointed to by `handle` must be either open and otherwise unowned, or equal to `INVALID_HANDLE_VALUE` (-1).",
        "suggest": "`handle` 指向的资源必须是开放的或无主的，或者等于 `INVALID_HANDLE_VALUE` (-1)。",
        "translate": ""
    },
    {
        "source": "It must not be null.",
        "suggest": "它不能为 null。",
        "translate": ""
    },
    {
        "source": "Note that not all Windows APIs use `INVALID_HANDLE_VALUE` for errors;",
        "suggest": "请注意，并非所有 Windows API 都使用 `INVALID_HANDLE_VALUE` 来处理错误;",
        "translate": ""
    },
    {
        "source": "see [here] for the full story.",
        "suggest": "有关完整故事，请参见 [这个][here]。",
        "translate": ""
    },
    {
        "source": "We require non-null here to catch errors earlier.",
        "suggest": "我们在这里需要非空值来更早地捕获错误。",
        "translate": ""
    },
    {
        "source": "A trait to borrow the handle from an underlying object.",
        "suggest": "A trait 借用底层 object 的句柄。",
        "translate": ""
    },
    {
        "source": "Borrows the handle.",
        "suggest": "借用句柄。",
        "translate": ""
    },
    {
        "source": "Safety: `OwnedHandle` and `BorrowedHandle` have the same validity invariants, and the `BorrowdHandle` is bounded by the lifetime of `&self`.",
        "suggest": "安全性: `OwnedHandle` 和 `BorrowedHandle` 具有相同的有效性不可变变量，`BorrowdHandle` 受 `&self` 的生命周期限制。",
        "translate": ""
    },
    {
        "source": "Just like raw pointers, raw Windows handles and sockets point to resources with dynamic lifetimes, and they can dangle if they outlive their resources or be forged if they're created from invalid values.",
        "suggest": "就像裸指针一样，原始的 Windows 句柄和套接字指向具有动态生命周期的资源，如果它们比它们的资源生命周期更长，它们可以悬垂，如果它们是由无效值创建的，则它们可以被伪造。",
        "translate": ""
    },
    {
        "source": "This module provides three types for representing raw handles and sockets with different ownership properties: raw, borrowed, and owned, which are analogous to types used for representing pointers:",
        "suggest": "该模块提供了三种类型来表示具有不同所有权属性的原始句柄和套接字: 原始、借用和拥有，类似于用于表示指针的类型:",
        "translate": ""
    },
    {
        "source": "Like raw pointers, `RawHandle` and `RawSocket` values are primitive values.",
        "suggest": "和裸指针一样，`RawHandle` 和 `RawSocket` 值都是原始值。",
        "translate": ""
    },
    {
        "source": "Rust did not always provide this guidance, so existing code in the Rust ecosystem often doesn't mark `RawHandle` and `RawSocket` usage as unsafe.",
        "suggest": "Rust 并不总是提供此指导，因此 Rust 生态系统中的现有代码通常不会将 `RawHandle` 和 `RawSocket` 的使用标记为不安全。",
        "translate": ""
    },
    {
        "source": "Once the `io_safety` feature is stable, libraries will be encouraged to migrate, either by adding `unsafe` to APIs that dereference `RawHandle` and `RawSocket` values, or by using to `BorrowedHandle`, `BorrowedSocket`, `OwnedHandle`, or `OwnedSocket`.",
        "suggest": "一旦 `io_safety` 功能稳定，将鼓励库迁移，通过将 `unsafe` 添加到解引用 `RawHandle` 和 `RawSocket` 值的 API，或通过使用 `BorrowedHandle`、`BorrowedSocket`、`OwnedHandle` 或 `OwnedSocket`。",
        "translate": ""
    },
    {
        "source": "Like references, `BorrowedHandle` and `BorrowedSocket` values are tied to a lifetime, to ensure that they don't outlive the resource they point to.",
        "suggest": "与引用一样，`BorrowedHandle` 和 `BorrowedSocket` 值与生命周期相关联，以确保它们的生命周期不会超过它们指向的资源。",
        "translate": ""
    },
    {
        "source": "and `BorrowedSocket` values may be used in APIs which provide safe access to any system call except for `CloseHandle`, `closesocket`, or any other call that would end the dynamic lifetime of the resource without ending the lifetime of the handle or socket.",
        "suggest": "`BorrowedSocket` 和 `BorrowedSocket` 值可用于提供对任何系统调用的安全访问的 API，除了 `CloseHandle`、`closesocket` 或任何其他会结束资源的动态生命周期而不结束句柄或套接字的生命周期的其他调用。",
        "translate": ""
    },
    {
        "source": "Like boxes, `OwnedHandle` and `OwnedSocket` values conceptually own the resource they point to, and free (close) it when they are dropped.",
        "suggest": "与 boxes 一样，`OwnedHandle` 和 `OwnedSocket` 值在概念上拥有它们指向的资源，并在它们被丢弃时释放 (close)。",
        "translate": ""
    },
    {
        "source": "Owned and borrowed OS sockets.",
        "suggest": "拥有和借用的操作系统套接字。",
        "translate": ""
    },
    {
        "source": "A borrowed socket.",
        "suggest": "借来的套接字。",
        "translate": ""
    },
    {
        "source": "This has a lifetime parameter to tie it to the lifetime of something that owns the socket.",
        "suggest": "它有一个生命周期参数，将它与拥有套接字的事物的生命周期联系起来。",
        "translate": ""
    },
    {
        "source": "This uses `repr(transparent)` and has the representation of a host socket, so it can be used in FFI in places where a socket is passed as an argument, it is not captured or consumed, and it never has the value `INVALID_SOCKET`.",
        "suggest": "这使用 `repr(transparent)` 并具有主机套接字的表示形式，因此它可以在 FFI 中用于套接字作为参数传递的地方，它不会被捕获或消耗，并且它永远不会有值 `INVALID_SOCKET`。",
        "translate": ""
    },
    {
        "source": "This is -2, in two's complement.",
        "suggest": "这是 -2，二进制补码。",
        "translate": ""
    },
    {
        "source": "-1 is `INVALID_SOCKET`.",
        "suggest": "-1 是 `INVALID_SOCKET`。",
        "translate": ""
    },
    {
        "source": "An owned socket.",
        "suggest": "一个拥有所有权的套接字。",
        "translate": ""
    },
    {
        "source": "This closes the socket on drop.",
        "suggest": "这将丢弃时关闭套接字。",
        "translate": ""
    },
    {
        "source": "This uses `repr(transparent)` and has the representation of a host socket, so it can be used in FFI in places where a socket is passed as a consumed argument or returned as an owned value, and it never has the value `INVALID_SOCKET`.",
        "suggest": "这使用 `repr(transparent)` 并具有主机套接字的表示，因此它可以在 FFI 中使用，在套接字作为消耗参数传递或作为拥有值返回的地方，它永远不会有值 `INVALID_SOCKET`。",
        "translate": ""
    },
    {
        "source": "Return a `BorrowedSocket` holding the given raw socket.",
        "suggest": "返回一个包含给定原始套接字的 `BorrowedSocket`。",
        "translate": ""
    },
    {
        "source": "The resource pointed to by `raw` must remain open for the duration of the returned `BorrowedSocket`, and it must not have the value `INVALID_SOCKET`.",
        "suggest": "`raw` 指向的资源在返回的 `BorrowedSocket` 期间必须保持打开状态，并且它不能具有值 `INVALID_SOCKET`。",
        "translate": ""
    },
    {
        "source": "Constructs a new instance of `Self` from the given raw socket.",
        "suggest": "从给定的原始套接字构造 `Self` 的新实例。",
        "translate": ""
    },
    {
        "source": "The resource pointed to by `socket` must be open and suitable for assuming ownership.",
        "suggest": "`socket` 指向的资源必须是开放的并且适合承担所有权。",
        "translate": ""
    },
    {
        "source": "The resource must not require cleanup other than `closesocket`.",
        "suggest": "除了 `closesocket` 之外，资源不得需要清理。",
        "translate": ""
    },
    {
        "source": "A trait to borrow the socket from an underlying object.",
        "suggest": "一个 trait 从底层 object 借用套接字。",
        "translate": ""
    },
    {
        "source": "Borrows the socket.",
        "suggest": "借用套接字。",
        "translate": ""
    },
    {
        "source": "Safety: `OwnedSocket` and `BorrowedSocket` have the same validity invariants, and the `BorrowdSocket` is bounded by the lifetime of `&self`.",
        "suggest": "安全性: `OwnedSocket` 和 `BorrowedSocket` 具有相同的有效性不可变变量，`BorrowdSocket` 受 `&self` 的生命周期限制。",
        "translate": ""
    },
    {
        "source": "Append literal text to the command line without any quoting or escaping.",
        "suggest": "将字面量文本附加到命令行，无需任何引用或转义。",
        "translate": ""
    },
    {
        "source": "This is useful for passing arguments to `cmd.exe /c`, which doesn't follow `CommandLineToArgvW` escaping rules.",
        "suggest": "这对于将参数传递给 `cmd.exe /c` 很有用，它不遵循 `CommandLineToArgvW` 转义规则。",
        "translate": ""
    },
    {
        "source": "Note that this function **might not catch all panics** in Rust.",
        "suggest": "请注意，此函数**可能无法捕获 Rust 中的所有 panics**。",
        "translate": ""
    },
    {
        "source": "Fast path for long shared prefixes",
        "suggest": "长共享前缀的快速路径",
        "translate": ""
    },
    {
        "source": "compare raw bytes to find first mismatch",
        "suggest": "比较原始字节以找到第一个不匹配",
        "translate": ""
    },
    {
        "source": "backtrack to find separator before mismatch to avoid ambiguous parsings of '.' or '..' characters",
        "suggest": "回溯以在不匹配之前找到分隔符，以避免 '.' 或 '..' 字符的歧义解析",
        "translate": ""
    },
    {
        "source": "if found update state to only do a component-wise comparison on the remainder, otherwise do it on the full path",
        "suggest": "如果发现更新状态只对剩余部分进行组件比较，否则在完整路径上进行",
        "translate": ""
    },
    {
        "source": "The fast path isn't taken for paths with a PrefixComponent to avoid backtracking into the middle of one",
        "suggest": "对于带有 PrefixComponent 的路径，不采用快速路径以避免回溯到一个路径的中间",
        "translate": ""
    },
    {
        "source": "this might benefit from a [u8]::first_mismatch simd implementation, if it existed",
        "suggest": "这可能会受益于 [u8]::first_mismatch simd 实现，如果它存在的话",
        "translate": ""
    },
    {
        "source": "This method is similar to [`Path::file_prefix`], which extracts the portion of the file name before the *first* `.`",
        "suggest": "这个方法类似于 [`Path::file_prefix`]，提取 *first* `.` 之前的文件名部分",
        "translate": ""
    },
    {
        "source": "Extracts the prefix of [`self.file_name`].",
        "suggest": "提取 [`self.file_name`] 的前缀。",
        "translate": ""
    },
    {
        "source": "The prefix is:",
        "suggest": "前缀是:",
        "translate": ""
    },
    {
        "source": "The portion of the file name before the first non-beginning `.`;",
        "suggest": "文件名中第一个非开头 `.` 之前的部分;",
        "translate": ""
    },
    {
        "source": "The portion of the file name before the second `.` if the file name begins with `.`",
        "suggest": "如果文件名以 `.` 开头，则为第二个 `.` 之前的文件名部分",
        "translate": ""
    },
    {
        "source": "This method is similar to [`Path::file_stem`], which extracts the portion of the file name before the *last* `.`",
        "suggest": "此方法类似于 [`Path::file_stem`]，提取文件名中 *last* `.` 之前的部分",
        "translate": ""
    },
    {
        "source": "Returns true if the path exists on disk and is pointing at a symbolic link.",
        "suggest": "如果路径存在于磁盘上并且指向符号链接，则返回 true。",
        "translate": ""
    },
    {
        "source": "This function will not traverse symbolic links.",
        "suggest": "这个函数不会遍历符号链接。",
        "translate": ""
    },
    {
        "source": "In case of a broken symbolic link this will also return true.",
        "suggest": "如果符号链接损坏，这也将返回 true。",
        "translate": ""
    },
    {
        "source": "If you cannot access the directory containing the file, e.g., because of a permission error, this will return false.",
        "suggest": "如果您无法访问包含该文件的目录，例如，由于权限错误，这将返回 false。",
        "translate": ""
    },
    {
        "source": "The first version of the prelude is used in Rust 2015 and Rust 2018, and lives in [`std::prelude::v1`].",
        "suggest": "prelude 的第一个版本用于 Rust 2015 和 Rust 2018，并存在于 [`std::prelude::v1`] 中。",
        "translate": ""
    },
    {
        "source": "and [`std::prelude::rust_2018`] re-export this prelude.",
        "suggest": "并且 [`std::prelude::rust_2018`] 重导出了这个 prelude。",
        "translate": ""
    },
    {
        "source": "It re-exports the following:",
        "suggest": "它重导出以下内容:",
        "translate": ""
    },
    {
        "source": "The prelude used in Rust 2021, [`std::prelude::rust_2021`], includes all of the above, and in addition re-exports:",
        "suggest": "Rust 2021 [`std::prelude::rust_2021`] 中使用的 prelude，包含了以上所有内容，另外还有重导出:",
        "translate": ""
    },
    {
        "source": "As always, remember that a human intuition for 'character' might not map to Unicode's definitions.",
        "suggest": "与往常一样，请记住，人类对 'character' 的直觉可能不是 map 到 Unicode 的定义。",
        "translate": ""
    },
    {
        "source": "Ensure that starting a process with no environment variables works on Windows.",
        "suggest": "确保在 Windows 上启动一个没有环境变量的进程。",
        "translate": ""
    },
    {
        "source": "This will fail if the environment block is ill-formed.",
        "suggest": "如果环境块格式错误，这将失败。",
        "translate": ""
    },
    {
        "source": "In addition to the `impl`s here, `ChildStdin` also has `impl`s for `AsFd`/`From<OwnedFd>`/`Into<OwnedFd>` and `AsRawFd`/`IntoRawFd`/`FromRawFd`, on Unix and WASI, and `AsHandle`/`From<OwnedHandle>`/`Into<OwnedHandle>` and `AsRawHandle`/`IntoRawHandle`/`FromRawHandle` on Windows.",
        "suggest": "除了这里的 impl 之外，`ChildStdin` 还有 `AsFd`/`From<OwnedFd>`/`Into<OwnedFd>` 和 `AsRawFd`/`IntoRawFd`/`FromRawFd`、Unix 和 WASI 以及 Windows 上的 `AsHandle`/`From<OwnedHandle>`/`Into<OwnedHandle>` 和 `AsRawHandle`/`IntoRawHandle`/`FromRawHandle` 的 impl。",
        "translate": ""
    },
    {
        "source": "In addition to the `impl`s here, `ChildStdout` also has `impl`s for `AsFd`/`From<OwnedFd>`/`Into<OwnedFd>` and `AsRawFd`/`IntoRawFd`/`FromRawFd`, on Unix and WASI, and `AsHandle`/`From<OwnedHandle>`/`Into<OwnedHandle>` and `AsRawHandle`/`IntoRawHandle`/`FromRawHandle` on Windows.",
        "suggest": "除了这里的 impl 之外，`ChildStdout` 还有 `AsFd`/`From<OwnedFd>`/`Into<OwnedFd>` 和 `AsRawFd`/`IntoRawFd`/`FromRawFd`、Unix 和 WASI 以及 Windows 上的 `AsHandle`/`From<OwnedHandle>`/`Into<OwnedHandle>` 和 `AsRawHandle`/`IntoRawHandle`/`FromRawHandle` 的 impl。",
        "translate": ""
    },
    {
        "source": "In addition to the `impl`s here, `ChildStderr` also has `impl`s for `AsFd`/`From<OwnedFd>`/`Into<OwnedFd>` and `AsRawFd`/`IntoRawFd`/`FromRawFd`, on Unix and WASI, and `AsHandle`/`From<OwnedHandle>`/`Into<OwnedHandle>` and `AsRawHandle`/`IntoRawHandle`/`FromRawHandle` on Windows.",
        "suggest": "除了这里的 impl 之外，`ChildStderr` 还有 `AsFd`/`From<OwnedFd>`/`Into<OwnedFd>` 和 `AsRawFd`/`IntoRawFd`/`FromRawFd`、Unix 和 WASI 以及 Windows 上的 `AsHandle`/`From<OwnedHandle>`/`Into<OwnedHandle>` 和 `AsRawHandle`/`IntoRawHandle`/`FromRawHandle` 的 impl。",
        "translate": ""
    },
    {
        "source": "This is exactly like [`code()`](Self::code), except that it returns a `NonZeroI32`.",
        "suggest": "这与 [`code()`](Self::code) 完全一样，只是它返回一个 `NonZeroI32`。",
        "translate": ""
    },
    {
        "source": "The mapping to [`ErrorKind`]s is not part of the compatibility contract of the function.",
        "suggest": "到 [`ErrorKind`] 的映射不是函数的兼容性契约的一部分。",
        "translate": ""
    },
    {
        "source": "Rust IO buffers (eg, from `BufWriter`) will not be flushed.",
        "suggest": "Rust IO 缓冲区 (例如，来自 `BufWriter`) 不会被刷新。",
        "translate": ""
    },
    {
        "source": "Likewise, C stdio buffers will (on most platforms) not be flushed.",
        "suggest": "同样，C 标准输入输出缓冲器 (在大多数平台上) 不会被刷新。",
        "translate": ""
    },
    {
        "source": "The process's termination will be similar to that from the C `abort()` function.",
        "suggest": "该进程的终止将类似于 C `abort()` 函数的终止。",
        "translate": ""
    },
    {
        "source": "On Unix, the process will terminate with signal `SIGABRT`, which typically means that the shell prints \"Aborted\".",
        "suggest": "在 Unix 上，进程将以信号 `SIGABRT` 终止，这通常意味着 shell 打印 \"Aborted\"。",
        "translate": ""
    },
    {
        "source": "Guard against the code called by this function from unwinding outside of the Rust-controlled code, which is UB.",
        "suggest": "在 Rust 控制的代码之外，要防范这个函数从展开中调用的代码，也就是 UB。",
        "translate": ""
    },
    {
        "source": "This is a requirement imposed by a combination of how the `#[lang=\"start\"]` attribute is implemented as well as by the implementation of the panicking mechanism itself.",
        "suggest": "这是由 `#[lang=\"start\"]` 属性的实现方式以及 panicking 机制本身的实现所强加的要求。",
        "translate": ""
    },
    {
        "source": "There are a couple of instances where unwinding can begin.",
        "suggest": "有几种情况可以开始展开。",
        "translate": ""
    },
    {
        "source": "First is inside of the `rt::init`, `rt::cleanup` and similar functions controlled by libstd.",
        "suggest": "首先是 libstd 控制的 `rt::init`、`rt::cleanup` 等类似函数的内部。",
        "translate": ""
    },
    {
        "source": "In those instances a panic is a libstd implementation bug.",
        "suggest": "在这些情况下，panic 是 libstd 实现错误。",
        "translate": ""
    },
    {
        "source": "A quite likely one too, as there isn't any way to prevent libstd from accidentally introducing a panic to these functions.",
        "suggest": "也很有可能，因为没有任何方法可以防止 libstd 意外地将 panic 引入这些函数。",
        "translate": ""
    },
    {
        "source": "Another is from user code from `main` or, more nefariously, as described in e.g.",
        "suggest": "另一个来自 `main` 的用户代码，或者更邪恶的是，如",
        "translate": ""
    },
    {
        "source": "This method should not be used for precise timing due to anomalies such as preemption or platform differences that might not cause the maximum amount of time waited to be precisely `ms`.",
        "suggest": "由于抢占或平台差异等异常情况可能不会导致最大等待时间精确到 `ms`，因此不应将此方法用于精确计时。",
        "translate": ""
    },
    {
        "source": "This method should not be used for precise timing due to anomalies such as preemption or platform differences that might not cause the maximum amount of time waited to be precisely `dur`.",
        "suggest": "由于抢占或平台差异等异常情况可能不会导致最大等待时间精确到 `dur`，因此不应将此方法用于精确计时。",
        "translate": ""
    },
    {
        "source": "It would be the same without thread and clone here since there will still be one `tx` left.",
        "suggest": "这里没有线程和克隆也是一样的，因为仍然会剩下一个 `tx`。",
        "translate": ""
    },
    {
        "source": "cloned tx dropped within thread",
        "suggest": "克隆的 tx 丢弃在线程中",
        "translate": ""
    },
    {
        "source": "Drop the last sender to stop `rx` waiting for message.",
        "suggest": "删除最后一个发送者停止 `rx` 等待消息。",
        "translate": ""
    },
    {
        "source": "The program will not complete if we comment this out.",
        "suggest": "如果我们将其注释掉，程序将无法完成。",
        "translate": ""
    },
    {
        "source": "**All** `tx` needs to be dropped for `rx` to have `Err`.",
        "suggest": "所有需要为 `rx` 排除 `tx` 才能拥有 `Err`。",
        "translate": ""
    },
    {
        "source": "Unbounded receiver waiting for all senders to complete.",
        "suggest": "无限接收者等待所有发送者完成。",
        "translate": ""
    },
    {
        "source": "Unbounded receive loop:",
        "suggest": "无限接收循环:",
        "translate": ""
    },
    {
        "source": "all senders (the original and the clones) need to be dropped for the receiver to stop blocking to receive messages with [`Receiver::recv`].",
        "suggest": "所有发送者 (原始和克隆) 都需要被接收者去除，以停止阻止接收带有 [`Receiver::recv`] 的消息。",
        "translate": ""
    },
    {
        "source": "will block until a message is available while there is at least one [`Sender`] alive (including clones).",
        "suggest": "当至少有一个 [`Sender`] 活着 (包括克隆) 时，将阻塞直到消息可用。",
        "translate": ""
    },
    {
        "source": "Clone a sender to send to other threads.",
        "suggest": "克隆发送者以发送到其他线程。",
        "translate": ""
    },
    {
        "source": "Note, be aware of the lifetime of the sender because all senders (including the original) need to be dropped in order for [`Receiver::recv`] to stop blocking.",
        "suggest": "请注意，请注意发送方的生命周期，因为所有发送方 (包括原始发送方) 都需要丢弃，以便 [`Receiver::recv`] 停止阻塞。",
        "translate": ""
    },
    {
        "source": "This function will always block the current thread if there is no data available and it's possible for more data to be sent (at least one sender still exists).",
        "suggest": "如果没有可用数据并且有可能发送更多数据 (至少一个发送者仍然存在)，此函数将始终阻塞当前线程。",
        "translate": ""
    },
    {
        "source": "Once a message is sent to the corresponding [`Sender`] (or [`SyncSender`]), this receiver will wake up and return that message.",
        "suggest": "一旦消息发送到相应的 [`Sender`] (或 [`SyncSender`])，该接收者将唤醒并返回该消息。",
        "translate": ""
    },
    {
        "source": "Due to this caveat, this queue might not be appropriate for all use-cases.",
        "suggest": "由于此警告，此队列可能不适用于所有用例。",
        "translate": ""
    },
    {
        "source": "The senders still have some responsibility, however, because some sends might not complete until after we flag the disconnection.",
        "suggest": "然而，发送者仍然有一些责任，因为在我们标记断开连接之前，一些发送可能不会完成。",
        "translate": ""
    },
    {
        "source": "Note that the data might not actually be sent on the channel just yet.",
        "suggest": "请注意，数据实际上可能尚未在通道上发送。",
        "translate": ""
    },
    {
        "source": "When this function returns, it is guaranteed that some initialization has run and completed (it might not be the closure specified).",
        "suggest": "当这个函数返回时，保证一些初始化已经运行并完成 (它可能不是指定的闭包)。",
        "translate": ""
    },
    {
        "source": "A `TryLockResult` doesn't necessarily hold the associated guard in the [`Err`] type as the lock might not have been acquired for other reasons.",
        "suggest": "`TryLockResult` 不一定持有 [`Err`] 类型的相关保护，因为可能由于其他原因没有获得锁。",
        "translate": ""
    },
    {
        "source": "will block",
        "suggest": "会阻塞",
        "translate": ""
    },
    {
        "source": "may deadlock         |",
        "suggest": "可能死锁         |",
        "translate": ""
    },
    {
        "source": "In particular, a writer which is waiting to acquire the lock in `write` might or might not block concurrent calls to `read`, e.g.:",
        "suggest": "特别是，等待获取 `write` 中的锁的 writer 可能会也可能不会阻止对 `read` 的并发调用，例如:",
        "translate": ""
    },
    {
        "source": "<summary>Potential deadlock example",
        "suggest": "<summary>潜在的死锁示例",
        "translate": ""
    },
    {
        "source": "It is a so called ticket lock and is completely fair.",
        "suggest": "这是一个所谓的 ticket 锁，是完全公平的。",
        "translate": ""
    },
    {
        "source": "not movable: see UnsafeList implementation",
        "suggest": "不可移动: 请参见 UnsafeList 实现",
        "translate": ""
    },
    {
        "source": "Rust normally maps Unix EBADF to `Uncategorized`",
        "suggest": "Rust 通常将 Unix EBADF 映射为 `Uncategorized`",
        "translate": ""
    },
    {
        "source": "self-referential struct!",
        "suggest": "自引用结构体!",
        "translate": ""
    },
    {
        "source": "The system-provided argc and argv, which we store in static memory here so that we can defer the work of parsing them until its actually needed.",
        "suggest": "系统提供的 argc 和 argv，我们将它们存储在这里的静态内存中，以便我们可以将解析它们的工作推迟到实际需要时。",
        "translate": ""
    },
    {
        "source": "Note that we never mutate argv/argc, the argv array, or the argv strings, which allows the code in this file to be very simple.",
        "suggest": "请注意，我们从不改变 argv/argc、argv 数组或 argv 字符串，这使得此文件中的代码非常简单。",
        "translate": ""
    },
    {
        "source": "These don't need to be ordered with each other or other stores, because they only hold the unmodified system-provide argv/argc.",
        "suggest": "这些不需要相互或其他商店订购，因为他们只持有未修改的系统提供的 argv/argc。",
        "translate": ""
    },
    {
        "source": "Load ARGC and ARGV, which hold the unmodified system-provided argc/argv, so we can read the pointed-to memory without atomics or synchronization.",
        "suggest": "加载 ARGC 和 ARGV，它们保存着未修改的系统提供的 argc/argv，因此我们可以在没有原子或同步的情况下读取指向的内存。",
        "translate": ""
    },
    {
        "source": "If either ARGC or ARGV is still zero or null, then either there really are no arguments, or someone is asking for `args()` before initialization has completed, and we return an empty list.",
        "suggest": "如果 ARGC 或 ARGV 仍然为零或空，那么要么真的没有 Parameter，要么有人在初始化完成之前要求 `args()`，我们返回一个空列表。",
        "translate": ""
    },
    {
        "source": "ESP-IDF's PTHREAD_COND_INITIALIZER support is not released yet So on that platform, init() should always be called Moreover, that platform does not have pthread_condattr_setclock support, hence that initialization should be skipped as well",
        "suggest": "ESP-IDF 的 PTHREAD_COND_INITIALIZER 支持还没有发布 所以在那个平台上，应该总是调用 init() 而且，那个平台没有 pthread_condattr_setclock 支持，因此也应该跳过初始化",
        "translate": ""
    },
    {
        "source": "FD_CLOEXEC is not supported in ESP-IDF but there's no need to, because ESP-IDF does not support spawning processes either.",
        "suggest": "ESP-IDF 不支持 FD_CLOEXEC，但没有必要，因为 ESP-IDF 也不支持生成进程。",
        "translate": ""
    },
    {
        "source": "For ESP-IDF, F_DUPFD is used instead, because the CLOEXEC semantics will never be supported, as this is a bare metal framework with no capabilities for multi-process execution.",
        "suggest": "对于 ESP-IDF，使用 F_DUPFD 代替，因为永远不会支持 CLOEXEC 语义，因为这是一个没有多进程执行功能的裸机框架。",
        "translate": ""
    },
    {
        "source": "While F_DUPFD is also not supported yet, it might be (currently it returns ENOSYS).",
        "suggest": "虽然还不支持 F_DUPFD，但它可能支持 (当前它返回 ENOSYS)。",
        "translate": ""
    },
    {
        "source": "Redox and ESP-IDF lack `linkat`, so use `link` instead.",
        "suggest": "Redox 和 ESP-IDF 缺少 `linkat`，因此请改用 `link`。",
        "translate": ""
    },
    {
        "source": "has `linkat` on newer versions, but we happen to know `link` always has the correct behavior, so it's here as well.",
        "suggest": "在较新的版本上有 `linkat`，但我们碰巧知道 `link` 总是有正确的行为，所以它也在这里。",
        "translate": ""
    },
    {
        "source": "On MacOS, older versions (<=10.9) lack support for linkat while newer versions have it.",
        "suggest": "在 MacOS 上，旧版本的 (<=10.9) 缺乏对 linkat 的支持，而较新的版本有它。",
        "translate": ""
    },
    {
        "source": "We want to use linkat if it is available, so we use weak!",
        "suggest": "我们想使用 linkat，如果它可用，所以我们使用 weak!",
        "translate": ""
    },
    {
        "source": "to check.",
        "suggest": "去检查。",
        "translate": ""
    },
    {
        "source": "`linkat` is preferable to `link` ecause it gives us a flag to specify how symlinks should be handled.",
        "suggest": "`linkat` 比 `link` 更可取，因为它给了我们一个标志来指定应该如何处理符号链接。",
        "translate": ""
    },
    {
        "source": "We pass 0 as the flags argument, meaning it shouldn't follow symlinks.",
        "suggest": "我们将 0 作为标志 Parameter 传递，这意味着它不应该遵循符号链接。",
        "translate": ""
    },
    {
        "source": "Where we can, use `linkat` instead of `link`;",
        "suggest": "在我们可以的情况下，使用 `linkat` 代替 `link`;",
        "translate": ""
    },
    {
        "source": "see the comment above this one for details on why.",
        "suggest": "有关原因的详细信息，请参见此评论上方的评论。",
        "translate": ""
    },
    {
        "source": "libc::abort() will run the SIGABRT handler.",
        "suggest": "libc::abort () 将运行 SIGABRT 处理程序。",
        "translate": ""
    },
    {
        "source": "That's fine because anyone who installs a SIGABRT handler already has to expect it to run in Very Bad situations (eg, malloc crashing).",
        "suggest": "这很好，因为任何安装 SIGABRT 处理程序的人都必须期望它在非常糟糕的情况下运行 (例如，malloc 崩溃)。",
        "translate": ""
    },
    {
        "source": "Current glibc's abort() function unblocks SIGABRT, raises SIGABRT, clears the SIGABRT handler and raises it again, and then starts to get creative.",
        "suggest": "当前 glibc 的 abort() 函数解除对 SIGABRT 的阻塞，引发 SIGABRT，清除 SIGABRT 处理程序并再次引发它，然后开始发挥创意。",
        "translate": ""
    },
    {
        "source": "See the public documentation for `intrinsics::abort()` and `process::abort()` for further discussion.",
        "suggest": "有关进一步讨论，请参见 `intrinsics::abort()` 和 `process::abort()` 的公共文档。",
        "translate": ""
    },
    {
        "source": "There is confusion about whether libc::abort() flushes stdio streams.",
        "suggest": "关于 libc::abort () 是否刷新标准输入输出流存在混淆。",
        "translate": ""
    },
    {
        "source": "libc::abort() is required by ISO C 99 (7.14.1.1p5) to be async-signal-safe, so flushing streams is at least extremely hard, if not entirely impossible.",
        "suggest": "ISO C 99 (7.14.1.1p5) 要求 libc::abort () 是异步信号安全的，因此刷新流至少非常困难，如果不是完全不可能的话。",
        "translate": ""
    },
    {
        "source": "However, some versions of POSIX (eg IEEE Std 1003.1-2001) required abort to do so.",
        "suggest": "但是，某些版本的 POSIX (例如 IEEE Std 1003.1-2001) 需要终止来执行此操作。",
        "translate": ""
    },
    {
        "source": "In 1003.1-2004 this was fixed.",
        "suggest": "在 1003.1-2004 中，这是确定的。",
        "translate": ""
    },
    {
        "source": "glibc's implementation did the flush, unsafely, before glibc commit",
        "suggest": "glibc 的实现在 glibc 提交之前不安全地进行了刷新",
        "translate": ""
    },
    {
        "source": "91e7cf982d01 `abort: Do not flush stdio streams [BZ #15436]' by Florian Weimer.",
        "suggest": "91e7cf982d01 `abort: Do not flush 标准输入输出流 [BZ#15436]' by Florian Weimer。",
        "translate": ""
    },
    {
        "source": "According to glibc's NEWS:",
        "suggest": "根据 glibc 的新闻:",
        "translate": ""
    },
    {
        "source": "The abort function terminates the process immediately, without flushing stdio streams.",
        "suggest": "终止函数立即终止该过程，而不刷新标准输入输出流。",
        "translate": ""
    },
    {
        "source": "Previous glibc versions used to flush streams, resulting in deadlocks and further data corruption.",
        "suggest": "以前的 glibc 版本用于刷新流，导致死锁和进一步的数据损坏。",
        "translate": ""
    },
    {
        "source": "This change also affects process aborts as the result of assertion failures.",
        "suggest": "由于断言失败，此更改还会影响进程中止。",
        "translate": ""
    },
    {
        "source": "This is an accurate description of the problem.",
        "suggest": "这是对问题的准确描述。",
        "translate": ""
    },
    {
        "source": "The only solution for program with nontrivial use of C stdio is a fixed libc - one which does not try to flush in abort - since even libc-internal errors, and assertion failures generated from C, will go via abort().",
        "suggest": "对于非平凡使用 C 标准输入输出的程序，唯一的解决方案是固定的 libc - 一个不会尝试在终止中刷新 - 因为即使是 libc 内部错误，以及由 C 产生的断言失败，也会通过 abort()。",
        "translate": ""
    },
    {
        "source": "On systems with old, buggy, libcs, the impact can be severe for a multithreaded C program.",
        "suggest": "在具有旧的 buggy、libcs 的系统上，对多线程 C 程序的影响可能很严重。",
        "translate": ""
    },
    {
        "source": "It is much less severe for Rust, because Rust stdlib doesn't use libc stdio buffering.",
        "suggest": "Rust 的严重程度要低得多，因为 Rust stdlib 不使用 libc 标准输入输出缓冲。",
        "translate": ""
    },
    {
        "source": "In a typical Rust program, which does not use C stdio, even a buggy libc::abort() is, in fact, safe.",
        "suggest": "在典型的 Rust 程序中，不使用 C 标准输入输出，即使是 buggy libc::abort () 实际上也是安全的。",
        "translate": ""
    },
    {
        "source": "See #41582 and https://blog.achernya.com/2013/03/os-x-has-silly-libsystem.html",
        "suggest": "请参见 #41582 和 https://blog.achernya.com/2013/03/os-x-has-silly-libsystem.html",
        "translate": ""
    },
    {
        "source": "This is used by sys_common code to abstract over Windows and Unix.",
        "suggest": "sys_common 代码使用它来抽象 Windows 和 Unix。",
        "translate": ""
    },
    {
        "source": "Safety: We obtained the pidfd from calling `clone3` with `CLONE_PIDFD` so it's valid an otherwise unowned.",
        "suggest": "安全性: 我们通过使用 `CLONE_PIDFD` 调用 `clone3` 获得了 pidfd，因此它是有效的，否则是无主的。",
        "translate": ""
    },
    {
        "source": "Attempts to fork the process.",
        "suggest": "尝试 fork 进程。",
        "translate": ""
    },
    {
        "source": "If successful, returns Ok((0, -1)) in the child, and Ok((child_pid, -1)) in the parent.",
        "suggest": "如果成功，则在子项中返回 Ok((0, -1))，在父项中返回 Ok((child_pid, -1))。",
        "translate": ""
    },
    {
        "source": "If successful, returns Ok((0, -1)) in the child, and Ok((child_pid, child_pidfd)) in the parent.",
        "suggest": "如果成功，则在子项中返回 Ok((0, -1))，在父项中返回 Ok((child_pid, child_pidfd))。",
        "translate": ""
    },
    {
        "source": "If we fail to create a pidfd for any reason, this will stay as -1, which indicates an error.",
        "suggest": "如果我们由于任何原因未能创建 pidfd，它将保持为 -1，这表示错误。",
        "translate": ""
    },
    {
        "source": "Attempt to use the `clone3` syscall, which supports more arguments (in particular, the ability to create a pidfd).",
        "suggest": "尝试使用 `clone3` 系统调用，它支持更多参数 (特别是创建 pidfd 的能力)。",
        "translate": ""
    },
    {
        "source": "If this fails, we will fall through this block to a call to `fork()`",
        "suggest": "如果失败，我们将通过此块调用到 `fork()`",
        "translate": ""
    },
    {
        "source": "Multiple threads can race to execute this store, but that's fine - that just means that multiple threads will have tried and failed to execute the same syscall, with no other side effects.",
        "suggest": "多个线程可以竞争执行这个存储，但这很好 -- 这只是意味着多个线程将尝试执行相同的系统调用但失败了，没有其他副作用。",
        "translate": ""
    },
    {
        "source": "Fallback to fork if `EPERM` is returned.",
        "suggest": "如果返回 `EPERM`，则回退到 fork。",
        "translate": ""
    },
    {
        "source": "(e.g. blocked by seccomp)",
        "suggest": "(例如被 seccomp 阻止)",
        "translate": ""
    },
    {
        "source": "If we get here, the 'clone3' syscall does not exist or we do not have permission to call it",
        "suggest": "如果我们到这里，'clone3' 系统调用不存在或我们没有权限调用它",
        "translate": ""
    },
    {
        "source": "Safety: -1 indicates we don't have a pidfd.",
        "suggest": "安全性: -1 表示我们没有 pidfd。",
        "translate": ""
    },
    {
        "source": "On Linux, stores the pidfd created for this child.",
        "suggest": "在 Linux 上，存储为这个子节点创建的 pidfd。",
        "translate": ""
    },
    {
        "source": "This is None if the user did not request pidfd creation, or if the pidfd could not be created for some reason (e.g.",
        "suggest": "如果用户没有请求创建 pidfd，或者由于某种原因无法创建 pidfd (例如",
        "translate": ""
    },
    {
        "source": "the `clone3` syscall was not available).",
        "suggest": "`clone3` 系统调用不可用)。",
        "translate": ""
    },
    {
        "source": "Safety: If `pidfd` is nonnegative, we assume it's valid and otherwise unowned.",
        "suggest": "安全性: 如果 `pidfd` 是非负的，我们假设它是有效的，否则是无主的。",
        "translate": ""
    },
    {
        "source": "0 indicates that the stack size configured in the ESP-IDF menuconfig system should be used",
        "suggest": "0 表示应使用 ESP-IDF menuconfig 系统中配置的栈大小",
        "translate": ""
    },
    {
        "source": "Only set the stack if a non-zero value is passed",
        "suggest": "仅在传递非零值时才设置栈",
        "translate": ""
    },
    {
        "source": "0 is used as an indication that the default stack size configured in the ESP-IDF menuconfig system should be used",
        "suggest": "0 用作指示应使用 ESP-IDF menuconfig 系统中配置的默认栈大小",
        "translate": ""
    },
    {
        "source": "Newlib, Emscripten, and VxWorks have no way to set a thread name.",
        "suggest": "Newlib、Emscripten 和 VxWorks 无法设置线程名称。",
        "translate": ""
    },
    {
        "source": "implement on vxWorks, Redox, Haiku, l4re",
        "suggest": "在 vxWorks、Redox、Haiku、l4re 上实现",
        "translate": ""
    },
    {
        "source": "The followiung list was obtained from",
        "suggest": "以下列表来自",
        "translate": ""
    },
    {
        "source": "in the Debian package mingw-w64_6.0.0-3_all.deb",
        "suggest": "在 Debian 软件包 mingw-w64_6.0.0-3_all.deb 中",
        "translate": ""
    },
    {
        "source": "The header of that file says:",
        "suggest": "该文件的标题说:",
        "translate": ""
    },
    {
        "source": "This file has no copyright assigned and is placed in the Public Domain.",
        "suggest": "该文件没有分配版权，并被置于公共领域。",
        "translate": ""
    },
    {
        "source": "This file is part of the mingw-w64 runtime package.",
        "suggest": "该文件是 mingw-w64 运行时包的一部分。",
        "translate": ""
    },
    {
        "source": "No warranty is given;",
        "suggest": "不提供任何保证;",
        "translate": ""
    },
    {
        "source": "refer to the file DISCLAIMER.PD within this package.",
        "suggest": "请参见此包中的文件 DISCLAIMER.PD。",
        "translate": ""
    },
    {
        "source": "The text here is the result of the following rune:",
        "suggest": "这里的文字是以下符文的结果:",
        "translate": ""
    },
    {
        "source": "grep -P '#define ERROR' /usr/x86_64-w64-mingw32/include/winerror.h >>library/std/src/sys/windows/c/errors.rs grep -P '#define WSA' /usr/x86_64-w64-mingw32/include/winerror.h >>library/std/src/sys/windows/c/errors.rs and then using some manually-invented but rather obvious editor search-and-replace invocations, plus some straightforward manual fixups, to turn it into Rust syntax and remove all the duplicates from the manual table above.",
        "suggest": "grep -P '#define ERROR' /usr/x86_64-w64-mingw32/include/winerror.h >>library/std/src/sys/windows/c/errors.rs grep -P '#define WSA' /usr/x86_64-w64-mingw32/include/winerror.h >>library/std/src/sys/windows/c/errors.rs 然后使用一些手动发明但相当明显的编辑器搜索和替换调用，加上一些简单的手动修复，将其转换为 Rust 语法并从上面的手动表中删除所有重复项。",
        "translate": ""
    },
    {
        "source": "is included from two places so we need to specify this",
        "suggest": "包含在两个地方，所以我们需要指定这个",
        "translate": ""
    },
    {
        "source": "The Windows implementation of mutexes is a little odd and it might not be immediately obvious what's going on.",
        "suggest": "互斥锁的 Windows 实现有点奇怪，可能不会立即明白发生了什么。",
        "translate": ""
    },
    {
        "source": "On Windows, environment args are case preserving but comparisons are case-insensitive.",
        "suggest": "在 Windows 上，环境参数保留大小写，但比较不区分大小写。",
        "translate": ""
    },
    {
        "source": "Test that `cmd.env` matches `env::set_var` when setting two strings that may (or may not) be case-folded when compared.",
        "suggest": "在设置两个比较时可能 (或可能不) case-folded 的字符串时，测试 `cmd.env` 是否与 `env::set_var` 匹配。",
        "translate": ""
    },
    {
        "source": "This stores a UTF-16 encoded string to workaround the mismatch between Rust's OsString (WTF-8) and the Windows API string type (UTF-16).",
        "suggest": "这存储了一个 UTF-16 编码的字符串，以解决 Rust 的 OsString (WTF-8) 和 Windows API 字符串类型 (UTF-16) 之间的不匹配。",
        "translate": ""
    },
    {
        "source": "Normally converting on every API call is acceptable but here `c::CompareStringOrdinal` will be called for every use of `==`.",
        "suggest": "通常在每个 API 调用上转换是可以接受的，但这里 `c::CompareStringOrdinal` 将在每次使用 `==` 时调用。",
        "translate": ""
    },
    {
        "source": "Comparing Windows environment variable keys[1] are behaviourally the composition of two operations[2]:",
        "suggest": "比较 Windows 环境变量 keys[1] 在行为上是两个 operations[2] 的组合:",
        "translate": ""
    },
    {
        "source": "Case-fold both strings.",
        "suggest": "Case-fold 两个字符串。",
        "translate": ""
    },
    {
        "source": "This is done using a language-independent uppercase mapping that's unique to Windows (albeit based on data from an older Unicode spec).",
        "suggest": "这是使用 Windows 独有的独立于语言的大写映射完成的 (尽管基于旧 Unicode 规范中的数据)。",
        "translate": ""
    },
    {
        "source": "It only operates on individual UTF-16 code units so surrogates are left unchanged.",
        "suggest": "它仅对单个 UTF-16 代码单元进行操作，因此代理项保持不变。",
        "translate": ""
    },
    {
        "source": "This uppercase mapping can potentially change between Windows versions.",
        "suggest": "这种大写映射可能会在 Windows 版本之间发生变化。",
        "translate": ""
    },
    {
        "source": "Perform an ordinal comparison of the strings.",
        "suggest": "执行字符串的序数比较。",
        "translate": ""
    },
    {
        "source": "A comparison using ordinal is just a comparison based on the numerical value of each UTF-16 code unit[3].",
        "suggest": "使用序号的比较只是基于每个 UTF-16 代码 unit[3] 的数值进行比较。",
        "translate": ""
    },
    {
        "source": "Because the case-folding mapping is unique to Windows and not guaranteed to be stable, we ask the OS to compare the strings for us.",
        "suggest": "因为 case-folding 映射是 Windows 独有的并且不能保证稳定，所以我们要求操作系统为我们比较字符串。",
        "translate": ""
    },
    {
        "source": "This is done by calling `CompareStringOrdinal`[4] with `bIgnoreCase` set to `TRUE`.",
        "suggest": "这是通过调用 `CompareStringOrdinal`[4] 并将 `bIgnoreCase` 设置为 `TRUE` 来完成的。",
        "translate": ""
    },
    {
        "source": "should never fail so long as the parameters are correct.",
        "suggest": "只要参数正确，就永远不会失败。",
        "translate": ""
    },
    {
        "source": "Environment variable keys should preserve their original case even though they are compared using a caseless string mapping.",
        "suggest": "即使使用无大小写字符串映射进行比较，环境变量键也应保留其原始大小写。",
        "translate": ""
    },
    {
        "source": "Add quotes (if needed)",
        "suggest": "添加引号 (如果需要)",
        "translate": ""
    },
    {
        "source": "Append raw string without quoting",
        "suggest": "附加原始字符串而不引用",
        "translate": ""
    },
    {
        "source": "Every arg is quoted",
        "suggest": "每个 arg 都被引用",
        "translate": ""
    },
    {
        "source": "Whitespace and empty args are quoted",
        "suggest": "引用空格和空参数",
        "translate": ""
    },
    {
        "source": "Arg appended without any changes (#29494)",
        "suggest": "附加的 Arg 没有任何变化 (#29494)",
        "translate": ""
    },
    {
        "source": "If there are no environment variables to set then signal this by pushing a null.",
        "suggest": "如果没有要设置的环境变量，则通过推送一个空值来发出信号。",
        "translate": ""
    },
    {
        "source": "In the worst case, a UTF-8 string can take 3 bytes for every `u16` of a UTF-16.",
        "suggest": "在最坏的情况下，对于 UTF-16 的每个 `u16`，UTF-8 字符串可能占用 3 个字节。",
        "translate": ""
    },
    {
        "source": "This is a best effort, and might not work if we are not the only reader on Stdin.",
        "suggest": "这是尽最大努力，如果我们不是 Stdin 上唯一的 reader，则可能无法工作。",
        "translate": ""
    },
    {
        "source": "Bare metal platforms usually have very small amounts of RAM (in the order of hundreds of KB)",
        "suggest": "裸机平台通常只有很少量的 RAM (大约数百 KB)",
        "translate": ""
    },
    {
        "source": "Simplify this if Arc gets an Arc::get_pin_mut.",
        "suggest": "如果 Arc 获得 Arc::get_pin_mut，请简化此操作。",
        "translate": ""
    },
    {
        "source": "memory layout of a &[u8] and &Wtf8 are the same",
        "suggest": "&[u8] 和 &Wtf8 的内存布局是一样的",
        "translate": ""
    },
    {
        "source": "However, this module provides convenient facilities for automatically waiting for the termination of a thread (i.e., join).",
        "suggest": "然而，这个模块为自动等待线程终止 (即 join) 提供了便利。",
        "translate": ""
    },
    {
        "source": "In this example, the spawned thread is \"detached,\" which means that there is no way for the program to learn when the spawned thread completes or otherwise terminates.",
        "suggest": "在此示例中，新建线程是 \"detached,\"，这意味着程序无法了解新建线程何时完成或以其他方式终止。",
        "translate": ""
    },
    {
        "source": "To learn when a thread completes, it is necessary to capture the [`JoinHandle`] object that is returned by the call to [`spawn`], which provides a `join` method that allows the caller to wait for the completion of the spawned thread:",
        "suggest": "要了解线程何时完成，需要捕获调用返回给 [`spawn`] 的 [`JoinHandle`] object，它提供了一个 `join` 方法，允许调用者等待新建线程的完成:",
        "translate": ""
    },
    {
        "source": "The [`join`] method returns a [`thread::Result`] containing [`Ok`] of the final value produced by the spawned thread, or [`Err`] of the value given to a call to [`panic!`] if the thread panicked.",
        "suggest": "[`join`] 方法返回一个 [`thread::Result`]，其中包含由新建线程生成的最终值的 [`Ok`]，或者如果线程 panicked，则返回给 [`panic!`] 的调用值的 [`Err`]。",
        "translate": ""
    },
    {
        "source": "Note that there is no parent/child relationship between a thread that spawns a new thread and the thread being spawned.",
        "suggest": "请注意，生成新线程的线程与生成的线程之间没有 parent/child 关系。",
        "translate": ""
    },
    {
        "source": "In particular, the spawned thread may or may not outlive the spawning thread, unless the spawning thread is the main thread.",
        "suggest": "特别是，除非生成线程是主线程，否则新建线程可能会也可能不会比生成线程的生命周期长。",
        "translate": ""
    },
    {
        "source": "A new thread can be configured before it is spawned via the [`Builder`] type, which currently allows you to set the name and stack size for the thread:",
        "suggest": "一个新线程可以在通过 [`Builder`] 类型生成之前进行配置，目前允许您设置线程的名称和栈大小:",
        "translate": ""
    },
    {
        "source": "The join handle can be used to block on termination of the spawned thread, including recovering its panics.",
        "suggest": "连接句柄可用于在新线程终止时阻塞，包括恢复其 panics。",
        "translate": ""
    },
    {
        "source": "The join handle provides a [`join`] method that can be used to join the spawned thread.",
        "suggest": "连接句柄提供了一个 [`join`] 方法，可用于连接新建线程。",
        "translate": ""
    },
    {
        "source": "If the spawned thread panics, [`join`] will return an [`Err`] containing the argument given to [`panic!`].",
        "suggest": "如果新建线程 panics，[`join`] 将返回一个 [`Err`]，其中包含给 [`panic!`] 的参数。",
        "translate": ""
    },
    {
        "source": "If the join handle is dropped, the spawned thread will implicitly be *detached*.",
        "suggest": "如果连接句柄是删除，则新建线程将隐式地*分离*。",
        "translate": ""
    },
    {
        "source": "In this case, the spawned thread may no longer be joined.",
        "suggest": "在这种情况下，可能不再加入新建线程。",
        "translate": ""
    },
    {
        "source": "(It is the responsibility of the program to either eventually join threads it creates or detach them; otherwise, a resource leak will result.)",
        "suggest": "(最终加入它创建的线程或分离它们是程序的责任; 否则，将导致资源泄漏。)",
        "translate": ""
    },
    {
        "source": "This call will create a thread using default parameters of [`Builder`], if you want to specify the stack size or the name of the thread, use this API instead.",
        "suggest": "此调用将使用 [`Builder`] 的默认参数创建线程，如果要指定栈大小或线程名称，请改用此 API。",
        "translate": ""
    },
    {
        "source": "The reason for this is that threads can outlive the lifetime they have been created in.",
        "suggest": "这样做的原因是线程可以比创建它们的生命周期更长。",
        "translate": ""
    },
    {
        "source": "This calls the underlying OS scheduler's yield primitive, signaling that the calling thread is willing to give up its remaining timeslice so that the OS may schedule other threads on the CPU.",
        "suggest": "这会调用底层操作系统调度程序的 yield 原语，表明调用线程愿意放弃其剩余的时间片，以便操作系统可以在 CPU 上调度其他线程。",
        "translate": ""
    },
    {
        "source": "A drawback of yielding in a loop is that if the OS does not have any other ready threads to run on the current CPU, the thread will effectively busy-wait, which wastes CPU time and energy.",
        "suggest": "在循环中让步的一个缺点是，如果操作系统没有任何其他就绪线程在当前 CPU 上运行，该线程将有效地进行忙等待，这会浪费 CPU 时间和精力。",
        "translate": ""
    },
    {
        "source": "Therefore, when waiting for events of interest, a programmer's first choice should be to use synchronization devices such as [`channel`]s, [`Condvar`]s, [`Mutex`]es or [`join`] since these primitives are implemented in a blocking manner, giving up the CPU until the event of interest has occurred which avoids repeated yielding.",
        "suggest": "因此，在等待感兴趣的事件时，程序员的首选应该是使用同步设备，例如 [`channel`]、[`Condvar`]、[`Mutex`] 或 [`join`]，因为这些原语是以阻塞方式实现，放弃 CPU 直到感兴趣的事件发生，避免重复让步。",
        "translate": ""
    },
    {
        "source": "should thus be used only rarely, mostly in situations where repeated polling is required because there is no other suitable way to learn when an event of interest has occurred.",
        "suggest": "因此应该很少使用，主要是在需要重复轮询的情况下，因为没有其他合适的方法来了解何时发生了感兴趣的事件。",
        "translate": ""
    },
    {
        "source": "This method should not be used for precise timing due to anomalies such as preemption or platform differences that might not cause the maximum amount of time waited to be precisely `ms` long.",
        "suggest": "由于抢占或平台差异等异常情况可能不会导致最长等待时间精确到 `ms` 长，因此不应将此方法用于精确计时。",
        "translate": ""
    },
    {
        "source": "This method should not be used for precise timing due to anomalies such as preemption or platform differences that might not cause the maximum amount of time waited to be precisely `dur` long.",
        "suggest": "由于抢占或平台差异等异常情况可能不会导致最长等待时间精确到 `dur` 长，因此不应将此方法用于精确计时。",
        "translate": ""
    },
    {
        "source": "in case the panic handler ends up calling `ThreadId::new()`, avoid reentrant lock acquire.",
        "suggest": "如果 panic 处理程序最终调用 `ThreadId::new()`，请避免获取可重入锁。",
        "translate": ""
    },
    {
        "source": "This packet is used to communicate the return value between the spawned thread and the rest of the program.",
        "suggest": "该数据包用于在程序的新建线程和对象部分之间传递返回值。",
        "translate": ""
    },
    {
        "source": "Memory is shared through the `Arc` within and there's no need for a mutex here because synchronization happens with `join()` (the caller will never read this packet until the thread has exited).",
        "suggest": "内存通过内部的 `Arc` 共享，这里不需要互斥锁，因为同步发生在 `join()` 上 (在线程退出之前调用者永远不会读取这个数据包)。",
        "translate": ""
    },
    {
        "source": "A thread being detached and outliving the thread that spawned it:",
        "suggest": "一个线程被分离并且比产生它的线程生命周期更长:",
        "translate": ""
    },
    {
        "source": "This function will return immediately if the associated thread has already finished.",
        "suggest": "如果关联的线程已经完成，这个函数将立即返回。",
        "translate": ""
    },
    {
        "source": "In other words, all operations performed by that thread [happen before](https://doc.rust-lang.org/nomicon/atomics.html#data-accesses) all operations that happen after `join` returns.",
        "suggest": "换句话说，该线程 [之前发生过](https://doc.rust-lang.org/nomicon/atomics.html#data-accesses) 执行的所有操作都是在 `join` 返回之后发生的所有操作。",
        "translate": ""
    },
    {
        "source": "If the associated thread panics, [`Err`] is returned with the parameter given to [`panic!`].",
        "suggest": "如果关联的线程 panics，则返回 [`Err`]，并返回给 [`panic!`] 的参数。",
        "translate": ""
    },
    {
        "source": "bits 30 and 31 are never used since the nanoseconds part never exceeds 10^9",
        "suggest": "位 30 和 31 从未使用过，因为纳秒部分从未超过 10^9",
        "translate": ""
    },
    {
        "source": "occupies no more than 30 bits (10^9 seconds)",
        "suggest": "占用不超过 30 位 (10^9 秒)",
        "translate": ""
    },
    {
        "source": "This wraps around every 136 years (2^32 seconds).",
        "suggest": "这每 136 年 (2^32 秒) 循环一次。",
        "translate": ""
    },
    {
        "source": "To detect backsliding we use wrapping arithmetic and declare forward steps smaller than 2^31 seconds as expected and everything else as a backslide which will be monotonized.",
        "suggest": "为了检测后退，我们使用包装算法并按预期声明小于 2^31 秒的前向步长，并将其他所有内容声明为将单调化的后退。",
        "translate": ""
    },
    {
        "source": "This could be a problem for programs that call instants at intervals greater than 68 years.",
        "suggest": "对于以大于 68 年的间隔调用即时的程序，这可能是一个问题。",
        "translate": ""
    },
    {
        "source": "Interstellar probes may want to ensure that actually_monotonic() is true.",
        "suggest": "星际探测器可能想要确保 actually_monotonic() 是真实的。",
        "translate": ""
    },
    {
        "source": "Backslide occurred.",
        "suggest": "发生了倒退。",
        "translate": ""
    },
    {
        "source": "We reconstruct monotonized time from the upper 32 bit of the passed in value and the 64bits loaded from the atomic",
        "suggest": "我们从传入值的高 32 位和从原子加载的 64 位重建单调时间",
        "translate": ""
    },
    {
        "source": "Backslide caused the lower 32bit of the seconds part to wrap.",
        "suggest": "Backslide 导致秒部分的低 32 位换行。",
        "translate": ""
    },
    {
        "source": "This must be the case because the seconds part is larger even though we are in the backslide branch, i.e. the seconds count should be smaller or equal.",
        "suggest": "这一定是这种情况，因为即使我们在 backslide 分支中，秒部分也更大，即秒数应该更小或相等。",
        "translate": ""
    },
    {
        "source": "We assume that backslides are smaller than 2^32 seconds which means we need to add 1 to the upper half to restore it.",
        "suggest": "我们假设后退小于 2^32 秒，这意味着我们需要在上半部分加 1 才能恢复它。",
        "translate": ""
    },
    {
        "source": "most recent observed time: 0xA1_0000_0000_0000_0000u128 bits stored in AtomicU64:     0x0000_0000_0000_0000u64 backslide by 1s caller time is             0xA0_ffff_ffff_0000_0000u128",
        "suggest": "最近观察到的时间: 0xA1_0000_0000_0000_0000u128 位存储在 AtomicU64 中: 0x0000_0000_0000_0000u64 倒退 1s 调用者时间是 0xA0_ffff_ffff_0000u12080",
        "translate": ""
    },
    {
        "source": "we can fix up the upper half time by adding 1 << 32",
        "suggest": "我们可以通过添加 1 << 32 来修复上半场",
        "translate": ""
    },
    {
        "source": "Split into seconds and nanos since Duration doesn't have a constructor that takes a u128",
        "suggest": "由于 Duration 没有采用 u128 的构造函数，因此分为秒和纳秒",
        "translate": ""
    },
    {
        "source": "platform cannot represent u32::MAX seconds so it won't have to deal with this kind of overflow either",
        "suggest": "平台不能代表 u32::MAX 秒，所以它也不必处理这种溢出",
        "translate": ""
    },
    {
        "source": "Calling a slow function, it may take a while",
        "suggest": "调用慢函数可能需要一段时间",
        "translate": ""
    },
    {
        "source": "Using [`Instant`] to calculate how long a function took to run:",
        "suggest": "使用 [`Instant`] 计算函数运行所需的时间:",
        "translate": ""
    },
    {
        "source": "Opaque and useful only with [`Duration`].",
        "suggest": "不透明且仅对 [`Duration`] 有用。",
        "translate": ""
    },
    {
        "source": "In other words, each tick of the underlying clock might not be the same length (e.g.",
        "suggest": "换句话说，底层时钟的每个滴答声的长度可能不同 (例如",
        "translate": ""
    },
    {
        "source": "This function may fail as the underlying system clock is susceptible to drift and updates (e.g., the system clock could go backwards), so this function might not always succeed.",
        "suggest": "这个函数可能会失败，因为底层系统时钟容易受到漂移和更新的影响 (例如，系统时钟可能会倒退)，所以这个函数可能并不总是成功。",
        "translate": ""
    },
    {
        "source": "Executes an exclusive LDR instruction for 8 bit value.",
        "suggest": "对 8 位值执行独占 LDR 指令。",
        "translate": ""
    },
    {
        "source": "Executes an exclusive LDR instruction for 16 bit value.",
        "suggest": "对 16 位值执行独占 LDR 指令。",
        "translate": ""
    },
    {
        "source": "Executes an exclusive LDR instruction for 32 bit value.",
        "suggest": "对 32 位值执行独占 LDR 指令。",
        "translate": ""
    },
    {
        "source": "Executes an exclusive STR instruction for 8 bit values",
        "suggest": "对 8 位值执行独占 STR 指令",
        "translate": ""
    },
    {
        "source": "Executes an exclusive STR instruction for 16 bit values",
        "suggest": "对 16 位值执行独占 STR 指令",
        "translate": ""
    },
    {
        "source": "Executes an exclusive STR instruction for 32 bit values",
        "suggest": "对 32 位值执行独占 STR 指令",
        "translate": ""
    },
    {
        "source": "Use AES for ARM when the minimum LLVM version includes b8baa2a9132498ea286dbb0d03f005760ecc6fdb",
        "suggest": "当最低 LLVM 版本包括 b8baa2a9132498ea286dbb0d03f005760ecc6fdb 时，对 ARM 使用 AES",
        "translate": ""
    },
    {
        "source": "Generates the [`unreachable`] instruction, which causes an unconditional [trap].",
        "suggest": "生成 [`unreachable`] 指令，这会导致无条件的 [trap]。",
        "translate": ""
    },
    {
        "source": "This function is safe to call and immediately aborts the execution.",
        "suggest": "这个函数对调用是安全的，并立即中止执行。",
        "translate": ""
    },
    {
        "source": "is the same as",
        "suggest": "是相同的",
        "translate": ""
    },
    {
        "source": "This intrinsic will emit a load with an alignment of 1.",
        "suggest": "这个内联函数将发出一个对齐为 1 的负载。",
        "translate": ""
    },
    {
        "source": "While this is provided for completeness it is not strictly necessary, you can also load the pointer directly:",
        "suggest": "虽然这是为了完整性而提供的，但并非绝对必要，您也可以直接加载指针:",
        "translate": ""
    },
    {
        "source": "The alignment of the load can be configured by doing a manual load without this intrinsic.",
        "suggest": "负载的对齐可以通过手动加载来配置，没有这个内联函数。",
        "translate": ""
    },
    {
        "source": "This intrinsic is unsafe because it takes a raw pointer as an argument, and the pointer must be valid to load 16 bytes from.",
        "suggest": "这个内联函数是不安全的，因为它需要一个裸指针作为参数，并且指针必须有效才能从中加载 16 个字节。",
        "translate": ""
    },
    {
        "source": "Note that there is no alignment requirement on this pointer since this intrinsic performs a",
        "suggest": "注意这个指针没有对齐要求，因为这个内联函数执行了一个",
        "translate": ""
    },
    {
        "source": "This intrinsic is unsafe because it takes a raw pointer as an argument, and the pointer must be valid to load 8 bytes from.",
        "suggest": "这个内联函数是不安全的，因为它需要一个裸指针作为参数，并且指针必须有效才能从中加载 8 个字节。",
        "translate": ""
    },
    {
        "source": "While this intrinsic is provided for completeness it can also be replaced with `u8x16_splat(*m)` and it should generate equivalent code (and also not require `unsafe`).",
        "suggest": "虽然这个内联函数是为了完整性而提供的，但它也可以用 `u8x16_splat(*m)` 替换，它应该生成等效的代码 (也不需要 `unsafe`)。",
        "translate": ""
    },
    {
        "source": "This intrinsic is unsafe because it takes a raw pointer as an argument, and the pointer must be valid to load 1 byte from.",
        "suggest": "这个内联函数是不安全的，因为它需要一个裸指针作为参数，并且指针必须有效才能从中加载 1 个字节。",
        "translate": ""
    },
    {
        "source": "While this intrinsic is provided for completeness it can also be replaced with `u16x8_splat(*m)` and it should generate equivalent code (and also not require `unsafe`).",
        "suggest": "虽然这个内联函数是为了完整性而提供的，但它也可以用 `u16x8_splat(*m)` 替换，它应该生成等效的代码 (也不需要 `unsafe`)。",
        "translate": ""
    },
    {
        "source": "This intrinsic is unsafe because it takes a raw pointer as an argument, and the pointer must be valid to load 2 bytes from.",
        "suggest": "这个内联函数是不安全的，因为它需要一个裸指针作为参数，并且指针必须有效才能从中加载 2 个字节。",
        "translate": ""
    },
    {
        "source": "While this intrinsic is provided for completeness it can also be replaced with `u32x4_splat(*m)` and it should generate equivalent code (and also not require `unsafe`).",
        "suggest": "虽然这个内联函数是为了完整性而提供的，但它也可以用 `u32x4_splat(*m)` 替换，它应该生成等效的代码 (也不需要 `unsafe`)。",
        "translate": ""
    },
    {
        "source": "This intrinsic is unsafe because it takes a raw pointer as an argument, and the pointer must be valid to load 4 bytes from.",
        "suggest": "这个内联函数是不安全的，因为它需要一个裸指针作为参数，并且指针必须有效才能从中加载 4 个字节。",
        "translate": ""
    },
    {
        "source": "While this intrinsic is provided for completeness it can also be replaced with `u64x2_splat(*m)` and it should generate equivalent code (and also not require `unsafe`).",
        "suggest": "虽然这个内联函数是为了完整性而提供的，但它也可以用 `u64x2_splat(*m)` 替换，它应该生成等效的代码 (也不需要 `unsafe`)。",
        "translate": ""
    },
    {
        "source": "This intrinsic is provided for completeness and is equivalent to `u32x4(*m,",
        "suggest": "这个内联函数是为了完整性而提供的，等价于 `u32x4 (*m,",
        "translate": ""
    },
    {
        "source": "0, 0, 0)` (which doesn't require `unsafe`).",
        "suggest": "0, 0, 0)` (不需要 `unsafe`)。",
        "translate": ""
    },
    {
        "source": "This intrinsic is provided for completeness and is equivalent to `u64x2_replace_lane::<0>(u64x2(0, 0), *m)` (which doesn't require `unsafe`).",
        "suggest": "这个内联函数是为了完整性而提供的，等效于 `u64x2_replace_lane::<0>(u64x2(0, 0), *m)` (不需要 `unsafe`)。",
        "translate": ""
    },
    {
        "source": "This intrinsic will emit a store with an alignment of 1.",
        "suggest": "这个内联函数会发出一个对齐为 1 的 store。",
        "translate": ""
    },
    {
        "source": "While this is provided for completeness it is not strictly necessary, you can also store the pointer directly:",
        "suggest": "虽然这是为了完整性而提供的，但并非绝对必要，您也可以直接存储指针:",
        "translate": ""
    },
    {
        "source": "The alignment of the store can be configured by doing a manual store without this intrinsic.",
        "suggest": "store 的对齐方式可以通过做一个没有这个内联函数的手动 store 来配置。",
        "translate": ""
    },
    {
        "source": "This intrinsic is unsafe because it takes a raw pointer as an argument, and the pointer must be valid to store 16 bytes to.",
        "suggest": "这个内联函数是不安全的，因为它需要一个裸指针作为参数，并且指针必须有效才能存储 16 个字节。",
        "translate": ""
    },
    {
        "source": "This intrinsic is provided for completeness and is equivalent to `u8x16_replace_lane::<L>(v, *m)` (which doesn't require `unsafe`).",
        "suggest": "这个内联函数是为了完整性而提供的，等效于 `u8x16_replace_lane::<L>(v, *m)` (不需要 `unsafe`)。",
        "translate": ""
    },
    {
        "source": "This intrinsic is provided for completeness and is equivalent to `u16x8_replace_lane::<L>(v, *m)` (which doesn't require `unsafe`).",
        "suggest": "这个内联函数是为了完整性而提供的，等效于 `u16x8_replace_lane::<L>(v, *m)` (不需要 `unsafe`)。",
        "translate": ""
    },
    {
        "source": "This intrinsic is provided for completeness and is equivalent to `u32x4_replace_lane::<L>(v, *m)` (which doesn't require `unsafe`).",
        "suggest": "这个内联函数是为了完整性而提供的，等效于 `u32x4_replace_lane::<L>(v, *m)` (不需要 `unsafe`)。",
        "translate": ""
    },
    {
        "source": "This intrinsic is provided for completeness and is equivalent to `u64x2_replace_lane::<L>(v, *m)` (which doesn't require `unsafe`).",
        "suggest": "这个内联函数是为了完整性而提供的，等效于 `u64x2_replace_lane::<L>(v, *m)` (不需要 `unsafe`)。",
        "translate": ""
    },
    {
        "source": "This intrinsic is provided for completeness and is equivalent to `*m = u8x16_extract_lane::<L>(v)` (which doesn't require `unsafe`).",
        "suggest": "这个内联函数是为了完整性而提供的，等效于 `*m = u8x16_extract_lane::<L>(v)` (不需要 `unsafe`)。",
        "translate": ""
    },
    {
        "source": "This intrinsic is unsafe because it takes a raw pointer as an argument, and the pointer must be valid to store 1 byte to.",
        "suggest": "这个内联函数是不安全的，因为它需要一个裸指针作为参数，并且指针必须有效才能存储 1 个字节。",
        "translate": ""
    },
    {
        "source": "This intrinsic is provided for completeness and is equivalent to `*m = u16x8_extract_lane::<L>(v)` (which doesn't require `unsafe`).",
        "suggest": "这个内联函数是为了完整性而提供的，等效于 `*m = u16x8_extract_lane::<L>(v)` (不需要 `unsafe`)。",
        "translate": ""
    },
    {
        "source": "This intrinsic is unsafe because it takes a raw pointer as an argument, and the pointer must be valid to store 2 bytes to.",
        "suggest": "这个内联函数是不安全的，因为它需要一个裸指针作为参数，并且指针必须有效才能存储 2 个字节。",
        "translate": ""
    },
    {
        "source": "This intrinsic is provided for completeness and is equivalent to `*m = u32x4_extract_lane::<L>(v)` (which doesn't require `unsafe`).",
        "suggest": "这个内联函数是为了完整性而提供的，等效于 `*m = u32x4_extract_lane::<L>(v)` (不需要 `unsafe`)。",
        "translate": ""
    },
    {
        "source": "This intrinsic is unsafe because it takes a raw pointer as an argument, and the pointer must be valid to store 4 bytes to.",
        "suggest": "这个内联函数是不安全的，因为它需要一个裸指针作为参数，并且指针必须有效才能存储 4 个字节。",
        "translate": ""
    },
    {
        "source": "This intrinsic is provided for completeness and is equivalent to `*m = u64x2_extract_lane::<L>(v)` (which doesn't require `unsafe`).",
        "suggest": "这个内联函数是为了完整性而提供的，等效于 `*m = u64x2_extract_lane::<L>(v)` (不需要 `unsafe`)。",
        "translate": ""
    },
    {
        "source": "This intrinsic is unsafe because it takes a raw pointer as an argument, and the pointer must be valid to store 8 bytes to.",
        "suggest": "这个内联函数是不安全的，因为它需要一个裸指针作为参数，并且指针必须有效才能存储 8 个字节。",
        "translate": ""
    },
    {
        "source": "Returns true if all lanes are non-zero, false otherwise.",
        "suggest": "如果所有通道都不为零，则返回 true，否则返回 false。",
        "translate": ""
    },
    {
        "source": "Its purpose is for bf16 related intrinsic implementations.",
        "suggest": "它的目的是用于 bf16 相关的内联函数实现。",
        "translate": ""
    },
    {
        "source": "is supposed to take an `i32` instead of a `u32` as is the case for [other shuffle intrinsics](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm_shuffle_).",
        "suggest": "应该像 [其他 shuffle 内联函数](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm_shuffle_) 一样采用 `i32` 而不是 `u32`。",
        "translate": ""
    },
    {
        "source": "Replace with AES when the minimum LLVM version has b8baa2a9132498ea286dbb0d03f005760ecc6fdb",
        "suggest": "当最低 LLVM 版本有 b8baa2a9132498ea286dbb0d03f005760ecc6fdb 时替换为 AES",
        "translate": ""
    },
    {
        "source": "Temporary, currently the fptosi.sat and fptoui.sat LLVM intrinsics emit unnecessary code on arm.",
        "suggest": "暂时的，目前 fptosi.sat 和 fptoui.sat LLVM 内联函数会在 arm 上发出不必要的代码。",
        "translate": ""
    },
    {
        "source": "This can be removed once it has been addressed in LLVM.",
        "suggest": "一旦在 LLVM 中解决了这个问题，就可以将其删除。",
        "translate": ""
    },
    {
        "source": "This function uses the CPUID instruction to read the feature flags from the CPU and encodes them in a `usize` where each bit position represents whether a feature is available (bit is set) or unavaiable (bit is cleared).",
        "suggest": "该函数使用 CPUID 指令从 CPU 读取特征标志并将它们编码在 `usize` 中，其中每个位位置表示特征是可用 (位已设置) 还是不可用 (位已清除)。",
        "translate": ""
    },
    {
        "source": "Terminal formatting module.",
        "suggest": "终端格式化模块。",
        "translate": ""
    },
    {
        "source": "This module provides the `Terminal` trait, which abstracts over an [ANSI Terminal][ansi] to provide color printing, among other things.",
        "suggest": "该模块提供了 `Terminal` trait，它抽象了 [ANSI Terminal][ansi] 以提供彩色打印等。",
        "translate": ""
    },
    {
        "source": "The `#[link]` attributes on `extern \"C\"` block marks those symbols declared in the block are reexported in dylib build of libstd.",
        "suggest": "`extern \"C\"` 块上的 `#[link]` 属性标记在块中声明的那些符号在 libstd 的 dylib 构建中重新导出。",
        "translate": ""
    },
    {
        "source": "This is needed when build rustc with feature `llvm-libunwind', as no other cdylib will provided those _Unwind_* symbols.",
        "suggest": "这在使用特性 `llvm-libunwind' 构建 rustc 时是必需的，因为没有其他 cdylib 会提供那些 _Unwind_* 符号。",
        "translate": ""
    },
    {
        "source": "However the `link` attribute is duplicated multiple times and does not just export symbol, a better way to manually export symbol would be another attribute like `#[export]`.",
        "suggest": "然而，`link` 属性被多次复制并且不只是导出符号，手动导出符号的更好方法是像 `#[export]` 这样的另一个属性。",
        "translate": ""
    },
    {
        "source": "See the logic in function rustc_codegen_ssa::src::back::exported_symbols, module rustc_codegen_ssa::src::back::symbol_export, rustc_middle::middle::exported_symbols and RFC 2841",
        "suggest": "参见函数 rustc_codegen_ssa::src::back::exported_symbols、模块 rustc_codegen_ssa::src::back::symbol_export、rustc_middle::middle::exported_symbols 和 RFC 2841 中的逻辑",
        "translate": ""
    },
    {
        "source": "In a LinkedList, either both the head and tail are None because the list is empty, or both head and tail are Some because the list is populated.",
        "suggest": "在 LinkedList 中，要么头部和尾部都是 None 因为列表是空的，或者头部和尾部都是 Some 因为列表被填充。",
        "translate": ""
    },
    {
        "source": "Since we have verified the head is Some, we are sure the tail is Some too.",
        "suggest": "由于我们已经验证了头部是 Some，我们确定尾部也是 Some。",
        "translate": ""
    },
    {
        "source": "Since Rust 1.53, arrays implement IntoIterator directly:",
        "suggest": "从 Rust 1.53 开始，数组直接实现 IntoIterator:",
        "translate": ""
    },
    {
        "source": "this method might be deprecated in the future, since [`IntoIterator`] is now implemented for arrays.",
        "suggest": "此方法可能在 future 中被弃用，因为 [`IntoIterator`] 现在已为数组实现。",
        "translate": ""
    },
    {
        "source": "The difference from [`get`] is that this function accepts a raw pointer, which is useful to avoid the creation of temporary references.",
        "suggest": "与 [`get`] 的不同之处在于该函数接受一个原始指针，这有助于避免创建临时引用。",
        "translate": ""
    },
    {
        "source": "This means variants at the top are less than variants at the bottom.",
        "suggest": "这意味着顶部的成员少于底部的成员。",
        "translate": ""
    },
    {
        "source": "Here's an example:",
        "suggest": "下面是一个例子:",
        "translate": ""
    },
    {
        "source": "Calculates the quotient of `self` and `rhs`, rounding the result towards negative infinity.",
        "suggest": "计算 `self` 和 `rhs` 的商，将结果四舍五入到负无穷大。",
        "translate": ""
    },
    {
        "source": "Calculates the quotient of `self` and `rhs`, rounding the result towards positive infinity.",
        "suggest": "计算 `self` 和 `rhs` 的商，将结果四舍五入到正无穷大。",
        "translate": ""
    },
    {
        "source": "If `rhs` is positive, calculates the smallest value greater than or equal to `self` that is a multiple of `rhs`.",
        "suggest": "如果 `rhs` 为正数，则计算大于或等于 `self` 的最小值，即 `rhs` 的倍数。",
        "translate": ""
    },
    {
        "source": "If `rhs` is negative, calculates the largest value less than or equal to `self` that is a multiple of `rhs`.",
        "suggest": "如果 `rhs` 为负数，则计算小于或等于 `rhs` 倍数的 `self` 的最大值。",
        "translate": ""
    },
    {
        "source": "This function will panic if `rhs` is 0 or the operation results in overflow.",
        "suggest": "如果 `rhs` 为 0 或操作导致溢出，则此函数将 panic。",
        "translate": ""
    },
    {
        "source": "This would otherwise fail when calculating `r` when self == T::MIN.",
        "suggest": "否则，当 self == T::MIN 时计算 `r` 时，将导致失败。",
        "translate": ""
    },
    {
        "source": "Returns `None` if `rhs` is zero or the operation would result in overflow.",
        "suggest": "如果 `rhs` 为零，则返回 `None`，否则操作会导致溢出。",
        "translate": ""
    },
    {
        "source": "This is the same as performing `self / rhs` for all unsigned integers.",
        "suggest": "这与对所有无符号整数执行 `self / rhs` 相同。",
        "translate": ""
    },
    {
        "source": "Calculates the smallest value greater than or equal to `self` that is a multiple of `rhs`.",
        "suggest": "计算大于或等于 `rhs` 倍数的 `self` 的最小值。",
        "translate": ""
    },
    {
        "source": "If `rhs` is negative,",
        "suggest": "如果 `rhs` 是负数，",
        "translate": ""
    },
    {
        "source": "The asserts are repeated in order to ensure that `get()` is non-mutating.",
        "suggest": "重复断言以确保 `get()` 是非可变的。",
        "translate": ""
    },
    {
        "source": "The asserts are repeated in order to ensure that `raw_get()` is non-mutating.",
        "suggest": "重复断言以确保 `raw_get()` 是非可变的。",
        "translate": ""
    },
    {
        "source": "This should not UB.",
        "suggest": "这应该不是 UB。",
        "translate": ""
    },
    {
        "source": "See #87891",
        "suggest": "请参见 #87891",
        "translate": ""
    },
    {
        "source": "Rust 2015 and 2018:",
        "suggest": "Rust 2015 和 2018:",
        "translate": ""
    },
    {
        "source": "Starting in the 2021 edition, `array.into_iter()` uses `IntoIterator` normally to iterate by value, and `iter()` should be used to iterate by reference like previous editions.",
        "suggest": "从 2021 版开始，`array.into_iter()` 通常使用 `IntoIterator` 进行值迭代，而应该像以前的版本一样使用 `iter()` 进行引用迭代。",
        "translate": ""
    },
    {
        "source": "use [`IntoIterator::into_iter`], equivalent to the post-2021 behavior (Rust 1.53+)",
        "suggest": "使用 [`IntoIterator::into_iter`]，相当于 2021 年后的行为 (Rust 1.53+)",
        "translate": ""
    },
    {
        "source": "Double Double Quotes",
        "suggest": "双双引号",
        "translate": ""
    },
    {
        "source": "The Windows command line is just a string",
        "suggest": "Windows 命令行只是一个字符串",
        "translate": ""
    },
    {
        "source": "This module implements the parsing necessary to turn that string into a list of arguments.",
        "suggest": "该模块实现了将该字符串转换为参数列表所需的解析。",
        "translate": ""
    },
    {
        "source": "`GetCommandLineW` returns a pointer to a null terminated UTF-16 string so it's safe for `WStrUnits` to use.",
        "suggest": "`GetCommandLineW` 返回一个指向以空字符结尾的 UTF-16 字符串的指针，因此使用 `WStrUnits` 是安全的。",
        "translate": ""
    },
    {
        "source": "Microsoft's documentation for the Windows CLI argument format can be found at",
        "suggest": "可以在以下位置找到 Microsoft 的 Windows CLI 参数格式文档",
        "translate": ""
    },
    {
        "source": "A more in-depth explanation is here:",
        "suggest": "更深入的解释在这里:",
        "translate": ""
    },
    {
        "source": "includes a function to do command line parsing in shell32.dll.",
        "suggest": "包括在 shell32.dll 中进行命令行解析的函数。",
        "translate": ""
    },
    {
        "source": "However, this is not used for two reasons:",
        "suggest": "但是，不使用它有两个原因:",
        "translate": ""
    },
    {
        "source": "Linking with that DLL causes the process to be registered as a GUI application.",
        "suggest": "与该 DLL 链接会使进程注册为 GUI 应用程序。",
        "translate": ""
    },
    {
        "source": "It does not follow the modern C/C++ argv rules outlined in the first two links above.",
        "suggest": "它不遵循上面前两个链接中概述的现代 C/C++ argv 规则。",
        "translate": ""
    },
    {
        "source": "This function was tested for equivalence to the C/C++ parsing rules using an extensive test suite available at <https://github.com/ChrisDenton/winarg/tree/std>.",
        "suggest": "使用可从以下站点获得的扩展测试套件测试了该函数与 C/C++ 解析规则的等效性：<https://github.com/ChrisDenton/winarg/tree/std>。",
        "translate": ""
    },
    {
        "source": "If the cmd line pointer is null or it points to an empty string then return the name of the executable as argv[0].",
        "suggest": "如果 cmd 行指针为空或指向空字符串，则将可执行文件的名称返回为 argv[0]。",
        "translate": ""
    },
    {
        "source": "A quote mark always toggles `in_quotes` no matter what because there are no escape characters when parsing the executable name.",
        "suggest": "无论如何，引号总是切换 `in_quotes`，因为在解析可执行文件名称时没有转义字符。",
        "translate": ""
    },
    {
        "source": "If not `in_quotes` then whitespace ends argv[0].",
        "suggest": "如果不是 `in_quotes`，则空格以 argv[0] 结尾。",
        "translate": ""
    },
    {
        "source": "In all other cases the code unit is taken literally.",
        "suggest": "在所有其他情况下，代码单元是按字面意思理解的。",
        "translate": ""
    },
    {
        "source": "Skip whitespace.",
        "suggest": "跳过空格。",
        "translate": ""
    },
    {
        "source": "Parse the arguments according to these rules:",
        "suggest": "根据以下规则解析参数:",
        "translate": ""
    },
    {
        "source": "All code units are taken literally except space, tab, quote and backslash.",
        "suggest": "除空格、制表符、引号和反斜杠外，所有代码单元均按字面意思表示。",
        "translate": ""
    },
    {
        "source": "When not `in_quotes`, space and tab separate arguments.",
        "suggest": "当不是 `in_quotes` 时，空格和制表符将参数分开。",
        "translate": ""
    },
    {
        "source": "Consecutive spaces and tabs are treated as a single separator.",
        "suggest": "连续的空格和制表符被视为单个分隔符。",
        "translate": ""
    },
    {
        "source": "A space or tab `in_quotes` is taken literally.",
        "suggest": "空格或制表符 `in_quotes` 按字面意思表示。",
        "translate": ""
    },
    {
        "source": "A quote toggles `in_quotes` mode unless it's escaped.",
        "suggest": "除非转义，否则引号会切换 `in_quotes` 模式。",
        "translate": ""
    },
    {
        "source": "An escaped quote is taken literally.",
        "suggest": "转义引用是按字面意思理解的。",
        "translate": ""
    },
    {
        "source": "A quote can be escaped if preceded by an odd number of backslashes.",
        "suggest": "如果前面有奇数个反斜杠，则可以对引号进行转义。",
        "translate": ""
    },
    {
        "source": "If any number of backslashes is immediately followed by a quote then the number of backslashes is halved (rounding down).",
        "suggest": "如果任何数量的反斜杠后面紧跟一个引号，则反斜杠的数量减半 (四舍五入)。",
        "translate": ""
    },
    {
        "source": "Backslashes not followed by a quote are all taken literally.",
        "suggest": "后面没有引号的反斜杠都是字面意思。",
        "translate": ""
    },
    {
        "source": "If `in_quotes` then a quote can also be escaped using another quote (i.e.",
        "suggest": "如果 `in_quotes` 那么一个引号也可以使用另一个引号进行转义 (比如",
        "translate": ""
    },
    {
        "source": "two consecutive quotes become one literal quote).",
        "suggest": "两个连续的引号变成一个字面量引号)。",
        "translate": ""
    },
    {
        "source": "If not `in_quotes`, a space or tab ends the argument.",
        "suggest": "如果不是 `in_quotes`，则以空格或制表符结束参数。",
        "translate": ""
    },
    {
        "source": "Backslashes can escape quotes or backslashes but only if consecutive backslashes are followed by a quote.",
        "suggest": "反斜杠可以转义引号或反斜杠，但前提是连续的反斜杠后跟一个引号。",
        "translate": ""
    },
    {
        "source": "The quote is escaped if there are an odd number of backslashes.",
        "suggest": "如果有奇数个反斜杠，引号将被转义。",
        "translate": ""
    },
    {
        "source": "If there is no quote on the end then there is no escaping.",
        "suggest": "如果最后没有引用，则没有转义。",
        "translate": ""
    },
    {
        "source": "If `in_quotes` and not backslash escaped (see above) then a quote either unsets `in_quote` or is escaped by another quote.",
        "suggest": "如果 `in_quotes` 而不是反斜杠转义 (见上文)，则引用要么取消设置 `in_quote`，要么被另一个引用转义。",
        "translate": ""
    },
    {
        "source": "Two consecutive quotes when `in_quotes` produces one literal quote.",
        "suggest": "当 `in_quotes` 产生一个文字引号时，两个连续的引号。",
        "translate": ""
    },
    {
        "source": "Otherwise set `in_quotes`.",
        "suggest": "否则设置 `in_quotes`。",
        "translate": ""
    },
    {
        "source": "The end of the command line.",
        "suggest": "命令行结束。",
        "translate": ""
    },
    {
        "source": "Push `cur` even if empty, which we do by breaking while `in_quotes` is still set.",
        "suggest": "即使是空的，也要推送 `cur`,当 `in_quotes` 仍然设置时，我们通过中断来实现。",
        "translate": ""
    },
    {
        "source": "If not `in_quotes` and not BACKSLASH escaped (see above) then a quote sets `in_quote`.",
        "suggest": "如果不是 `in_quotes` 并且没有转义反斜杠 (见上文)，则引用设置 `in_quote`。",
        "translate": ""
    },
    {
        "source": "Everything else is always taken literally.",
        "suggest": "其他的一切总是从字面上理解。",
        "translate": ""
    },
    {
        "source": "Push the final argument, if any.",
        "suggest": "推送最后一个参数，如果有的话。",
        "translate": ""
    },
    {
        "source": "A safe iterator over a LPWSTR (aka a pointer to a series of UTF-16 code units terminated by a NULL).",
        "suggest": "LPWSTR 上的安全迭代器 (又名指向以 NULL 结尾的一系列 UTF-16 代码单元的指针)。",
        "translate": ""
    },
    {
        "source": "The pointer must never be null...",
        "suggest": "指针永远不能为空...",
        "translate": ""
    },
    {
        "source": "...and the memory it points to must be valid for this lifetime.",
        "suggest": "... 并且它指向的内存必须在此生命周期内有效。",
        "translate": ""
    },
    {
        "source": "Create the iterator.",
        "suggest": "创建迭代器。",
        "translate": ""
    },
    {
        "source": "Returns `None` if `lpwstr` is null.",
        "suggest": "如果 `lpwstr` 为空，则返回 `None`。",
        "translate": ""
    },
    {
        "source": "`lpwstr` must point to a null-terminated wide string that lives at least as long as the lifetime of this struct.",
        "suggest": "`lpwstr` 必须指向一个以空字符结尾的宽字符串，该字符串至少与此结构体的生命周期一样长。",
        "translate": ""
    },
    {
        "source": "It's always safe to read the current item because we don't ever move out of the array's bounds.",
        "suggest": "读取当前的项总是安全的，因为我们永远不会移出数组的边界。",
        "translate": ""
    },
    {
        "source": "Advance the iterator while `predicate` returns true.",
        "suggest": "在 `predicate` 返回 true 时推进迭代器。",
        "translate": ""
    },
    {
        "source": "Returns the number of items it advanced by.",
        "suggest": "返回其前进的项数。",
        "translate": ""
    },
    {
        "source": "This can never return zero as that marks the end of the string.",
        "suggest": "这永远不会返回零，因为这标志着字符串的结尾。",
        "translate": ""
    },
    {
        "source": "If NULL is reached we immediately return.",
        "suggest": "如果达到 NULL，我们立即返回。",
        "translate": ""
    },
    {
        "source": "Therefore it's safe to advance the pointer after that.",
        "suggest": "因此，在那之后推进指针是安全的。",
        "translate": ""
    },
    {
        "source": "not a continuation byte - reject",
        "suggest": "不是连续字节 - 拒绝",
        "translate": ""
    },
    {
        "source": "more bytes needed",
        "suggest": "需要更多字节",
        "translate": ""
    },
    {
        "source": "guaranteed by write_valid_utf8_to_console() for single codepoint writes",
        "suggest": "由 write_valid_utf8_to_console() 保证单个代码点写入",
        "translate": ""
    },
    {
        "source": "As the console is meant for presenting text, we assume bytes of `data` are encoded as UTF-8, which needs to be encoded as UTF-16.",
        "suggest": "由于控制台用于呈现文本，我们假设 `data` 的字节编码为 UTF-8，需要编码为 UTF-16。",
        "translate": ""
    },
    {
        "source": "If the first byte is invalid it is either first byte of a multi-byte sequence but the provided byte slice is too short or it is the first byte of an invalide multi-byte sequence.",
        "suggest": "如果第一个字节无效，则它是多字节序列的第一个字节，但提供的字节字节太短，或者它是无效多字节序列的第一个字节。",
        "translate": ""
    },
    {
        "source": "Always evaluates to [`TryReserveError::CapacityOverflow`].",
        "suggest": "始终评估为 [`TryReserveError::CapacityOverflow`]。",
        "translate": ""
    },
    {
        "source": "While you cannot `break` from a closure, the [`crate::ops::ControlFlow`] type allows a similar idea:",
        "suggest": "虽然您不能从闭包中 `break`，但 [`crate::ops::ControlFlow`] 类型允许类似的想法:",
        "translate": ""
    },
    {
        "source": "The [`crate::ops::ControlFlow`] type can be used with this method for the situations in which you'd use `break` and `continue` in a normal loop:",
        "suggest": "[`crate::ops::ControlFlow`] 类型可以与此方法一起用于在正常循环中使用 `break` 和 `continue` 的情况:",
        "translate": ""
    },
    {
        "source": "Fast conversion of a the significant digits and decimal exponent a float to a extended representation with a binary float.",
        "suggest": "将浮点数的有效数字和十进制指数快速转换为具有二进制浮点数的扩展表示。",
        "translate": ""
    },
    {
        "source": "This method may not be optimized owing to implementation details;",
        "suggest": "由于实现细节，此方法可能未优化;",
        "translate": ""
    },
    {
        "source": "and Redox lack `linkat`, so use `link` instead.",
        "suggest": "Redox 缺少 `linkat`，所以用 `link` 代替。",
        "translate": ""
    },
    {
        "source": "Temporary null documentation to work around #57569 until the fix is beta",
        "suggest": "临时空文档以解决 #57569 问题，直到修复程序成为 beta 版",
        "translate": ""
    }
]
