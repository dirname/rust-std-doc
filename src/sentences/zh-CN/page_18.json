[
    {
        "source": "VxWorks-specific raw type definitions",
        "suggest": "VxWorks 特定的原始类型定义",
        "translate": ""
    },
    {
        "source": "WASI-specific definitions",
        "suggest": "WASI 特定的定义",
        "translate": ""
    },
    {
        "source": "This code will not compile because the closure captures `&mut variable` which is not considered unwind safe by default.",
        "suggest": "由于闭包捕获 `&mut variable` (默认情况下不认为 unwind 安全)，因此不会编译该代码。",
        "translate": ""
    },
    {
        "source": "panic::catch_unwind(|| { variable += 3; });",
        "suggest": "panic::catch_unwind (|| { variable += 3; }) ;",
        "translate": ""
    },
    {
        "source": "This, however, will compile due to the `AssertUnwindSafe` wrapper",
        "suggest": "但是，由于 `AssertUnwindSafe` 包装器，它将进行编译",
        "translate": ""
    },
    {
        "source": "Panic the current thread with the given message as the panic payload.",
        "suggest": "Panic 当前线程，给定消息为 panic 有效负载。",
        "translate": ""
    },
    {
        "source": "The message can be of any (`Any + Send`) type, not just strings.",
        "suggest": "该消息可以是任何 (`Any + Send`) 类型，而不仅仅是字符串。",
        "translate": ""
    },
    {
        "source": "The message is wrapped in a `Box<'static + Any + Send>`, which can be accessed later using [`PanicInfo::payload`].",
        "suggest": "该消息包装在 `Box<'static + Any + Send>` 中，以后可以使用 [`PanicInfo::payload`] 进行访问。",
        "translate": ""
    },
    {
        "source": "See the [`panic!`] macro for more information about panicking.",
        "suggest": "有关恐慌的更多信息，请参见 [`panic!`] 宏。",
        "translate": ""
    },
    {
        "source": "A marker trait which represents \"panic safe\" types in Rust.",
        "suggest": "表示 Rust 中 \"panic safe\" 类型的标记 trait。",
        "translate": ""
    },
    {
        "source": "This trait is implemented by default for many types and behaves similarly in terms of inference of implementation to the [`Send`] and [`Sync`] traits.",
        "suggest": "默认情况下，此 trait 对许多类型都实现，并且在推断实现时类似于 [`Send`] 和 [`Sync`] traits。",
        "translate": ""
    },
    {
        "source": "The purpose of this trait is to encode what types are safe to cross a [`catch_unwind`] boundary with no fear of unwind safety.",
        "suggest": "trait 的目的是对可以跨越 [`catch_unwind`] 边界安全的类型进行编码，而不必担心 unwind 安全。",
        "translate": ""
    },
    {
        "source": "What is unwind safety?",
        "suggest": "什么是 unwind 安全性?",
        "translate": ""
    },
    {
        "source": "In Rust a function can \"return\" early if it either panics or calls a function which transitively panics.",
        "suggest": "在 Rust 中，如果一个函数可以 0panics 或调用一个传递 panics 的函数，则可以提前 \"return\"。",
        "translate": ""
    },
    {
        "source": "This sort of control flow is not always anticipated, and has the possibility of causing subtle bugs through a combination of two critical components:",
        "suggest": "这种控制流并非总是可以预期的，并且有可能通过结合以下两个关键组件而导致细微的错误:",
        "translate": ""
    },
    {
        "source": "A data structure is in a temporarily invalid state when the thread panics.",
        "suggest": "当线程 panics 时，数据结构体处于暂时无效状态。",
        "translate": ""
    },
    {
        "source": "This broken invariant is then later observed.",
        "suggest": "然后，随后观察到该破碎的不变式。",
        "translate": ""
    },
    {
        "source": "Typically in Rust, it is difficult to perform step (2) because catching a panic involves either spawning a thread (which in turns makes it difficult to later witness broken invariants) or using the `catch_unwind` function in this module.",
        "suggest": "通常，在 Rust 中，很难执行步骤 (2)，因为捕获 panic 涉及生成线程 (这又使以后很难看到损坏的不变式) 或在此模块中使用 `catch_unwind` 函数。",
        "translate": ""
    },
    {
        "source": "Additionally, even if an invariant is witnessed, it typically isn't a problem in Rust because there are no uninitialized values (like in C or C++).",
        "suggest": "此外，即使见证了一个不变式，在 Rust 中也通常不是问题，因为不存在未初始化的值 (如 C 或 C++ )。",
        "translate": ""
    },
    {
        "source": "It is possible, however, for **logical** invariants to be broken in Rust, which can end up causing behavioral bugs.",
        "suggest": "然而，在Rust中，**logical** 不可变变量被破坏是有可能的，这最终会导致行为 Bug。",
        "translate": ""
    },
    {
        "source": "Another key aspect of unwind safety in Rust is that, in the absence of `unsafe` code, a panic cannot lead to memory unsafety.",
        "suggest": "Rust 中 unwind 安全性的另一个关键方面是，在没有 `unsafe` 代码的情况下，panic 不会导致内存不安全。",
        "translate": ""
    },
    {
        "source": "That was a bit of a whirlwind tour of unwind safety, but for more information about unwind safety and how it applies to Rust, see an [associated RFC][rfc].",
        "suggest": "那是 unwind 安全性的旋风之旅，但是有关 unwind 安全性及其如何应用于 Rust 的更多信息，请参见 [associated RFC][rfc]。",
        "translate": ""
    },
    {
        "source": "What is `UnwindSafe`?",
        "suggest": "什么是 `UnwindSafe`?",
        "translate": ""
    },
    {
        "source": "Now that we've got an idea of what unwind safety is in Rust, it's also important to understand what this trait represents.",
        "suggest": "现在我们已经了解了 Rust 中的 unwind 安全性，了解此 trait 所代表的意义也很重要。",
        "translate": ""
    },
    {
        "source": "As mentioned above, one way to witness broken invariants is through the `catch_unwind` function in this module as it allows catching a panic and then re-using the environment of the closure.",
        "suggest": "如上所述，见证不可变变量不变的一种方法是通过此模块中的 `catch_unwind` 函数，因为它允许捕获 panic，然后重新使用闭包的环境。",
        "translate": ""
    },
    {
        "source": "Simply put, a type `T` implements `UnwindSafe` if it cannot easily allow witnessing a broken invariant through the use of `catch_unwind` (catching a panic).",
        "suggest": "简而言之，如果类型 `T` 无法通过使用 `catch_unwind` (捕获 panic) 来轻松地见证破损的不变式，则可以实现 `UnwindSafe`。",
        "translate": ""
    },
    {
        "source": "This trait is an auto trait, so it is automatically implemented for many types, and it is also structurally composed (e.g., a struct is unwind safe if all of its components are unwind safe).",
        "suggest": "trait 是自动的 trait，因此可以自动实现为多种类型，并且在结构上也已组成 (例如，如果结构体的所有组件都是 unwind 安全的，则该结构体是 unwind 安全的)。",
        "translate": ""
    },
    {
        "source": "Note, however, that this is not an unsafe trait, so there is not a succinct contract that this trait is providing.",
        "suggest": "但是请注意，这不是不安全的 trait，因此该 trait 没有提供简洁的契约。",
        "translate": ""
    },
    {
        "source": "Instead it is intended as more of a \"speed bump\" to alert users of `catch_unwind` that broken invariants may be witnessed and may need to be accounted for.",
        "suggest": "相反，它旨在作为 \"speed bump\" 的一部分，以警告 `catch_unwind` 用户，可能会目击到破碎的不变式，并且可能需要解决这些不变式。",
        "translate": ""
    },
    {
        "source": "Who implements `UnwindSafe`?",
        "suggest": "谁实现 `UnwindSafe`?",
        "translate": ""
    },
    {
        "source": "Types such as `&mut T` and `&RefCell<T>` are examples which are **not** unwind safe.",
        "suggest": "`&mut T` 和 `&RefCell<T>` 之类的类型是 unwind 不安全的示例。",
        "translate": ""
    },
    {
        "source": "The general idea is that any mutable state which can be shared across `catch_unwind` is not unwind safe by default.",
        "suggest": "通常的想法是，默认情况下，可以在 `catch_unwind` 之间共享的任何可变状态都不是 unwind 安全的。",
        "translate": ""
    },
    {
        "source": "This is because it is very easy to witness a broken invariant outside of `catch_unwind` as the data is simply accessed as usual.",
        "suggest": "这是因为很容易看到 `catch_unwind` 之外的不可变变量，因为像往常一样简单地访问数据。",
        "translate": ""
    },
    {
        "source": "Types like `&Mutex<T>`, however, are unwind safe because they implement poisoning by default.",
        "suggest": "但是，像 `&Mutex<T>` 这样的类型是 unwind 安全的，因为它们默认实现中毒。",
        "translate": ""
    },
    {
        "source": "They still allow witnessing a broken invariant, but they already provide their own \"speed bumps\" to do so.",
        "suggest": "他们仍然可以目击损坏的不变式，但是他们已经提供了自己的 \"speed bumps\"。",
        "translate": ""
    },
    {
        "source": "When should `UnwindSafe` be used?",
        "suggest": "什么时候应使用 `UnwindSafe`?",
        "translate": ""
    },
    {
        "source": "It is not intended that most types or functions need to worry about this trait.",
        "suggest": "并非意味着大多数类型或函数都不必担心此 trait。",
        "translate": ""
    },
    {
        "source": "It is only used as a bound on the `catch_unwind` function and as mentioned above, the lack of `unsafe` means it is mostly an advisory.",
        "suggest": "它仅用作 `catch_unwind` 函数的绑定，如上所述，缺少 `unsafe` 意味着它主要是建议。",
        "translate": ""
    },
    {
        "source": "The [`AssertUnwindSafe`] wrapper struct can be used to force this trait to be implemented for any closed over variables passed to `catch_unwind`.",
        "suggest": "[`AssertUnwindSafe`] 包装器结构体可用于强制将 trait 应用于传递给 `catch_unwind` 的任何封闭变量。",
        "translate": ""
    },
    {
        "source": "A marker trait representing types where a shared reference is considered unwind safe.",
        "suggest": "标记 trait 表示将 X 表示 unwind 安全的共享引用的类型。",
        "translate": ""
    },
    {
        "source": "This trait is namely not implemented by [`UnsafeCell`], the root of all interior mutability.",
        "suggest": "即，该 trait 并非由 [`UnsafeCell`] 实现，[`UnsafeCell`] 是所有内部可变性的根。",
        "translate": ""
    },
    {
        "source": "This is a \"helper marker trait\" used to provide impl blocks for the [`UnwindSafe`] trait, for more information see that documentation.",
        "suggest": "这是 \"helper marker trait\"，用于为 [`UnwindSafe`] trait 提供 impl 块，有关更多信息，请参见该文档。",
        "translate": ""
    },
    {
        "source": "A simple wrapper around a type to assert that it is unwind safe.",
        "suggest": "一个简单的包装器，可以断言它是 unwind 安全的。",
        "translate": ""
    },
    {
        "source": "When using [`catch_unwind`] it may be the case that some of the closed over variables are not unwind safe.",
        "suggest": "使用 [`catch_unwind`] 时，可能某些封闭变量不是 unwind 安全的。",
        "translate": ""
    },
    {
        "source": "For example if `&mut T` is captured the compiler will generate a warning indicating that it is not unwind safe.",
        "suggest": "例如，如果捕获了 `&mut T`，编译器将生成一条警告，指出它不是 unwind 安全的。",
        "translate": ""
    },
    {
        "source": "It may not be the case, however, that this is actually a problem due to the specific usage of [`catch_unwind`] if unwind safety is specifically taken into account.",
        "suggest": "但是，如果特别考虑了 unwind 的安全性，则由于 [`catch_unwind`] 的特定用法，实际上可能不是问题。",
        "translate": ""
    },
    {
        "source": "This wrapper struct is useful for a quick and lightweight annotation that a variable is indeed unwind safe.",
        "suggest": "此包装结构体对于快速且轻便的注解很有用，因为变量确实是 unwind 安全的。",
        "translate": ""
    },
    {
        "source": "One way to use `AssertUnwindSafe` is to assert that the entire closure itself is unwind safe, bypassing all checks for all variables:",
        "suggest": "使用 `AssertUnwindSafe` 的一种方法是断言整个闭包本身是 unwind 安全的，绕过所有变量的所有检查:",
        "translate": ""
    },
    {
        "source": "Wrapping the entire closure amounts to a blanket assertion that all captured variables are unwind safe.",
        "suggest": "包装整个闭包就等于断言所有捕获的变量都是 unwind 安全的。",
        "translate": ""
    },
    {
        "source": "This has the downside that if new captures are added in the future, they will also be considered unwind safe.",
        "suggest": "不利之处在于，如果在 future 中添加了新的捕获，它们也将被视为 unwind 安全。",
        "translate": ""
    },
    {
        "source": "Therefore, you may prefer to just wrap individual captures, as shown below.",
        "suggest": "因此，您可能希望只包装单个捕获，如下所示。",
        "translate": ""
    },
    {
        "source": "This is more annotation, but it ensures that if a new capture is added which is not unwind safe, you will get a compilation error at that time, which will allow you to consider whether that new capture in fact represent a bug or not.",
        "suggest": "这是更多的注解，但是它可以确保如果添加的 unwind 不安全的新捕获，您将在那时遇到编译错误，这将使您考虑该新捕获是否实际上代表错误。",
        "translate": ""
    },
    {
        "source": "Implementations of the `UnwindSafe` trait:",
        "suggest": "`UnwindSafe` trait 的实现:",
        "translate": ""
    },
    {
        "source": "By default everything is unwind safe",
        "suggest": "默认情况下，所有内容都是 unwind 安全的",
        "translate": ""
    },
    {
        "source": "pointers T contains mutability of some form are not unwind safe",
        "suggest": "指针 T 包含某种形式的可变性不是 unwind 安全的",
        "translate": ""
    },
    {
        "source": "Unique, an owning pointer, lifts an implementation",
        "suggest": "唯一的拥有指针，可以提升实现",
        "translate": ""
    },
    {
        "source": "Types like Mutex/RwLock which are explicitly poisoned are unwind safe",
        "suggest": "像 Mutex/RwLock 这样被明确中毒的类型是 unwind 安全的",
        "translate": ""
    },
    {
        "source": "Our custom AssertUnwindSafe wrapper is indeed unwind safe",
        "suggest": "我们的自定义 AssertUnwindSafe 包装器确实是 unwind 安全的",
        "translate": ""
    },
    {
        "source": "not covered via the Shared impl above b/c the inner contents use Cell/AtomicUsize, but the usage here is unwind safe so we can lift the impl up one level to Arc/Rc itself",
        "suggest": "未通过 b/c 上方的共享 impl 覆盖，内部内容使用 Cell/AtomicUsize，但此处的用法是 unwind 安全的，因此我们可以将 impl 提升至 Arc/Rc 本身",
        "translate": ""
    },
    {
        "source": "Pretty simple implementations for the `RefUnwindSafe` marker trait, basically just saying that `UnsafeCell` is the only thing which doesn't implement it (which then transitively applies to everything else).",
        "suggest": "`RefUnwindSafe` 标记 trait 的非常简单的实现，基本上只是说 `UnsafeCell` 是唯一不实现它的东西 (然后将其可传递地应用于其他所有东西)。",
        "translate": ""
    },
    {
        "source": "Invokes a closure, capturing the cause of an unwinding panic if one occurs.",
        "suggest": "调用一个闭包，如果发生，则捕获展开 panic 的原因。",
        "translate": ""
    },
    {
        "source": "This function will return `Ok` with the closure's result if the closure does not panic, and will return `Err(cause)` if the closure panics.",
        "suggest": "如果闭包不是 panic，则此函数将返回 `Ok`，并返回闭包的结果; 如果闭包 panics，则此函数将返回 `Err(cause)`。",
        "translate": ""
    },
    {
        "source": "The `cause` returned is the object with which panic was originally invoked.",
        "suggest": "返回的 `cause` 是最初调用 panic 的 object。",
        "translate": ""
    },
    {
        "source": "It is currently undefined behavior to unwind from Rust code into foreign code, so this function is particularly useful when Rust is called from another language (normally C).",
        "suggest": "unwind 当前从 Rust 代码转换为外来代码是未定义的行为，因此当从另一种语言 (通常为 C) 调用 Rust 时，此函数特别有用。",
        "translate": ""
    },
    {
        "source": "This can run arbitrary Rust code, capturing a panic and allowing a graceful handling of the error.",
        "suggest": "这可以运行任意的 Rust 代码，捕获 panic 并允许对错误进行适当的处理。",
        "translate": ""
    },
    {
        "source": "It is **not** recommended to use this function for a general try/catch mechanism.",
        "suggest": "不建议将此函数用于一般的 try/catch 机制。",
        "translate": ""
    },
    {
        "source": "The [`Result`] type is more appropriate to use for functions that can fail on a regular basis.",
        "suggest": "[`Result`] 类型更适合用于经常失败的函数。",
        "translate": ""
    },
    {
        "source": "Additionally, this function is not guaranteed to catch all panics, see the \"Notes\" section below.",
        "suggest": "此外，不能保证此函数可以捕获所有 panics，请参见下面的 \"Notes\" 部分。",
        "translate": ""
    },
    {
        "source": "The closure provided is required to adhere to the [`UnwindSafe`] trait to ensure that all captured variables are safe to cross this boundary.",
        "suggest": "提供的闭包必须遵守 [`UnwindSafe`] trait，以确保所有捕获的变量都可以安全越过此边界。",
        "translate": ""
    },
    {
        "source": "The purpose of this bound is to encode the concept of [exception safety][rfc] in the type system.",
        "suggest": "此绑定的目的是在类型系统中对 [异常安全][rfc] 的概念进行编码。",
        "translate": ""
    },
    {
        "source": "Most usage of this function should not need to worry about this bound as programs are naturally unwind safe without `unsafe` code.",
        "suggest": "此函数的大多数用法都不必担心此绑定，因为没有 `unsafe` 代码的程序自然是 unwind 安全的。",
        "translate": ""
    },
    {
        "source": "If it becomes a problem the [`AssertUnwindSafe`] wrapper struct can be used to quickly assert that the usage here is indeed unwind safe.",
        "suggest": "如果出现问题，可以使用 [`AssertUnwindSafe`] 包装器结构体快速断言此处的使用确实是 unwind 安全的。",
        "translate": ""
    },
    {
        "source": "Note that this function **may not catch all panics** in Rust.",
        "suggest": "请注意，此函数 **可能无法捕获 Rust 中的所有 panics**。",
        "translate": ""
    },
    {
        "source": "A panic in Rust is not always implemented via unwinding, but can be implemented by aborting the process as well.",
        "suggest": "Rust 中的 panic 并不总是通过展开来实现，但是也可以通过终止进程来实现。",
        "translate": ""
    },
    {
        "source": "This function *only* catches unwinding panics, not those that abort the process.",
        "suggest": "该函数 *仅* 捕获展开 panics，而不是终止进程的 panics。",
        "translate": ""
    },
    {
        "source": "Also note that unwinding into Rust code with a foreign exception (e.g.",
        "suggest": "另请注意，使用外部异常 (例如，展开为 Rust 代码)",
        "translate": ""
    },
    {
        "source": "an exception thrown from C++ code) is undefined behavior.",
        "suggest": "从 C++ 代码引发的异常) 是未定义的行为。",
        "translate": ""
    },
    {
        "source": "Triggers a panic without invoking the panic hook.",
        "suggest": "触发 panic 而不调用 panic hook。",
        "translate": ""
    },
    {
        "source": "This is designed to be used in conjunction with [`catch_unwind`] to, for example, carry a panic across a layer of C code.",
        "suggest": "它被设计为与 [`catch_unwind`] 结合使用，例如，跨 C 代码层携带 panic。",
        "translate": ""
    },
    {
        "source": "Note that panics in Rust are not always implemented via unwinding, but they may be implemented by aborting the process.",
        "suggest": "请注意，Rust 中的 panics 并不总是通过展开来实现，但是可以通过中止进程来实现。",
        "translate": ""
    },
    {
        "source": "If this function is called when panics are implemented this way then this function will abort the process, not trigger an unwind.",
        "suggest": "如果以这种方式实现 panics 时调用了此函数，则此函数将终止进程，而不触发 unwind。",
        "translate": ""
    },
    {
        "source": "Implementation of various bits and pieces of the `panic!` macro and associated runtime pieces.",
        "suggest": "`panic!` 宏的各个部分以及相关运行时块的实现。",
        "translate": ""
    },
    {
        "source": "Specifically, this module contains the implementation of:",
        "suggest": "具体来说，该模块包含以下内容的实现:",
        "translate": ""
    },
    {
        "source": "Executing a panic up to doing the actual implementation",
        "suggest": "执行 panic 直到完成实际实现",
        "translate": ""
    },
    {
        "source": "Shims around \"try\"",
        "suggest": "\"try\" 周围的垫片",
        "translate": ""
    },
    {
        "source": "make sure to use the stderr output configured by libtest in the real copy of std",
        "suggest": "确保在 std 的真实副本中使用 libtest 配置的 stderr 输出",
        "translate": ""
    },
    {
        "source": "Binary interface to the panic runtime that the standard library depends on.",
        "suggest": "标准库所依赖的 panic 运行时的二进制接口。",
        "translate": ""
    },
    {
        "source": "The standard library is tagged with `#![needs_panic_runtime]` (introduced in RFC 1513) to indicate that it requires some other crate tagged with `#![panic_runtime]` to exist somewhere.",
        "suggest": "标准库用 `#![needs_panic_runtime]` 标记 (在 RFC 1513 中引入)，以表明它需要一些其他用 `#![panic_runtime]` 标记的 crate 才能存在。",
        "translate": ""
    },
    {
        "source": "Each panic runtime is intended to implement these symbols (with the same signatures) so we can get matched up to them.",
        "suggest": "每个 panic 运行时都旨在实现这些符号 (具有相同的签名)，因此我们可以对其进行匹配。",
        "translate": ""
    },
    {
        "source": "One day this may look a little less ad-hoc with the compiler helping out to hook up these functions, but it is not this day!",
        "suggest": "有一天，编译器可以帮助这些函数 hook 临时看起来不那么特别，但这不是今天!",
        "translate": ""
    },
    {
        "source": "is passed through another layer of raw pointers as `&mut dyn Trait` is not FFI-safe.",
        "suggest": "由于 `&mut dyn Trait` 并非 FFI 安全，因此会通过另一层裸指针传递。",
        "translate": ""
    },
    {
        "source": "lazily performs allocation only when needed (this avoids allocations when using the \"abort\" panic runtime).",
        "suggest": "仅在需要时才懒惰地执行分配 (这避免了在使用 \"abort\" panic 运行时时的分配)。",
        "translate": ""
    },
    {
        "source": "This function is called by the panic runtime if FFI code catches a Rust panic but doesn't rethrow it.",
        "suggest": "如果 FFI 代码捕获到 Rust panic 但不将其抛出，则 panic 运行时将调用此函数。",
        "translate": ""
    },
    {
        "source": "We don't support this case since it messes with our panic count.",
        "suggest": "我们不支持这种情况，因为它与我们的 panic 计数弄混了。",
        "translate": ""
    },
    {
        "source": "This function is called by the panic runtime if it catches an exception object which does not correspond to a Rust panic.",
        "suggest": "如果 panic 运行时捕获到一个与 X0Rust0Z panic 不对应的异常 object，则该函数由 panic 运行时调用。",
        "translate": ""
    },
    {
        "source": "Registers a custom panic hook, replacing any that was previously registered.",
        "suggest": "注册一个自定义 panic hook，替换以前注册的任何 panic。",
        "translate": ""
    },
    {
        "source": "The panic hook is invoked when a thread panics, but before the panic runtime is invoked.",
        "suggest": "panic hook 在线程 panics 时但在调用 panic 运行时之前被调用。",
        "translate": ""
    },
    {
        "source": "As such, the hook will run with both the aborting and unwinding runtimes.",
        "suggest": "这样，hook 将与终止和展开运行时一起运行。",
        "translate": ""
    },
    {
        "source": "The default hook prints a message to standard error and generates a backtrace if requested, but this behavior can be customized with the `set_hook` and [`take_hook`] functions.",
        "suggest": "默认的 hook 将消息显示为标准错误，并在请求时生成回溯，但是可以使用 `set_hook` 和 [`take_hook`] 函数自定义此行为。",
        "translate": ""
    },
    {
        "source": "The hook is provided with a `PanicInfo` struct which contains information about the origin of the panic, including the payload passed to `panic!` and the source code location from which the panic originated.",
        "suggest": "hook 提供了一个 `PanicInfo` 结构体，该结构体包含有关 panic 的起源的信息，包括传递给 `panic!` 的有效负载和 panic 起源的源代码位置。",
        "translate": ""
    },
    {
        "source": "The panic hook is a global resource.",
        "suggest": "panic hook 是一个资源。",
        "translate": ""
    },
    {
        "source": "Panics if called from a panicking thread.",
        "suggest": "Panics (如果从紧急恐慌线程调用)。",
        "translate": ""
    },
    {
        "source": "The following will print \"Custom panic hook\":",
        "suggest": "以下将打印 \"Custom panic hook\":",
        "translate": ""
    },
    {
        "source": "Unregisters the current panic hook, returning it.",
        "suggest": "注销当前的 panic hook，并将其返回。",
        "translate": ""
    },
    {
        "source": "See also the function [`set_hook`].",
        "suggest": "另请参见函数 [`set_hook`]。",
        "translate": ""
    },
    {
        "source": "The following will print \"Normal panic\":",
        "suggest": "以下将打印 \"Normal panic\":",
        "translate": ""
    },
    {
        "source": "If this is a double panic, make sure that we print a backtrace for this panic.",
        "suggest": "如果这是 panic 的两倍，请确保我们为此 panic 打印回溯。",
        "translate": ""
    },
    {
        "source": "Otherwise only print it if logging is enabled.",
        "suggest": "否则，仅在启用日志记录的情况下才打印它。",
        "translate": ""
    },
    {
        "source": "The current implementation always returns `Some`.",
        "suggest": "当前实现始终返回 `Some`。",
        "translate": ""
    },
    {
        "source": "Panic count for the current thread.",
        "suggest": "当前线程的 Panic 计数。",
        "translate": ""
    },
    {
        "source": "Sum of panic counts from all threads.",
        "suggest": "panic 的总和来自所有线程。",
        "translate": ""
    },
    {
        "source": "The purpose of this is to have a fast path in `is_zero` (which is used by `panicking`).",
        "suggest": "目的是在 `is_zero` (`panicking` 使用) 中具有快速路径。",
        "translate": ""
    },
    {
        "source": "In any particular thread, if that thread currently views `GLOBAL_PANIC_COUNT` as being zero, then `LOCAL_PANIC_COUNT` in that thread is zero.",
        "suggest": "在任何特定线程中，如果该线程当前将 `GLOBAL_PANIC_COUNT` 视为零，则该线程中的 `LOCAL_PANIC_COUNT` 为零。",
        "translate": ""
    },
    {
        "source": "This invariant holds before and after increase and decrease, but not necessarily during their execution.",
        "suggest": "该不变在增加和减少之前和之后均成立，但不一定在其执行期间成立。",
        "translate": ""
    },
    {
        "source": "Fast path: if `GLOBAL_PANIC_COUNT` is zero, all threads (including the current one) will have `LOCAL_PANIC_COUNT` equal to zero, so TLS access can be avoided.",
        "suggest": "快速路径: 如果 `GLOBAL_PANIC_COUNT` 为零，则所有线程 (包括当前线程) 的 `LOCAL_PANIC_COUNT` 均等于零，因此可以避免 TLS 访问。",
        "translate": ""
    },
    {
        "source": "In terms of performance, a relaxed atomic load is similar to a normal aligned memory read (e.g., a mov instruction in x86), but with some compiler optimization restrictions.",
        "suggest": "在性能方面，宽松的原子负载类似于正常对齐的内存读取 (例如，x86 中的 mov 指令)，但有一些编译器优化限制。",
        "translate": ""
    },
    {
        "source": "On the other hand, a TLS access might require calling a non-inlinable function (such as `__tls_get_addr` when using the GD TLS model).",
        "suggest": "另一方面，TLS 访问可能需要调用不可插入的函数 (例如，使用 GD TLS 模型时为 `__tls_get_addr`)。",
        "translate": ""
    },
    {
        "source": "Slow path is in a separate function to reduce the amount of code inlined from `is_zero`.",
        "suggest": "慢速路径位于单独的函数中，以减少从 `is_zero` 内联的代码量。",
        "translate": ""
    },
    {
        "source": "Invoke a closure, capturing the cause of an unwinding panic if one occurs.",
        "suggest": "调用一个闭包，如果发生，请捕获展开 panic 的原因。",
        "translate": ""
    },
    {
        "source": "We do some sketchy operations with ownership here for the sake of performance.",
        "suggest": "为了性能起见，我们在此处使用所有权进行一些粗略的操作。",
        "translate": ""
    },
    {
        "source": "We can only pass pointers down to `do_call` (can't pass objects by value), so we do all the ownership tracking here manually using a union.",
        "suggest": "我们只能将指针向下传递到 `do_call` (不能按值传递对象)，所以我们在此处使用 union 进行手动的所有的所有权跟踪。",
        "translate": ""
    },
    {
        "source": "We go through a transition where:",
        "suggest": "我们经历了一个过渡，其中:",
        "translate": ""
    },
    {
        "source": "First, we set the data field `f` to be the argumentless closure that we're going to call.",
        "suggest": "首先，我们将数据字段 `f` 设置为要调用的无参数闭包。",
        "translate": ""
    },
    {
        "source": "When we make the function call, the `do_call` function below, we take ownership of the function pointer.",
        "suggest": "在进行下面的 `do_call` 函数的函数调用时，我们将拥有函数指针的所有权。",
        "translate": ""
    },
    {
        "source": "At this point the `data` union is entirely uninitialized.",
        "suggest": "此时，`data` union 完全没有初始化。",
        "translate": ""
    },
    {
        "source": "If the closure successfully returns, we write the return value into the data's return slot (field `r`).",
        "suggest": "如果闭包成功返回，则将返回值写入数据的返回插槽 (字段 `r`)。",
        "translate": ""
    },
    {
        "source": "If the closure panics (`do_catch` below), we write the panic payload into field `p`.",
        "suggest": "如果闭包 panics (下面的 `do_catch`)，我们将 panic 有效负载写入字段 `p`。",
        "translate": ""
    },
    {
        "source": "Finally, when we come back out of the `try` intrinsic we're in one of two states:",
        "suggest": "最后，当我们退出 `try` 内联函数时，我们处于以下两种状态之一:",
        "translate": ""
    },
    {
        "source": "The closure didn't panic, in which case the return value was filled in.",
        "suggest": "闭包不是 panic，在这种情况下将填写返回值。",
        "translate": ""
    },
    {
        "source": "We move it out of `data.r` and return it.",
        "suggest": "我们将其移出 `data.r` 并返回。",
        "translate": ""
    },
    {
        "source": "The closure panicked, in which case the panic payload was filled in.",
        "suggest": "闭包恐慌，在这种情况下，panic 有效负载被填充。",
        "translate": ""
    },
    {
        "source": "We move it out of `data.p` and return it.",
        "suggest": "我们将其移出 `data.p` 并返回。",
        "translate": ""
    },
    {
        "source": "Once we stack all that together we should have the \"most efficient' method of calling a catch panic whilst juggling ownership.",
        "suggest": "一旦我们把所有这些都堆在一起，我们就有了最有效的方法，可以在兼顾所有权的同时触发 panic。",
        "translate": ""
    },
    {
        "source": "Access to the union's fields: this is `std` and we know that the `r#try` intrinsic fills in the `r` or `p` union field based on its return value.",
        "suggest": "访问 union 的字段: 这是 `std`，我们知道 `r#try` 内联函数根据其返回值填充 `r` 或 `p` union 字段。",
        "translate": ""
    },
    {
        "source": "The call to `intrinsics::r#try` is made safe by:",
        "suggest": "通过以下方法可以安全地调用 `intrinsics::r#try`:",
        "translate": ""
    },
    {
        "source": "the first argument, can be called with the initial `data_ptr`.",
        "suggest": "第一个参数，可以用初始 `data_ptr` 调用。",
        "translate": ""
    },
    {
        "source": "the second argument, can be called with the `data_ptr` as well.",
        "suggest": "第二个参数，也可以用 `data_ptr` 调用。",
        "translate": ""
    },
    {
        "source": "See their safety preconditions for more informations",
        "suggest": "有关更多信息，请参见其安全先决条件",
        "translate": ""
    },
    {
        "source": "We consider unwinding to be rare, so mark this function as cold.",
        "suggest": "我们认为展开很少见，因此将此函数标记为 `cold`。",
        "translate": ""
    },
    {
        "source": "However, do not mark it no-inline -- that decision is best to leave to the optimizer (in most cases this function is not inlined even as a normal, non-cold function, though, as of the writing of this comment).",
        "suggest": "但是，请勿将其标记为非内联 - 最好将决定权留给优化器 (在撰写此评论之时，大多数情况下，即使作为普通的非冷函数，也不会内联此函数)。",
        "translate": ""
    },
    {
        "source": "The whole unsafe block hinges on a correct implementation of the panic handler `__rust_panic_cleanup`.",
        "suggest": "整个不安全块取决于 panic 处理程序 `__rust_panic_cleanup` 的正确实现。",
        "translate": ""
    },
    {
        "source": "As such we can only assume it returns the correct thing for `Box::from_raw` to work without undefined behavior.",
        "suggest": "因此，我们只能假设它为 `Box::from_raw` 工作时返回正确的东西，而没有未定义的行为。",
        "translate": ""
    },
    {
        "source": "data must be non-NUL, correctly aligned, and a pointer to a `Data<F, R>` Its must contains a valid `f` (type: F) value that can be use to fill `data.r`.",
        "suggest": "数据必须为非 NUL，正确对齐且指向 `Data<F, R>` 的指针，其必须包含可用于填充 `data.r` 的有效 `f` (类型: F) 值。",
        "translate": ""
    },
    {
        "source": "This function cannot be marked as `unsafe` because `intrinsics::r#try` expects normal function pointers.",
        "suggest": "此函数不能标记为 `unsafe`，因为 `intrinsics::r#try` 需要正常的函数指针。",
        "translate": ""
    },
    {
        "source": "this is the responsibilty of the caller, see above.",
        "suggest": "这是调用者的责任，请参见上文。",
        "translate": ""
    },
    {
        "source": "We *do* want this part of the catch to be inlined: this allows the compiler to properly track accesses to the Data union and optimize it away most of the time.",
        "suggest": "我们 *确实* 希望这部分的 catch 被内联: 这允许编译器正确跟踪对 Data union 的访问，并在大多数情况下对其进行优化。",
        "translate": ""
    },
    {
        "source": "data must be non-NUL, correctly aligned, and a pointer to a `Data<F, R>` Since this uses `cleanup` it also hinges on a correct implementation of `__rustc_panic_cleanup`.",
        "suggest": "数据必须为非 NUL，正确对齐并指向 `Data<F, R>` 的指针。由于它使用 `cleanup`，因此还取决于 `__rustc_panic_cleanup` 的正确实现。",
        "translate": ""
    },
    {
        "source": "When `__rustc_panic_cleaner` is correctly implemented we can rely on `obj` being the correct thing to pass to `data.p` (after wrapping in `ManuallyDrop`).",
        "suggest": "正确实现 `__rustc_panic_cleaner` 后，我们可以依靠 `obj` 作为传递给 `data.p` 的正确对象 (在 `ManuallyDrop` 中包装)。",
        "translate": ""
    },
    {
        "source": "Determines whether the current thread is unwinding because of panic.",
        "suggest": "确定当前线程是否由于 panic 而处于展开状态。",
        "translate": ""
    },
    {
        "source": "The entry point for panicking with a formatted message.",
        "suggest": "带有格式化消息的恐慌的入口点。",
        "translate": ""
    },
    {
        "source": "This is designed to reduce the amount of code required at the call site as much as possible (so that `panic!()` has as low an impact on (e.g.) the inlining of other functions as possible), by moving the actual formatting into this shared place.",
        "suggest": "通过将实际格式移到该共享位置，可以最大程度地减少调用站点上所需的代码量 (以使 `panic!()` 对 (e.g.) 内联其他函数的影响尽可能小)。",
        "translate": ""
    },
    {
        "source": "If panic_immediate_abort, inline the abort call, otherwise avoid inlining because of it is cold path.",
        "suggest": "如果使用 panic_immediate_abort，则内联终止调用，否则请避免内联，因为它是冷路径。",
        "translate": ""
    },
    {
        "source": "Entry point of panics from the libcore crate (`panic_impl` lang item).",
        "suggest": "libcore crate (`panic_impl` lang 项) 中 panics 的入口点。",
        "translate": ""
    },
    {
        "source": "Lazily, the first time this gets called, run the actual string formatting.",
        "suggest": "懒惰的是，第一次调用此方法时，请运行实际的字符串格式。",
        "translate": ""
    },
    {
        "source": "We do two allocations here, unfortunately.",
        "suggest": "不幸的是，我们在这里做了两个分配。",
        "translate": ""
    },
    {
        "source": "But (a) they're required with the current scheme, and (b) we don't handle panic + OOM properly anyway (see comment in begin_panic below).",
        "suggest": "但是 (a) 是当前方案所必需的，而 (b) 我们无论如何都无法正确处理 panic + OOM (请参见下面 begin_panic 中的注释)。",
        "translate": ""
    },
    {
        "source": "The current implementation always returns Some",
        "suggest": "当前的实现总是返回 Some",
        "translate": ""
    },
    {
        "source": "This is the entry point of panicking for the non-format-string variants of panic!() and assert!().",
        "suggest": "这是 panic! () 和 assert! () 的非格式字符串成员恐慌的入口点。",
        "translate": ""
    },
    {
        "source": "In particular, this is the only entry point that supports arbitrary payloads, not just format strings.",
        "suggest": "特别是，这是唯一支持任意有效载荷的入口点，而不仅仅是格式字符串。",
        "translate": ""
    },
    {
        "source": "lang item for CTFE panic support never inline unless panic_immediate_abort to avoid code bloat at the call sites as much as possible",
        "suggest": "除非 panic_immediate_abort 尽可能避免调用站点上的代码膨胀，否则 CTFE panic 支持的 lang 项永远不会内联",
        "translate": ""
    },
    {
        "source": "Note that this should be the only allocation performed in this code path.",
        "suggest": "请注意，这应该是在此代码路径中执行的唯一分配。",
        "translate": ""
    },
    {
        "source": "Currently this means that panic!() on OOM will invoke this code path, but then again we're not really ready for panic on OOM anyway.",
        "suggest": "当前，这意味着 OOM 上的 panic! () 将调用此代码路径，但是无论如何，我们仍然没有真正为 OOM 上的 panic 做好准备。",
        "translate": ""
    },
    {
        "source": "If we do start doing this, then we should propagate this allocation to be performed in the parent of this thread instead of the thread that's panicking.",
        "suggest": "如果确实开始执行此操作，则应将此分配传播给要在此线程的父级中执行，而不是在发生 panic 的线程中执行。",
        "translate": ""
    },
    {
        "source": "Central point for dispatching panics.",
        "suggest": "调度 panics 的中心点。",
        "translate": ""
    },
    {
        "source": "Executes the primary logic for a panic, including checking for recursive panics, panic hooks, and finally dispatching to the panic runtime to either abort or unwind.",
        "suggest": "执行 panic 的主要逻辑，包括检查递归 panics，panic hooks，最后将其分发到 panic 运行时以终止或 unwind。",
        "translate": ""
    },
    {
        "source": "If this is the third nested call (e.g., panics == 2, this is 0-indexed), the panic hook probably triggered the last panic, otherwise the double-panic check would have aborted the process.",
        "suggest": "如果这是第三个嵌套调用 (例如 panics == 2，则为 0 索引)，则 panic hook 可能触发了最后一个 panic，否则，两次 panic 检查将中止该进程。",
        "translate": ""
    },
    {
        "source": "In this case abort the process real quickly as we don't want to try calling it again as it'll probably just panic again.",
        "suggest": "在这种情况下，请尽快终止进程，因为我们不想再次调用它，因为它可能只是 panic。",
        "translate": ""
    },
    {
        "source": "Some platforms (like wasm) know that printing to stderr won't ever actually print anything, and if that's the case we can skip the default hook.",
        "suggest": "一些平台 (例如 wasm) 知道打印到 stderr 实际上不会打印任何内容，如果是这种情况，我们可以跳过默认的 hook。",
        "translate": ""
    },
    {
        "source": "Since string formatting happens lazily when calling `payload` methods, this means we avoid formatting the string at all!",
        "suggest": "由于调用 `payload` 方法时字符串格式化的发生比较懒惰，因此这意味着我们完全避免格式化字符串!",
        "translate": ""
    },
    {
        "source": "(The panic runtime might still call `payload.take_box()` though and trigger formatting.)",
        "suggest": "(尽管 panic 运行时可能仍然调用 `payload.take_box()` 并触发格式化。)",
        "translate": ""
    },
    {
        "source": "If a thread panics while it's already unwinding then we have limited options.",
        "suggest": "如果线程 panics 已经展开，则我们的选择有限。",
        "translate": ""
    },
    {
        "source": "Currently our preference is to just abort.",
        "suggest": "当前，我们的首选是终止。",
        "translate": ""
    },
    {
        "source": "In the future we may consider resuming unwinding or otherwise exiting the thread cleanly.",
        "suggest": "在 future 中，我们可以考虑恢复展开或以其他方式干净退出线程。",
        "translate": ""
    },
    {
        "source": "This is the entry point for `resume_unwind`.",
        "suggest": "这是 `resume_unwind` 的入口点。",
        "translate": ""
    },
    {
        "source": "It just forwards the payload to the panic runtime.",
        "suggest": "它只是将有效负载转发到 panic 运行时。",
        "translate": ""
    },
    {
        "source": "An unmangled function (through `rustc_std_internal_symbol`) on which to slap yer breakpoints.",
        "suggest": "一个无残缺的函数 (通过 `rustc_std_internal_symbol`)，可以在其上施加断点。",
        "translate": ""
    },
    {
        "source": "Forward iteration",
        "suggest": "正向迭代",
        "translate": ""
    },
    {
        "source": "Reverse iteration",
        "suggest": "反向迭代",
        "translate": ""
    },
    {
        "source": "modified from old path API",
        "suggest": "从旧路径 API 修改",
        "translate": ""
    },
    {
        "source": "again, not sure about the following, but I'm assuming \\\\.\\ should be verbatim",
        "suggest": "同样，不确定以下内容，但我假设 \\\\。\\ 应该是逐字记录",
        "translate": ""
    },
    {
        "source": "this is a weird one",
        "suggest": "这是一个奇怪的",
        "translate": ""
    },
    {
        "source": "This way works...",
        "suggest": "这种方式有效...",
        "translate": ""
    },
    {
        "source": "but push is best used if you don't know everything up front.",
        "suggest": "但是如果您不了解所有内容，则最好使用推送。",
        "translate": ""
    },
    {
        "source": "If you do, this way is better:",
        "suggest": "如果您这样做，则这种方法更好:",
        "translate": ""
    },
    {
        "source": "works for both Unix and Windows",
        "suggest": "适用于 Unix 和 Windows",
        "translate": ""
    },
    {
        "source": "this example does work on Windows",
        "suggest": "这个例子可以在 Windows 上使用",
        "translate": ""
    },
    {
        "source": "extra slash is okay",
        "suggest": "额外的斜线是可以的",
        "translate": ""
    },
    {
        "source": "use .extension() instead",
        "suggest": "改用 .extension()",
        "translate": ""
    },
    {
        "source": "Cross-platform path manipulation.",
        "suggest": "跨平台路径操纵。",
        "translate": ""
    },
    {
        "source": "This module provides two types, [`PathBuf`] and [`Path`] (akin to [`String`] and [`str`]), for working with paths abstractly.",
        "suggest": "该模块提供两种类型，即 [`PathBuf`] 和 [`Path`] (类似于 [`String`] 和 [`str`])，用于抽象地处理路径。",
        "translate": ""
    },
    {
        "source": "These types are thin wrappers around [`OsString`] and [`OsStr`] respectively, meaning that they work directly on strings according to the local platform's path syntax.",
        "suggest": "这些类型分别是围绕 [`OsString`] 和 [`OsStr`] 的薄包装器，这意味着它们根据本地平台的路径语法直接在字符串上工作。",
        "translate": ""
    },
    {
        "source": "Paths can be parsed into [`Component`]s by iterating over the structure returned by the [`components`] method on [`Path`].",
        "suggest": "通过遍历 [`Path`] 上 [`components`] 方法返回的结构体，可以将路径解析为 [`Component`]。",
        "translate": ""
    },
    {
        "source": "[`Component`]s roughly correspond to the substrings between path separators (`/` or `\\`).",
        "suggest": "[`Component`] 大致对应于路径分隔符 (`/` 或 `\\`) 之间的子字符串。",
        "translate": ""
    },
    {
        "source": "You can reconstruct an equivalent path from components with the [`push`] method on [`PathBuf`];",
        "suggest": "您可以使用 [`PathBuf`] 上的 [`push`] 方法从组件重建等效路径;",
        "translate": ""
    },
    {
        "source": "note that the paths may differ syntactically by the normalization described in the documentation for the [`components`] method.",
        "suggest": "请注意，根据 [`components`] 方法文档中描述的规范化，路径可能在语法上有所不同。",
        "translate": ""
    },
    {
        "source": "Simple usage",
        "suggest": "使用简单",
        "translate": ""
    },
    {
        "source": "Path manipulation includes both parsing components from slices and building new owned paths.",
        "suggest": "路径操作既包括从切片中解析组件，也包括构建新的拥有的路径。",
        "translate": ""
    },
    {
        "source": "To parse a path, you can create a [`Path`] slice from a [`str`] slice and start asking questions:",
        "suggest": "要解析路径，您可以从 [`str`] 切片创建 [`Path`] 切片并开始提出问题:",
        "translate": ""
    },
    {
        "source": "To build or modify paths, use [`PathBuf`]:",
        "suggest": "要构建或修改路径，请使用 [`PathBuf`]:",
        "translate": ""
    },
    {
        "source": "GENERAL NOTES",
        "suggest": "一般注意事项",
        "translate": ""
    },
    {
        "source": "Parsing in this module is done by directly transmuting OsStr to [u8] slices, taking advantage of the fact that OsStr always encodes ASCII characters as-is.",
        "suggest": "利用 OsStr 始终按原样编码 ASCII 字符这一事实，可以通过将 OsStr 直接转换为 [u8] slice 来完成此模块中的解析。",
        "translate": ""
    },
    {
        "source": "Eventually, this transmutation should be replaced by direct uses of OsStr APIs for parsing, but it will take a while for those to become available.",
        "suggest": "最终，应使用直接使用 OsStr API 进行解析来代替这种转换，但是要使这些转换可用需要一些时间。",
        "translate": ""
    },
    {
        "source": "path prefixes, e.g., `C:` or `\\\\server\\share`.",
        "suggest": "路径前缀，例如 `C:` 或 `\\\\server\\share`。",
        "translate": ""
    },
    {
        "source": "uses a variety of path prefix styles, including references to drive volumes (like `C:`), network shared folders (like `\\\\server\\share`), and others.",
        "suggest": "使用各种路径前缀样式，包括引用来驱动卷 (例如 `C:`)，网络共享文件夹 (例如 `\\\\server\\share`) 以及其他。",
        "translate": ""
    },
    {
        "source": "In addition, some path prefixes are \"verbatim\" (i.e., prefixed with `\\\\?\\`), in which case `/` is *not* treated as a separator and essentially no normalization is performed.",
        "suggest": "另外，某些路径前缀是 \"verbatim\" (即以 `\\\\?\\` 前缀)，在这种情况下，*不* 将 `/` 视为分隔符，并且基本上不执行规范化。",
        "translate": ""
    },
    {
        "source": "Verbatim prefix, e.g.,",
        "suggest": "逐字前缀，例如",
        "translate": ""
    },
    {
        "source": "Verbatim prefixes consist of `\\\\?\\` immediately followed by the given component.",
        "suggest": "逐字前缀由 `\\\\?\\` 组成，紧随其后是给定的组件。",
        "translate": ""
    },
    {
        "source": "Verbatim prefix using Windows' _**U**niform **N**aming **C**onvention_, e.g.,",
        "suggest": "使用 Windows 的 _**U** niform **N** aming **C** onvention_ 的逐字前缀，例如，",
        "translate": ""
    },
    {
        "source": "Verbatim UNC prefixes consist of `\\\\?\\UNC\\` immediately followed by the server's hostname and a share name.",
        "suggest": "Verbatim UNC 前缀由 `\\\\?\\UNC\\` 组成，其后紧跟服务器的主机名和共享名。",
        "translate": ""
    },
    {
        "source": "Verbatim disk prefix, e.g.,",
        "suggest": "逐字磁盘前缀，例如，",
        "translate": ""
    },
    {
        "source": "Verbatim disk prefixes consist of `\\\\?\\` immediately followed by the drive letter and `:`.",
        "suggest": "逐字磁盘前缀由 `\\\\?\\` 紧随其后的驱动器号和 `:` 组成。",
        "translate": ""
    },
    {
        "source": "Device namespace prefix, e.g.,",
        "suggest": "设备名称空间前缀，例如",
        "translate": ""
    },
    {
        "source": "Device namespace prefixes consist of `\\\\.\\` immediately followed by the device name.",
        "suggest": "设备名称空间前缀由 `\\\\.\\` 紧随其后的设备名称组成。",
        "translate": ""
    },
    {
        "source": "Prefix using Windows' _**U**niform **N**aming **C**onvention_, e.g.",
        "suggest": "使用 Windows 的 _**U** niform **N** aming **C** onvention_ 的前缀，例如",
        "translate": ""
    },
    {
        "source": "UNC prefixes consist of the server's hostname and a share name.",
        "suggest": "UNC 前缀由服务器的主机名和共享名组成。",
        "translate": ""
    },
    {
        "source": "Prefix `C:` for the given disk drive.",
        "suggest": "给定磁盘驱动器的前缀 `C:`。",
        "translate": ""
    },
    {
        "source": "Determines if the prefix is verbatim, i.e., begins with `\\\\?\\`.",
        "suggest": "确定前缀是否为逐字形式，即以 `\\\\?\\` 开头。",
        "translate": ""
    },
    {
        "source": "Exposed parsing helpers",
        "suggest": "公开的解析助手",
        "translate": ""
    },
    {
        "source": "Determines whether the character is one of the permitted path separators for the current platform.",
        "suggest": "确定字符是否为当前平台允许的路径分隔符之一。",
        "translate": ""
    },
    {
        "source": "The primary separator of path components for the current platform.",
        "suggest": "当前平台的路径组件的主要分隔符。",
        "translate": ""
    },
    {
        "source": "For example, `/` on Unix and `\\` on Windows.",
        "suggest": "例如，Unix 上的 `/` 和 Windows 上的 `\\`。",
        "translate": ""
    },
    {
        "source": "Misc helpers",
        "suggest": "杂项帮手",
        "translate": ""
    },
    {
        "source": "Iterate through `iter` while it matches `prefix`;",
        "suggest": "与 `prefix` 匹配时遍历 `iter`;",
        "translate": ""
    },
    {
        "source": "return `None` if `prefix` is not a prefix of `iter`, otherwise return `Some(iter_after_prefix)` giving `iter` after having exhausted `prefix`.",
        "suggest": "如果 `prefix` 不是 `iter` 的前缀，则返回 `None`; 否则，在用完 `prefix` 后返回 `Some(iter_after_prefix)`，得到 `iter`。",
        "translate": ""
    },
    {
        "source": "See note at the top of this module to understand why these are used:",
        "suggest": "请参见本模块顶部的说明以了解为什么使用它们:",
        "translate": ""
    },
    {
        "source": "These casts are safe as OsStr is internally a wrapper around [u8] on all platforms.",
        "suggest": "这些强制转换是安全的，因为 OsStr 在内部是所有平台上 [u8] 的包装。",
        "translate": ""
    },
    {
        "source": "Note that currently this relies on the special knowledge that libstd has;",
        "suggest": "请注意，当前这依赖于 libstd 拥有的特殊知识。",
        "translate": ""
    },
    {
        "source": "these types are single-element structs but are not marked repr(transparent) or repr(C) which would make these casts allowable outside std.",
        "suggest": "这些类型是单一元素结构体，但未标记为 repr(transparent) 或 repr(C)，这会使这些转换在 std 之外是允许的。",
        "translate": ""
    },
    {
        "source": "see the comment of `os_str_as_u8_slice`",
        "suggest": "查看 `os_str_as_u8_slice` 的评论",
        "translate": ""
    },
    {
        "source": "Detect scheme on Redox",
        "suggest": "`Redox` 检测方案",
        "translate": ""
    },
    {
        "source": "Cross-platform, iterator-independent parsing",
        "suggest": "跨平台，独立于迭代器的解析",
        "translate": ""
    },
    {
        "source": "Says whether the first byte after the prefix is a separator.",
        "suggest": "说前缀之后的第一个字节是否为分隔符。",
        "translate": ""
    },
    {
        "source": "basic workhorse for splitting stem and extension",
        "suggest": "分裂茎和伸展的基本力量",
        "translate": ""
    },
    {
        "source": "The unsafety here stems from converting between &OsStr and &[u8] and back.",
        "suggest": "这里的不安全性源于 &OsStr 和 &[u8] and 之间的转换。",
        "translate": ""
    },
    {
        "source": "This is safe to do because (1) we only look at ASCII contents of the encoding and (2) new &OsStr values are produced only from ASCII-bounded slices of existing &OsStr values.",
        "suggest": "这样做是安全的，因为 (1) 我们仅查看编码的 ASCII 内容，而 (2) 新的 &OsStr 值仅从现有 &OsStr values 的 ASCII 限制切片中产生。",
        "translate": ""
    },
    {
        "source": "The core iterators",
        "suggest": "core 迭代器",
        "translate": ""
    },
    {
        "source": "Component parsing works by a double-ended state machine;",
        "suggest": "组件解析由双端状态机完成;",
        "translate": ""
    },
    {
        "source": "the cursors at the front and back of the path each keep track of what parts of the path have been consumed so far.",
        "suggest": "路径前面和后面的游标都记录了到目前为止路径的哪些部分被消耗了。",
        "translate": ""
    },
    {
        "source": "Going front to back, a path is made up of a prefix, a starting directory component, and a body (of normal components)",
        "suggest": "从前到后，路径由前缀，起始目录组件和主体组成 (由常规组件组成)",
        "translate": ""
    },
    {
        "source": "or . or nothing",
        "suggest": "或者。或者什么都没有",
        "translate": ""
    },
    {
        "source": "A structure wrapping a Windows path prefix as well as its unparsed string representation.",
        "suggest": "包裹 Windows 路径前缀及其未解析的字符串表示形式的结构体。",
        "translate": ""
    },
    {
        "source": "In addition to the parsed [`Prefix`] information returned by [`kind`], `PrefixComponent` also holds the raw and unparsed [`OsStr`] slice, returned by [`as_os_str`].",
        "suggest": "除了由 [`kind`] 返回的已解析 [`Prefix`] 信息外，`PrefixComponent` 还保存由 [`as_os_str`] 返回的原始和未解析的 [`OsStr`] 切片。",
        "translate": ""
    },
    {
        "source": "Instances of this `struct` can be obtained by matching against the [`Prefix` variant] on [`Component`].",
        "suggest": "可以通过与 [`Component`] 上的 [`Prefix` variant] 匹配来获得此 `struct` 的实例。",
        "translate": ""
    },
    {
        "source": "Does not occur on Unix.",
        "suggest": "在 Unix 上不会发生。",
        "translate": ""
    },
    {
        "source": "The prefix as an unparsed `OsStr` slice.",
        "suggest": "前缀为未解析的 `OsStr` 切片。",
        "translate": ""
    },
    {
        "source": "The parsed prefix data.",
        "suggest": "解析的前缀数据。",
        "translate": ""
    },
    {
        "source": "Returns the parsed prefix data.",
        "suggest": "返回已解析的前缀数据。",
        "translate": ""
    },
    {
        "source": "See [`Prefix`]'s documentation for more information on the different kinds of prefixes.",
        "suggest": "有关不同种类的前缀的更多信息，请参见 [`Prefix`] 的文档。",
        "translate": ""
    },
    {
        "source": "Returns the raw [`OsStr`] slice for this prefix.",
        "suggest": "返回此前缀的原始 [`OsStr`] 切片。",
        "translate": ""
    },
    {
        "source": "A single component of a path.",
        "suggest": "路径的单个组成部分。",
        "translate": ""
    },
    {
        "source": "A `Component` roughly corresponds to a substring between path separators (`/` or `\\`).",
        "suggest": "`Component` 大致对应于路径分隔符 (`/` 或 `\\`) 之间的子字符串。",
        "translate": ""
    },
    {
        "source": "This `enum` is created by iterating over [`Components`], which in turn is created by the [`components`](Path::components) method on [`Path`].",
        "suggest": "该 `enum` 是通过迭代 [`Components`] 来创建的，而 [`Components`] 又是通过 [`Path`] 上的 [`components`](Path::components) 方法创建的。",
        "translate": ""
    },
    {
        "source": "A Windows path prefix, e.g., `C:` or `\\\\server\\share`.",
        "suggest": "Windows 路径前缀，例如 `C:` 或 `\\\\server\\share`。",
        "translate": ""
    },
    {
        "source": "There is a large variety of prefix types, see [`Prefix`]'s documentation for more.",
        "suggest": "前缀类型种类繁多，有关更多信息，请参见 [`Prefix`] 的文档。",
        "translate": ""
    },
    {
        "source": "The root directory component, appears after any prefix and before anything else.",
        "suggest": "根目录组件出现在任何前缀之后和其他任何内容之前。",
        "translate": ""
    },
    {
        "source": "It represents a separator that designates that a path starts from root.",
        "suggest": "它代表一个分隔符，它指定路径从根开始。",
        "translate": ""
    },
    {
        "source": "A reference to the current directory, i.e.,",
        "suggest": "对当前目录的引用，即",
        "translate": ""
    },
    {
        "source": "A reference to the parent directory, i.e.,",
        "suggest": "对父目录的引用，即",
        "translate": ""
    },
    {
        "source": "A normal component, e.g., `a` and `b` in `a/b`.",
        "suggest": "正常组件，例如 `a/b` 中的 `a` 和 `b`。",
        "translate": ""
    },
    {
        "source": "This variant is the most common one, it represents references to files or directories.",
        "suggest": "这个成员是最常见的一个，它代表对文件或目录的引用。",
        "translate": ""
    },
    {
        "source": "Extracts the underlying [`OsStr`] slice.",
        "suggest": "提取基础的 [`OsStr`] 切片。",
        "translate": ""
    },
    {
        "source": "An iterator over the [`Component`]s of a [`Path`].",
        "suggest": "[`Path`] 的 [`Component`] 上的迭代器。",
        "translate": ""
    },
    {
        "source": "This `struct` is created by the [`components`] method on [`Path`].",
        "suggest": "该 `struct` 是通过 [`Path`] 上的 [`components`] 方法创建的。",
        "translate": ""
    },
    {
        "source": "The path left to parse components from",
        "suggest": "解析组件所剩下的路径",
        "translate": ""
    },
    {
        "source": "The prefix as it was originally parsed, if any",
        "suggest": "最初解析的前缀 (如果有)",
        "translate": ""
    },
    {
        "source": "true if path *physically* has a root separator;",
        "suggest": "如果 path *物理* 具有根分隔符，则为 true; 否则为 true。",
        "translate": ""
    },
    {
        "source": "for most Windows prefixes, it may have a \"logical\" rootseparator for the purposes of normalization, e.g.,  \\\\server\\share == \\\\server\\share\\.",
        "suggest": "对于大多数 Windows 前缀，出于标准化的目的，它可能具有 \"logical\" 根分隔符，例如 \\\\server\\share == \\\\server\\share\\。",
        "translate": ""
    },
    {
        "source": "The iterator is double-ended, and these two states keep track of what has been produced from either end",
        "suggest": "迭代器是双端的，这两个状态跟踪从两端产生的结果",
        "translate": ""
    },
    {
        "source": "An iterator over the [`Component`]s of a [`Path`], as [`OsStr`] slices.",
        "suggest": "[`Path`] 的 [`Component`] 上的迭代器，作为 [`OsStr`] 切片。",
        "translate": ""
    },
    {
        "source": "This `struct` is created by the [`iter`] method on [`Path`].",
        "suggest": "该 `struct` 是通过 [`Path`] 上的 [`iter`] 方法创建的。",
        "translate": ""
    },
    {
        "source": "how long is the prefix, if any?",
        "suggest": "前缀多长时间 (如果有) ?",
        "translate": ""
    },
    {
        "source": "how much of the prefix is left from the point of view of iteration?",
        "suggest": "从迭代的角度来看，还剩下多少前缀?",
        "translate": ""
    },
    {
        "source": "Given the iteration so far, how much of the pre-State::Body path is left?",
        "suggest": "给定到目前为止的迭代，还剩下多少 pre-State::Body 路径?",
        "translate": ""
    },
    {
        "source": "is the iteration complete?",
        "suggest": "迭代完成了吗?",
        "translate": ""
    },
    {
        "source": "Extracts a slice corresponding to the portion of the path remaining for iteration.",
        "suggest": "提取与迭代剩余路径部分相对应的切片。",
        "translate": ""
    },
    {
        "source": "Is the *original* path rooted?",
        "suggest": "*原始* 路径是否扎根?",
        "translate": ""
    },
    {
        "source": "Should the normalized path include a leading . ?",
        "suggest": "规范化路径是否应包含前导。?",
        "translate": ""
    },
    {
        "source": "parse a given byte sequence into the corresponding path component",
        "suggest": "将给定的字节序列解析为相应的路径组件",
        "translate": ""
    },
    {
        "source": "the beginning of a path, which is treated separately via `include_cur_dir`",
        "suggest": "路径的开始，通过 `include_cur_dir` 进行单独处理",
        "translate": ""
    },
    {
        "source": "parse a component from the left, saying how many bytes to consume to remove the component",
        "suggest": "从左侧解析一个组件，说出删除该组件要消耗多少字节",
        "translate": ""
    },
    {
        "source": "parse a component from the right, saying how many bytes to consume to remove the component",
        "suggest": "从右边解析一个组件，说出删除该组件要消耗多少字节",
        "translate": ""
    },
    {
        "source": "trim away repeated separators (i.e., empty components) on the left",
        "suggest": "在左侧修剪掉重复的分隔符 (即空组件)",
        "translate": ""
    },
    {
        "source": "trim away repeated separators (i.e., empty components) on the right",
        "suggest": "在右侧修剪掉重复的分隔符 (即空组件)",
        "translate": ""
    },
    {
        "source": "An iterator over [`Path`] and its ancestors.",
        "suggest": "[`Path`] 及其祖先上的迭代器。",
        "translate": ""
    },
    {
        "source": "This `struct` is created by the [`ancestors`] method on [`Path`].",
        "suggest": "该 `struct` 是通过 [`Path`] 上的 [`ancestors`] 方法创建的。",
        "translate": ""
    },
    {
        "source": "Basic types and traits",
        "suggest": "基本类型和 traits",
        "translate": ""
    },
    {
        "source": "An owned, mutable path (akin to [`String`]).",
        "suggest": "拥有的可变路径 (类似于 [`String`])。",
        "translate": ""
    },
    {
        "source": "This type provides methods like [`push`] and [`set_extension`] that mutate the path in place.",
        "suggest": "这种类型提供了 [`push`] 和 [`set_extension`] 之类的方法，这些方法会改变路径。",
        "translate": ""
    },
    {
        "source": "It also implements [`Deref`] to [`Path`], meaning that all methods on [`Path`] slices are available on `PathBuf` values as well.",
        "suggest": "它还实现了 [`Deref`] 到 [`Path`]，这意味着 [`Path`] 切片上的所有方法也可以在 `PathBuf` 值上使用。",
        "translate": ""
    },
    {
        "source": "More details about the overall approach can be found in the [module documentation](self).",
        "suggest": "有关整体方法的更多详细信息，请参见 [module documentation](self)。",
        "translate": ""
    },
    {
        "source": "You can use [`push`] to build up a `PathBuf` from components:",
        "suggest": "您可以使用 [`push`] 从组件构建 `PathBuf`:",
        "translate": ""
    },
    {
        "source": "However, [`push`] is best used for dynamic situations.",
        "suggest": "但是，[`push`] 最适合用于动态情况。",
        "translate": ""
    },
    {
        "source": "This is a better way to do this when you know all of the components ahead of time:",
        "suggest": "当您提前了解所有组件时，这是一种更好的方法:",
        "translate": ""
    },
    {
        "source": "We can still do better than this!",
        "suggest": "我们仍然可以做得更好!",
        "translate": ""
    },
    {
        "source": "Since these are all strings, we can use",
        "suggest": "由于这些都是字符串，因此我们可以使用",
        "translate": ""
    },
    {
        "source": "Which method works best depends on what kind of situation you're in.",
        "suggest": "哪种方法最有效取决于您所处的情况。",
        "translate": ""
    },
    {
        "source": "current implementation relies on `PathBuf` being layout-compatible with `Vec<u8>`.",
        "suggest": "当前的实现依赖于 `PathBuf` 与 `Vec<u8>` 在布局上兼容。",
        "translate": ""
    },
    {
        "source": "When attribute privacy is implemented, `PathBuf` should be annotated as `#[repr(transparent)]`.",
        "suggest": "实现属性隐私时，应将 `PathBuf` 注解为 `#[repr(transparent)]`。",
        "translate": ""
    },
    {
        "source": "Anyway, `PathBuf` representation and layout are considered implementation detail, are not documented and must not be relied upon.",
        "suggest": "无论如何，`PathBuf` 表示形式和布局被视为实现细节，没有文档记录，因此不能依赖。",
        "translate": ""
    },
    {
        "source": "Allocates an empty `PathBuf`.",
        "suggest": "分配一个空的 `PathBuf`。",
        "translate": ""
    },
    {
        "source": "Creates a new `PathBuf` with a given capacity used to create the internal [`OsString`].",
        "suggest": "创建具有给定容量的新 `PathBuf`，用于创建内部 [`OsString`]。",
        "translate": ""
    },
    {
        "source": "See [`with_capacity`] defined on [`OsString`].",
        "suggest": "请参见在 [`OsString`] 上定义的 [`with_capacity`]。",
        "translate": ""
    },
    {
        "source": "Coerces to a [`Path`] slice.",
        "suggest": "强制转换为 [`Path`] 切片。",
        "translate": ""
    },
    {
        "source": "Extends `self` with `path`.",
        "suggest": "用 `path` 扩展 `self`。",
        "translate": ""
    },
    {
        "source": "If `path` is absolute, it replaces the current path.",
        "suggest": "如果 `path` 是绝对路径，它将替换当前路径。",
        "translate": ""
    },
    {
        "source": "if `path` has a root but no prefix (e.g., `\\windows`), it replaces everything except for the prefix (if any) of `self`.",
        "suggest": "如果 `path` 具有根但没有前缀 (例如 `\\windows`)，它将替换 `self` 的前缀 (如果有) 之外的所有内容。",
        "translate": ""
    },
    {
        "source": "if `path` has a prefix but no root, it replaces `self`.",
        "suggest": "如果 `path` 有前缀但没有根，它将替换 `self`。",
        "translate": ""
    },
    {
        "source": "Pushing a relative path extends the existing path:",
        "suggest": "推动相对路径可扩展现有路径:",
        "translate": ""
    },
    {
        "source": "Pushing an absolute path replaces the existing path:",
        "suggest": "推送绝对路径将替换现有路径:",
        "translate": ""
    },
    {
        "source": "in general, a separator is needed if the rightmost byte is not a separator",
        "suggest": "通常，如果最右边的字节不是分隔符，则需要分隔符",
        "translate": ""
    },
    {
        "source": "in the special case of `C:` on Windows, do *not* add a separator",
        "suggest": "在 Windows 上的 `C:` 的特殊情况下，请 *不要* 添加分隔符",
        "translate": ""
    },
    {
        "source": "absolute `path` replaces `self`",
        "suggest": "绝对 `path` 替代 `self`",
        "translate": ""
    },
    {
        "source": "has a root but no prefix, e.g., `\\windows` (Windows only)",
        "suggest": "具有根但没有前缀，例如 `\\windows` (仅 Windows)",
        "translate": ""
    },
    {
        "source": "is a pure relative path",
        "suggest": "是一条纯粹的相对路径",
        "translate": ""
    },
    {
        "source": "Truncates `self` to [`self.parent`].",
        "suggest": "将 `self` 截断为 [`self.parent`]。",
        "translate": ""
    },
    {
        "source": "Returns `false` and does nothing if [`self.parent`] is [`None`].",
        "suggest": "返回 `false`，如果 [`self.parent`] 为 [`None`]，则不执行任何操作。",
        "translate": ""
    },
    {
        "source": "Otherwise, returns `true`.",
        "suggest": "否则，返回 `true`。",
        "translate": ""
    },
    {
        "source": "Updates [`self.file_name`] to `file_name`.",
        "suggest": "将 [`self.file_name`] 更新为 `file_name`。",
        "translate": ""
    },
    {
        "source": "If [`self.file_name`] was [`None`], this is equivalent to pushing `file_name`.",
        "suggest": "如果 [`self.file_name`] 是 [`None`]，则等效于按下 `file_name`。",
        "translate": ""
    },
    {
        "source": "Otherwise it is equivalent to calling [`pop`] and then pushing `file_name`.",
        "suggest": "否则，这等效于调用 [`pop`]，然后按 `file_name`。",
        "translate": ""
    },
    {
        "source": "The new path will be a sibling of the original path.",
        "suggest": "新路径将是原始路径的同级。",
        "translate": ""
    },
    {
        "source": "(That is, it will have the same parent.)",
        "suggest": "(也就是说，它将具有相同的父对象。)",
        "translate": ""
    },
    {
        "source": "Updates [`self.extension`] to `extension`.",
        "suggest": "将 [`self.extension`] 更新为 `extension`。",
        "translate": ""
    },
    {
        "source": "Returns `false` and does nothing if [`self.file_name`] is [`None`], returns `true` and updates the extension otherwise.",
        "suggest": "返回 `false`，如果 [`self.file_name`] 为 [`None`]，则不执行任何操作，否则返回 `true`，并更新扩展名。",
        "translate": ""
    },
    {
        "source": "If [`self.extension`] is [`None`], the extension is added;",
        "suggest": "如果 [`self.extension`] 为 [`None`]，则添加扩展名;",
        "translate": ""
    },
    {
        "source": "otherwise it is replaced.",
        "suggest": "否则将被替换。",
        "translate": ""
    },
    {
        "source": "truncate until right after the file stem",
        "suggest": "截断直到文件干之后",
        "translate": ""
    },
    {
        "source": "add the new extension, if any",
        "suggest": "添加新的扩展名 (如果有)",
        "translate": ""
    },
    {
        "source": "Consumes the `PathBuf`, yielding its internal [`OsString`] storage.",
        "suggest": "消耗 `PathBuf`，产生其内部 [`OsString`] 存储。",
        "translate": ""
    },
    {
        "source": "Converts this `PathBuf` into a [boxed](Box) [`Path`].",
        "suggest": "将此 `PathBuf` 转换为 [boxed](Box) [`Path`]。",
        "translate": ""
    },
    {
        "source": "Invokes [`capacity`] on the underlying instance of [`OsString`].",
        "suggest": "在 [`OsString`] 的基础实例上调用 [`capacity`]。",
        "translate": ""
    },
    {
        "source": "Invokes [`clear`] on the underlying instance of [`OsString`].",
        "suggest": "在 [`OsString`] 的基础实例上调用 [`clear`]。",
        "translate": ""
    },
    {
        "source": "Invokes [`reserve`] on the underlying instance of [`OsString`].",
        "suggest": "在 [`OsString`] 的基础实例上调用 [`reserve`]。",
        "translate": ""
    },
    {
        "source": "Invokes [`reserve_exact`] on the underlying instance of [`OsString`].",
        "suggest": "在 [`OsString`] 的基础实例上调用 [`reserve_exact`]。",
        "translate": ""
    },
    {
        "source": "Invokes [`shrink_to_fit`] on the underlying instance of [`OsString`].",
        "suggest": "在 [`OsString`] 的基础实例上调用 [`shrink_to_fit`]。",
        "translate": ""
    },
    {
        "source": "Invokes [`shrink_to`] on the underlying instance of [`OsString`].",
        "suggest": "在 [`OsString`] 的基础实例上调用 [`shrink_to`]。",
        "translate": ""
    },
    {
        "source": "Converts a `Box<Path>` into a `PathBuf`",
        "suggest": "将 `Box<Path>` 转换为 `PathBuf`",
        "translate": ""
    },
    {
        "source": "This conversion does not allocate or copy memory.",
        "suggest": "此转换不会分配或复制内存。",
        "translate": ""
    },
    {
        "source": "Converts a `PathBuf` into a `Box<Path>`",
        "suggest": "将 `PathBuf` 转换为 `Box<Path>`",
        "translate": ""
    },
    {
        "source": "This conversion currently should not allocate memory, but this behavior is not guaranteed on all platforms or in all future versions.",
        "suggest": "此转换当前不应该分配内存，但是不能在所有平台上或所有 future 版本中都保证此行为。",
        "translate": ""
    },
    {
        "source": "Converts a `OsString` into a `PathBuf`",
        "suggest": "将 `OsString` 转换为 `PathBuf`",
        "translate": ""
    },
    {
        "source": "Converts a `PathBuf` into a `OsString`",
        "suggest": "将 `PathBuf` 转换为 `OsString`",
        "translate": ""
    },
    {
        "source": "Converts a `String` into a `PathBuf`",
        "suggest": "将 `String` 转换为 `PathBuf`",
        "translate": ""
    },
    {
        "source": "Converts a `PathBuf` into an `Arc` by moving the `PathBuf` data into a new `Arc` buffer.",
        "suggest": "通过将 `PathBuf` 数据移动到新的 `Arc` 缓冲区中，将 `PathBuf` 转换为 `Arc`。",
        "translate": ""
    },
    {
        "source": "Converts a `Path` into an `Arc` by copying the `Path` data into a new `Arc` buffer.",
        "suggest": "通过将 `Path` 数据复制到新的 `Arc` 缓冲区中，将 `Path` 转换为 `Arc`。",
        "translate": ""
    },
    {
        "source": "Converts a `PathBuf` into an `Rc` by moving the `PathBuf` data into a new `Rc` buffer.",
        "suggest": "通过将 `PathBuf` 数据移动到新的 `Rc` 缓冲区中，将 `PathBuf` 转换为 `Rc`。",
        "translate": ""
    },
    {
        "source": "Converts a `Path` into an `Rc` by copying the `Path` data into a new `Rc` buffer.",
        "suggest": "通过将 `Path` 数据复制到新的 `Rc` 缓冲区中，将 `Path` 转换为 `Rc`。",
        "translate": ""
    },
    {
        "source": "A slice of a path (akin to [`str`]).",
        "suggest": "路径的切片 (类似于 [`str`])。",
        "translate": ""
    },
    {
        "source": "This type supports a number of operations for inspecting a path, including breaking the path into its components (separated by `/` on Unix and by either `/` or `\\` on Windows), extracting the file name, determining whether the path is absolute, and so on.",
        "suggest": "此类型支持许多检查路径的操作，包括将路径分为其各个组成部分 (由 Unix 上的 `/` 和 Windows 上的 `/` 或 `\\` 分隔)，提取文件名，确定路径是否为绝对路径，等等。。",
        "translate": ""
    },
    {
        "source": "This is an *unsized* type, meaning that it must always be used behind a pointer like `&` or [`Box`].",
        "suggest": "这是未定义大小的类型，表示必须始终在 `&` 或 [`Box`] 之类的指针后面使用它。",
        "translate": ""
    },
    {
        "source": "For an owned version of this type, see [`PathBuf`].",
        "suggest": "有关此类型的拥有版本，请参见 [`PathBuf`]。",
        "translate": ""
    },
    {
        "source": "current implementation relies on `Path` being layout-compatible with `OsStr`.",
        "suggest": "当前的实现依赖于 `Path` 与 `OsStr` 在布局上兼容。",
        "translate": ""
    },
    {
        "source": "When attribute privacy is implemented, `Path` should be annotated as `#[repr(transparent)]`.",
        "suggest": "实现属性隐私时，应将 `Path` 注解为 `#[repr(transparent)]`。",
        "translate": ""
    },
    {
        "source": "Anyway, `Path` representation and layout are considered implementation detail, are not documented and must not be relied upon.",
        "suggest": "无论如何，`Path` 表示形式和布局被视为实现细节，没有文档记录，因此不能依赖。",
        "translate": ""
    },
    {
        "source": "An error returned from [`Path::strip_prefix`] if the prefix was not found.",
        "suggest": "如果找不到前缀，则从 [`Path::strip_prefix`] 返回错误。",
        "translate": ""
    },
    {
        "source": "This `struct` is created by the [`strip_prefix`] method on [`Path`].",
        "suggest": "该 `struct` 是通过 [`Path`] 上的 [`strip_prefix`] 方法创建的。",
        "translate": ""
    },
    {
        "source": "The following (private!) function allows construction of a path from a u8 slice, which is only safe when it is known to follow the OsStr encoding.",
        "suggest": "以下 (private!) 函数允许从 u8 切片构造路径，仅当已知遵循 OsStr 编码时，此路径才是安全的。",
        "translate": ""
    },
    {
        "source": "The following (private!) function reveals the byte encoding used for OsStr.",
        "suggest": "以下 (private!) 函数揭示了用于 OsStr 的字节编码。",
        "translate": ""
    },
    {
        "source": "Directly wraps a string slice as a `Path` slice.",
        "suggest": "将字符串切片直接包装为 `Path` 切片。",
        "translate": ""
    },
    {
        "source": "This is a cost-free conversion.",
        "suggest": "这是一个免费的转换。",
        "translate": ""
    },
    {
        "source": "You can create `Path`s from `String`s, or even other `Path`s:",
        "suggest": "您可以从 `String` 甚至其他 `Path`s 创建 `Path`s:",
        "translate": ""
    },
    {
        "source": "Yields the underlying [`OsStr`] slice.",
        "suggest": "产生基础的 [`OsStr`] 切片。",
        "translate": ""
    },
    {
        "source": "Yields a [`&str`] slice if the `Path` is valid unicode.",
        "suggest": "如果 `Path` 是有效的 unicode，则产生 [`&str`] 切片。",
        "translate": ""
    },
    {
        "source": "Note that validation is performed because non-UTF-8 strings are perfectly valid for some OS.",
        "suggest": "请注意，执行验证是因为非 UTF-8 字符串对于某些 OS 完全有效。",
        "translate": ""
    },
    {
        "source": "Converts a `Path` to a [`Cow<str>`].",
        "suggest": "将 `Path` 转换为 [`Cow<str>`]。",
        "translate": ""
    },
    {
        "source": "Calling `to_string_lossy` on a `Path` with valid unicode:",
        "suggest": "使用有效的 Unicode 在 `Path` 上调用 `to_string_lossy`:",
        "translate": ""
    },
    {
        "source": "Had `path` contained invalid unicode, the `to_string_lossy` call might have returned `\"fo.txt\"`.",
        "suggest": "如果 `path` 包含无效的 unicode，则 `to_string_lossy` 调用可能已返回 `\"fo.txt\"`。",
        "translate": ""
    },
    {
        "source": "Converts a `Path` to an owned [`PathBuf`].",
        "suggest": "将 `Path` 转换为拥有的 [`PathBuf`]。",
        "translate": ""
    },
    {
        "source": "Returns `true` if the `Path` is absolute, i.e., if it is independent of the current directory.",
        "suggest": "如果 `Path` 是绝对的，即独立于当前目录，则返回 `true`。",
        "translate": ""
    },
    {
        "source": "On Unix, a path is absolute if it starts with the root, so `is_absolute` and [`has_root`] are equivalent.",
        "suggest": "在 Unix 上，如果路径以根开头，则它是绝对的，因此 `is_absolute` 和 [`has_root`] 是等效的。",
        "translate": ""
    },
    {
        "source": "On Windows, a path is absolute if it has a prefix and starts with the root: `c:\\windows` is absolute, while `c:temp` and `\\temp` are not.",
        "suggest": "在 Windows 上，如果路径具有前缀并以根开头，则它是绝对路径: `c:\\windows` 是绝对路径，而 `c:temp` 和 `\\temp` 不是。",
        "translate": ""
    },
    {
        "source": "Allow Redox prefixes",
        "suggest": "允许 `Redox` 前缀",
        "translate": ""
    },
    {
        "source": "Returns `true` if the `Path` is relative, i.e., not absolute.",
        "suggest": "如果 `Path` 是相对的，即不是绝对的，则返回 `true`。",
        "translate": ""
    },
    {
        "source": "See [`is_absolute`]'s documentation for more details.",
        "suggest": "有关更多详细信息，请参见 [`is_absolute`] 的文档。",
        "translate": ""
    },
    {
        "source": "Returns `true` if the `Path` has a root.",
        "suggest": "如果 `Path` 具有根，则返回 `true`。",
        "translate": ""
    },
    {
        "source": "On Unix, a path has a root if it begins with `/`.",
        "suggest": "在 Unix 上，如果路径以 `/` 开头，则该路径具有根。",
        "translate": ""
    },
    {
        "source": "On Windows, a path has a root if it:",
        "suggest": "在 Windows 上，如果路径具有根，则它是:",
        "translate": ""
    },
    {
        "source": "has no prefix and begins with a separator, e.g.,",
        "suggest": "没有前缀，并以分隔符开头，例如，",
        "translate": ""
    },
    {
        "source": "has a prefix followed by a separator, e.g., `c:\\windows` but not `c:windows`",
        "suggest": "有一个前缀，后跟一个分隔符，例如 `c:\\windows`，但没有 `c:windows`",
        "translate": ""
    },
    {
        "source": "has any non-disk prefix, e.g.,",
        "suggest": "具有任何非磁盘前缀，例如",
        "translate": ""
    },
    {
        "source": "Returns the `Path` without its final component, if there is one.",
        "suggest": "如果没有 `Path`，则返回不包含其最终组成部分的 `Path`。",
        "translate": ""
    },
    {
        "source": "Returns [`None`] if the path terminates in a root or prefix.",
        "suggest": "如果路径以根或前缀结尾，则返回 [`None`]。",
        "translate": ""
    },
    {
        "source": "Produces an iterator over `Path` and its ancestors.",
        "suggest": "在 `Path` 及其祖先上生成一个迭代器。",
        "translate": ""
    },
    {
        "source": "The iterator will yield the `Path` that is returned if the [`parent`] method is used zero or more times.",
        "suggest": "如果 [`parent`] 方法使用了 0 次或多次，则迭代器将产生返回的 `Path`。",
        "translate": ""
    },
    {
        "source": "That means, the iterator will yield `&self`, `&self.parent().unwrap()`, `&self.parent().unwrap().parent().unwrap()` and so on.",
        "suggest": "这意味着，迭代器将产生 `&self`，`&self.parent().unwrap()`，`&self.parent().unwrap().parent().unwrap()` 等。",
        "translate": ""
    },
    {
        "source": "If the [`parent`] method returns [`None`], the iterator will do likewise.",
        "suggest": "如果 [`parent`] 方法返回 [`None`]，则迭代器也将这样做。",
        "translate": ""
    },
    {
        "source": "The iterator will always yield at least one value, namely `&self`.",
        "suggest": "迭代器将始终产生至少一个值，即 `&self`。",
        "translate": ""
    },
    {
        "source": "Returns the final component of the `Path`, if there is one.",
        "suggest": "返回 `Path` 的最后一个组件 (如果有)。",
        "translate": ""
    },
    {
        "source": "If the path is a normal file, this is the file name.",
        "suggest": "如果路径是普通文件，则为文件名。",
        "translate": ""
    },
    {
        "source": "If it's the path of a directory, this is the directory name.",
        "suggest": "如果是目录路径，则为目录名称。",
        "translate": ""
    },
    {
        "source": "Returns [`None`] if the path terminates in `..`.",
        "suggest": "如果路径以 `..` 结尾，则返回 [`None`]。",
        "translate": ""
    },
    {
        "source": "Returns a path that, when joined onto `base`, yields `self`.",
        "suggest": "返回连接到 `base` 时产生 `self` 的路径。",
        "translate": ""
    },
    {
        "source": "If `base` is not a prefix of `self` (i.e., [`starts_with`] returns `false`), returns [`Err`].",
        "suggest": "如果 `base` 不是 `self` 的前缀 (即 [`starts_with`] 返回 `false`)，则返回 [`Err`]。",
        "translate": ""
    },
    {
        "source": "Determines whether `base` is a prefix of `self`.",
        "suggest": "确定 `base` 是否为 `self` 的前缀。",
        "translate": ""
    },
    {
        "source": "Only considers whole path components to match.",
        "suggest": "仅考虑整个路径组件匹配。",
        "translate": ""
    },
    {
        "source": "Determines whether `child` is a suffix of `self`.",
        "suggest": "确定 `child` 是否为 `self` 的后缀。",
        "translate": ""
    },
    {
        "source": "Extracts the stem (non-extension) portion of [`self.file_name`].",
        "suggest": "提取 [`self.file_name`] 的茎 (non-extension) 部分。",
        "translate": ""
    },
    {
        "source": "The stem is:",
        "suggest": "词干为:",
        "translate": ""
    },
    {
        "source": "if there is no file name;",
        "suggest": "如果没有文件名;",
        "translate": ""
    },
    {
        "source": "The entire file name if there is no embedded `.`;",
        "suggest": "如果没有嵌入式 `.`，则为整个文件名; 否则为 0。",
        "translate": ""
    },
    {
        "source": "The entire file name if the file name begins with `.` and has no other `.`s within;",
        "suggest": "如果文件名以 `.` 开头且内部没有其他 `.`，则为整个文件名;",
        "translate": ""
    },
    {
        "source": "Otherwise, the portion of the file name before the final `.`",
        "suggest": "否则，文件名中最后 `.` 之前的部分",
        "translate": ""
    },
    {
        "source": "Extracts the extension of [`self.file_name`], if possible.",
        "suggest": "如果可能，提取 [`self.file_name`] 的扩展名。",
        "translate": ""
    },
    {
        "source": "The extension is:",
        "suggest": "扩展名是:",
        "translate": ""
    },
    {
        "source": "if there is no embedded `.`;",
        "suggest": "如果没有嵌入式 `.`;",
        "translate": ""
    },
    {
        "source": "if the file name begins with `.` and has no other `.`s within;",
        "suggest": "如果文件名以 `.` 开头，并且里面没有其他 `.`;",
        "translate": ""
    },
    {
        "source": "Otherwise, the portion of the file name after the final `.`",
        "suggest": "否则，文件名中最后一个 `.` 之后的部分",
        "translate": ""
    },
    {
        "source": "Creates an owned [`PathBuf`] with `path` adjoined to `self`.",
        "suggest": "创建一个拥有的 [`PathBuf`]，并将 `path` 附加到 `self`。",
        "translate": ""
    },
    {
        "source": "See [`PathBuf::push`] for more details on what it means to adjoin a path.",
        "suggest": "有关连接路径的含义的更多详细信息，请参见 [`PathBuf::push`]。",
        "translate": ""
    },
    {
        "source": "Creates an owned [`PathBuf`] like `self` but with the given file name.",
        "suggest": "创建一个拥有的 [`PathBuf`]，例如 `self`，但具有给定的文件名。",
        "translate": ""
    },
    {
        "source": "See [`PathBuf::set_file_name`] for more details.",
        "suggest": "有关更多详细信息，请参见 [`PathBuf::set_file_name`]。",
        "translate": ""
    },
    {
        "source": "Creates an owned [`PathBuf`] like `self` but with the given extension.",
        "suggest": "创建一个拥有的 [`PathBuf`]，例如 `self`，但具有给定的扩展名。",
        "translate": ""
    },
    {
        "source": "See [`PathBuf::set_extension`] for more details.",
        "suggest": "有关更多详细信息，请参见 [`PathBuf::set_extension`]。",
        "translate": ""
    },
    {
        "source": "Produces an iterator over the [`Component`]s of the path.",
        "suggest": "生成路径的 [`Component`] 上的迭代器。",
        "translate": ""
    },
    {
        "source": "When parsing the path, there is a small amount of normalization:",
        "suggest": "解析路径时，需要进行少量标准化:",
        "translate": ""
    },
    {
        "source": "Repeated separators are ignored, so `a/b` and `a//b` both have `a` and `b` as components.",
        "suggest": "重复的分隔符将被忽略，因此 `a/b` 和 `a//b` 都具有 `a` 和 `b` 作为组件。",
        "translate": ""
    },
    {
        "source": "Occurrences of `.` are normalized away, except if they are at the beginning of the path.",
        "suggest": "`.` 的出现被归一化，除非它们位于路径的开头。",
        "translate": ""
    },
    {
        "source": "For example, `a/./b`, `a/b/`, `a/b/.` and `a/b` all have `a` and `b` as components, but `./a/b` starts with an additional [`CurDir`] component.",
        "suggest": "例如，`a/./b`，`a/b/`，`a/b/.` 和 `a/b` 都具有 `a` 和 `b` 作为组件，但是 `./a/b` 以附加的 [`CurDir`] 组件开头。",
        "translate": ""
    },
    {
        "source": "A trailing slash is normalized away, `/a/b` and `/a/b/` are equivalent.",
        "suggest": "尾部的斜杠已标准化，`/a/b` 和 `/a/b/` 是等效的。",
        "translate": ""
    },
    {
        "source": "Note that no other normalization takes place;",
        "suggest": "请注意，没有其他标准化发生。",
        "translate": ""
    },
    {
        "source": "in particular, `a/c` and `a/b/../c` are distinct, to account for the possibility that `b` is a symbolic link (so its parent isn't `a`).",
        "suggest": "特别是，`a/c` 和 `a/b/../c` 是不同的，以考虑到 `b` 是符号链接 (因此其父代不是 `a`) 的可能性。",
        "translate": ""
    },
    {
        "source": "Produces an iterator over the path's components viewed as [`OsStr`] slices.",
        "suggest": "在视为 [`OsStr`] slice 的路径的组件上生成迭代器。",
        "translate": ""
    },
    {
        "source": "For more information about the particulars of how the path is separated into components, see [`components`].",
        "suggest": "有关如何将路径分成多个组件的详细信息，请参见 [`components`]。",
        "translate": ""
    },
    {
        "source": "Returns an object that implements [`Display`] for safely printing paths that may contain non-Unicode data.",
        "suggest": "返回实现 [`Display`] 的 object，以安全地打印可能包含非 Unicode 数据的路径。",
        "translate": ""
    },
    {
        "source": "This may perform lossy conversion, depending on the platform.",
        "suggest": "根据平台的不同，这可能会执行有损转换。",
        "translate": ""
    },
    {
        "source": "If you would like an implementation which escapes the path please use [`Debug`] instead.",
        "suggest": "如果您想要一个转义路径的实现，请改用 [`Debug`]。",
        "translate": ""
    },
    {
        "source": "Queries the file system to get information about a file, directory, etc.",
        "suggest": "查询文件系统以获取有关文件，目录等的信息。",
        "translate": ""
    },
    {
        "source": "This is an alias to [`fs::metadata`].",
        "suggest": "这是 [`fs::metadata`] 的别名。",
        "translate": ""
    },
    {
        "source": "Queries the metadata about a file without following symlinks.",
        "suggest": "查询有关文件的元数据，而无需遵循符号链接。",
        "translate": ""
    },
    {
        "source": "This is an alias to [`fs::symlink_metadata`].",
        "suggest": "这是 [`fs::symlink_metadata`] 的别名。",
        "translate": ""
    },
    {
        "source": "Returns the canonical, absolute form of the path with all intermediate components normalized and symbolic links resolved.",
        "suggest": "返回路径的规范，绝对形式，所有中间组件均已标准化，符号链接已解析。",
        "translate": ""
    },
    {
        "source": "This is an alias to [`fs::canonicalize`].",
        "suggest": "这是 [`fs::canonicalize`] 的别名。",
        "translate": ""
    },
    {
        "source": "This is an alias to [`fs::read_link`].",
        "suggest": "这是 [`fs::read_link`] 的别名。",
        "translate": ""
    },
    {
        "source": "The iterator will yield instances of [`io::Result`]`<`[`fs::DirEntry`]`>`.",
        "suggest": "迭代器将产生 [`io::Result`]`<`[`fs::DirEntry`]`>` 的实例。",
        "translate": ""
    },
    {
        "source": "This is an alias to [`fs::read_dir`].",
        "suggest": "这是 [`fs::read_dir`] 的别名。",
        "translate": ""
    },
    {
        "source": "Returns `true` if the path points at an existing entity.",
        "suggest": "如果路径指向现有实体，则返回 `true`。",
        "translate": ""
    },
    {
        "source": "In case of broken symbolic links this will return `false`.",
        "suggest": "如果符号链接断开，则将返回 `false`。",
        "translate": ""
    },
    {
        "source": "If you cannot access the directory containing the file, e.g., because of a permission error, this will return `false`.",
        "suggest": "如果由于权限错误而无法访问包含文件的目录，则将返回 `false`。",
        "translate": ""
    },
    {
        "source": "See Also",
        "suggest": "也可以看看",
        "translate": ""
    },
    {
        "source": "This is a convenience function that coerces errors to false.",
        "suggest": "这是一个方便的函数，可将错误强制为 false。",
        "translate": ""
    },
    {
        "source": "If you want to check errors, call [`fs::metadata`].",
        "suggest": "如果要检查错误，请调用 [`fs::metadata`]。",
        "translate": ""
    },
    {
        "source": "Returns `Ok(true)` if the path points at an existing entity.",
        "suggest": "如果路径指向现有实体，则返回 `Ok(true)`。",
        "translate": ""
    },
    {
        "source": "In case of broken symbolic links this will return `Ok(false)`.",
        "suggest": "如果符号链接断开，则将返回 `Ok(false)`。",
        "translate": ""
    },
    {
        "source": "As opposed to the `exists()` method, this one doesn't silently ignore errors unrelated to the path not existing.",
        "suggest": "与 `exists()` 方法相反，此方法不会默默地忽略与不存在的路径无关的错误。",
        "translate": ""
    },
    {
        "source": "it will return `Err(_)` in case of permission denied on some of the parent directories.)",
        "suggest": "如果某些父目录的权限被拒绝，它将返回 `Err(_)`。)",
        "translate": ""
    },
    {
        "source": "stabilization should modify documentation of `exists()` to recommend this method instead.",
        "suggest": "稳定性应修改 `exists()` 的文档以推荐此方法。",
        "translate": ""
    },
    {
        "source": "Returns `true` if the path exists on disk and is pointing at a regular file.",
        "suggest": "如果路径在磁盘上并且指向常规文件，则返回 `true`。",
        "translate": ""
    },
    {
        "source": "Then call [`fs::Metadata::is_file`] if it was [`Ok`].",
        "suggest": "如果是 [`Ok`]，则调用 [`fs::Metadata::is_file`]。",
        "translate": ""
    },
    {
        "source": "See [`fs::File::open`] or [`fs::OpenOptions::open`] for more information.",
        "suggest": "有关更多信息，请参见 [`fs::File::open`] 或 [`fs::OpenOptions::open`]。",
        "translate": ""
    },
    {
        "source": "Returns `true` if the path exists on disk and is pointing at a directory.",
        "suggest": "如果路径在磁盘上并且指向目录，则返回 `true`。",
        "translate": ""
    },
    {
        "source": "If you want to check errors, call [`fs::metadata`] and handle its [`Result`].",
        "suggest": "如果要检查错误，请调用 [`fs::metadata`] 并处理其 [`Result`]。",
        "translate": ""
    },
    {
        "source": "Then call [`fs::Metadata::is_dir`] if it was [`Ok`].",
        "suggest": "如果是 [`Ok`]，则调用 [`fs::Metadata::is_dir`]。",
        "translate": ""
    },
    {
        "source": "Converts a [`Box<Path>`](Box) into a [`PathBuf`] without copying or allocating.",
        "suggest": "无需复制或分配即可将 [`Box<Path>`](Box) 转换为 [`PathBuf`]。",
        "translate": ""
    },
    {
        "source": "Helper struct for safely printing paths with [`format!`] and `{}`.",
        "suggest": "Helper 结构体，用于使用 [`format!`] 和 `{}` 安全地打印路径。",
        "translate": ""
    },
    {
        "source": "A [`Path`] might contain non-Unicode data.",
        "suggest": "[`Path`] 可能包含非 Unicode 数据。",
        "translate": ""
    },
    {
        "source": "This `struct` implements the [`Display`] trait in a way that mitigates that.",
        "suggest": "该 `struct` 可以减轻 [`Display`] trait 的负担。",
        "translate": ""
    },
    {
        "source": "It is created by the [`display`](Path::display) method on [`Path`].",
        "suggest": "它是通过 [`Path`] 上的 [`display`](Path::display) 方法创建的。",
        "translate": ""
    },
    {
        "source": "The Rust Prelude",
        "suggest": "Rust Prelude",
        "translate": ""
    },
    {
        "source": "Rust comes with a variety of things in its standard library.",
        "suggest": "Rust 在其标准库中附带了许多东西。",
        "translate": ""
    },
    {
        "source": "However, if you had to manually import every single thing that you used, it would be very verbose.",
        "suggest": "但是，如果您必须手动导入所用的每件事，那将非常冗长。",
        "translate": ""
    },
    {
        "source": "But importing a lot of things that a program never uses isn't good either.",
        "suggest": "但是，导入很多程序从未使用过的东西也是不好的。",
        "translate": ""
    },
    {
        "source": "A balance needs to be struck.",
        "suggest": "需要取得平衡。",
        "translate": ""
    },
    {
        "source": "The *prelude* is the list of things that Rust automatically imports into every Rust program.",
        "suggest": "*prelude* 是 Rust 自动导入每个 Rust 程序的内容的列表。",
        "translate": ""
    },
    {
        "source": "It's kept as small as possible, and is focused on things, particularly traits, which are used in almost every single Rust program.",
        "suggest": "它保持尽可能的小，并专注于几乎在每个 Rust 程序中使用的东西，尤其是 traits。",
        "translate": ""
    },
    {
        "source": "Other preludes",
        "suggest": "其他 preludes",
        "translate": ""
    },
    {
        "source": "Preludes can be seen as a pattern to make using multiple types more convenient.",
        "suggest": "preludes 可以看作是使使用多种类型更方便的一种模式。",
        "translate": ""
    },
    {
        "source": "As such, you'll find other preludes in the standard library, such as [`std::io::prelude`].",
        "suggest": "这样，您将在标准库中找到其他 preludes，例如 [`std::io::prelude`]。",
        "translate": ""
    },
    {
        "source": "Various libraries in the Rust ecosystem may also define their own preludes.",
        "suggest": "Rust 生态系统中的各种库也可以定义自己的 preludes。",
        "translate": ""
    },
    {
        "source": "The difference between 'the prelude' and these other preludes is that they are not automatically `use`'d, and must be imported manually.",
        "suggest": "`prelude` 和其他 preludes 之间的区别是它们不会自动 `use`，而必须手动导入。",
        "translate": ""
    },
    {
        "source": "This is still easier than importing all of their constituent components.",
        "suggest": "这仍然比导入其所有组成组件容易。",
        "translate": ""
    },
    {
        "source": "Prelude contents",
        "suggest": "Prelude 的内容",
        "translate": ""
    },
    {
        "source": "The current version of the prelude (version 1) lives in [`std::prelude::v1`], and re-exports the following:",
        "suggest": "prelude (版本 1) 的当前版本位于 [`std::prelude::v1`] 中，并重导出以下内容:",
        "translate": ""
    },
    {
        "source": "marker traits that indicate fundamental properties of types.",
        "suggest": "指示类型的基本属性的标记 traits。",
        "translate": ""
    },
    {
        "source": "[`Fn`], [`FnMut`], [`FnOnce`]}: various operations for both destructors and overloading `()`.",
        "suggest": "[`Fn`]，[`FnMut`] 和 [`FnOnce`]}: 析构函数和 `()` 重载的各种操作。",
        "translate": ""
    },
    {
        "source": "a convenience function for explicitly dropping a value.",
        "suggest": "用于显式丢弃值的便捷函数。",
        "translate": ""
    },
    {
        "source": "a way to allocate values on the heap.",
        "suggest": "一种在堆上分配值的方法。",
        "translate": ""
    },
    {
        "source": "the conversion trait that defines [`to_owned`], the generic method for creating an owned type from a borrowed type.",
        "suggest": "定义 [`to_owned`] 的转换 trait，这是从借用类型创建拥有类型的泛型方法。",
        "translate": ""
    },
    {
        "source": "the ubiquitous trait that defines [`clone`][`Clone::clone`], the method for producing a copy of a value.",
        "suggest": "定义 [`clone`][`Clone::clone`] 的无处不在的 trait，即产生值副本的方法。",
        "translate": ""
    },
    {
        "source": "[`PartialOrd`], [`Eq`], [`Ord`]}: the comparison traits, which implement the comparison operators and are often seen in trait bounds.",
        "suggest": "[`PartialOrd`]，[`Eq`]，[`Ord`]}: 比较 traits，实现比较运算符，通常在 trait bounds 中看到。",
        "translate": ""
    },
    {
        "source": "[`AsMut`], [`Into`], [`From`]}: generic conversions, used by savvy API authors to create overloaded methods.",
        "suggest": "[`AsMut`]，[`Into`] 和 [`From`]}: 泛型转换，由精明的 API 作者用于创建重载方法。",
        "translate": ""
    },
    {
        "source": "types that have default values.",
        "suggest": "具有默认值的类型。",
        "translate": ""
    },
    {
        "source": "[`Extend`], [`IntoIterator`], [`DoubleEndedIterator`], [`ExactSizeIterator`]}: iterators of various kinds.",
        "suggest": "[`Extend`]，[`IntoIterator`]，[`DoubleEndedIterator`]，[`ExactSizeIterator`]}: 各种迭代器。",
        "translate": ""
    },
    {
        "source": "[`Some`], [`None`]}, a type which expresses the presence or absence of a value.",
        "suggest": "[`Some`]，[`None`]}，一种表示存在或不存在值的类型。",
        "translate": ""
    },
    {
        "source": "This type is so commonly used, its variants are also exported.",
        "suggest": "这种类型非常常用，其成员也已导出。",
        "translate": ""
    },
    {
        "source": "[`Ok`], [`Err`]}: a type for functions that may succeed or fail.",
        "suggest": "[`Ok`]，[`Err`]}: 可能成功或失败的函数的类型。",
        "translate": ""
    },
    {
        "source": "Like [`Option`], its variants are exported as well.",
        "suggest": "像 [`Option`] 一样，它的成员也被导出。",
        "translate": ""
    },
    {
        "source": "[`ToString`]}: heap-allocated strings.",
        "suggest": "[`ToString`]}: 堆分配的字符串。",
        "translate": ""
    },
    {
        "source": "a growable, heap-allocated vector.",
        "suggest": "一个可增长的，堆分配的 vector。",
        "translate": ""
    },
    {
        "source": "The 2015 version of the prelude of The Rust Standard Library.",
        "suggest": "Rust 标准库的 prelude 的 2015 版本。",
        "translate": ""
    },
    {
        "source": "The 2018 version of the prelude of The Rust Standard Library.",
        "suggest": "Rust 标准库的 prelude 2018 版本。",
        "translate": ""
    },
    {
        "source": "The 2021 version of the prelude of The Rust Standard Library.",
        "suggest": "Rust 标准库的 prelude 的 2021 版本。",
        "translate": ""
    },
    {
        "source": "The first version of the prelude of The Rust Standard Library.",
        "suggest": "Rust 标准库的 prelude 的第一个版本。",
        "translate": ""
    },
    {
        "source": "Attribute and internal derive macros are not documented because for them rustdoc generates dead links which fail link checker testing.",
        "suggest": "没有记录属性和内部派生宏，因为 rustdoc 会生成失效的链接，使链接检查器测试失败。",
        "translate": ""
    },
    {
        "source": "The file so far is equivalent to src/libcore/prelude/v1.rs, and below to src/liballoc/prelude.rs.",
        "suggest": "到目前为止，该文件等效于 src/libcore/prelude/v1.rs，而其等效于 src/liballoc/prelude.rs。",
        "translate": ""
    },
    {
        "source": "Those files are duplicated rather than using glob imports because we want docs to show these re-exports as pointing to within `std`.",
        "suggest": "这些文件是重复的，而不是使用 glob 导入，因为我们希望文档将这些重导出显示为指向 `std` 中的指针。",
        "translate": ""
    },
    {
        "source": "using the `if` conditional",
        "suggest": "使用 `if` 有条件",
        "translate": ""
    },
    {
        "source": "or, a match pattern",
        "suggest": "或者，匹配模式",
        "translate": ""
    },
    {
        "source": "five elements times four bytes for each element",
        "suggest": "五个元素乘以每个元素四个字节",
        "translate": ""
    },
    {
        "source": "five elements times one byte per element",
        "suggest": "5 个元素乘以每个元素一个字节",
        "translate": ""
    },
    {
        "source": "'latin small letter e with acute'",
        "suggest": "带有小写字母的拉丁小写字母 e",
        "translate": ""
    },
    {
        "source": "'latin small letter e'",
        "suggest": "拉丁小写字母 e",
        "translate": ""
    },
    {
        "source": "'combining acute accent'",
        "suggest": "结合重音",
        "translate": ""
    },
    {
        "source": "By taking ownership of the original `Box<T>` though we are obligated to put it together later to be destroyed.",
        "suggest": "通过拥有原始 `Box<T>` 的所有权，我们有义务稍后将其放在一起销毁。",
        "translate": ""
    },
    {
        "source": "This loop prints: 0 1 2",
        "suggest": "该循环打印: 0 1 2",
        "translate": ""
    },
    {
        "source": "error: the trait bound `[i32; 3]: std::iter::Iterator` is not satisfied",
        "suggest": "错误: 不满足 trait bound `[i32; 3]: std::iter::Iterator`",
        "translate": ""
    },
    {
        "source": "Take a full slice of `x`.",
        "suggest": "取 `x` 的完整切片。",
        "translate": ""
    },
    {
        "source": "with an explicit type annotation",
        "suggest": "带有明确的类型注解",
        "translate": ""
    },
    {
        "source": "We can re-build a str out of ptr and len.",
        "suggest": "我们可以根据 ptr 和 len 重新构建一个 str。",
        "translate": ""
    },
    {
        "source": "This is all unsafe because we are responsible for making sure the two components are valid:",
        "suggest": "这都是不安全的，因为我们有责任确保两个组件均有效:",
        "translate": ""
    },
    {
        "source": "First, we build a &[u8]...",
        "suggest": "首先，我们建立一个 &[u8] ...",
        "translate": ""
    },
    {
        "source": "and then convert that slice into a string slice",
        "suggest": "然后将该切片转换为字符串",
        "translate": ""
    },
    {
        "source": "Don't do a calculation, that's not the point of the example",
        "suggest": "不要进行计算，这不是示例的重点",
        "translate": ""
    },
    {
        "source": "Combining this with patterns can be nicer.",
        "suggest": "将此与模式结合起来会更好。",
        "translate": ""
    },
    {
        "source": "mismatched types: expected normal fn, found unsafe fn let bad_ptr: fn(usize) -> usize = add_one_unsafely;",
        "suggest": "不匹配的类型: 预期正常 fn，发现不安全 fn let bad_ptr: fn(usize) -> usize=add_one_unsafely;",
        "translate": ""
    },
    {
        "source": "is zero-sized, uniquely identifying `bar`",
        "suggest": "大小为零，唯一标识 `bar`",
        "translate": ""
    },
    {
        "source": "force coercion to function pointer",
        "suggest": "强制转换为函数指针",
        "translate": ""
    },
    {
        "source": "this is a shared reference to the zero-sized type identifying `bar`",
        "suggest": "这是对标识 `bar` 的零大小类型的共享引用",
        "translate": ""
    },
    {
        "source": "The boolean type.",
        "suggest": "布尔类型。",
        "translate": ""
    },
    {
        "source": "The `bool` represents a value, which could only be either `true` or `false`.",
        "suggest": "`bool` 代表一个值，只能是 `true` 或 `false`。",
        "translate": ""
    },
    {
        "source": "If you cast a `bool` into an integer, `true` will be 1 and `false` will be 0.",
        "suggest": "如果将 `bool` 转换为整数，则 `true` 将为 1，`false` 将为 0。",
        "translate": ""
    },
    {
        "source": "implements various traits, such as [`BitAnd`], [`BitOr`], [`Not`], etc., which allow us to perform boolean operations using `&`, `|` and `!`.",
        "suggest": "实现各种 traits，例如 [`BitAnd`]，[`BitOr`]，[`Not`] 等，它们使我们能够使用 `&`，`|` 和 `!` 执行布尔运算。",
        "translate": ""
    },
    {
        "source": "requires a `bool` value as its conditional.",
        "suggest": "需要 `bool` 值作为它的条件。",
        "translate": ""
    },
    {
        "source": "which is an important macro in testing, checks whether an expression is `true` and panics if it isn't.",
        "suggest": "在测试中是重要的宏，它检查表达式是否为 `true` 和 panics (如果不是)。",
        "translate": ""
    },
    {
        "source": "A trivial example of the usage of `bool`:",
        "suggest": "`bool` 用法的一个简单示例:",
        "translate": ""
    },
    {
        "source": "Also, since `bool` implements the [`Copy`] trait, we don't have to worry about the move semantics (just like the integer and float primitives).",
        "suggest": "另外，由于 `bool` 实现了 [`Copy`] trait，因此我们不必担心移动语义 (就像整数和浮点图元一样)。",
        "translate": ""
    },
    {
        "source": "Now an example of `bool` cast to integer type:",
        "suggest": "现在将 `bool` 强制转换为整数类型的示例:",
        "translate": ""
    },
    {
        "source": "The `!` type, also called \"never\".",
        "suggest": "`!` 类型，也称为 \"never\"。",
        "translate": ""
    },
    {
        "source": "represents the type of computations which never resolve to any value at all.",
        "suggest": "表示永远无法解析为任何值的计算类型。",
        "translate": ""
    },
    {
        "source": "For example, the [`exit`] function `fn exit(code: i32) -> !` exits the process without ever returning, and so returns `!`.",
        "suggest": "例如，[`exit`] 函数 `fn exit(code: i32) -> !` 退出该进程而不返回，因此返回 `!`。",
        "translate": ""
    },
    {
        "source": "`continue` and `return` expressions also have type `!`.",
        "suggest": "`continue` 和 `return` 表达式也具有 `!` 类型。",
        "translate": ""
    },
    {
        "source": "For example we are allowed to write:",
        "suggest": "例如，我们可以写:",
        "translate": ""
    },
    {
        "source": "Although the `let` is pointless here, it illustrates the meaning of `!`.",
        "suggest": "尽管 `let` 在这里毫无意义，但它说明了 `!` 的含义。",
        "translate": ""
    },
    {
        "source": "Since `x` is never assigned a value (because `return` returns from the entire function), `x` can be given type `!`.",
        "suggest": "由于从未给 `x` 赋值 (因为 `return` 从整个函数返回)，因此可以给 `x` 指定 `!` 类型。",
        "translate": ""
    },
    {
        "source": "We could also replace `return 123` with a `panic!` or a never-ending `loop` and this code would still be valid.",
        "suggest": "我们也可以将 `return 123` 替换为 `panic!` 或永无休止的 `loop`，并且此代码仍然有效。",
        "translate": ""
    },
    {
        "source": "A more realistic usage of `!` is in this code:",
        "suggest": "以下代码更实际地使用 `!`:",
        "translate": ""
    },
    {
        "source": "Both match arms must produce values of type [`u32`], but since `break` never produces a value at all we know it can never produce a value which isn't a [`u32`].",
        "suggest": "两个匹配分支都必须产生 [`u32`] 类型的值，但是由于 `break` 根本不会产生值，我们知道它永远不会产生不是 [`u32`] 的值。",
        "translate": ""
    },
    {
        "source": "This illustrates another behaviour of the `!` type - expressions with type `!` will coerce into any other type.",
        "suggest": "这说明了 `!` 类型的另一种行为 - 类型为 `!` 的表达式将强制转换为任何其他类型。",
        "translate": ""
    },
    {
        "source": "and generics",
        "suggest": "和泛型",
        "translate": ""
    },
    {
        "source": "Infallible errors",
        "suggest": "绝对的错误",
        "translate": ""
    },
    {
        "source": "The main place you'll see `!` used explicitly is in generic code.",
        "suggest": "您将看到显式使用的 `!` 的主要位置是泛型代码。",
        "translate": ""
    },
    {
        "source": "Consider the [`FromStr`] trait:",
        "suggest": "考虑 [`FromStr`] trait:",
        "translate": ""
    },
    {
        "source": "When implementing this trait for [`String`] we need to pick a type for [`Err`].",
        "suggest": "当为 [`String`] 实现此 trait 时，我们需要为 [`Err`] 选择一个类型。",
        "translate": ""
    },
    {
        "source": "And since converting a string into a string will never result in an error, the appropriate type is `!`.",
        "suggest": "并且由于将字符串转换为字符串永远不会导致错误，因此适当的类型是 `!`。",
        "translate": ""
    },
    {
        "source": "(Currently the type actually used is an enum with no variants, though this is only because `!` was added to Rust at a later date and it may change in the future.) With an [`Err`] type of `!`, if we have to call [`String::from_str`] for some reason the result will be a [`Result<String, !>`] which we can unpack like this:",
        "suggest": "(当前实际使用的类型是一个没有成员的枚举，尽管这只是因为 `!` 以后才会被添加到 Rust 中，并且将来可能会发生变化。) 对于 [`Err`] 类型的 `!`，如果我们由于某种原因不得不调用 [`String::from_str`]，那么结果将是 [`Result<String, !>`]，我们可以像这样解包:",
        "translate": ""
    },
    {
        "source": "Since the [`Err`] variant contains a `!`, it can never occur.",
        "suggest": "由于 [`Err`] 成员包含 `!`，因此永远不会发生。",
        "translate": ""
    },
    {
        "source": "If the `exhaustive_patterns` feature is present this means we can exhaustively match on [`Result<T, !>`] by just taking the [`Ok`] variant.",
        "suggest": "如果存在 `exhaustive_patterns` 功能，则意味着我们只需采用 [`Ok`] 成员就可以在 [`Result<T, !>`] 上进行全面匹配。",
        "translate": ""
    },
    {
        "source": "This illustrates another behaviour of `!` - it can be used to \"delete\" certain enum variants from generic types like `Result`.",
        "suggest": "这说明了 `!` 的另一种行为 - 它可以用于 \"delete\" 泛型 (如 `Result`) 中的某些枚举成员。",
        "translate": ""
    },
    {
        "source": "Infinite loops",
        "suggest": "无限循环",
        "translate": ""
    },
    {
        "source": "While [`Result<T, !>`] is very useful for removing errors, `!` can also be used to remove successes as well.",
        "suggest": "尽管 [`Result<T, !>`] 对于消除错误非常有用，但 `!` 也可以用于消除成功。",
        "translate": ""
    },
    {
        "source": "If we think of [`Result<T, !>`] as \"if this function returns, it has not errored,\" we get a very intuitive idea of [`Result<!, E>`] as well: if the function returns, it *has* errored.",
        "suggest": "如果我们将 [`Result<T, !>`] 视为 \"if this function returns, it has not errored,\"，那么我们也会非常直观地想到 [`Result<!, E>`]: 如果函数返回，则 *有* 错误。",
        "translate": ""
    },
    {
        "source": "For example, consider the case of a simple web server, which can be simplified to:",
        "suggest": "例如，考虑一个简单的 Web 服务器的情况，它可以简化为:",
        "translate": ""
    },
    {
        "source": "Currently, this isn't ideal, because we simply panic whenever we fail to get a new connection.",
        "suggest": "目前，这并不理想，因为只要无法建立新的连接，我们就简单地使用 panic。",
        "translate": ""
    },
    {
        "source": "Instead, we'd like to keep track of this error, like this:",
        "suggest": "相反，我们想跟踪此错误，如下所示:",
        "translate": ""
    },
    {
        "source": "Now, when the server disconnects, we exit the loop with an error instead of panicking.",
        "suggest": "现在，当服务器断开连接时，我们以错误退出循环而不是恐慌。",
        "translate": ""
    },
    {
        "source": "While it might be intuitive to simply return the error, we might want to wrap it in a [`Result<!, E>`] instead:",
        "suggest": "虽然简单地返回错误可能很直观，但我们可能希望将其包装在 [`Result<!, E>`] 中:",
        "translate": ""
    },
    {
        "source": "Now, we can use `?` instead of `match`, and the return type makes a lot more sense: if the loop ever stops, it means that an error occurred.",
        "suggest": "现在，我们可以使用 `?` 代替 `match`，并且返回类型更有意义: 如果循环停止，则意味着发生了错误。",
        "translate": ""
    },
    {
        "source": "We don't even have to wrap the loop in an `Ok` because `!` coerces to `Result<!, ConnectionError>` automatically.",
        "suggest": "我们甚至不必将循环包装在 `Ok` 中，因为 `!` 会自动强制转换为 `Result<!, ConnectionError>`。",
        "translate": ""
    },
    {
        "source": "and traits",
        "suggest": "和 traits",
        "translate": ""
    },
    {
        "source": "When writing your own traits, `!` should have an `impl` whenever there is an obvious `impl` which doesn't `panic!`.",
        "suggest": "编写自己的 traits 时，只要有明显的 `impl` 而不是 `panic!`，`!` 就应该有一个 `impl`。",
        "translate": ""
    },
    {
        "source": "The reason is that functions returning an `impl Trait` where `!` does not have an `impl` of `Trait` cannot diverge as their only possible code path.",
        "suggest": "原因是返回 `impl Trait` 且 `!` 没有 `impl` 的函数不能作为它的唯一可能的代码路径发散。",
        "translate": ""
    },
    {
        "source": "In other words, they can't return `!` from every code path.",
        "suggest": "换句话说，它们不能从每个代码路径返回 `!`。",
        "translate": ""
    },
    {
        "source": "As an example, this code doesn't compile:",
        "suggest": "例如，此代码不会编译:",
        "translate": ""
    },
    {
        "source": "But this code does:",
        "suggest": "但是这段代码可以做到:",
        "translate": ""
    },
    {
        "source": "The reason is that, in the first example, there are many possible types that `!` could coerce to, because many types implement `Add<u32>`.",
        "suggest": "原因是，在第一个示例中，`!` 可以强制转换为许多可能的类型，因为许多类型实现了 `Add<u32>`。",
        "translate": ""
    },
    {
        "source": "However, in the second example, the `else` branch returns a `0`, which the compiler infers from the return type to be of type `u32`.",
        "suggest": "但是，在第二个示例中，`else` 分支返回 `0`，编译器从返回类型推断出它为 `u32` 类型。",
        "translate": ""
    },
    {
        "source": "Since `u32` is a concrete type, `!` can and will be coerced to it.",
        "suggest": "由于 `u32` 是具体类型，因此 `!` 可以并且将被强制使用。",
        "translate": ""
    },
    {
        "source": "See issue [#36375] for more information on this quirk of `!`.",
        "suggest": "有关此 `!` 的更多信息，请参见问题 [#36375]。",
        "translate": ""
    },
    {
        "source": "As it turns out, though, most traits can have an `impl` for `!`.",
        "suggest": "但是，事实证明，大多数 traits 都可以将 `impl` 用作 `!`。",
        "translate": ""
    },
    {
        "source": "Take [`Debug`] for example:",
        "suggest": "以 [`Debug`] 为例:",
        "translate": ""
    },
    {
        "source": "Once again we're using `!`'s ability to coerce into any other type, in this case [`fmt::Result`].",
        "suggest": "我们再次使用 `! ` 的功能来强制转换为任何其他类型，在本例中为 [`fmt::Result`]。",
        "translate": ""
    },
    {
        "source": "Since this method takes a `&!` as an argument we know that it can never be called (because there is no value of type `!` for it to be called with).",
        "suggest": "由于此方法将 `&!` 作为参数，因此我们知道它永远不能被调用 (因为没有 `!` 类型的值可以调用它)。",
        "translate": ""
    },
    {
        "source": "Writing `*self` essentially tells the compiler \"We know that this code can never be run, so just treat the entire function body as having type [`fmt::Result`]\".",
        "suggest": "编写 `*self` 实质上就是告诉编译器 \"We know that this code can never be run, so just treat the entire function body as having type [`fmt::Result`]\"。",
        "translate": ""
    },
    {
        "source": "This pattern can be used a lot when implementing traits for `!`.",
        "suggest": "当为 `!` 实现 traits 时，可以使用这种模式。",
        "translate": ""
    },
    {
        "source": "Generally, any trait which only has methods which take a `self` parameter should have such an impl.",
        "suggest": "通常，任何仅具有采用 `self` 参数的方法的 trait 都应具有这样的含义。",
        "translate": ""
    },
    {
        "source": "On the other hand, one trait which would not be appropriate to implement is [`Default`]:",
        "suggest": "另一方面，不适合实现的一个 trait 是 [`Default`]:",
        "translate": ""
    },
    {
        "source": "Since `!` has no values, it has no default value either.",
        "suggest": "由于 `!` 没有值，因此也没有默认值。",
        "translate": ""
    },
    {
        "source": "It's true that we could write an `impl` for this which simply panics, but the same is true for any type (we could `impl Default` for (eg.) [`File`] by just making [`default()`] panic.)",
        "suggest": "的确，我们可以为此编写一个 `impl`，它只是 panics，但是对于任何类型都一样 (我们可以通过仅将 [`default()`] panic 制作为 (eg.) [`File`] 来使用 `impl Default`)。",
        "translate": ""
    },
    {
        "source": "This documentation describes a number of methods and trait implementations on the `char` type.",
        "suggest": "本文档描述了 `char` 类型上的许多方法和 trait 实现。",
        "translate": ""
    },
    {
        "source": "For technical reasons, there is additional, separate documentation in [the `std::char` module](char/index.html) as well.",
        "suggest": "由于技术原因，[the `std::char` module](char/index.html) 中还有其他单独的文档。",
        "translate": ""
    },
    {
        "source": "is always four bytes in size.",
        "suggest": "大小始终为四个字节。",
        "translate": ""
    },
    {
        "source": "This is a different representation than a given character would have as part of a [`String`].",
        "suggest": "这与给定字符作为 [`String`] 的一部分的表示形式不同。",
        "translate": ""
    },
    {
        "source": "As always, remember that a human intuition for 'character' may not map to Unicode's definitions.",
        "suggest": "与往常一样，请记住，对于 'character' 的直观理解可能不会 map 到 Unicode 的定义。",
        "translate": ""
    },
    {
        "source": "For example, despite looking similar, the 'é' character is one Unicode code point while 'é' is two Unicode code points:",
        "suggest": "例如，尽管看起来相似，但 'é' 字符是一个 Unicode 代码点，而 'é' 是两个 Unicode 代码点:",
        "translate": ""
    },
    {
        "source": "This means that the contents of the first string above _will_ fit into a `char` while the contents of the second string _will not_.",
        "suggest": "这意味着 _will_ 上方的第一个字符串的内容适合 `char`，而第二个字符串 _will_ 的内容则不会。",
        "translate": ""
    },
    {
        "source": "Trying to create a `char` literal with the contents of the second string gives an error:",
        "suggest": "尝试使用第二个字符串的内容创建 `char` 字面量会产生错误:",
        "translate": ""
    },
    {
        "source": "Another implication of the 4-byte fixed size of a `char` is that per-`char` processing can end up using a lot more memory:",
        "suggest": "`char` 的 4 字节固定大小的另一个含义是，每个字符处理可能最终会使用更多的内存:",
        "translate": ""
    },
    {
        "source": "The `()` type, also called \"unit\".",
        "suggest": "`()` 类型，也称为 \"unit\"。",
        "translate": ""
    },
    {
        "source": "The `()` type has exactly one value `()`, and is used when there is no other meaningful value that could be returned.",
        "suggest": "`()` 类型只有一个值 `()`，在没有其他有意义的值可以返回时使用。",
        "translate": ""
    },
    {
        "source": "is most commonly seen implicitly: functions without a `-> ...` implicitly have return type `()`, that is, these are equivalent:",
        "suggest": "最常见的隐含形式: 没有 `-> ...` 的函数隐含具有返回类型 `()`，即，它们是等效的:",
        "translate": ""
    },
    {
        "source": "The semicolon `;` can be used to discard the result of an expression at the end of a block, making the expression (and thus the block) evaluate to `()`.",
        "suggest": "分号 `;` 可用于在块末尾丢弃表达式的结果，从而使表达式 (从而使该块) 的值为 `()`。",
        "translate": ""
    },
    {
        "source": "Raw, unsafe pointers, `*const T`, and `*mut T`.",
        "suggest": "原始，不安全的指针 `*const T` 和 `* mut T`。",
        "translate": ""
    },
    {
        "source": "Working with raw pointers in Rust is uncommon, typically limited to a few patterns.",
        "suggest": "在 Rust 中使用裸指针并不常见，通常仅限于几种模式。",
        "translate": ""
    },
    {
        "source": "Raw pointers can be unaligned or [`null`].",
        "suggest": "裸指针可以是未对齐的或 [`null`]。",
        "translate": ""
    },
    {
        "source": "However, when a raw pointer is dereferenced (using the `*` operator), it must be non-null and aligned.",
        "suggest": "但是，当解引用裸指针 (使用 `*` 运算符) 时，它必须为非 null 并对齐。",
        "translate": ""
    },
    {
        "source": "Storing through a raw pointer using `*ptr = data` calls `drop` on the old value, so [`write`] must be used if the type has drop glue and memory is not already initialized - otherwise `drop` would be called on the uninitialized memory.",
        "suggest": "使用 `*ptr = data` 通过裸指针存储会在旧值上调用 `drop`，因此，如果该类型具有 drop glue 并且尚未初始化内存，则必须使用 [`write`]; 否则，将在未初始化的内存上调用 `drop`。",
        "translate": ""
    },
    {
        "source": "Use the [`null`] and [`null_mut`] functions to create null pointers, and the [`is_null`] method of the `*const T` and `*mut T` types to check for null.",
        "suggest": "使用 [`null`] 和 [`null_mut`] 函数创建空指针，并使用 `*const T` 和 `* mut T` 类型的 [`is_null`] 方法检查空值。",
        "translate": ""
    },
    {
        "source": "The `*const T` and `*mut T` types also define the [`offset`] method, for pointer math.",
        "suggest": "`*const T` 和 `* mut T` 类型还定义了用于指针数学的 [`offset`] 方法。",
        "translate": ""
    },
    {
        "source": "Common ways to create raw pointers",
        "suggest": "创建裸指针的常用方法",
        "translate": ""
    },
    {
        "source": "Coerce a reference (`&T`) or mutable reference (`&mut T`).",
        "suggest": "强制引用 (`&T`) 或可变引用 (`&mut T`)。",
        "translate": ""
    },
    {
        "source": "To get a pointer to a boxed value, dereference the box:",
        "suggest": "要获得指向 boxed 值的指针，请解引用 box:",
        "translate": ""
    },
    {
        "source": "This does not take ownership of the original allocation and requires no resource management later, but you must not use the pointer after its lifetime.",
        "suggest": "这不会获得原始分配的所有权，并且以后不需要任何资源管理，但是您一定不能在其生命周期之后使用该指针。",
        "translate": ""
    },
    {
        "source": "Consume a box (`Box<T>`).",
        "suggest": "消费 box (`Box<T>`)。",
        "translate": ""
    },
    {
        "source": "The [`into_raw`] function consumes a box and returns the raw pointer.",
        "suggest": "[`into_raw`] 函数使用 box 并返回裸指针。",
        "translate": ""
    },
    {
        "source": "It doesn't destroy `T` or deallocate any memory.",
        "suggest": "它不会销毁 `T` 或释放任何内存。",
        "translate": ""
    },
    {
        "source": "Note that here the call to [`drop`] is for clarity - it indicates that we are done with the given value and it should be destroyed.",
        "suggest": "请注意，此处对 [`drop`] 的调用是为了清楚起见 - 表示我们已经完成了给定值的操作，应将其销毁。",
        "translate": ""
    },
    {
        "source": "Get it from C.",
        "suggest": "从 C 获取它。",
        "translate": ""
    },
    {
        "source": "Usually you wouldn't literally use `malloc` and `free` from Rust, but C APIs hand out a lot of pointers generally, so are a common source of raw pointers in Rust.",
        "suggest": "通常，您实际上不会使用 Rust 中的 `malloc` 和 `free`，但是 C API 通常会发出很多指针，因此 Rust 中的裸指针常见来源。",
        "translate": ""
    },
    {
        "source": "unfortunately, rustdoc doesn't have fuzzy search for aliases",
        "suggest": "不幸的是，rustdoc 没有对别名的模糊搜索",
        "translate": ""
    },
    {
        "source": "A fixed-size array, denoted `[T; N]`, for the element type, `T`, and the non-negative compile-time constant size,",
        "suggest": "一个固定大小的数组，表示为 `[T; N]`，用于元素类型 `T` 和非负编译时常量大小，",
        "translate": ""
    },
    {
        "source": "There are two syntactic forms for creating an array:",
        "suggest": "创建数组有两种语法形式:",
        "translate": ""
    },
    {
        "source": "A list with each element, i.e.,",
        "suggest": "每个元素的列表，即",
        "translate": ""
    },
    {
        "source": "A repeat expression `[x; N]`, which produces an array with `N` copies of `x`.",
        "suggest": "重复表达式 `[x; N]`，该数组生成包含 `x` 的 `N` 副本的数组。",
        "translate": ""
    },
    {
        "source": "The type of `x` must be [`Copy`].",
        "suggest": "`x` 的类型必须为 [`Copy`]。",
        "translate": ""
    },
    {
        "source": "Note that `[expr; 0]` is allowed, and produces an empty array.",
        "suggest": "请注意，`[expr; 0]` 是允许的，并产生一个空数组。",
        "translate": ""
    },
    {
        "source": "Arrays of *any* size implement the following traits if the element type allows it:",
        "suggest": "如果元素类型允许，则 *any* 大小的数组将实现以下 traits:",
        "translate": ""
    },
    {
        "source": "(implemented for `&[T; N]` and `&mut [T; N]`)",
        "suggest": "(针对 `&[T; N]` 和 `&mut [T; N]` 实现)",
        "translate": ""
    },
    {
        "source": "Arrays of sizes from 0 to 32 (inclusive) implement the [`Default`] trait if the element type allows it.",
        "suggest": "如果元素类型允许，则大小为 0 到 32 (inclusive) 的数组将实现 [`Default`] trait。",
        "translate": ""
    },
    {
        "source": "As a stopgap, trait implementations are statically generated up to size 32.",
        "suggest": "作为权宜之计，trait 实现是静态生成的，最大大小为 32。",
        "translate": ""
    },
    {
        "source": "Arrays coerce to [slices (`[T]`)][slice], so a slice method may be called on an array.",
        "suggest": "数组强制转换为 [slices (`[T]`) ][slice]，因此可以在数组上调用 slice 方法。",
        "translate": ""
    },
    {
        "source": "Indeed, this provides most of the API for working with arrays.",
        "suggest": "实际上，这提供了用于处理数组的大多数 API。",
        "translate": ""
    },
    {
        "source": "Slices have a dynamic size and do not coerce to arrays.",
        "suggest": "切片具有动态大小，并且不强制转换为数组。",
        "translate": ""
    },
    {
        "source": "You can move elements out of an array with a [slice pattern].",
        "suggest": "您可以使用 [slice pattern] 将元素移出数组。",
        "translate": ""
    },
    {
        "source": "If you want one element, see [`mem::replace`].",
        "suggest": "如果需要一个元素，请参见 [`mem::replace`]。",
        "translate": ""
    },
    {
        "source": "An array itself is not iterable:",
        "suggest": "数组本身是不可迭代的:",
        "translate": ""
    },
    {
        "source": "The solution is to coerce the array to a slice by calling a slice method:",
        "suggest": "解决方案是通过调用切片方法将数组强制为切片:",
        "translate": ""
    },
    {
        "source": "You can also use the array reference's [`IntoIterator`] implementation:",
        "suggest": "您还可以使用数组引用的 [`IntoIterator`] 实现:",
        "translate": ""
    },
    {
        "source": "You can use a [slice pattern] to move elements out of an array:",
        "suggest": "您可以使用 [slice pattern] 将元素移出数组:",
        "translate": ""
    },
    {
        "source": "Contiguous here means that elements are laid out so that every element is the same distance from its neighbors.",
        "suggest": "这里的连续意味着元素的布局应使每个元素与其相邻元素之间的距离相同。",
        "translate": ""
    },
    {
        "source": "As slices store the length of the sequence they refer to, they have twice the size of pointers to [`Sized`](marker/trait.Sized.html) types.",
        "suggest": "当切片存储所引用序列的长度时，它们的指针大小是 [`Sized`](marker/trait.Sized.html) 类型的两倍。",
        "translate": ""
    },
    {
        "source": "Also see the reference on [dynamically sized types](../reference/dynamically-sized-types.html).",
        "suggest": "另请参见 [dynamically sized types](../reference/dynamically-sized-types.html) 上的引用。",
        "translate": ""
    },
    {
        "source": "String slices.",
        "suggest": "字符串片。",
        "translate": ""
    },
    {
        "source": "The `str` type, also called a 'string slice', is the most primitive string type.",
        "suggest": "`str` 类型，也称为字符串切片，是最原始的字符串类型。",
        "translate": ""
    },
    {
        "source": "It is usually seen in its borrowed form,",
        "suggest": "通常以借用形式出现",
        "translate": ""
    },
    {
        "source": "It is also the type of string literals,",
        "suggest": "也是字面量的类型",
        "translate": ""
    },
    {
        "source": "String slices are always valid UTF-8.",
        "suggest": "字符串片始终是有效的 UTF-8。",
        "translate": ""
    },
    {
        "source": "String literals are string slices:",
        "suggest": "字符串字面量是字符串切片:",
        "translate": ""
    },
    {
        "source": "They are `'static` because they're stored directly in the final binary, and so will be valid for the `'static` duration.",
        "suggest": "它们是 `'static`，因为它们直接存储在最终二进制文件中，因此在 `'static` 持续时间内有效。",
        "translate": ""
    },
    {
        "source": "A `&str` is made up of two components: a pointer to some bytes, and a length.",
        "suggest": "`&str` 由两个部分组成: 一个指向某些字节的指针和一个长度。",
        "translate": ""
    },
    {
        "source": "You can look at these with the [`as_ptr`] and [`len`] methods:",
        "suggest": "您可以使用 [`as_ptr`] 和 [`len`] 方法查看它们:",
        "translate": ""
    },
    {
        "source": "This example shows the internals of `&str`.",
        "suggest": "本示例显示了 `&str` 的内部结构。",
        "translate": ""
    },
    {
        "source": "should not be used to get a string slice under normal circumstances.",
        "suggest": "通常情况下，不应使用它来获取字符串切片。",
        "translate": ""
    },
    {
        "source": "Use `as_str` instead.",
        "suggest": "请改用 `as_str`。",
        "translate": ""
    },
    {
        "source": "A finite heterogeneous sequence,",
        "suggest": "有限的异质序列，",
        "translate": ""
    },
    {
        "source": "Let's cover each of those in turn:",
        "suggest": "让我们依次介绍每个:",
        "translate": ""
    },
    {
        "source": "Tuples are *finite*.",
        "suggest": "元组是有限的。",
        "translate": ""
    },
    {
        "source": "In other words, a tuple has a length.",
        "suggest": "换句话说，元组具有长度。",
        "translate": ""
    },
    {
        "source": "Here's a tuple of length `3`:",
        "suggest": "这是长度为 `3` 的元组:",
        "translate": ""
    },
    {
        "source": "is also sometimes called 'arity' here;",
        "suggest": "在这里有时也称为 'arity';",
        "translate": ""
    },
    {
        "source": "each tuple of a different length is a different, distinct type.",
        "suggest": "每个不同长度的元组都是不同的，不同的类型。",
        "translate": ""
    },
    {
        "source": "Tuples are *heterogeneous*.",
        "suggest": "元组是异构的。",
        "translate": ""
    },
    {
        "source": "This means that each element of the tuple can have a different type.",
        "suggest": "这意味着元组的每个元素可以具有不同的类型。",
        "translate": ""
    },
    {
        "source": "In that tuple above, it has the type:",
        "suggest": "在上面的元组中，其类型为:",
        "translate": ""
    },
    {
        "source": "Tuples are a *sequence*.",
        "suggest": "元组是一个序列。",
        "translate": ""
    },
    {
        "source": "This means that they can be accessed by position;",
        "suggest": "这意味着可以按位置访问它们;",
        "translate": ""
    },
    {
        "source": "this is called 'tuple indexing', and it looks like this:",
        "suggest": "这称为元组索引，它看起来像这样:",
        "translate": ""
    },
    {
        "source": "The sequential nature of the tuple applies to its implementations of various traits.",
        "suggest": "元组的顺序性质适用于各种 traits 的实现。",
        "translate": ""
    },
    {
        "source": "For example, in `PartialOrd` and `Ord`, the elements are compared sequentially until the first non-equal set is found.",
        "suggest": "例如，在 `PartialOrd` 和 `Ord` 中，顺序比较元素，直到找到第一个非等式集合。",
        "translate": ""
    },
    {
        "source": "For more about tuples, see [the book](../book/ch03-02-data-types.html#the-tuple-type).",
        "suggest": "有关元组的更多信息，请参见 [the book](../book/ch03-02-data-types.html#the-tuple-type)。",
        "translate": ""
    },
    {
        "source": "If every type inside a tuple implements one of the following traits, then a tuple itself also implements it.",
        "suggest": "如果元组中的每个类型都实现以下 traits 之一，则元组本身也将实现它。",
        "translate": ""
    },
    {
        "source": "Due to a temporary restriction in Rust's type system, these traits are only implemented on tuples of arity 12 or less.",
        "suggest": "由于 Rust 的类型系统中的临时限制，这些 traits 仅在 Arity 12 以下的元组上实现。",
        "translate": ""
    },
    {
        "source": "In the future, this may change.",
        "suggest": "未来，这可能会改变。",
        "translate": ""
    },
    {
        "source": "Tuples are often used as a return type when you want to return more than one value:",
        "suggest": "当您要返回多个值时，通常将元组用作返回类型:",
        "translate": ""
    },
    {
        "source": "A 32-bit floating point type (specifically, the \"binary32\" type defined in IEEE 754-2008).",
        "suggest": "32 位浮点类型 (特别是 IEEE 754-2008 中定义的 \"binary32\" 类型)。",
        "translate": ""
    },
    {
        "source": "This type can represent a wide range of decimal numbers, like `3.5`, `27`, `-113.75`, `0.0078125`, `34359738368`, `0`, `-1`.",
        "suggest": "此类型可以表示各种十进制数字，例如 `3.5`，`27`，`-113.75`，`0.0078125`，`34359738368`，`0`，`-1`。",
        "translate": ""
    },
    {
        "source": "So unlike integer types (such as `i32`), floating point types can represent non-integer numbers, too.",
        "suggest": "因此，与整数类型 (例如 `i32`) 不同，浮点类型也可以表示非整数。",
        "translate": ""
    },
    {
        "source": "However, being able to represent this wide range of numbers comes at the cost of precision: floats can only represent some of the real numbers and calculation with floats round to a nearby representable number.",
        "suggest": "但是，能够表示这么广泛的数字是以牺牲精度为代价的: 浮点数只能表示某些实数，并且计算时会将浮点数舍入到附近的可表示数字。",
        "translate": ""
    },
    {
        "source": "For example, `5.0` and `1.0` can be exactly represented as `f32`, but `1.0 / 5.0` results in `0.20000000298023223876953125` since `0.2` cannot be exactly represented as `f32`.",
        "suggest": "例如，`5.0` 和 `1.0` 可以精确地表示为 `f32`，但是 `1.0 / 5.0` 会导致 `0.20000000298023223876953125`，因为 `0.2` 不能精确地表示为 `f32`。",
        "translate": ""
    },
    {
        "source": "Note, however, that printing floats with `println` and friends will often discard insignificant digits: `println!(\"{}\", 1.0f32 / 5.0f32)` will print `0.2`.",
        "suggest": "但是请注意，带有 `println` 的浮动彩信和朋友经常会丢弃无关紧要的数字: `println!(\"{}\", 1.0f32 / 5.0f32)` 会打印 `0.2`。",
        "translate": ""
    },
    {
        "source": "Additionally, `f32` can represent a couple of special values:",
        "suggest": "此外，`f32` 可以代表几个特殊值:",
        "translate": ""
    },
    {
        "source": "this is just due to how floats are encoded.",
        "suggest": "这仅仅是由于浮点数是如何编码的。",
        "translate": ""
    },
    {
        "source": "It is semantically equivalent to `0` and `-0.0 == 0.0` results in `true`.",
        "suggest": "从语义上讲，它等效于 `0`，`true` 中的 `-0.0 == 0.0` 结果。",
        "translate": ""
    },
    {
        "source": "and [−∞](#associatedconstant.NEG_INFINITY): these result from calculations like `1.0 / 0.0`.",
        "suggest": "和 [−∞](#associatedconstant.NEG_INFINITY): 这些是通过 `1.0 / 0.0` 之类的计算得出的。",
        "translate": ""
    },
    {
        "source": "this value results from calculations like `(-1.0).sqrt()`.",
        "suggest": "该值是由 `(-1.0).sqrt()` 之类的计算得出的。",
        "translate": ""
    },
    {
        "source": "NaN has some potentially unexpected behavior: it is unequal to any float, including itself!",
        "suggest": "NaN 有一些潜在的意外行为: 它不等于任何浮点数，包括它本身!",
        "translate": ""
    },
    {
        "source": "It is also neither smaller nor greater than any float, making it impossible to sort.",
        "suggest": "它也不小于或大于任何浮点数，因此无法分类。",
        "translate": ""
    },
    {
        "source": "Lastly, it is considered infectious as almost all calculations where one of the operands is NaN will also result in NaN.",
        "suggest": "最后，由于操作数之一为 NaN 的几乎所有计算也将产生 NaN，因此它被认为具有传染性。",
        "translate": ""
    },
    {
        "source": "For more information on floating point numbers, see [Wikipedia][wikipedia].",
        "suggest": "有关浮点数的更多信息，请参见 [Wikipedia][wikipedia]。",
        "translate": ""
    },
    {
        "source": "A 64-bit floating point type (specifically, the \"binary64\" type defined in IEEE 754-2008).",
        "suggest": "64 位浮点类型 (特别是 IEEE 754-2008 中定义的 \"binary64\" 类型)。",
        "translate": ""
    },
    {
        "source": "This type is very similar to [`f32`], but has increased precision by using twice as many bits.",
        "suggest": "此类型与 [`f32`] 非常相似，但是通过使用两倍的位来提高精度。",
        "translate": ""
    },
    {
        "source": "Please see [the documentation for `f32`][`f32`] or [Wikipedia on double precision values][wikipedia] for more information.",
        "suggest": "请参见 [`f32`] 的文档或关于双精度值的 [维基百科][wikipedia] 了解更多信息。",
        "translate": ""
    },
    {
        "source": "The 8-bit signed integer type.",
        "suggest": "8 位带符号整数类型。",
        "translate": ""
    },
    {
        "source": "The 16-bit signed integer type.",
        "suggest": "16 位带符号整数类型。",
        "translate": ""
    },
    {
        "source": "The 32-bit signed integer type.",
        "suggest": "32 位带符号整数类型。",
        "translate": ""
    },
    {
        "source": "The 64-bit signed integer type.",
        "suggest": "64 位带符号整数类型。",
        "translate": ""
    },
    {
        "source": "The 128-bit signed integer type.",
        "suggest": "128 位带符号整数类型。",
        "translate": ""
    },
    {
        "source": "The 8-bit unsigned integer type.",
        "suggest": "8 位无符号整数类型。",
        "translate": ""
    },
    {
        "source": "The 16-bit unsigned integer type.",
        "suggest": "16 位无符号整数类型。",
        "translate": ""
    },
    {
        "source": "The 32-bit unsigned integer type.",
        "suggest": "32 位无符号整数类型。",
        "translate": ""
    },
    {
        "source": "The 64-bit unsigned integer type.",
        "suggest": "64 位无符号整数类型。",
        "translate": ""
    },
    {
        "source": "The 128-bit unsigned integer type.",
        "suggest": "128 位无符号整数类型。",
        "translate": ""
    },
    {
        "source": "The pointer-sized signed integer type.",
        "suggest": "指针大小的有符号整数类型。",
        "translate": ""
    },
    {
        "source": "The size of this primitive is how many bytes it takes to reference any location in memory.",
        "suggest": "该原语的大小是引用内存中任何位置所需要的字节数。",
        "translate": ""
    },
    {
        "source": "For example, on a 32 bit target, this is 4 bytes and on a 64 bit target, this is 8 bytes.",
        "suggest": "例如，在 32 位目标上，这是 4 个字节，而在 64 位目标上，这是 8 个字节。",
        "translate": ""
    },
    {
        "source": "The pointer-sized unsigned integer type.",
        "suggest": "指针大小的无符号整数类型。",
        "translate": ""
    },
    {
        "source": "References, both shared and mutable.",
        "suggest": "引用，共享和可变。",
        "translate": ""
    },
    {
        "source": "A reference represents a borrow of some owned value.",
        "suggest": "引用代表某种拥有值的借用。",
        "translate": ""
    },
    {
        "source": "You can get one by using the `&` or `&mut` operators on a value, or by using a `ref` or `ref mut` pattern.",
        "suggest": "您可以通过在值上使用 `&` 或 `&mut` 运算符，或者使用 `ref` 或 `ref mut` 模式来获得一个。",
        "translate": ""
    },
    {
        "source": "For those familiar with pointers, a reference is just a pointer that is assumed to be aligned, not null, and pointing to memory containing a valid value of `T` - for example, `&bool` can only point to an allocation containing the integer values `1` (`true`) or `0` (`false`), but creating a `&bool` that points to an allocation containing the value `3` causes undefined behaviour.",
        "suggest": "对于熟悉指针的人来说，引用只是假定为已对齐的指针，而不是 null，并且指向包含有效值 `T` 的内存 - 例如，`&bool` 只能指向包含整数值 `1` (`true`) 或 `0` (`false`)，但是创建指向包含值 `3` 的分配的 `&bool` 会导致未定义的行为。",
        "translate": ""
    },
    {
        "source": "In fact, `Option<&T>` has the same memory representation as a nullable but aligned pointer, and can be passed across FFI boundaries as such.",
        "suggest": "实际上，`Option<&T>` 与可为空但对齐的指针具有相同的内存表示形式，因此可以跨 FFI 边界传递。",
        "translate": ""
    },
    {
        "source": "In most cases, references can be used much like the original value.",
        "suggest": "在大多数情况下，引用可以像原始值一样使用。",
        "translate": ""
    },
    {
        "source": "Field access, method calling, and indexing work the same (save for mutability rules, of course).",
        "suggest": "字段访问，方法调用和索引工作相同 (当然，要保留可变性规则)。",
        "translate": ""
    },
    {
        "source": "In addition, the comparison operators transparently defer to the referent's implementation, allowing references to be compared the same as owned values.",
        "suggest": "另外，比较运算符透明地遵从引用对象的实现，从而允许将引用与拥有的值进行比较。",
        "translate": ""
    },
    {
        "source": "References have a lifetime attached to them, which represents the scope for which the borrow is valid.",
        "suggest": "引用具有附加的生命周期，代表借用有效的作用域。",
        "translate": ""
    },
    {
        "source": "A lifetime is said to \"outlive\" another one if its representative scope is as long or longer than the other.",
        "suggest": "如果一个生命周期的代表作用域与另一个生命周期一样长或更长，则将其称为 \"outlive\"。",
        "translate": ""
    },
    {
        "source": "The `'static` lifetime is the longest lifetime, which represents the total life of the program.",
        "suggest": "`'static` 生命周期是最长的生命周期，它代表程序的总生命周期。",
        "translate": ""
    },
    {
        "source": "For example, string literals have a `'static` lifetime because the text data is embedded into the binary of the program, rather than in an allocation that needs to be dynamically managed.",
        "suggest": "例如，字符串字面量具有 `'static` 生命周期，因为文本数据嵌入到程序的二进制文件中，而不是嵌入在需要动态管理的分配中。",
        "translate": ""
    },
    {
        "source": "references can be freely coerced into `&T` references with the same referent type, and references with longer lifetimes can be freely coerced into references with shorter ones.",
        "suggest": "相同的引用类型可以将引用自由地强制为 `&T`，较长生命周期的引用可以自由地强制为 `&T`。",
        "translate": ""
    },
    {
        "source": "Reference equality by address, instead of comparing the values pointed to, is accomplished via implicit reference-pointer coercion and raw pointer equality via [`ptr::eq`], while [`PartialEq`] compares values.",
        "suggest": "通过地址引用相等，而不是比较所指向的值，是通过 [`ptr::eq`] 通过隐式引用指针强制和裸指针相等来实现的，而 [`PartialEq`] 则是对值进行比较。",
        "translate": ""
    },
    {
        "source": "For more information on how to use references, see [the book's section on \"References and Borrowing\"][book-refs].",
        "suggest": "有关如何使用引用的更多信息，请参见 [the book's section on \"References and Borrowing\"][book-refs]。",
        "translate": ""
    },
    {
        "source": "The following traits are implemented for all `&T`, regardless of the type of its referent:",
        "suggest": "对于所有 `&T` 都实现了以下 traits，无论其引用的类型是什么:",
        "translate": ""
    },
    {
        "source": "\\(Note that this will not defer to `T`'s `Clone` implementation if it exists!)",
        "suggest": "\\(请注意，如果存在，这不会遵循 T 的 `Clone` 实现! )",
        "translate": ""
    },
    {
        "source": "references get all of the above except `Copy` and `Clone` (to prevent creating multiple simultaneous mutable borrows), plus the following, regardless of the type of its referent:",
        "suggest": "引用除了 `Copy` 和 `Clone` (以防止创建多个同时可变借用) 之外，还获得以下所有内容，以及以下内容，无论其引用的类型是什么:",
        "translate": ""
    },
    {
        "source": "The following traits are implemented on `&T` references if the underlying `T` also implements that trait:",
        "suggest": "如果基础 `T` 也实现了 trait，则在 `&T` 上实现以下 traits:",
        "translate": ""
    },
    {
        "source": "All the traits in [`std::fmt`] except [`Pointer`] and [`fmt::Write`]",
        "suggest": "[`std::fmt`] 中的所有 traits ([`Pointer`] 和 [`fmt::Write`] 除外)",
        "translate": ""
    },
    {
        "source": "\\(in addition, `&T` references get [`FnMut`] and [`FnOnce`] if `T: Fn`)",
        "suggest": "\\(此外，如果使用 `T: Fn`，则引用 `&T` 和 [`FnOnce`])",
        "translate": ""
    },
    {
        "source": "references get all of the above except `ToSocketAddrs`, plus the following, if `T` implements that trait:",
        "suggest": "引用如果 `T` 实现了 trait，则获得除 `ToSocketAddrs` 之外的所有上述内容:",
        "translate": ""
    },
    {
        "source": "\\(in addition, `&mut T` references get [`FnOnce`] if `T: FnMut`)",
        "suggest": "\\(此外，如果 `T: FnMut` 引用 `&mut T`，则获得 [`FnOnce`])",
        "translate": ""
    },
    {
        "source": "\\(note that `&T` references only get `Send` if `T: Sync`)",
        "suggest": "\\(请注意，如果使用 `T: Sync`，则 `&T` 引用仅获得 `Send`)",
        "translate": ""
    },
    {
        "source": "Note that due to method call deref coercion, simply calling a trait method will act like they work on references as well as they do on owned values!",
        "suggest": "请注意，由于采用了调用解引用强制多态方法，只需调用 trait 方法就可以像处理引用一样，也可以使用其拥有的值!",
        "translate": ""
    },
    {
        "source": "The implementations described here are meant for generic contexts, where the final type `T` is a type parameter or otherwise not locally known.",
        "suggest": "这里描述的实现是针对泛型上下文的，其中最终类型 `T` 是类型参数或本地未知。",
        "translate": ""
    },
    {
        "source": "Function pointers, like `fn(usize) -> bool`.",
        "suggest": "函数指针，例如 `fn(usize) -> bool`。",
        "translate": ""
    },
    {
        "source": "See also the traits [`Fn`], [`FnMut`], and [`FnOnce`].",
        "suggest": "另请参见 traits [`Fn`]，[`FnMut`] 和 [`FnOnce`]。",
        "translate": ""
    },
    {
        "source": "Function pointers are pointers that point to *code*, not data.",
        "suggest": "函数指针是指向 *code* 的指针，而不是数据。",
        "translate": ""
    },
    {
        "source": "They can be called just like functions.",
        "suggest": "它们可以像函数一样被调用。",
        "translate": ""
    },
    {
        "source": "Like references, function pointers are, among other things, assumed to not be null, so if you want to pass a function pointer over FFI and be able to accommodate null pointers, make your type `Option<fn()>` with your required signature.",
        "suggest": "像引用一样，函数指针除其他外被假定为非 null，因此，如果您想在 FFI 上传递函数指针并能够容纳 null 指针，请使 `Option<fn()>` 类型具有所需的签名。",
        "translate": ""
    },
    {
        "source": "Plain function pointers are obtained by casting either plain functions, or closures that don't capture an environment:",
        "suggest": "普通函数指针是通过强制转换不能捕获环境的普通函数或闭包而获得的:",
        "translate": ""
    },
    {
        "source": "In addition to varying based on their signature, function pointers come in two flavors: safe and unsafe.",
        "suggest": "除了根据其签名而有所不同外，函数指针还具有两种形式: 安全和不安全。",
        "translate": ""
    },
    {
        "source": "Plain `fn()` function pointers can only point to safe functions, while `unsafe fn()` function pointers can point to safe or unsafe functions.",
        "suggest": "普通 `fn()` 函数指针只能指向安全函数，而 `unsafe fn()` 函数指针可以指向安全或不安全函数。",
        "translate": ""
    },
    {
        "source": "On top of that, function pointers can vary based on what ABI they use.",
        "suggest": "最重要的是，函数指针可以根据它们使用的 ABI 有所不同。",
        "translate": ""
    },
    {
        "source": "This is achieved by adding the `extern` keyword before the type, followed by the ABI in question.",
        "suggest": "这是通过在类型之前添加 `extern` 关键字，然后是所涉及的 ABI 来实现的。",
        "translate": ""
    },
    {
        "source": "The default ABI is \"Rust\", i.e., `fn()` is the exact same type as `extern \"Rust\" fn()`.",
        "suggest": "默认的 ABI 是 \"Rust\"，即 `fn()` 是与 `extern \"Rust\" fn()` 完全相同的类型。",
        "translate": ""
    },
    {
        "source": "A pointer to a function with C ABI would have type `extern \"C\" fn()`.",
        "suggest": "指向带有 C ABI 的函数的指针的类型为 `extern \"C\" fn()`。",
        "translate": ""
    },
    {
        "source": "blocks declare functions with ABI \"ABI\".",
        "suggest": "块使用 ABI \"ABI\" 声明函数。",
        "translate": ""
    },
    {
        "source": "The default here is \"C\", i.e., functions declared in an `extern {...}` block have \"C\" ABI.",
        "suggest": "此处的默认值为 \"C\"，即，在 `extern {...}` 块中声明的函数具有 \"C\" ABI。",
        "translate": ""
    },
    {
        "source": "For more information and a list of supported ABIs, see [the nomicon's section on foreign calling conventions][nomicon-abi].",
        "suggest": "有关更多信息和受支持的 ABI 列表，请参见 [the nomicon's section on foreign calling conventions][nomicon-abi]。",
        "translate": ""
    },
    {
        "source": "Variadic functions",
        "suggest": "可变函数",
        "translate": ""
    },
    {
        "source": "Extern function declarations with the \"C\" or \"cdecl\" ABIs can also be *variadic*, allowing them to be called with a variable number of arguments.",
        "suggest": "\"C\" 或 \"cdecl\" ABI 的 Extern 函数声明也可以 *variadic*，允许使用可变数量的参数来调用它们。",
        "translate": ""
    },
    {
        "source": "Normal Rust functions, even those with an `extern \"ABI\"`, cannot be variadic.",
        "suggest": "普通的 Rust 函数，即使是 `extern \"ABI\"` 的函数，也不能可变。",
        "translate": ""
    },
    {
        "source": "For more information, see [the nomicon's section on variadic functions][nomicon-variadic].",
        "suggest": "有关更多信息，请参见 [关于可变参数函数的 nomicon 部分][nomicon-variadic]。",
        "translate": ""
    },
    {
        "source": "Creating function pointers",
        "suggest": "创建函数指针",
        "translate": ""
    },
    {
        "source": "When `bar` is the name of a function, then the expression `bar` is *not* a function pointer.",
        "suggest": "如果 `bar` 是函数的名称，则表达式 `bar`*不是* 函数指针。",
        "translate": ""
    },
    {
        "source": "Rather, it denotes a value of an unnameable type that uniquely identifies the function `bar`.",
        "suggest": "相反，它表示唯一标识函数 `bar` 的无法命名类型的值。",
        "translate": ""
    },
    {
        "source": "The value is zero-sized because the type already identifies the function.",
        "suggest": "该值的大小为零，因为该类型已经标识了该函数。",
        "translate": ""
    },
    {
        "source": "This has the advantage that \"calling\" the value (it implements the `Fn*` traits) does not require dynamic dispatch.",
        "suggest": "这样做的好处是 \"calling\" 值 (实现 `Fn*` traits) 不需要动态分配。",
        "translate": ""
    },
    {
        "source": "This zero-sized type *coerces* to a regular function pointer.",
        "suggest": "零大小的类型 *强制* 到常规函数指针。",
        "translate": ""
    },
    {
        "source": "The last line shows that `&bar` is not a function pointer either.",
        "suggest": "最后一行显示 `&bar` 也不是函数指针。",
        "translate": ""
    },
    {
        "source": "Rather, it is a reference to the function-specific ZST.",
        "suggest": "相反，它是特定于函数的 ZST 的引用。",
        "translate": ""
    },
    {
        "source": "`&bar` is basically never what you want when `bar` is a function.",
        "suggest": "当 `bar` 是一个函数时，`&bar` 基本上不是您想要的。",
        "translate": ""
    },
    {
        "source": "Function pointers implement the following traits:",
        "suggest": "函数指针实现以下 traits:",
        "translate": ""
    },
    {
        "source": "Due to a temporary restriction in Rust's type system, these traits are only implemented on functions that take 12 arguments or less, with the `\"Rust\"` and `\"C\"` ABIs.",
        "suggest": "由于 Rust 的类型系统中的临时限制，这些 traits 仅在 `\"Rust\"` 和 `\"C\"` ABI 上使用不超过 12 个参数的函数上实现。",
        "translate": ""
    },
    {
        "source": "In addition, function pointers of *any* signature, ABI, or safety are [`Copy`], and all *safe* function pointers implement [`Fn`], [`FnMut`], and [`FnOnce`].",
        "suggest": "另外，具有 *any* 签名，ABI 或 safety 的函数指针是 [`Copy`]，并且所有 *safe* 函数指针都实现 [`Fn`]，[`FnMut`] 和 [`FnOnce`]。",
        "translate": ""
    },
    {
        "source": "This works because these traits are specially known to the compiler.",
        "suggest": "之所以可行，是因为这些 traits 是编译器特有的。",
        "translate": ""
    },
    {
        "source": "these tests should not all be ignored on android.",
        "suggest": "这些测试在 android 上不应全部被忽略。",
        "translate": ""
    },
    {
        "source": "In some build environments (such as chrooted Nix builds), `env` can only be found in the explicitly-provided PATH env variable, not in default places such as /bin or /usr/bin.",
        "suggest": "在某些构建环境 (例如 chroot 的 Nix 构建) 中，只能在显式提供的 PATH env 变量中找到 `env`，而在默认位置 (例如 /bin 或 /usr/bin) 中找不到 `env`。",
        "translate": ""
    },
    {
        "source": "So we need to pass through PATH to our sub-process.",
        "suggest": "因此，我们需要通过 PATH 进入子进程。",
        "translate": ""
    },
    {
        "source": "This variable will not be present if the environment has already been captured above.",
        "suggest": "如果上面已经捕获了环境，则该变量将不存在。",
        "translate": ""
    },
    {
        "source": "Regression tests for #30858.",
        "suggest": "#30858 的回归测试。",
        "translate": ""
    },
    {
        "source": "Regression tests for #30862.",
        "suggest": "#30862 的回归测试。",
        "translate": ""
    },
    {
        "source": "Tests that process creation flags work by debugging a process.",
        "suggest": "通过调试进程来测试进程创建标志是否起作用。",
        "translate": ""
    },
    {
        "source": "Other creation flags make it hard or impossible to detect behavioral changes in the process.",
        "suggest": "其他创建标志使得检测过程中的行为变化变得困难或不可能。",
        "translate": ""
    },
    {
        "source": "This is a union in the real struct, but we don't need this data for the purposes of this test.",
        "suggest": "这是真实结构中的一个 union，但是我们不需要这个数据来进行这个测试。",
        "translate": ""
    },
    {
        "source": "stdout must be configured with `Stdio::piped` in order to use",
        "suggest": "stdout 必须配置 `Stdio::piped` 才能使用",
        "translate": ""
    },
    {
        "source": "Note that `echo_child` is moved here, but we won't be needing `echo_child` anymore",
        "suggest": "请注意，`echo_child` 已移到此处，但我们不再需要 `echo_child`",
        "translate": ""
    },
    {
        "source": "If the child process fills its stdout buffer, it may end up waiting until the parent reads the stdout, and not be able to read stdin in the meantime, causing a deadlock.",
        "suggest": "如果子进程填充了其 stdout 缓冲区，则它可能最终会等待，直到父进程读取 stdout，并且在此期间无法读取 stdin，从而导致死锁。",
        "translate": ""
    },
    {
        "source": "Writing from another thread ensures that stdout is being read at the same time, avoiding the problem.",
        "suggest": "从另一个线程进行写入可确保同时读取 stdout，从而避免了该问题。",
        "translate": ""
    },
    {
        "source": "Execute `ls` in the current directory of the program.",
        "suggest": "在程序的当前目录中执行 `ls`。",
        "translate": ""
    },
    {
        "source": "Change `ls` to execute in the root directory.",
        "suggest": "更改 `ls` 以在根目录中执行。",
        "translate": ""
    },
    {
        "source": "And then execute `ls` again but in the root directory.",
        "suggest": "然后再次在根目录中执行 `ls`。",
        "translate": ""
    },
    {
        "source": "Nothing echoed to console",
        "suggest": "控制台没有回显",
        "translate": ""
    },
    {
        "source": "echoed to console",
        "suggest": "回显到控制台",
        "translate": ""
    },
    {
        "source": "Ignores any piped-in input",
        "suggest": "忽略任何管道输入",
        "translate": ""
    },
    {
        "source": "Converted into a Stdio here",
        "suggest": "在此处转换为 Stdio",
        "translate": ""
    },
    {
        "source": "With the `foo.txt` file containing `Hello, world!\"",
        "suggest": "使用包含 `Hello，world! ` 的 `foo.txt` 文件。",
        "translate": ""
    },
    {
        "source": "Implicit File conversion into a Stdio",
        "suggest": "隐式文件转换为 Stdio",
        "translate": ""
    },
    {
        "source": "Application logic here",
        "suggest": "这里的应用逻辑",
        "translate": ""
    },
    {
        "source": "execution never gets here",
        "suggest": "执行永远不会到这里",
        "translate": ""
    },
    {
        "source": "the destructor implemented for HasDrop will never get run",
        "suggest": "为 HasDrop 实现的析构函数永远不会运行",
        "translate": ""
    },
    {
        "source": "A module for working with processes.",
        "suggest": "用于处理进程的模块。",
        "translate": ""
    },
    {
        "source": "This module is mostly concerned with spawning and interacting with child processes, but it also provides [`abort`] and [`exit`] for terminating the current process.",
        "suggest": "该模块主要与产生和与子进程交互有关，但是它也提供了 [`abort`] 和 [`exit`] 来终止当前进程。",
        "translate": ""
    },
    {
        "source": "Spawning a process",
        "suggest": "产生一个进程",
        "translate": ""
    },
    {
        "source": "The [`Command`] struct is used to configure and spawn processes:",
        "suggest": "[`Command`] 结构体用于配置和 spawn 进程:",
        "translate": ""
    },
    {
        "source": "Several methods on [`Command`], such as [`spawn`] or [`output`], can be used to spawn a process.",
        "suggest": "[`Command`] 上的几种方法 (例如 [`spawn`] 或 [`output`]) 可用于 spawn 进程。",
        "translate": ""
    },
    {
        "source": "In particular, [`output`] spawns the child process and waits until the process terminates, while [`spawn`] will return a [`Child`] that represents the spawned child process.",
        "suggest": "特别是，[`output`] 生成子进程并等待直到该进程终止，而 [`spawn`] 将返回代表生成的子进程的 [`Child`]。",
        "translate": ""
    },
    {
        "source": "Handling I/O",
        "suggest": "处理 I/O",
        "translate": ""
    },
    {
        "source": "The [`stdout`], [`stdin`], and [`stderr`] of a child process can be configured by passing an [`Stdio`] to the corresponding method on [`Command`].",
        "suggest": "可以通过将 [`Stdio`] 传递给 [`Command`] 上的相应方法来配置子进程的 [`stdout`]，[`stdin`] 和 [`stderr`]。",
        "translate": ""
    },
    {
        "source": "Once spawned, they can be accessed from the [`Child`].",
        "suggest": "生成后，可以从 [`Child`] 访问它们。",
        "translate": ""
    },
    {
        "source": "For example, piping output from one command into another command can be done like so:",
        "suggest": "例如，可以将一个命令的输出管道输送到另一命令，如下所示:",
        "translate": ""
    },
    {
        "source": "Note that [`ChildStderr`] and [`ChildStdout`] implement [`Read`] and [`ChildStdin`] implements [`Write`]:",
        "suggest": "请注意，[`ChildStderr`] 和 [`ChildStdout`] 实现 [`Read`]，而 [`ChildStdin`] 实现 [`Write`]:",
        "translate": ""
    },
    {
        "source": "Representation of a running or exited child process.",
        "suggest": "表示正在运行或退出的子进程。",
        "translate": ""
    },
    {
        "source": "This structure is used to represent and manage child processes.",
        "suggest": "该结构体用于表示和管理子进程。",
        "translate": ""
    },
    {
        "source": "A child process is created via the [`Command`] struct, which configures the spawning process and can itself be constructed using a builder-style interface.",
        "suggest": "子进程是通过 [`Command`] 结构体创建的，该子进程配置了生成进程，并且可以使用生成器样式的接口本身来创建子进程。",
        "translate": ""
    },
    {
        "source": "There is no implementation of [`Drop`] for child processes, so if you do not ensure the `Child` has exited then it will continue to run, even after the `Child` handle to the child process has gone out of scope.",
        "suggest": "子进程没有 [`Drop`] 的实现，所以如果您不确保 `Child` 已经退出，那么它会继续运行，即使在子进程的 `Child` 句柄已经离开作用域之后。",
        "translate": ""
    },
    {
        "source": "Calling [`wait`] (or other functions that wrap around it) will make the parent process wait until the child has actually exited before continuing.",
        "suggest": "调用 [`wait`] (或其他环绕它的函数) 将使父进程等待直到子进程实际退出后再继续。",
        "translate": ""
    },
    {
        "source": "On some systems, calling [`wait`] or similar is necessary for the OS to release resources.",
        "suggest": "在某些系统上，操作系统释放资源必须调用 [`wait`] 或类似方法。",
        "translate": ""
    },
    {
        "source": "A process that terminated but has not been waited on is still around as a \"zombie\".",
        "suggest": "终止但尚未等待的进程仍然是 \"zombie\"。",
        "translate": ""
    },
    {
        "source": "Leaving too many zombies around may exhaust global resources (for example process IDs).",
        "suggest": "留下太多的僵尸可能会耗尽整个资源 (例如，进程 ID)。",
        "translate": ""
    },
    {
        "source": "The standard library does *not* automatically wait on child processes (not even if the `Child` is dropped), it is up to the application developer to do so.",
        "suggest": "标准库不会自动等待子进程 (即使 `Child` 被丢弃也不会)，这取决于应用程序开发人员。",
        "translate": ""
    },
    {
        "source": "As a consequence, dropping `Child` handles without waiting on them first is not recommended in long-running applications.",
        "suggest": "因此，在长时间运行的应用程序中，不建议先丢弃 `Child` 句柄而不先等待它们。",
        "translate": ""
    },
    {
        "source": "The handle for writing to the child's standard input (stdin), if it has been captured.",
        "suggest": "写入子节点标准输入 (stdin) 的句柄 (如果已捕获)。",
        "translate": ""
    },
    {
        "source": "To avoid partially moving the `child` and thus blocking yourself from calling functions on `child` while using `stdin`, you might find it helpful:",
        "suggest": "为避免部分移动 `child` 并因此阻止您自己在使用 `stdin` 时在 `child` 上调用函数，您可能会发现它很有用:",
        "translate": ""
    },
    {
        "source": "The handle for reading from the child's standard output (stdout), if it has been captured.",
        "suggest": "从子节点的标准输出 (stdout) 读取的句柄 (如果已捕获)。",
        "translate": ""
    },
    {
        "source": "You might find it helpful to do",
        "suggest": "您可能会发现这样做很有帮助",
        "translate": ""
    },
    {
        "source": "to avoid partially moving the `child` and thus blocking yourself from calling functions on `child` while using `stdout`.",
        "suggest": "为了避免部分移动 `child`，从而在使用 `stdout` 时阻止自己在 `child` 上调用函数。",
        "translate": ""
    },
    {
        "source": "The handle for reading from the child's standard error (stderr), if it has been captured.",
        "suggest": "从子节点的标准错误 (stderr) 读取的句柄 (如果已捕获)。",
        "translate": ""
    },
    {
        "source": "to avoid partially moving the `child` and thus blocking yourself from calling functions on `child` while using `stderr`.",
        "suggest": "为了避免部分移动 `child`，从而在使用 `stderr` 时阻止自己在 `child` 上调用函数。",
        "translate": ""
    },
    {
        "source": "A handle to a child process's standard input (stdin).",
        "suggest": "子进程的标准输入 (stdin) 的句柄。",
        "translate": ""
    },
    {
        "source": "This struct is used in the [`stdin`] field on [`Child`].",
        "suggest": "该结构体用于 [`Child`] 的 [`stdin`] 字段中。",
        "translate": ""
    },
    {
        "source": "When an instance of `ChildStdin` is [dropped], the `ChildStdin`'s underlying file handle will be closed.",
        "suggest": "当 `ChildStdin` 的实例是 [dropped] 时，`ChildStdin` 的基础文件句柄将关闭。",
        "translate": ""
    },
    {
        "source": "If the child process was blocked on input prior to being dropped, it will become unblocked after dropping.",
        "suggest": "如果子进程在丢弃之前已在输入上被阻止，则子进程将在丢弃后变为未阻止状态。",
        "translate": ""
    },
    {
        "source": "A handle to a child process's standard output (stdout).",
        "suggest": "子进程的标准输出 (stdout) 的句柄。",
        "translate": ""
    },
    {
        "source": "This struct is used in the [`stdout`] field on [`Child`].",
        "suggest": "该结构体用于 [`Child`] 的 [`stdout`] 字段中。",
        "translate": ""
    },
    {
        "source": "When an instance of `ChildStdout` is [dropped], the `ChildStdout`'s underlying file handle will be closed.",
        "suggest": "当 `ChildStdout` 的实例是 [dropped] 时，`ChildStdout` 的基础文件句柄将关闭。",
        "translate": ""
    },
    {
        "source": "A handle to a child process's stderr.",
        "suggest": "子进程的 stderr 的句柄。",
        "translate": ""
    },
    {
        "source": "This struct is used in the [`stderr`] field on [`Child`].",
        "suggest": "该结构体用于 [`Child`] 的 [`stderr`] 字段中。",
        "translate": ""
    },
    {
        "source": "When an instance of `ChildStderr` is [dropped], the `ChildStderr`'s underlying file handle will be closed.",
        "suggest": "当 `ChildStderr` 的实例是 [dropped] 时，`ChildStderr` 的基础文件句柄将关闭。",
        "translate": ""
    },
    {
        "source": "A process builder, providing fine-grained control over how a new process should be spawned.",
        "suggest": "进程生成器，提供对如何生成新进程的细粒度控制。",
        "translate": ""
    },
    {
        "source": "A default configuration can be generated using `Command::new(program)`, where `program` gives a path to the program to be executed.",
        "suggest": "可以使用 `Command::new(program)` 生成默认配置，其中 `program` 提供了要执行的程序的路径。",
        "translate": ""
    },
    {
        "source": "Additional builder methods allow the configuration to be changed (for example, by adding arguments) prior to spawning:",
        "suggest": "其他生成器方法允许在生成之前更改配置 (例如，通过添加参数) :",
        "translate": ""
    },
    {
        "source": "can be reused to spawn multiple processes.",
        "suggest": "可以重用到 spawn 的多个进程。",
        "translate": ""
    },
    {
        "source": "The builder methods change the command without needing to immediately spawn the process.",
        "suggest": "构建器方法无需立即使进程 spawn 即可更改命令。",
        "translate": ""
    },
    {
        "source": "Similarly, you can call builder methods after spawning a process and then spawn a new process with the modified settings.",
        "suggest": "同样，您可以在生成进程之后调用构建器方法，然后使用修改后的设置 spawn 新建一个进程。",
        "translate": ""
    },
    {
        "source": "Constructs a new `Command` for launching the program at path `program`, with the following default configuration:",
        "suggest": "使用以下默认配置创建一个新的 `Command`，以在路径 `program` 处启动该程序:",
        "translate": ""
    },
    {
        "source": "No arguments to the program",
        "suggest": "程序无参数",
        "translate": ""
    },
    {
        "source": "Inherit the current process's environment",
        "suggest": "继承当前进程的环境",
        "translate": ""
    },
    {
        "source": "Inherit the current process's working directory",
        "suggest": "继承当前进程的工作目录",
        "translate": ""
    },
    {
        "source": "Inherit stdin/stdout/stderr for `spawn` or `status`, but create pipes for `output`",
        "suggest": "为 `spawn` 或 `status` 继承 stdin/stdout/stderr，但为 `output` 创建管道",
        "translate": ""
    },
    {
        "source": "Builder methods are provided to change these defaults and otherwise configure the process.",
        "suggest": "提供了生成器方法来更改这些默认值，并以其他方式配置该进程。",
        "translate": ""
    },
    {
        "source": "If `program` is not an absolute path, the `PATH` will be searched in an OS-defined way.",
        "suggest": "如果 `program` 不是绝对路径，则将以 OS 定义的方式搜索 `PATH`。",
        "translate": ""
    },
    {
        "source": "The search path to be used may be controlled by setting the `PATH` environment variable on the Command, but this has some implementation limitations on Windows (see issue #37519).",
        "suggest": "可以通过在 Command 上设置 `PATH` 环境变量来控制要使用的搜索路径，但这在 Windows 上有一些实现上的限制 (请参见 issue #37519)。",
        "translate": ""
    },
    {
        "source": "Adds an argument to pass to the program.",
        "suggest": "添加参数以传递给程序。",
        "translate": ""
    },
    {
        "source": "Only one argument can be passed per use.",
        "suggest": "每次使用只能传递一个参数。",
        "translate": ""
    },
    {
        "source": "So instead of:",
        "suggest": "因此，而不是:",
        "translate": ""
    },
    {
        "source": "usage would be:",
        "suggest": "用法是:",
        "translate": ""
    },
    {
        "source": "To pass multiple arguments see [`args`].",
        "suggest": "要传递多个参数，请参见 [`args`]。",
        "translate": ""
    },
    {
        "source": "Note that the argument is not passed through a shell, but given literally to the program.",
        "suggest": "注意，该参数不是通过 shell 传递的，而是按字面意义提供给程序的。",
        "translate": ""
    },
    {
        "source": "This means that shell syntax like quotes, escaped characters, word splitting, glob patterns, substitution, etc.",
        "suggest": "这意味着 shell 语法，例如引号，转义字符，单词拆分，全局模式，替换等。",
        "translate": ""
    },
    {
        "source": "have no effect.",
        "suggest": "没有效果。",
        "translate": ""
    },
    {
        "source": "Adds multiple arguments to pass to the program.",
        "suggest": "添加多个参数以传递给程序。",
        "translate": ""
    },
    {
        "source": "To pass a single argument see [`arg`].",
        "suggest": "要传递单个参数，请参见 [`arg`]。",
        "translate": ""
    },
    {
        "source": "Note that the arguments are not passed through a shell, but given literally to the program.",
        "suggest": "请注意，该参数不是通过 shell 传递的，而是按字面意义提供给程序的。",
        "translate": ""
    },
    {
        "source": "Inserts or updates an environment variable mapping.",
        "suggest": "插入或更新环境变量映射。",
        "translate": ""
    },
    {
        "source": "Note that environment variable names are case-insensitive (but case-preserving) on Windows, and case-sensitive on all other platforms.",
        "suggest": "请注意，环境变量名称在 Windows 上不区分大小写 (但保留大小写)，在所有其他平台上则区分大小写。",
        "translate": ""
    },
    {
        "source": "Adds or updates multiple environment variable mappings.",
        "suggest": "添加或更新多个环境变量映射。",
        "translate": ""
    },
    {
        "source": "Removes an environment variable mapping.",
        "suggest": "删除环境变量映射。",
        "translate": ""
    },
    {
        "source": "Clears the entire environment map for the child process.",
        "suggest": "清除子进程的整个环境 map。",
        "translate": ""
    },
    {
        "source": "Sets the working directory for the child process.",
        "suggest": "设置子进程的工作目录。",
        "translate": ""
    },
    {
        "source": "If the program path is relative (e.g., `\"./script.sh\"`), it's ambiguous whether it should be interpreted relative to the parent's working directory or relative to `current_dir`.",
        "suggest": "如果程序路径是相对路径 (例如 `\"./script.sh\"`)，则是相对于父级工作目录还是相对于 `current_dir` 来解释路径。",
        "translate": ""
    },
    {
        "source": "The behavior in this case is platform specific and unstable, and it's recommended to use [`canonicalize`] to get an absolute program path instead.",
        "suggest": "这种情况下的行为是特定于平台且不稳定的，建议使用 [`canonicalize`] 来获取绝对程序路径。",
        "translate": ""
    },
    {
        "source": "Configuration for the child process's standard input (stdin) handle.",
        "suggest": "子进程的标准输入 (stdin) 句柄的配置。",
        "translate": ""
    },
    {
        "source": "Defaults to [`inherit`] when used with `spawn` or `status`, and defaults to [`piped`] when used with `output`.",
        "suggest": "与 `spawn` 或 `status` 一起使用时默认为 [`inherit`]，与 `output` 一起使用时默认为 [`piped`]。",
        "translate": ""
    },
    {
        "source": "Configuration for the child process's standard output (stdout) handle.",
        "suggest": "子进程的标准输出 (stdout) 句柄的配置。",
        "translate": ""
    },
    {
        "source": "Configuration for the child process's standard error (stderr) handle.",
        "suggest": "子进程的标准错误 (stderr) 句柄的配置。",
        "translate": ""
    },
    {
        "source": "Executes the command as a child process, returning a handle to it.",
        "suggest": "将命令作为子进程执行，并返回其句柄。",
        "translate": ""
    },
    {
        "source": "By default, stdin, stdout and stderr are inherited from the parent.",
        "suggest": "默认情况下，stdin、stdout 和 stderr 都是从父级继承的。",
        "translate": ""
    },
    {
        "source": "Executes the command as a child process, waiting for it to finish and collecting all of its output.",
        "suggest": "将命令作为子进程执行，等待其完成并收集所有输出。",
        "translate": ""
    },
    {
        "source": "By default, stdout and stderr are captured (and used to provide the resulting output).",
        "suggest": "默认情况下，将捕获 stdout 和 stderr (并用于提供结果输出)。",
        "translate": ""
    },
    {
        "source": "Stdin is not inherited from the parent and any attempt by the child process to read from the stdin stream will result in the stream immediately closing.",
        "suggest": "Stdin 不是从父级继承的，子进程尝试从 stdin 流中进行读取的任何尝试都将导致该流立即关闭。",
        "translate": ""
    },
    {
        "source": "Executes a command as a child process, waiting for it to finish and collecting its status.",
        "suggest": "将命令作为子进程执行，等待其完成并收集其状态。",
        "translate": ""
    },
    {
        "source": "Returns the path to the program that was given to [`Command::new`].",
        "suggest": "返回给 [`Command::new`] 的程序的路径。",
        "translate": ""
    },
    {
        "source": "Returns an iterator of the arguments that will be passed to the program.",
        "suggest": "返回将传递给程序的参数的迭代器。",
        "translate": ""
    },
    {
        "source": "This does not include the path to the program as the first argument;",
        "suggest": "这不包括程序的路径作为第一个参数;",
        "translate": ""
    },
    {
        "source": "it only includes the arguments specified with [`Command::arg`] and [`Command::args`].",
        "suggest": "它仅包含 [`Command::arg`] 和 [`Command::args`] 指定的参数。",
        "translate": ""
    },
    {
        "source": "Returns an iterator of the environment variables that will be set when the process is spawned.",
        "suggest": "返回将在生成进程时设置的环境变量的迭代器。",
        "translate": ""
    },
    {
        "source": "Each element is a tuple `(&OsStr, Option<&OsStr>)`, where the first value is the key, and the second is the value, which is [`None`] if the environment variable is to be explicitly removed.",
        "suggest": "每个元素都是一个元组 `(&OsStr, Option<&OsStr>)`，其中第一个值为键，第二个为值，如果要显式删除环境变量，则为 [`None`]。",
        "translate": ""
    },
    {
        "source": "This only includes environment variables explicitly set with [`Command::env`], [`Command::envs`], and [`Command::env_remove`].",
        "suggest": "这仅包括用 [`Command::env`]，[`Command::envs`] 和 [`Command::env_remove`] 显式设置的环境变量。",
        "translate": ""
    },
    {
        "source": "It does not include environment variables that will be inherited by the child process.",
        "suggest": "它不包括子进程将继承的环境变量。",
        "translate": ""
    },
    {
        "source": "Returns the working directory for the child process.",
        "suggest": "返回子进程的工作目录。",
        "translate": ""
    },
    {
        "source": "This returns [`None`] if the working directory will not be changed.",
        "suggest": "如果不更改工作目录，则返回 [`None`]。",
        "translate": ""
    },
    {
        "source": "Format the program and arguments of a Command for display.",
        "suggest": "格式化命令的程序和参数以进行显示。",
        "translate": ""
    },
    {
        "source": "Any non-utf8 data is lossily converted using the utf8 replacement character.",
        "suggest": "使用 utf8 替换字符有损地转换所有非 utf8 数据。",
        "translate": ""
    },
    {
        "source": "An iterator over the command arguments.",
        "suggest": "命令的迭代器。",
        "translate": ""
    },
    {
        "source": "This struct is created by [`Command::get_args`].",
        "suggest": "该结构体由 [`Command::get_args`] 创建。",
        "translate": ""
    },
    {
        "source": "The output of a finished process.",
        "suggest": "完成的进程的输出。",
        "translate": ""
    },
    {
        "source": "This is returned in a Result by either the [`output`] method of a [`Command`], or the [`wait_with_output`] method of a [`Child`] process.",
        "suggest": "[`Command`] 的 [`output`] 方法或 [`Child`] 进程的 [`wait_with_output`] 方法在结果中返回该值。",
        "translate": ""
    },
    {
        "source": "The status (exit code) of the process.",
        "suggest": "进程的状态 (退出代码)。",
        "translate": ""
    },
    {
        "source": "The data that the process wrote to stdout.",
        "suggest": "进程写入 stdout 的数据。",
        "translate": ""
    },
    {
        "source": "The data that the process wrote to stderr.",
        "suggest": "进程写入 stderr 的数据。",
        "translate": ""
    },
    {
        "source": "If either stderr or stdout are valid utf8 strings it prints the valid strings, otherwise it prints the byte sequence instead",
        "suggest": "如果 stderr 或 stdout 是有效的 utf8 字符串，它将打印有效的字符串，否则将打印字节序列。",
        "translate": ""
    },
    {
        "source": "Describes what to do with a standard I/O stream for a child process when passed to the [`stdin`], [`stdout`], and [`stderr`] methods of [`Command`].",
        "suggest": "描述当传递给 [`Command`] 的 [`stdin`]，[`stdout`] 和 [`stderr`] 方法时，如何对子进程使用标准 I/O 流。",
        "translate": ""
    },
    {
        "source": "A new pipe should be arranged to connect the parent and child processes.",
        "suggest": "应该安排一个新管道来连接父进程和子进程。",
        "translate": ""
    },
    {
        "source": "With stdout:",
        "suggest": "使用 stdout:",
        "translate": ""
    },
    {
        "source": "With stdin:",
        "suggest": "使用 stdin:",
        "translate": ""
    },
    {
        "source": "Writing more than a pipe buffer's worth of input to stdin without also reading stdout and stderr at the same time may cause a deadlock.",
        "suggest": "在不同时读取 stdout 和 stderr 的情况下，向 stdin 写入超过管道缓冲区的输入值可能会导致死锁。",
        "translate": ""
    },
    {
        "source": "This is an issue when running any program that doesn't guarantee that it reads its entire stdin before writing more than a pipe buffer's worth of output.",
        "suggest": "这在运行任何不能保证在写入超过管道缓冲区的输出值之前不能保证读取其整个 stdin 的程序时就是一个问题。",
        "translate": ""
    },
    {
        "source": "The size of a pipe buffer varies on different targets.",
        "suggest": "管道缓冲区的大小在不同的目标上有所不同。",
        "translate": ""
    },
    {
        "source": "The child inherits from the corresponding parent descriptor.",
        "suggest": "子级从相应的父级描述符继承。",
        "translate": ""
    },
    {
        "source": "This stream will be ignored.",
        "suggest": "此流将被忽略。",
        "translate": ""
    },
    {
        "source": "This is the equivalent of attaching the stream to `/dev/null`.",
        "suggest": "这等效于将流附加到 `/dev/null`。",
        "translate": ""
    },
    {
        "source": "Converts a `ChildStdin` into a `Stdio`",
        "suggest": "将 `ChildStdin` 转换为 `Stdio`",
        "translate": ""
    },
    {
        "source": "will be converted to `Stdio` using `Stdio::from` under the hood.",
        "suggest": "将在引擎盖下使用 `Stdio::from` 转换为 `Stdio`。",
        "translate": ""
    },
    {
        "source": "Converts a `ChildStdout` into a `Stdio`",
        "suggest": "将 `ChildStdout` 转换为 `Stdio`",
        "translate": ""
    },
    {
        "source": "Converts a `ChildStderr` into a `Stdio`",
        "suggest": "将 `ChildStderr` 转换为 `Stdio`",
        "translate": ""
    },
    {
        "source": "Converts a `File` into a `Stdio`",
        "suggest": "将 `File` 转换为 `Stdio`",
        "translate": ""
    },
    {
        "source": "Describes the result of a process after it has terminated.",
        "suggest": "描述进程终止后的结果。",
        "translate": ""
    },
    {
        "source": "This `struct` is used to represent the exit status or other termination of a child process.",
        "suggest": "`struct` 用于表示子进程的退出状态或其他终止。",
        "translate": ""
    },
    {
        "source": "Child processes are created via the [`Command`] struct and their exit status is exposed through the [`status`] method, or the [`wait`] method of a [`Child`] process.",
        "suggest": "子进程是通过 [`Command`] 结构体创建的，其退出状态通过 [`status`] 方法或 [`Child`] 进程的 [`wait`] 方法公开。",
        "translate": ""
    },
    {
        "source": "An `ExitStatus` represents every possible disposition of a process.",
        "suggest": "`ExitStatus` 表示进程的每一种可能的配置。",
        "translate": ""
    },
    {
        "source": "On Unix this is the **wait status**.",
        "suggest": "在 Unix 上，这是等待状态。",
        "translate": ""
    },
    {
        "source": "It is *not* simply an *exit status* (a value passed to `exit`).",
        "suggest": "*不是* 仅仅是 *exit 状态*(传递给 `exit` 的值)。",
        "translate": ""
    },
    {
        "source": "For proper error reporting of failed processes, print the value of `ExitStatus` using its implementation of [`Display`](crate::fmt::Display).",
        "suggest": "为了正确报告失败的进程，请使用 [`Display`](crate::fmt::Display) 的实现来打印 `ExitStatus` 的值。",
        "translate": ""
    },
    {
        "source": "Was termination successful?",
        "suggest": "终止成功了吗?",
        "translate": ""
    },
    {
        "source": "Signal termination is not considered a success, and success is defined as a zero exit status.",
        "suggest": "信号终止不被视为成功，并且成功被定义为零退出状态。",
        "translate": ""
    },
    {
        "source": "Returns the exit code of the process, if any.",
        "suggest": "返回进程的退出代码 (如果有)。",
        "translate": ""
    },
    {
        "source": "In Unix terms the return value is the **exit status**: the value passed to `exit`, if the process finished by calling `exit`.",
        "suggest": "用 Unix 的术语来说，返回值是退出状态: 如果进程通过调用 `exit` 完成，则传递给 `exit` 的值。",
        "translate": ""
    },
    {
        "source": "Note that on Unix the exit status is truncated to 8 bits, and that values that didn't come from a program's call to `exit` may be invented the runtime system (often, for example, 255, 254, 127 or 126).",
        "suggest": "请注意，在 Unix 上，退出状态被截断为 8 位，并且不是从程序调用 `exit` 来的值可能是在运行时系统中发明的 (通常是 255、254、127 或 126)。",
        "translate": ""
    },
    {
        "source": "On Unix, this will return `None` if the process was terminated by a signal.",
        "suggest": "在 Unix 上，如果进程被信号终止，它将返回 `None`。",
        "translate": ""
    },
    {
        "source": "is an extension trait for extracting any such signal, and other details, from the `ExitStatus`.",
        "suggest": "是 trait 的扩展名，用于从 `ExitStatus` 中提取任何此类信号以及其他详细信息。",
        "translate": ""
    },
    {
        "source": "This type represents the status code a process can return to its parent under normal termination.",
        "suggest": "此类型表示进程在正常终止下可以返回其父级的状态代码。",
        "translate": ""
    },
    {
        "source": "Numeric values used in this type don't have portable meanings, and different platforms may mask different amounts of them.",
        "suggest": "此类型中使用的数字值没有可移植的含义，并且不同的平台可能会掩盖不同数量的含义。",
        "translate": ""
    },
    {
        "source": "For the platform's canonical successful and unsuccessful codes, see the [`SUCCESS`] and [`FAILURE`] associated items.",
        "suggest": "有关平台的规范成功和失败代码，请参见 [`SUCCESS`] 和 [`FAILURE`] 关联项。",
        "translate": ""
    },
    {
        "source": "**Warning**: While various forms of this were discussed in [RFC #1937], it was ultimately cut from that RFC, and thus this type is more subject to change even than the usual unstable item churn.",
        "suggest": "**警告**: 虽然在 [RFC #1937] 中讨论了各种形式，但最终还是从 RFC 中删除了该形式，因此，与通常的不稳定项搅动相比，该类型更容易发生变化。",
        "translate": ""
    },
    {
        "source": "The canonical ExitCode for successful termination on this platform.",
        "suggest": "在此平台上成功终止的规范 ExitCode。",
        "translate": ""
    },
    {
        "source": "Note that a `()`-returning `main` implicitly results in a successful termination, so there's no need to return this from `main` unless you're also returning other possible codes.",
        "suggest": "请注意，返回 `main` 的 ` () ` 隐式导致成功终止，因此除非您还返回了其他可能的代码，否则无需从 `main` 返回此值。",
        "translate": ""
    },
    {
        "source": "The canonical ExitCode for unsuccessful termination on this platform.",
        "suggest": "在此平台上无法成功终止的规范 ExitCode。",
        "translate": ""
    },
    {
        "source": "If you're only returning this and `SUCCESS` from `main`, consider instead returning `Err(_)` and `Ok(())` respectively, which will return the same codes (but will also `eprintln!` the error).",
        "suggest": "如果仅从 `main` 返回此代码和 `SUCCESS`，则考虑分别返回 `Err(_)` 和 `Ok(())`，这将返回相同的代码 (但也会返回 `eprintln!` 错误)。",
        "translate": ""
    },
    {
        "source": "Forces the child process to exit.",
        "suggest": "强制子进程退出。",
        "translate": ""
    },
    {
        "source": "If the child has already exited, an [`InvalidInput`] error is returned.",
        "suggest": "如果子节点已经退出，则返回 [`InvalidInput`] 错误。",
        "translate": ""
    },
    {
        "source": "The mapping to [`ErrorKind`]s is not part of the compatibility contract of the function, especially the [`Other`] kind might change to more specific kinds in the future.",
        "suggest": "到 [`ErrorKind`] 的映射不是函数兼容性契约的一部分，尤其是 [`Other`] 类型可能会在 future 中更改为更特定的类型。",
        "translate": ""
    },
    {
        "source": "This is equivalent to sending a SIGKILL on Unix platforms.",
        "suggest": "这等效于在 Unix 平台上发送 SIGKILL。",
        "translate": ""
    },
    {
        "source": "Returns the OS-assigned process identifier associated with this child.",
        "suggest": "返回与此子级关联的操作系统分配的进程标识符。",
        "translate": ""
    },
    {
        "source": "Waits for the child to exit completely, returning the status that it exited with.",
        "suggest": "等待子节点完全退出，并返回退出时的状态。",
        "translate": ""
    },
    {
        "source": "This function will continue to have the same return value after it has been called at least once.",
        "suggest": "至少调用一次之后，该函数将继续具有相同的返回值。",
        "translate": ""
    },
    {
        "source": "The stdin handle to the child process, if any, will be closed before waiting.",
        "suggest": "子进程的 stdin 句柄 (如果有) 将在等待之前关闭。",
        "translate": ""
    },
    {
        "source": "This helps avoid deadlock: it ensures that the child does not block waiting for input from the parent, while the parent waits for the child to exit.",
        "suggest": "这有助于避免死锁: 它确保子进程在父进程等待子进程退出时不会阻止其等待父进程的输入。",
        "translate": ""
    },
    {
        "source": "Attempts to collect the exit status of the child if it has already exited.",
        "suggest": "如果子节点已经退出，则尝试收集其退出状态。",
        "translate": ""
    },
    {
        "source": "This function will not block the calling thread and will only check to see if the child process has exited or not.",
        "suggest": "这个函数不会阻塞调用线程，只会检查子进程是否退出。",
        "translate": ""
    },
    {
        "source": "If the child has exited then on Unix the process ID is reaped.",
        "suggest": "如果子节点退出了，则在 Unix 上获取进程 ID。",
        "translate": ""
    },
    {
        "source": "This function is guaranteed to repeatedly return a successful exit status so long as the child has already exited.",
        "suggest": "只要子节点已经退出，就可以保证该函数重复返回成功的退出状态。",
        "translate": ""
    },
    {
        "source": "If the child has exited, then `Ok(Some(status))` is returned.",
        "suggest": "如果子节点已经退出，则返回 `Ok(Some(status))`。",
        "translate": ""
    },
    {
        "source": "If the exit status is not available at this time then `Ok(None)` is returned.",
        "suggest": "如果此时退出状态不可用，则返回 `Ok(None)`。",
        "translate": ""
    },
    {
        "source": "If an error occurs, then that error is returned.",
        "suggest": "如果发生错误，则返回该错误。",
        "translate": ""
    },
    {
        "source": "Note that unlike `wait`, this function will not attempt to drop stdin.",
        "suggest": "请注意，与 `wait` 不同，此函数不会尝试丢弃 stdin。",
        "translate": ""
    },
    {
        "source": "Simultaneously waits for the child to exit and collect all remaining output on the stdout/stderr handles, returning an `Output` instance.",
        "suggest": "同时等待子节点退出并收集 stdout/stderr 句柄上的所有剩余输出，并返回 `Output` 实例。",
        "translate": ""
    },
    {
        "source": "In order to capture the output into this `Result<Output>` it is necessary to create new pipes between parent and child.",
        "suggest": "为了将输出捕获到此 `Result<Output>` 中，必须在父级和子级之间创建新管道。",
        "translate": ""
    },
    {
        "source": "Use `stdout(Stdio::piped())` or `stderr(Stdio::piped())`, respectively.",
        "suggest": "分别使用 `stdout(Stdio::piped())` 或 `stderr(Stdio::piped())`。",
        "translate": ""
    },
    {
        "source": "Terminates the current process with the specified exit code.",
        "suggest": "使用指定的退出代码终止当前进程。",
        "translate": ""
    },
    {
        "source": "This function will never return and will immediately terminate the current process.",
        "suggest": "该函数将永远不会返回，并会立即终止当前进程。",
        "translate": ""
    },
    {
        "source": "The exit code is passed through to the underlying OS and will be available for consumption by another process.",
        "suggest": "退出代码将传递到底层操作系统，并且可供其他进程使用。",
        "translate": ""
    },
    {
        "source": "Note that because this function never returns, and that it terminates the process, no destructors on the current stack or any other thread's stack will be run.",
        "suggest": "请注意，由于此函数从不返回，并且终止了该进程，因此将不运行当前栈或任何其他线程的栈上的析构函数。",
        "translate": ""
    },
    {
        "source": "If a clean shutdown is needed it is recommended to only call this function at a known point where there are no more destructors left to run.",
        "suggest": "如果需要彻底关闭，建议仅在没有更多析构函数可以运行的已知点上调用此函数。",
        "translate": ""
    },
    {
        "source": "**Unix**: On Unix-like platforms, it is unlikely that all 32 bits of `exit` will be visible to a parent process inspecting the exit code.",
        "suggest": "**Unix**: 在类似 Unix 的平台上，检查父级退出代码的父进程不太可能看到 `exit` 的所有 32 位。",
        "translate": ""
    },
    {
        "source": "On most Unix-like platforms, only the eight least-significant bits are considered.",
        "suggest": "在大多数类 Unix 平台上，仅考虑八个最低有效位。",
        "translate": ""
    },
    {
        "source": "Due to this function’s behavior regarding destructors, a conventional way to use the function is to extract the actual computation to another function and compute the exit code from its return value:",
        "suggest": "由于此函数的行为与析构函数有关，因此使用该函数的常规方法是将实际的计算提取到另一个函数，并从其返回值计算退出代码:",
        "translate": ""
    },
    {
        "source": "Due to [platform-specific behavior], the exit code for this example will be `0` on Linux, but `256` on Windows:",
        "suggest": "由于 [platform-specific behavior]，此示例的退出代码将是 Linux 上的 `0`，但 Windows 上的 `256`:",
        "translate": ""
    },
    {
        "source": "Terminates the process in an abnormal fashion.",
        "suggest": "以异常方式终止进程。",
        "translate": ""
    },
    {
        "source": "The function will never return and will immediately terminate the current process in a platform specific \"abnormal\" manner.",
        "suggest": "该函数将永远不会返回，并会以特定于平台的 \"abnormal\" 方式立即终止当前进程。",
        "translate": ""
    },
    {
        "source": "This is in contrast to the default behaviour of [`panic!`] which unwinds the current thread's stack and calls all destructors.",
        "suggest": "这与 [`panic!`] 的默认行为相反，后者默认情况下会展开当前线程的栈并调用所有析构函数。",
        "translate": ""
    },
    {
        "source": "When `panic=\"abort\"` is set, either as an argument to `rustc` or in a crate's Cargo.toml, [`panic!`] and `abort` are similar.",
        "suggest": "设置 `panic=\"abort\"` 时，无论是 `rustc` 的参数还是 crate 的 Cargo.toml，[`panic!`] 和 `abort` 都是相似的。",
        "translate": ""
    },
    {
        "source": "However, [`panic!`] will still call the [panic hook] while `abort` will not.",
        "suggest": "但是，[`panic!`] 仍然会调用 [panic hook]，而 `abort` 不会。",
        "translate": ""
    },
    {
        "source": "The `abort` function terminates the process, so the destructor will not get run on the example below:",
        "suggest": "`abort` 函数会终止该进程，因此析构函数将不会在以下示例上运行:",
        "translate": ""
    },
    {
        "source": "Returns the OS-assigned process identifier associated with this process.",
        "suggest": "返回与此进程关联的操作系统分配的进程标识符。",
        "translate": ""
    },
    {
        "source": "A trait for implementing arbitrary return types in the `main` function.",
        "suggest": "trait，用于在 `main` 函数中实现任意返回类型。",
        "translate": ""
    },
    {
        "source": "The C-main function only supports to return integers as return type.",
        "suggest": "C-main 函数仅支持返回整数作为返回类型。",
        "translate": ""
    },
    {
        "source": "So, every type implementing the `Termination` trait has to be converted to an integer.",
        "suggest": "因此，实现 `Termination` trait 的每种类型都必须转换为整数。",
        "translate": ""
    },
    {
        "source": "The default implementations are returning `libc::EXIT_SUCCESS` to indicate a successful execution.",
        "suggest": "默认实现将返回 `libc::EXIT_SUCCESS` 以指示成功执行。",
        "translate": ""
    },
    {
        "source": "In case of a failure, `libc::EXIT_FAILURE` is returned.",
        "suggest": "如果发生故障，则返回 `libc::EXIT_FAILURE`。",
        "translate": ""
    },
    {
        "source": "Is called to get the representation of the value as status code.",
        "suggest": "被调用以获取值的表示形式作为状态码。",
        "translate": ""
    },
    {
        "source": "This status code is returned to the operating system.",
        "suggest": "此状态代码返回到操作系统。",
        "translate": ""
    },
    {
        "source": "Runtime services",
        "suggest": "运行时服务",
        "translate": ""
    },
    {
        "source": "The `rt` module provides a narrow set of runtime services, including the global heap (exported in `heap`) and unwinding and backtrace support.",
        "suggest": "`rt` 模块提供了一组 narrow 的运行时服务，包括全局堆 (在 `heap` 中导出) 以及展开和回溯支持。",
        "translate": ""
    },
    {
        "source": "The APIs in this module are highly unstable, and should be considered as private implementation details for the time being.",
        "suggest": "该模块中的 API 高度不稳定，因此暂时应将其视为私有实现细节。",
        "translate": ""
    },
    {
        "source": "Re-export some of our utilities which are expected by other crates.",
        "suggest": "重推出其他 crates 期望的一些实用工具。",
        "translate": ""
    },
    {
        "source": "To reduce the generated code of the new `lang_start`, this function is doing the real work.",
        "suggest": "为了减少新 `lang_start` 的生成代码，此函数正在做实际工作。",
        "translate": ""
    },
    {
        "source": "Next, set up the current Thread with the guard information we just created.",
        "suggest": "接下来，使用我们刚刚创建的保护信息设置当前线程。",
        "translate": ""
    },
    {
        "source": "Note that this isn't necessary in general for new threads, but we just do this to name the main thread and to give it correct info about the stack bounds.",
        "suggest": "请注意，通常对于新线程来说这不是必需的，但是我们只是这样做以命名主线程并为它提供有关栈边界的正确信息。",
        "translate": ""
    },
    {
        "source": "Store our args if necessary in a squirreled away location",
        "suggest": "如果需要，将我们的参数存储在一个松散的地方",
        "translate": ""
    },
    {
        "source": "Let's run some code!",
        "suggest": "让我们运行一些代码!",
        "translate": ""
    },
    {
        "source": "At this point, all spawned threads should be blocked, so we shouldn't get anything from the port",
        "suggest": "在这一点上，所有的新建线程应该被阻塞，所以我们不应该从端口得到任何东西",
        "translate": ""
    },
    {
        "source": "Now, the barrier is cleared and we should get data.",
        "suggest": "现在，障碍已清除，我们应该获取数据。",
        "translate": ""
    },
    {
        "source": "The same messages will be printed together.",
        "suggest": "相同的消息将一起打印。",
        "translate": ""
    },
    {
        "source": "You will NOT see any interleaving.",
        "suggest": "您将看不到任何交错。",
        "translate": ""
    },
    {
        "source": "Wait for other threads to finish.",
        "suggest": "等待其他线程完成。",
        "translate": ""
    },
    {
        "source": "A barrier enables multiple threads to synchronize the beginning of some computation.",
        "suggest": "屏障使多个线程能够同步某些计算的开始。",
        "translate": ""
    },
    {
        "source": "The inner state of a double barrier",
        "suggest": "双重屏障的内部状态",
        "translate": ""
    },
    {
        "source": "A `BarrierWaitResult` is returned by [`Barrier::wait()`] when all threads in the [`Barrier`] have rendezvoused.",
        "suggest": "当 [`Barrier`] 中的所有线程都汇合时，[`Barrier::wait()`] 将返回 `BarrierWaitResult`。",
        "translate": ""
    },
    {
        "source": "Creates a new barrier that can block a given number of threads.",
        "suggest": "创建一个新的屏障，该屏障可以阻止给定数量的线程。",
        "translate": ""
    },
    {
        "source": "A barrier will block `n`-1 threads which call [`wait()`] and then wake up all threads at once when the `n`th thread calls [`wait()`].",
        "suggest": "屏障将阻塞调用 [`wait()`] 的 `n - 1` 个线程，然后在第 n 个线程调用 [`wait()`] 时立即唤醒所有线程。",
        "translate": ""
    },
    {
        "source": "Blocks the current thread until all threads have rendezvoused here.",
        "suggest": "阻塞当前线程，直到所有线程都在此处集合为止。",
        "translate": ""
    },
    {
        "source": "Barriers are re-usable after all threads have rendezvoused once, and can be used continuously.",
        "suggest": "所有线程集合一次后，屏障可以重新使用，并且可以连续使用。",
        "translate": ""
    },
    {
        "source": "A single (arbitrary) thread will receive a [`BarrierWaitResult`] that returns `true` from [`BarrierWaitResult::is_leader()`] when returning from this function, and all other threads will receive a result that will return `false` from [`BarrierWaitResult::is_leader()`].",
        "suggest": "从该函数返回时，单个 (arbitrary) 线程将接收从 [`BarrierWaitResult::is_leader()`] 返回 `true` 的 [`BarrierWaitResult`]，而所有其他线程将接收从 [`BarrierWaitResult::is_leader()`] 返回 `false` 的结果。",
        "translate": ""
    },
    {
        "source": "We need a while loop to guard against spurious wakeups.",
        "suggest": "我们需要一个 while 循环来防止虚假唤醒。",
        "translate": ""
    },
    {
        "source": "Returns `true` if this thread is the \"leader thread\" for the call to [`Barrier::wait()`].",
        "suggest": "如果此线程是调用 [`Barrier::wait()`] 的 \"leader thread\"，则返回 `true`。",
        "translate": ""
    },
    {
        "source": "Only one thread will have `true` returned from their result, all other threads will have `false` returned.",
        "suggest": "只有一个线程从其结果返回 `true`，所有其他线程将返回 `false`。",
        "translate": ""
    },
    {
        "source": "Inside of our lock, spawn a new thread, and then wait for it to start.",
        "suggest": "在我们的锁内部，spawn 有一个新线程，然后等待它启动。",
        "translate": ""
    },
    {
        "source": "We notify the condvar that the value has changed.",
        "suggest": "我们通知 condvar 值已更改。",
        "translate": ""
    },
    {
        "source": "Wait for the thread to start up.",
        "suggest": "等待线程启动。",
        "translate": ""
    },
    {
        "source": "spurious wakeups mean this isn't necessarily true so execute test again, if not timeout",
        "suggest": "虚假唤醒意味着这不一定是正确的，因此如果没有超时，请再次执行测试",
        "translate": ""
    },
    {
        "source": "no spurious wakeups.",
        "suggest": "没有虚假的唤醒。",
        "translate": ""
    },
    {
        "source": "ensure it timed-out",
        "suggest": "确保它超时",
        "translate": ""
    },
    {
        "source": "ensure it didn't time-out even if we were not given any time.",
        "suggest": "确保即使我们没有时间也不会超时。",
        "translate": ""
    },
    {
        "source": "spurious wakeups mean this isn't necessarily true so execute test again, if not notified",
        "suggest": "虚假唤醒意味着这不一定是正确的，因此如果没有通知，请再次执行测试",
        "translate": ""
    },
    {
        "source": "Let's wait 20 milliseconds before notifying the condvar.",
        "suggest": "让我们等待 20 毫秒，然后再通知 condvar。",
        "translate": ""
    },
    {
        "source": "We update the boolean value.",
        "suggest": "我们更新布尔值。",
        "translate": ""
    },
    {
        "source": "Let's put a timeout on the condvar's wait.",
        "suggest": "让我们在 condvar 的等待上设置超时。",
        "translate": ""
    },
    {
        "source": "10 milliseconds have passed, or maybe the value changed!",
        "suggest": "10 毫秒已过去，或者值已更改!",
        "translate": ""
    },
    {
        "source": "We received the notification and the value has been updated, we can leave.",
        "suggest": "我们已收到通知，并且值已更新，我们可以离开。",
        "translate": ""
    },
    {
        "source": "As long as the value inside the `Mutex<bool>` is `false`, we wait.",
        "suggest": "只要 `Mutex<bool>` 内部的值为 `false`，我们就等待。",
        "translate": ""
    },
    {
        "source": "As long as the value inside the `Mutex<bool>` is `true`, we wait.",
        "suggest": "只要 `Mutex<bool>` 内部的值为 `true`，我们就等待。",
        "translate": ""
    },
    {
        "source": "wait for the thread to start up",
        "suggest": "等待线程启动",
        "translate": ""
    },
    {
        "source": "as long as the value inside the `Mutex<bool>` is `false`, we wait",
        "suggest": "只要 `Mutex<bool>` 内的值为 `false`，我们就等待",
        "translate": ""
    }
]
