[
    {
        "source": "generate the definition of `HandleStore` in `server.rs`.",
        "suggest": "在 `server.rs` 中生成 `HandleStore` 的定义。",
        "translate": ""
    },
    {
        "source": "Forward `Drop::drop` to the inherent `drop` method.",
        "suggest": "将 `Drop::drop` 转发到固有的 `drop` 方法。",
        "translate": ""
    },
    {
        "source": "generate these impls by pattern-matching on the names of methods - also could use the presence of `fn drop` to distinguish between 'owned and 'interned, above.",
        "suggest": "通过对方法名称进行模式匹配来生成这些 impls - 也可以使用 `fn drop` 的存在来区分上面的 'owned' 和 'interned'。",
        "translate": ""
    },
    {
        "source": "Alternatively, special 'modes\" could be listed of types in with_api instead of pattern matching on methods, here and in server decl.",
        "suggest": "或者，可以在 with_api 中列出特殊的 `modes` 类型，而不是在此以及在服务器 decl 中对方法进行模式匹配。",
        "translate": ""
    },
    {
        "source": "format the kind without quotes, as in `kind: Float`",
        "suggest": "格式化无引号的格式，例如 `kind: Float`",
        "translate": ""
    },
    {
        "source": "format `Some(\"...\")` on one line even in {:#?} mode",
        "suggest": "即使在 {:#?} 模式下，也可以在一行上格式化 `Some(\"...\")`",
        "translate": ""
    },
    {
        "source": "No server is currently connected to this client.",
        "suggest": "当前没有服务器连接到该客户端。",
        "translate": ""
    },
    {
        "source": "A server is connected and available for requests.",
        "suggest": "服务器已连接并且可用于请求。",
        "translate": ""
    },
    {
        "source": "Access to the bridge is being exclusively acquired (e.g., during `BridgeState::with`).",
        "suggest": "专门获取对网桥的访问权限 (例如，在 `BridgeState::with` 期间)。",
        "translate": ""
    },
    {
        "source": "Take exclusive control of the thread-local `BridgeState`, and pass it to `f`, mutably.",
        "suggest": "独占控制线程本地的 `BridgeState`，并将其可变地传递给 `f`。",
        "translate": ""
    },
    {
        "source": "The state will be restored after `f` exits, even by panic, including modifications made to it by `f`.",
        "suggest": "`f` 退出后，甚至 panic 都将恢复状态，包括 `f` 对它的修改。",
        "translate": ""
    },
    {
        "source": "N.B., while `f` is running, the thread-local state is `BridgeState::InUse`.",
        "suggest": "注意，在运行 `f` 时，线程本地状态为 `BridgeState::InUse`。",
        "translate": ""
    },
    {
        "source": "pass `f` directly to `replace` when `RefMutL` is gone",
        "suggest": "`RefMutL` 消失后，将 `f` 直接传递给 `replace`",
        "translate": ""
    },
    {
        "source": "Hide the default panic output within `proc_macro` expansions.",
        "suggest": "隐藏 `proc_macro` 扩展中的默认 panic 输出。",
        "translate": ""
    },
    {
        "source": "NB. the server can't do this because it may use a different libstd.",
        "suggest": "注意服务器无法执行此操作，因为它可能使用了不同的 libstd。",
        "translate": ""
    },
    {
        "source": "A client-side \"global object\" (usually a function pointer), which may be using a different `proc_macro` from the one used by the server, but can be interacted with compatibly.",
        "suggest": "客户端 \"global object\" (通常是函数指针)，可以使用与服务器使用的 `proc_macro` 不同的 `proc_macro`，但可以兼容地进行交互。",
        "translate": ""
    },
    {
        "source": "N.B., `F` must have FFI-friendly memory layout (e.g., a pointer).",
        "suggest": "注意，`F` 必须具有 FFI 友好的内存布局 (例如，指针)。",
        "translate": ""
    },
    {
        "source": "The call ABI of function pointers used for `F` doesn't need to match between server and client, since it's only passed between them and (eventually) called by the client.",
        "suggest": "用于 `F` 的函数指针的调用 ABI 不需要在服务器和客户端之间匹配，因为它仅在它们与客户端调用的 (eventually) 之间传递。",
        "translate": ""
    },
    {
        "source": "Client-side helper for handling client panics, entering the bridge, deserializing input and serializing output.",
        "suggest": "客户端帮助程序，用于处理客户端 panics，进入网桥，反序列化输入和序列化输出。",
        "translate": ""
    },
    {
        "source": "maybe replace `Bridge::enter` with this?",
        "suggest": "也许用这个代替 `Bridge::enter`?",
        "translate": ""
    },
    {
        "source": "The initial `cached_buffer` contains the input.",
        "suggest": "初始 `cached_buffer` 包含输入。",
        "translate": ""
    },
    {
        "source": "Put the `cached_buffer` back in the `Bridge`, for requests.",
        "suggest": "将 `cached_buffer` 放回 `Bridge`，以进行请求。",
        "translate": ""
    },
    {
        "source": "Take the `cached_buffer` back out, for the output value.",
        "suggest": "取出 `cached_buffer` 作为输出值。",
        "translate": ""
    },
    {
        "source": "Separate encoding a success value (`Ok(output)`) from encoding a panic (`Err(e: PanicMessage)`) to avoid having handles outside the `bridge.enter(|| ...)` scope, and to catch panics that could happen while encoding the success.",
        "suggest": "将成功值 (`Ok(output)`) 与对 panic (`Err(e: PanicMessage)`) 进行编码分开，以避免在 `bridge.enter(|| ...)` 作用域之外使用句柄，并捕获对成功编码时可能发生的 panics。",
        "translate": ""
    },
    {
        "source": "Note that panics should be impossible beyond this point, but this is defensively trying to avoid any accidental panicking reaching the `extern \"C\"` (which should `abort` but may not at the moment, so this is also potentially preventing UB).",
        "suggest": "请注意，panics 超出此范围应该是不可能的，但这是为了避免任何意外的恐慌而到达 `extern \"C\"` (`extern \"C\"` 应该是 `abort`，但目前可能不会，所以这也有可能阻止 UB)。",
        "translate": ""
    },
    {
        "source": "Closure type (equivalent to `&mut dyn FnMut(A) -> R`) that's `repr(C)`.",
        "suggest": "闭包类型 (等同于 `&mut dyn FnMut(A) -> R`) 为 `repr(C)`。",
        "translate": ""
    },
    {
        "source": "Server-side handles and storage for per-handle data.",
        "suggest": "服务器端句柄和每个句柄数据的存储。",
        "translate": ""
    },
    {
        "source": "Ensure the handle counter isn't 0, which would panic later, when `NonZeroU32::new` (aka `Handle::new`) is called in `alloc`.",
        "suggest": "确保在 `alloc` 中调用 `NonZeroU32::new` (也称为 `Handle::new`) 时，句柄计数器不为 0，之后为 panic。",
        "translate": ""
    },
    {
        "source": "Internal interface for communicating between a `proc_macro` client (a proc macro crate) and a `proc_macro` server (a compiler front-end).",
        "suggest": "`proc_macro` 客户端 (proc 宏 crate) 和 `proc_macro` 服务器 (编译器前端) 之间进行通信的内部接口。",
        "translate": ""
    },
    {
        "source": "Serialization (with C ABI buffers) and unique integer handles are employed to allow safely interfacing between two copies of `proc_macro` built (from the same source) by different compilers with potentially mismatching Rust ABIs (e.g., stage0/bin/rustc vs stage1/bin/rustc during bootstrap).",
        "suggest": "采用序列化 (带有 C ABI 缓冲区) 和唯一的整数句柄，以允许由不同编译器 (可能具有不匹配的 Rust ABI) (例如，引导过程中的 stage0/bin/rustc 与 stage1/bin/rustc) 安全地连接由不同编译器构建的 `proc_macro` 的两个副本 (来自同一源)。",
        "translate": ""
    },
    {
        "source": "Higher-order macro describing the server RPC API, allowing automatic generation of type-safe Rust APIs, both client-side and server-side.",
        "suggest": "描述服务器 RPC API 的高阶宏，允许在客户端和服务器端自动生成类型安全的 Rust API。",
        "translate": ""
    },
    {
        "source": "expands to:",
        "suggest": "扩展为:",
        "translate": ""
    },
    {
        "source": "The first two arguments serve to customize the arguments names and argument/return types, to enable several different usecases:",
        "suggest": "前两个参数用于自定义参数名称和 argument/return 类型，以启用几种不同的用例:",
        "translate": ""
    },
    {
        "source": "If `my_self` is just `self`, then each `fn` signature can be used as-is for a method.",
        "suggest": "如果 `my_self` 只是 `self`，则每个 `fn` 签名都可以按原样用作方法。",
        "translate": ""
    },
    {
        "source": "If it's anything else (`self_` in practice), then the signatures don't have a special `self` argument, and can, therefore, have a different one introduced.",
        "suggest": "如果还有其他问题 (实际上是 `self_`)，则签名没有特殊的 `self` 参数，因此可以引入其他签名。",
        "translate": ""
    },
    {
        "source": "If `MySelf` is just `Self`, then the types are only valid inside a trait or a trait impl, where the trait has associated types for each of the API types.",
        "suggest": "如果 `MySelf` 只是 `Self`，则这些类型仅在 trait 或 trait impl 中有效，其中 trait 具有每种 API 类型的关联类型。",
        "translate": ""
    },
    {
        "source": "If non-associated types are desired, a module name (`self` in practice) can be used instead of `Self`.",
        "suggest": "如果需要非关联类型，则可以使用模块名称 (实际上是 `self`) 代替 `Self`。",
        "translate": ""
    },
    {
        "source": "this calls `encode` for each argument, but in reverse, to avoid borrow conflicts from borrows started by `&mut` arguments.",
        "suggest": "这会为每个参数调用 `encode`，但相反，是为了避免 `&mut` 参数开始的借用与借用发生冲突。",
        "translate": ""
    },
    {
        "source": "this calls `decode` for each argument, but in reverse, to avoid borrow conflicts from borrows started by `&mut` arguments.",
        "suggest": "这会为每个参数调用 `decode`，但相反，是为了避免 `&mut` 参数开始的借用与借用发生冲突。",
        "translate": ""
    },
    {
        "source": "An active connection between a server and a client.",
        "suggest": "服务器和客户端之间的活动连接。",
        "translate": ""
    },
    {
        "source": "The server creates the bridge (`Bridge::run_server` in `server.rs`), then passes it to the client through the function pointer in the `run` field of `client::Client`.",
        "suggest": "服务器创建网桥 (`server.rs` 中的 `Bridge::run_server`)，然后通过 `client::Client` 的 `run` 字段中的函数指针将其传递给客户端。",
        "translate": ""
    },
    {
        "source": "The client holds its copy of the `Bridge` in TLS during its execution (`Bridge::{enter, with}` in `client.rs`).",
        "suggest": "客户端在执行期间将其 `Bridge` 的副本保存在 TLS 中 (`client.rs` 中的 `Bridge::{enter, with}`)。",
        "translate": ""
    },
    {
        "source": "Reusable buffer (only `clear`-ed, never shrunk), primarily used for making requests, but also for passing input to client.",
        "suggest": "可重复使用的缓冲区 (仅 `clear`，从不缩小)，主要用于发出请求，也用于将输入传递给客户端。",
        "translate": ""
    },
    {
        "source": "Server-side function that the client uses to make requests.",
        "suggest": "客户端用来发出请求的服务器端函数。",
        "translate": ""
    },
    {
        "source": "If 'true', always invoke the default panic hook",
        "suggest": "如果为 'true'，请始终调用默认的 panic hook",
        "translate": ""
    },
    {
        "source": "Helper to wrap associated types to allow trait impl dispatch.",
        "suggest": "帮助程序包装关联类型以允许 trait impl 调度。",
        "translate": ""
    },
    {
        "source": "That is, normally a pair of impls for `T::Foo` and `T::Bar` can overlap, but if the impls are, instead, on types like `Marked<T::Foo, Foo>` and `Marked<T::Bar, Bar>`, they can't.",
        "suggest": "也就是说，通常 `T::Foo` 和 `T::Bar` 的一对 impl 可以重叠，但是如果这些 impls 在 `Marked<T::Foo, Foo>` 和 `Marked<T::Bar, Bar>` 之类的类型上则不能重叠。",
        "translate": ""
    },
    {
        "source": "Unwrap types wrapped by `Mark::mark` (see `Mark` for details).",
        "suggest": "解开由 `Mark::mark` 包装的类型 (有关详细信息，请参见 `Mark`)。",
        "translate": ""
    },
    {
        "source": "Serialization for client-server communication.",
        "suggest": "客户端 - 服务器通信的序列化。",
        "translate": ""
    },
    {
        "source": "`Tag` enum duplicated between the two impls as there's no other place to stash it.",
        "suggest": "`Tag` 枚举在两个 impls 之间重复，因为没有其他地方可以隐藏它。",
        "translate": ""
    },
    {
        "source": "Simplied version of panic payloads, ignoring types other than `&'static str` and `String`.",
        "suggest": "panic 有效负载的简化版本，忽略 `&'static str` 和 `String` 以外的类型。",
        "translate": ""
    },
    {
        "source": "variant for (scoped) existential lifetimes.",
        "suggest": "(scoped) 存在的生命周期成员。",
        "translate": ""
    },
    {
        "source": "Type lambda application, with a lifetime.",
        "suggest": "输入具有生命周期的 lambda 应用程序。",
        "translate": ""
    },
    {
        "source": "Type lambda taking a lifetime, i.e.,",
        "suggest": "输入生命周期的 lambda 类型，即",
        "translate": ""
    },
    {
        "source": "work around projection limitations with a newtype FIXME(#52812) replace with `&'a mut <T as ApplyL<'b>>::Out`",
        "suggest": "使用 newtype FIXME(#52812) 来解决投影限制，用 `&'a mut <T as ApplyL<'b>>::Out` 代替",
        "translate": ""
    },
    {
        "source": "Sets the value in `self` to `replacement` while running `f`, which gets the old value, mutably.",
        "suggest": "在运行 `f` 时将 `self` 中的值设置为 `replacement`，该值可变地获取旧值。",
        "translate": ""
    },
    {
        "source": "The old value will be restored after `f` exits, even by panic, including modifications made to it by `f`.",
        "suggest": "`f` 退出后，即使是 panic 也将恢复旧值，包括 `f` 对其所做的修改。",
        "translate": ""
    },
    {
        "source": "Wrapper that ensures that the cell always gets filled (with the original state, optionally changed by `f`), even if `f` had panicked.",
        "suggest": "即使 `f` 发生了 panic，也可以确保始终填充 cell  (具有原始状态，可以通过 `f` 进行更改) 的包装器。",
        "translate": ""
    },
    {
        "source": "Sets the value in `self` to `value` while running `f`.",
        "suggest": "运行 `f` 时，将 `self` 中的值设置为 `value`。",
        "translate": ""
    },
    {
        "source": "Server-side traits.",
        "suggest": "服务器端 traits。",
        "translate": ""
    },
    {
        "source": "Declare an associated item of one of the traits below, optionally adjusting it (i.e., adding bounds to types and default bodies to methods).",
        "suggest": "声明以下 traits 之一的关联项，可以选择对其进行调整 (即，为类型添加边界，为方法添加默认主体)。",
        "translate": ""
    },
    {
        "source": "`pub` only for `ExecutionStrategy` below.",
        "suggest": "`pub` 仅适用于下面的 `ExecutionStrategy`。",
        "translate": ""
    },
    {
        "source": "these are here to allow `Self::$name` to work below.",
        "suggest": "这些是为了允许 `Self::$name` 在下面工作。",
        "translate": ""
    },
    {
        "source": "don't use `panic::catch_unwind` in a panic.",
        "suggest": "不要在 panic 中使用 `panic::catch_unwind`。",
        "translate": ""
    },
    {
        "source": "If client and server happen to use the same `libstd`, `catch_unwind` asserts that the panic counter was 0, even when the closure passed to it didn't panic.",
        "suggest": "如果客户机和服务器恰好使用相同的 `libstd`，则 `catch_unwind` 断言 panic 计数器为 0，即使传递给它的闭包不是 panic。",
        "translate": ""
    },
    {
        "source": "Two implementations are provided, the second one is a bit faster but neither is anywhere near as fast as same-thread execution.",
        "suggest": "提供了两种实现，第二种实现更快一些，但都没有同一线程执行那么快。",
        "translate": ""
    },
    {
        "source": "Wake up the server so it can exit the dispatch loop.",
        "suggest": "唤醒服务器，使其可以退出调度循环。",
        "translate": ""
    },
    {
        "source": "Check whether `state2` was dropped, to know when to stop.",
        "suggest": "检查 `state2` 是否被丢弃，以了解何时停止。",
        "translate": ""
    },
    {
        "source": "An enum representing a diagnostic level.",
        "suggest": "代表诊断级别的枚举。",
        "translate": ""
    },
    {
        "source": "An error.",
        "suggest": "一个错误。",
        "translate": ""
    },
    {
        "source": "A warning.",
        "suggest": "一个警告。",
        "translate": ""
    },
    {
        "source": "A note.",
        "suggest": "一条消息。",
        "translate": ""
    },
    {
        "source": "A help message.",
        "suggest": "一条帮助消息。",
        "translate": ""
    },
    {
        "source": "Trait implemented by types that can be converted into a set of `Span`s.",
        "suggest": "Trait 由可以转换为一组 `Span` 的类型实现。",
        "translate": ""
    },
    {
        "source": "Converts `self` into a `Vec<Span>`.",
        "suggest": "将 `self` 转换为 `Vec<Span>`。",
        "translate": ""
    },
    {
        "source": "A structure representing a diagnostic message and associated children messages.",
        "suggest": "表示诊断消息和关联的子消息的结构体。",
        "translate": ""
    },
    {
        "source": "Adds a new child diagnostic message to `self` with the level identified by this method's name with the given `spans` and `message`.",
        "suggest": "将新的子诊断消息添加到 `self`，其级别由此方法的名称以及给定的 `spans` 和 `message` 标识。",
        "translate": ""
    },
    {
        "source": "Adds a new child diagnostic message to `self` with the level identified by this method's name with the given `message`.",
        "suggest": "将新的子诊断消息添加到 `self`，其级别由该方法的名称和给定的 `message` 标识。",
        "translate": ""
    },
    {
        "source": "Iterator over the children diagnostics of a `Diagnostic`.",
        "suggest": "迭代 `Diagnostic` 的子级诊断。",
        "translate": ""
    },
    {
        "source": "Creates a new diagnostic with the given `level` and `message`.",
        "suggest": "使用给定的 `level` 和 `message` 创建新的诊断。",
        "translate": ""
    },
    {
        "source": "Creates a new diagnostic with the given `level` and `message` pointing to the given set of `spans`.",
        "suggest": "使用给定的 `level` 和 `message` 指向给定的 `spans` 集创建新的诊断。",
        "translate": ""
    },
    {
        "source": "Returns the diagnostic `level` for `self`.",
        "suggest": "返回 `self` 的诊断 `level`。",
        "translate": ""
    },
    {
        "source": "Sets the level in `self` to `level`.",
        "suggest": "将 `self` 中的级别设置为 `level`。",
        "translate": ""
    },
    {
        "source": "Returns the message in `self`.",
        "suggest": "以 `self` 返回消息。",
        "translate": ""
    },
    {
        "source": "Sets the message in `self` to `message`.",
        "suggest": "将 `self` 中的消息设置为 `message`。",
        "translate": ""
    },
    {
        "source": "Returns the `Span`s in `self`.",
        "suggest": "返回 `self` 中的 `Span`。",
        "translate": ""
    },
    {
        "source": "Sets the `Span`s in `self` to `spans`.",
        "suggest": "将 `self` 中的 `Span` 设置为 `spans`。",
        "translate": ""
    },
    {
        "source": "Returns an iterator over the children diagnostics of `self`.",
        "suggest": "返回 `self` 子诊断的迭代器。",
        "translate": ""
    },
    {
        "source": "Emit the diagnostic.",
        "suggest": "发出诊断信息。",
        "translate": ""
    },
    {
        "source": "A support library for macro authors when defining new macros.",
        "suggest": "定义新宏时为宏作者提供的支持库。",
        "translate": ""
    },
    {
        "source": "This library, provided by the standard distribution, provides the types consumed in the interfaces of procedurally defined macro definitions such as function-like macros `#[proc_macro]`, macro attributes `#[proc_macro_attribute]` and custom derive attributes`#[proc_macro_derive]`.",
        "suggest": "由标准发行版提供的该库提供了在过程定义的宏定义的接口中使用的类型，例如，类似函数的宏 `#[proc_macro]`，宏属性 `#[proc_macro_attribute]` 和自定义派生属性 `#[proc_macro_derive]`。",
        "translate": ""
    },
    {
        "source": "See [the book] for more.",
        "suggest": "有关更多信息，请参见 [the book]。",
        "translate": ""
    },
    {
        "source": "Determines whether proc_macro has been made accessible to the currently running program.",
        "suggest": "确定是否已使 proc_macro 可被当前正在运行的程序访问。",
        "translate": ""
    },
    {
        "source": "The proc_macro crate is only intended for use inside the implementation of procedural macros.",
        "suggest": "proc_macro crate 仅用于在过程宏的实现内部使用。",
        "translate": ""
    },
    {
        "source": "All the functions in this crate panic if invoked from outside of a procedural macro, such as from a build script or unit test or ordinary Rust binary.",
        "suggest": "crate panic 中的所有函数 (如果从程序宏外部调用，例如从构建脚本或单元测试或常规 Rust 二进制文件调用)。",
        "translate": ""
    },
    {
        "source": "With consideration for Rust libraries that are designed to support both macro and non-macro use cases, `proc_macro::is_available()` provides a non-panicking way to detect whether the infrastructure required to use the API of proc_macro is presently available.",
        "suggest": "考虑到旨在支持宏和非宏用例的 Rust 库，`proc_macro::is_available()` 提供了一种非 panic 的方式来检测使用 proc_macro API 所需的基础结构是否当前可用。",
        "translate": ""
    },
    {
        "source": "Returns true if invoked from inside of a procedural macro, false if invoked from any other binary.",
        "suggest": "如果从程序宏内部调用，则返回 true; 如果从任何其他二进制文件中调用，则返回 false。",
        "translate": ""
    },
    {
        "source": "The main type provided by this crate, representing an abstract stream of tokens, or, more specifically, a sequence of token trees.",
        "suggest": "此 crate 提供的主要类型，表示 tokens 的抽象流，或更具体地说，表示 token 树的序列。",
        "translate": ""
    },
    {
        "source": "The type provide interfaces for iterating over those token trees and, conversely, collecting a number of token trees into one stream.",
        "suggest": "该类型提供用于迭代这些 token 树的接口，并且相反，将大量 token 树收集到一个流中。",
        "translate": ""
    },
    {
        "source": "This is both the input and output of `#[proc_macro]`, `#[proc_macro_attribute]` and `#[proc_macro_derive]` definitions.",
        "suggest": "这是 `#[proc_macro]`，`#[proc_macro_attribute]` 和 `#[proc_macro_derive]` 定义的输入和输出。",
        "translate": ""
    },
    {
        "source": "Error returned from `TokenStream::from_str`.",
        "suggest": "`TokenStream::from_str` 返回错误。",
        "translate": ""
    },
    {
        "source": "Returns an empty `TokenStream` containing no token trees.",
        "suggest": "返回不包含 token 树的空 `TokenStream`。",
        "translate": ""
    },
    {
        "source": "Checks if this `TokenStream` is empty.",
        "suggest": "检查此 `TokenStream` 是否为空。",
        "translate": ""
    },
    {
        "source": "Attempts to break the string into tokens and parse those tokens into a token stream.",
        "suggest": "尝试将字符串拆分为 tokens 并将那些 tokens 解析为 token 流。",
        "translate": ""
    },
    {
        "source": "May fail for a number of reasons, for example, if the string contains unbalanced delimiters or characters not existing in the language.",
        "suggest": "可能由于多种原因而失败，例如，如果字符串包含不平衡的定界符或该语言中不存在的字符。",
        "translate": ""
    },
    {
        "source": "All tokens in the parsed stream get `Span::call_site()` spans.",
        "suggest": "解析的流中的所有 tokens 都获得 `Span::call_site()` 跨度。",
        "translate": ""
    },
    {
        "source": "some errors may cause panics instead of returning `LexError`.",
        "suggest": "某些错误可能导致 panics 而不是返回 `LexError`。",
        "translate": ""
    },
    {
        "source": "We reserve the right to change these errors into `LexError`s later.",
        "suggest": "我们保留稍后将这些错误更改为 LexError 的权利。",
        "translate": ""
    },
    {
        "source": "N.B., the bridge only provides `to_string`, implement `fmt::Display` based on it (the reverse of the usual relationship between the two).",
        "suggest": "注意，网桥仅提供 `to_string`，基于它实现 `fmt::Display` (两者之间通常的关系相反)。",
        "translate": ""
    },
    {
        "source": "Prints the token stream as a string that is supposed to be losslessly convertible back into the same token stream (modulo spans), except for possibly `TokenTree::Group`s with `Delimiter::None` delimiters and negative numeric literals.",
        "suggest": "将 token 流打印为应该无损转换为相同 token 流 (模数跨度) 的字符串，但可能带有 `Delimiter::None` 分隔符和负数字字面量的 `TokenTree::Group` 除外。",
        "translate": ""
    },
    {
        "source": "Prints token in a form convenient for debugging.",
        "suggest": "以方便调试的形式打印 token。",
        "translate": ""
    },
    {
        "source": "Creates a token stream containing a single token tree.",
        "suggest": "创建包含单个 token 树的 token 流。",
        "translate": ""
    },
    {
        "source": "Collects a number of token trees into a single stream.",
        "suggest": "将多个 token 树收集到单个流中。",
        "translate": ""
    },
    {
        "source": "A \"flattening\" operation on token streams, collects token trees from multiple token streams into a single stream.",
        "suggest": "对 token 流的 \"flattening\" 操作将来自多个 token 流的 token 树收集到单个流中。",
        "translate": ""
    },
    {
        "source": "Use an optimized implementation if/when possible.",
        "suggest": "可能使用优化的实现 if/when。",
        "translate": ""
    },
    {
        "source": "Public implementation details for the `TokenStream` type, such as iterators.",
        "suggest": "`TokenStream` 类型的公共实现详细信息，例如迭代器。",
        "translate": ""
    },
    {
        "source": "An iterator over `TokenStream`'s `TokenTree`s.",
        "suggest": "遍历 TokenStream 的 TokenTree 的迭代器。",
        "translate": ""
    },
    {
        "source": "The iteration is \"shallow\", e.g., the iterator doesn't recurse into delimited groups, and returns whole groups as token trees.",
        "suggest": "迭代是 \"shallow\"，例如，迭代器不会递归到定界的组中，而是将整个组作为 token 树返回。",
        "translate": ""
    },
    {
        "source": "accepts arbitrary tokens and expands into a `TokenStream` describing the input.",
        "suggest": "接受任意的 tokens 并扩展为描述输入的 `TokenStream`。",
        "translate": ""
    },
    {
        "source": "For example, `quote!(a + b)` will produce a expression, that, when evaluated, constructs the `TokenStream` `[Ident(\"a\"), Punct('+', Alone), Ident(\"b\")]`.",
        "suggest": "例如，`quote!(a + b)` 将产生一个表达式，该表达式在被求值时将构造 `TokenStream` `[Ident(\"a\"), Punct('+', Alone), Ident(\"b\")]`。",
        "translate": ""
    },
    {
        "source": "Unquoting is done with `$`, and works by taking the single next ident as the unquoted term.",
        "suggest": "用 `$` 解引用，并通过将单个下一个标识符作为未引用的术语来工作。",
        "translate": ""
    },
    {
        "source": "To quote `$` itself, use `$$`.",
        "suggest": "要引用 `$` 本身，请使用 `$$`。",
        "translate": ""
    },
    {
        "source": "A region of source code, along with macro expansion information.",
        "suggest": "源代码区域以及宏展开信息。",
        "translate": ""
    },
    {
        "source": "Creates a new `Diagnostic` with the given `message` at the span `self`.",
        "suggest": "使用跨度为 `self` 的给定 `message` 创建一个新的 `Diagnostic`。",
        "translate": ""
    },
    {
        "source": "A span that resolves at the macro definition site.",
        "suggest": "在宏定义站点解析的跨度。",
        "translate": ""
    },
    {
        "source": "The span of the invocation of the current procedural macro.",
        "suggest": "当前过程宏的调用范围。",
        "translate": ""
    },
    {
        "source": "Identifiers created with this span will be resolved as if they were written directly at the macro call location (call-site hygiene) and other code at the macro call site will be able to refer to them as well.",
        "suggest": "以此范围创建的标识符将被解析，就像它们是直接在宏调用位置 (调用站点卫生) 上编写的一样，宏调用站点上的其他代码也将能够引用它们。",
        "translate": ""
    },
    {
        "source": "A span that represents `macro_rules` hygiene, and sometimes resolves at the macro definition site (local variables, labels, `$crate`) and sometimes at the macro call site (everything else).",
        "suggest": "代表 `macro_rules` 卫生状况的跨度，有时在宏定义站点 (本地变量，标签，`$crate`) 解析，有时在宏调用站点 (其他所有解析) 解析。",
        "translate": ""
    },
    {
        "source": "The span location is taken from the call-site.",
        "suggest": "跨度位置取自调用站点。",
        "translate": ""
    },
    {
        "source": "The original source file into which this span points.",
        "suggest": "此跨度指向的原始源文件。",
        "translate": ""
    },
    {
        "source": "The `Span` for the tokens in the previous macro expansion from which `self` was generated from, if any.",
        "suggest": "上一个宏的 tokens 的 `Span` (如果有的话) 是从中生成 `self` 的。",
        "translate": ""
    },
    {
        "source": "The span for the origin source code that `self` was generated from.",
        "suggest": "生成 `self` 的原始源代码的范围。",
        "translate": ""
    },
    {
        "source": "If this `Span` wasn't generated from other macro expansions then the return value is the same as `*self`.",
        "suggest": "如果此 `Span` 不是由其他宏扩展生成的，则返回值与 `*self` 相同。",
        "translate": ""
    },
    {
        "source": "Gets the starting line/column in the source file for this span.",
        "suggest": "在源文件中获取此范围的起始 line/column。",
        "translate": ""
    },
    {
        "source": "Gets the ending line/column in the source file for this span.",
        "suggest": "在源文件中获取此跨度的结尾 line/column。",
        "translate": ""
    },
    {
        "source": "Creates a new span encompassing `self` and `other`.",
        "suggest": "创建一个包含 `self` 和 `other` 的新跨度。",
        "translate": ""
    },
    {
        "source": "Returns `None` if `self` and `other` are from different files.",
        "suggest": "如果 `self` 和 `other` 来自不同的文件，则返回 `None`。",
        "translate": ""
    },
    {
        "source": "Creates a new span with the same line/column information as `self` but that resolves symbols as though it were at `other`.",
        "suggest": "创建一个具有与 `self` 相同的 line/column 信息的新跨度，但是可以像在 `other` 一样解析符号。",
        "translate": ""
    },
    {
        "source": "Creates a new span with the same name resolution behavior as `self` but with the line/column information of `other`.",
        "suggest": "创建一个具有与 `self` 相同的名称解析行为但具有 `other` 的 line/column 信息的新跨度。",
        "translate": ""
    },
    {
        "source": "Compares to spans to see if they're equal.",
        "suggest": "比较跨度以查看它们是否相等。",
        "translate": ""
    },
    {
        "source": "Returns the source text behind a span.",
        "suggest": "返回跨度后面的源文本。",
        "translate": ""
    },
    {
        "source": "This preserves the original source code, including spaces and comments.",
        "suggest": "这将保留原始源代码，包括空格和注释。",
        "translate": ""
    },
    {
        "source": "It only returns a result if the span corresponds to real source code.",
        "suggest": "仅当范围与实际源代码相对应时，它才返回结果。",
        "translate": ""
    },
    {
        "source": "The observable result of a macro should only rely on the tokens and not on this source text.",
        "suggest": "宏的可观察结果应仅依赖于 tokens，而不依赖于此源文本。",
        "translate": ""
    },
    {
        "source": "The result of this function is a best effort to be used for diagnostics only.",
        "suggest": "该函数的结果是尽力而为，仅用于诊断。",
        "translate": ""
    },
    {
        "source": "Prints a span in a form convenient for debugging.",
        "suggest": "以便于调试的形式打印跨度。",
        "translate": ""
    },
    {
        "source": "A line-column pair representing the start or end of a `Span`.",
        "suggest": "代表 `Span` 开头或结尾的行 - 列对。",
        "translate": ""
    },
    {
        "source": "The 1-indexed line in the source file on which the span starts or ends (inclusive).",
        "suggest": "源文件中跨度开始或结束 (inclusive) 的 1 索引行。",
        "translate": ""
    },
    {
        "source": "The 0-indexed column (in UTF-8 characters) in the source file on which the span starts or ends (inclusive).",
        "suggest": "跨度开始或结束 (inclusive) 的源文件中的 0 索引列 (以 UTF-8 字符表示)。",
        "translate": ""
    },
    {
        "source": "The source file of a given `Span`.",
        "suggest": "给定 `Span` 的源文件。",
        "translate": ""
    },
    {
        "source": "Gets the path to this source file.",
        "suggest": "获取此源文件的路径。",
        "translate": ""
    },
    {
        "source": "If the code span associated with this `SourceFile` was generated by an external macro, this macro, this may not be an actual path on the filesystem.",
        "suggest": "如果与此 `SourceFile` 关联的代码范围是由外部宏 (此宏) 生成的，则这可能不是文件系统上的实际路径。",
        "translate": ""
    },
    {
        "source": "Use [`is_real`] to check.",
        "suggest": "使用 [`is_real`] 进行检查。",
        "translate": ""
    },
    {
        "source": "Also note that even if `is_real` returns `true`, if `--remap-path-prefix` was passed on the command line, the path as given may not actually be valid.",
        "suggest": "还要注意，即使 `is_real` 返回 `true`，如果在命令行上传递了 `--remap-path-prefix`，则给定的路径实际上也可能无效。",
        "translate": ""
    },
    {
        "source": "Returns `true` if this source file is a real source file, and not generated by an external macro's expansion.",
        "suggest": "如果此源文件是真实的源文件，并且不是由外部宏的扩展生成的，则返回 `true`。",
        "translate": ""
    },
    {
        "source": "This is a hack until intercrate spans are implemented and we can have real source files for spans generated in external macros.",
        "suggest": "在实现跨度跨度之前，这是一个技巧，我们可以为外部宏中生成的跨度提供真实的源文件。",
        "translate": ""
    },
    {
        "source": "A single token or a delimited sequence of token trees (e.g., `[1, (), ..]`).",
        "suggest": "单个 token 或 token 树的定界序列 (例如 `[1, (), ..]`)。",
        "translate": ""
    },
    {
        "source": "A token stream surrounded by bracket delimiters.",
        "suggest": "由括号定界符包围的 token 流。",
        "translate": ""
    },
    {
        "source": "An identifier.",
        "suggest": "标识符。",
        "translate": ""
    },
    {
        "source": "A single punctuation character (`+`, `,`, `$`, etc.).",
        "suggest": "单个标点符号 (`+`，`,`，`$` 等)。",
        "translate": ""
    },
    {
        "source": "A literal character (`'a'`), string (`\"hello\"`), number (`2.3`), etc.",
        "suggest": "字面量字符 (`'a'`)，字符串 (`\"hello\"`)，数字 (`2.3`) 等。",
        "translate": ""
    },
    {
        "source": "Returns the span of this tree, delegating to the `span` method of the contained token or a delimited stream.",
        "suggest": "返回此树的范围，委托给包含的 token 或分隔流的 `span` 方法。",
        "translate": ""
    },
    {
        "source": "Configures the span for *only this token*.",
        "suggest": "为 *only this token* 配置范围。",
        "translate": ""
    },
    {
        "source": "Note that if this token is a `Group` then this method will not configure the span of each of the internal tokens, this will simply delegate to the `set_span` method of each variant.",
        "suggest": "请注意，如果此 token 是 `Group`，则此方法将不会配置每个内部 tokens 的跨度，这将仅委托给每个成员的 `set_span` 方法。",
        "translate": ""
    },
    {
        "source": "Prints token tree in a form convenient for debugging.",
        "suggest": "以方便调试的形式打印 token 树。",
        "translate": ""
    },
    {
        "source": "Each of these has the name in the struct type in the derived debug, so don't bother with an extra layer of indirection",
        "suggest": "它们中的每一个在派生调试中的结构体类型中都具有名称，因此不必担心额外的间接层",
        "translate": ""
    },
    {
        "source": "Prints the token tree as a string that is supposed to be losslessly convertible back into the same token tree (modulo spans), except for possibly `TokenTree::Group`s with `Delimiter::None` delimiters and negative numeric literals.",
        "suggest": "将 token 树打印为应该无损转换为同一 token 树 (取模跨度) 的字符串，但可能带有 `Delimiter::None` 定界符和负数字字面量的 `TokenTree::Group` 除外。",
        "translate": ""
    },
    {
        "source": "A delimited token stream.",
        "suggest": "分隔的 token 流。",
        "translate": ""
    },
    {
        "source": "A `Group` internally contains a `TokenStream` which is surrounded by `Delimiter`s.",
        "suggest": "`Group` 内部包含一个 `TokenStream`，该 `TokenStream` 被 `Delimiter` 包围。",
        "translate": ""
    },
    {
        "source": "Describes how a sequence of token trees is delimited.",
        "suggest": "描述如何分隔 token 树的序列。",
        "translate": ""
    },
    {
        "source": "An implicit delimiter, that may, for example, appear around tokens coming from a \"macro variable\" `$var`.",
        "suggest": "一个隐式定界符，例如，可能出现在来自 \"macro variable\" `$var` 的 tokens 周围。",
        "translate": ""
    },
    {
        "source": "It is important to preserve operator priorities in cases like `$var * 3` where `$var` is `1 + 2`.",
        "suggest": "在诸如 `$var` 为 `1 + 2` 的 `$var * 3` 之类的情况下，保留操作员的优先级很重要。",
        "translate": ""
    },
    {
        "source": "Implicit delimiters may not survive roundtrip of a token stream through a string.",
        "suggest": "隐式定界符可能无法在 token 流通过字符串的往返过程中幸免。",
        "translate": ""
    },
    {
        "source": "Creates a new `Group` with the given delimiter and token stream.",
        "suggest": "使用给定的定界符和 token 流创建一个新的 `Group`。",
        "translate": ""
    },
    {
        "source": "This constructor will set the span for this group to `Span::call_site()`.",
        "suggest": "此构造函数将将此组的跨度设置为 `Span::call_site()`。",
        "translate": ""
    },
    {
        "source": "To change the span you can use the `set_span` method below.",
        "suggest": "要更改跨度，可以使用下面的 `set_span` 方法。",
        "translate": ""
    },
    {
        "source": "Returns the delimiter of this `Group`",
        "suggest": "返回此 `Group` 的定界符",
        "translate": ""
    },
    {
        "source": "Returns the `TokenStream` of tokens that are delimited in this `Group`.",
        "suggest": "返回在此 `Group` 中定界的 tokens 的 `TokenStream`。",
        "translate": ""
    },
    {
        "source": "Note that the returned token stream does not include the delimiter returned above.",
        "suggest": "请注意，返回的 token 流不包括上面返回的定界符。",
        "translate": ""
    },
    {
        "source": "Returns the span for the delimiters of this token stream, spanning the entire `Group`.",
        "suggest": "返回此 token 流的定界符的范围，该范围跨越整个 `Group`。",
        "translate": ""
    },
    {
        "source": "Returns the span pointing to the opening delimiter of this group.",
        "suggest": "返回指向该组的开始定界符的跨度。",
        "translate": ""
    },
    {
        "source": "Returns the span pointing to the closing delimiter of this group.",
        "suggest": "返回指向该组的结束定界符的跨度。",
        "translate": ""
    },
    {
        "source": "Configures the span for this `Group`'s delimiters, but not its internal tokens.",
        "suggest": "配置此 `Group` 定界符的范围，但不配置其内部 tokens 的范围。",
        "translate": ""
    },
    {
        "source": "This method will **not** set the span of all the internal tokens spanned by this group, but rather it will only set the span of the delimiter tokens at the level of the `Group`.",
        "suggest": "此方法将不设置该组所跨越的所有内部 tokens 的跨度，而只会将定界符 tokens 的跨度设置为 `Group` 的水平。",
        "translate": ""
    },
    {
        "source": "Prints the group as a string that should be losslessly convertible back into the same group (modulo spans), except for possibly `TokenTree::Group`s with `Delimiter::None` delimiters.",
        "suggest": "将组打印为字符串，该字符串应无损地转换回同一组 (模跨度)，但可能带有 `Delimiter::None` 分隔符的 'TokenTree::Group' 除外。",
        "translate": ""
    },
    {
        "source": "An `Punct` is an single punctuation character like `+`, `-` or `#`.",
        "suggest": "`Punct` 是单个标点字符，例如 `+`，`-` 或 `#`。",
        "translate": ""
    },
    {
        "source": "Multi-character operators like `+=` are represented as two instances of `Punct` with different forms of `Spacing` returned.",
        "suggest": "像 `+=` 这样的多字符运算符表示为 `Punct` 的两个实例，它们返回了不同形式的 `Spacing`。",
        "translate": ""
    },
    {
        "source": "Whether an `Punct` is followed immediately by another `Punct` or followed by another token or whitespace.",
        "suggest": "`Punct` 后面紧跟另一个 `Punct` 还是紧随另一个 token 或空格。",
        "translate": ""
    },
    {
        "source": "e.g., `+` is `Alone` in `+ =`, `+ident` or `+()`.",
        "suggest": "例如，`+` 是 `+ =`，`+ident` 或 `+()` 中的 `Alone`。",
        "translate": ""
    },
    {
        "source": "e.g., `+` is `Joint` in `+=` or `'#`.",
        "suggest": "例如，`+` 是 `+=` 或 `'#` 中的 `Joint`。",
        "translate": ""
    },
    {
        "source": "Additionally, single quote `'` can join with identifiers to form lifetimes `'ident`.",
        "suggest": "此外，单引号 `'` 可以与标识符结合起来形成生命周期 `'ident`。",
        "translate": ""
    },
    {
        "source": "Creates a new `Punct` from the given character and spacing.",
        "suggest": "根据给定的字符和间距创建一个新的 `Punct`。",
        "translate": ""
    },
    {
        "source": "The `ch` argument must be a valid punctuation character permitted by the language, otherwise the function will panic.",
        "suggest": "`ch` 参数必须是语言允许的有效标点符号，否则函数将为 panic。",
        "translate": ""
    },
    {
        "source": "The returned `Punct` will have the default span of `Span::call_site()` which can be further configured with the `set_span` method below.",
        "suggest": "返回的 `Punct` 将具有默认范围 `Span::call_site()`，可以使用下面的 `set_span` 方法对其进行进一步配置。",
        "translate": ""
    },
    {
        "source": "Returns the value of this punctuation character as `char`.",
        "suggest": "将此标点符号的值返回为 `char`。",
        "translate": ""
    },
    {
        "source": "Returns the spacing of this punctuation character, indicating whether it's immediately followed by another `Punct` in the token stream, so they can potentially be combined into a multi-character operator (`Joint`), or it's followed by some other token or whitespace (`Alone`) so the operator has certainly ended.",
        "suggest": "返回此标点符号的间距，指示其是否紧随 token 流中的另一个 `Punct`，以便可以将它们组合为多字符运算符 (`Joint`)，也可以将其与其他 token 或空格 (`Alone`) 组合在一起，因此该运算符肯定具有结束了。",
        "translate": ""
    },
    {
        "source": "Returns the span for this punctuation character.",
        "suggest": "返回此标点符号字符的跨度。",
        "translate": ""
    },
    {
        "source": "Configure the span for this punctuation character.",
        "suggest": "配置该标点字符的跨度。",
        "translate": ""
    },
    {
        "source": "Prints the punctuation character as a string that should be losslessly convertible back into the same character.",
        "suggest": "将标点符号打印为字符串，该字符串应可以无损地转换回相同的字符。",
        "translate": ""
    },
    {
        "source": "An identifier (`ident`).",
        "suggest": "标识符 (`ident`)。",
        "translate": ""
    },
    {
        "source": "Creates a new `Ident` with the given `string` as well as the specified `span`.",
        "suggest": "使用给定的 `string` 和指定的 `span` 创建新的 `Ident`。",
        "translate": ""
    },
    {
        "source": "The `string` argument must be a valid identifier permitted by the language (including keywords, e.g. `self` or `fn`).",
        "suggest": "`string` 参数必须是该语言允许的有效标识符 (包括关键字，例如 `self` 或 `fn`)。",
        "translate": ""
    },
    {
        "source": "Otherwise, the function will panic.",
        "suggest": "否则，函数将为 panic。",
        "translate": ""
    },
    {
        "source": "Note that `span`, currently in rustc, configures the hygiene information for this identifier.",
        "suggest": "请注意，当前位于 rustc 中的 `span` 为此标识符配置了卫生信息。",
        "translate": ""
    },
    {
        "source": "As of this time `Span::call_site()` explicitly opts-in to \"call-site\" hygiene meaning that identifiers created with this span will be resolved as if they were written directly at the location of the macro call, and other code at the macro call site will be able to refer to them as well.",
        "suggest": "截止到目前，`Span::call_site()` 明确选择采用 \"call-site\" 卫生标准，这意味着使用该跨度创建的标识符将被解析，就好像它们直接写在宏调用的位置一样，并且宏调用站点上的其他代码将能够引用他们也是。",
        "translate": ""
    },
    {
        "source": "Later spans like `Span::def_site()` will allow to opt-in to \"definition-site\" hygiene meaning that identifiers created with this span will be resolved at the location of the macro definition and other code at the macro call site will not be able to refer to them.",
        "suggest": "以后的跨度 (例如 `Span::def_site()`) 将允许选择使用 \"definition-site\" 卫生，这意味着用该跨度创建的标识符将在宏定义的位置解析，而宏调用站点上的其他代码将无法引用它们。",
        "translate": ""
    },
    {
        "source": "Due to the current importance of hygiene this constructor, unlike other tokens, requires a `Span` to be specified at construction.",
        "suggest": "由于当前对卫生的重要性，与其他 tokens 不同，该构造函数需要在构造时指定 `Span`。",
        "translate": ""
    },
    {
        "source": "Same as `Ident::new`, but creates a raw identifier (`r#ident`).",
        "suggest": "与 `Ident::new` 相同，但创建原始标识符 (`r#ident`)。",
        "translate": ""
    },
    {
        "source": "The `string` argument be a valid identifier permitted by the language (including keywords, e.g. `fn`).",
        "suggest": "`string` 参数是该语言允许的有效标识符 (包括关键字，例如 `fn`)。",
        "translate": ""
    },
    {
        "source": "Keywords which are usable in path segments (e.g.",
        "suggest": "在路径段中可用的关键字 (例如，",
        "translate": ""
    },
    {
        "source": "`super`) are not supported, and will cause a panic.",
        "suggest": "不支持 `super`)，这会导致 panic。",
        "translate": ""
    },
    {
        "source": "Returns the span of this `Ident`, encompassing the entire string returned by [`to_string`](Self::to_string).",
        "suggest": "返回此 `Ident` 的范围，包括 [`to_string`](Self::to_string) 返回的整个字符串。",
        "translate": ""
    },
    {
        "source": "Configures the span of this `Ident`, possibly changing its hygiene context.",
        "suggest": "配置此 `Ident` 的跨度，可能会更改其卫生状况。",
        "translate": ""
    },
    {
        "source": "Prints the identifier as a string that should be losslessly convertible back into the same identifier.",
        "suggest": "将标识符打印为字符串，该字符串应可以无损地转换回相同的标识符。",
        "translate": ""
    },
    {
        "source": "A literal string (`\"hello\"`), byte string (`b\"hello\"`), character (`'a'`), byte character (`b'a'`), an integer or floating point number with or without a suffix (`1`, `1u8`, `2.3`, `2.3f32`).",
        "suggest": "字面量字符串 (`\"hello\"`)，字节字符串 (`b\"hello\"`)，字符 (`'a'`)，字节字符 (`b'a'`)，带或不带后缀 ('1'，`1u8`，`2.3`，`2.3f32`) 的整数或浮点数。",
        "translate": ""
    },
    {
        "source": "Boolean literals like `true` and `false` do not belong here, they are `Ident`s.",
        "suggest": "`true` 和 `false` 之类的布尔字面量在这里不属于它们，它们是 `Ident`。",
        "translate": ""
    },
    {
        "source": "Creates a new suffixed integer literal with the specified value.",
        "suggest": "用指定的值创建一个新的后缀整数字面量。",
        "translate": ""
    },
    {
        "source": "This function will create an integer like `1u32` where the integer value specified is the first part of the token and the integral is also suffixed at the end.",
        "suggest": "此函数将创建一个类似于 `1u32` 的整数，其中指定的整数值是 token 的第一部分，并且整数也以结尾加后缀。",
        "translate": ""
    },
    {
        "source": "Literals created from negative numbers may not survive round-trips through `TokenStream` or strings and may be broken into two tokens (`-` and positive literal).",
        "suggest": "由负数创建的字面量可能无法通过 `TokenStream` 或字符串往返，并且可能会分成两个 tokens (`-` 和正字面量)。",
        "translate": ""
    },
    {
        "source": "Literals created through this method have the `Span::call_site()` span by default, which can be configured with the `set_span` method below.",
        "suggest": "通过此方法创建的字面量默认情况下具有 `Span::call_site()` 跨度，可以使用以下 `set_span` 方法进行配置。",
        "translate": ""
    },
    {
        "source": "Creates a new unsuffixed integer literal with the specified value.",
        "suggest": "用指定的值创建一个新的无后缀的整数字面量。",
        "translate": ""
    },
    {
        "source": "This function will create an integer like `1` where the integer value specified is the first part of the token.",
        "suggest": "此函数将创建一个类似于 `1` 的整数，其中指定的整数值是 token 的第一部分。",
        "translate": ""
    },
    {
        "source": "No suffix is specified on this token, meaning that invocations like `Literal::i8_unsuffixed(1)` are equivalent to `Literal::u32_unsuffixed(1)`.",
        "suggest": "在此 token 上未指定后缀，这意味着像 `Literal::i8_unsuffixed(1)` 这样的调用等效于 `Literal::u32_unsuffixed(1)`。",
        "translate": ""
    },
    {
        "source": "Literals created from negative numbers may not survive rountrips through `TokenStream` or strings and may be broken into two tokens (`-` and positive literal).",
        "suggest": "由负数创建的字面量可能无法在 `TokenStream` 或字符串的往返旅行中幸存下来，并且可能会分成两个 tokens (`-` 和正字面量)。",
        "translate": ""
    },
    {
        "source": "Creates a new unsuffixed floating-point literal.",
        "suggest": "创建一个新的不带后缀的浮点字面量。",
        "translate": ""
    },
    {
        "source": "This constructor is similar to those like `Literal::i8_unsuffixed` where the float's value is emitted directly into the token but no suffix is used, so it may be inferred to be a `f64` later in the compiler.",
        "suggest": "此构造函数类似于 `Literal::i8_unsuffixed`，后者将 float 的值直接发出到 token 中，但不使用后缀，因此可以在以后的编译器中推断出它是 `f64`。",
        "translate": ""
    },
    {
        "source": "This function requires that the specified float is finite, for example if it is infinity or NaN this function will panic.",
        "suggest": "此函数要求指定的浮点数是有限的，例如，如果它是无穷大或 NaN，则此函数将为 panic。",
        "translate": ""
    },
    {
        "source": "Creates a new suffixed floating-point literal.",
        "suggest": "创建一个新的后缀浮点字面量。",
        "translate": ""
    },
    {
        "source": "This constructor will create a literal like `1.0f32` where the value specified is the preceding part of the token and `f32` is the suffix of the token.",
        "suggest": "该构造函数将创建一个像 `1.0f32` 这样的字面量，其中指定的值是 token 的前一部分，而 `f32` 是 token 的后缀。",
        "translate": ""
    },
    {
        "source": "This token will always be inferred to be an `f32` in the compiler.",
        "suggest": "token 在编译器中将始终被推断为 `f32`。",
        "translate": ""
    },
    {
        "source": "This constructor will create a literal like `1.0f64` where the value specified is the preceding part of the token and `f64` is the suffix of the token.",
        "suggest": "该构造函数将创建一个像 `1.0f64` 这样的字面量，其中指定的值是 token 的前一部分，而 `f64` 是 token 的后缀。",
        "translate": ""
    },
    {
        "source": "This token will always be inferred to be an `f64` in the compiler.",
        "suggest": "token 在编译器中将始终被推断为 `f64`。",
        "translate": ""
    },
    {
        "source": "String literal.",
        "suggest": "字符串字面量。",
        "translate": ""
    },
    {
        "source": "Character literal.",
        "suggest": "字符字面量。",
        "translate": ""
    },
    {
        "source": "Byte string literal.",
        "suggest": "字节字符串字面量。",
        "translate": ""
    },
    {
        "source": "Returns the span encompassing this literal.",
        "suggest": "返回包含此字面量的范围。",
        "translate": ""
    },
    {
        "source": "Configures the span associated for this literal.",
        "suggest": "配置与此字面量关联的范围。",
        "translate": ""
    },
    {
        "source": "Returns a `Span` that is a subset of `self.span()` containing only the source bytes in range `range`.",
        "suggest": "返回 `Span`，它是 `self.span()` 的子集，仅包含范围 `range` 中的源字节。",
        "translate": ""
    },
    {
        "source": "Returns `None` if the would-be trimmed span is outside the bounds of `self`.",
        "suggest": "如果要修剪的跨度超出 `self` 的边界，则返回 `None`。",
        "translate": ""
    },
    {
        "source": "check that the byte range starts and ends at a UTF-8 boundary of the source.",
        "suggest": "检查字节范围在源的 UTF-8 边界处开始和结束。",
        "translate": ""
    },
    {
        "source": "otherwise, it's likely that a panic will occur elsewhere when the source text is printed.",
        "suggest": "否则，在打印源文本时，panic 可能会出现在其他位置。",
        "translate": ""
    },
    {
        "source": "there is no way for the user to know what `self.span()` actually maps to, so this method can currently only be called blindly.",
        "suggest": "用户无法知道 `self.span()` 实际上是 maps，因此当前只能盲目调用此方法。",
        "translate": ""
    },
    {
        "source": "For example, `to_string()` for the character 'c' returns \"'\\u{63}'\";",
        "suggest": "例如，字符 'c' 的 `to_string()` 返回 \"'\\u{63}'\";",
        "translate": ""
    },
    {
        "source": "there is no way for the user to know whether the source text was 'c' or whether it was '\\u{63}'.",
        "suggest": "用户无法知道源文本是 'c' 还是 '\\u{63}'。",
        "translate": ""
    },
    {
        "source": "something akin to `Option::cloned`, but for `Bound<&T>`.",
        "suggest": "类似于 `Option::cloned`，但适用于 `Bound<&T>`。",
        "translate": ""
    },
    {
        "source": "Prints the literal as a string that should be losslessly convertible back into the same literal (except for possible rounding for floating point literals).",
        "suggest": "将字面量打印为一个字符串，该字符串应可以无损地转换回相同的字面量 (但浮点型字面量的可能取整除外)。",
        "translate": ""
    },
    {
        "source": "Tracked access to environment variables.",
        "suggest": "跟踪对环境变量的访问。",
        "translate": ""
    },
    {
        "source": "Retrieve an environment variable and add it to build dependency info.",
        "suggest": "检索环境变量并将其添加以构建依赖项信息。",
        "translate": ""
    },
    {
        "source": "Build system executing the compiler will know that the variable was accessed during compilation, and will be able to rerun the build when the value of that variable changes.",
        "suggest": "执行编译器的构建系统将知道在编译期间访问了该变量，并且能够在该变量的值发生变化时重新运行构建。",
        "translate": ""
    },
    {
        "source": "Besides the dependency tracking this function should be equivalent to `env::var` from the standard library, except that the argument must be UTF-8.",
        "suggest": "除了依赖项跟踪之外，此函数应与标准库中的 `env::var` 等效，除了参数必须为 UTF-8。",
        "translate": ""
    },
    {
        "source": "This file contains the implementation internals of the quasiquoter provided by `quote!`.",
        "suggest": "该文件包含 `quote!` 提供的拟报价器的实现内部。",
        "translate": ""
    },
    {
        "source": "This quasiquoter uses macros 2.0 hygiene to reliably access items from `proc_macro`, to build a `proc_macro::TokenStream`.",
        "suggest": "该准报价器使用宏 2.0 卫生来可靠地访问 `proc_macro` 的项，从而构建 `proc_macro::TokenStream`。",
        "translate": ""
    },
    {
        "source": "Simpler version of the real `quote!` macro, implemented solely through `macro_rules`, for bootstrapping the real implementation (see the `quote` function), which does not have access to the real `quote!` macro due to the `proc_macro` crate not being able to depend on itself.",
        "suggest": "真正的 `quote!` 宏的简化版本，仅通过 `macro_rules` 实现，用于引导实际的实现 (请参见 `quote` 函数)，由于 `proc_macro` crate 无法依靠自身，因此无法访问真正的 `quote!` 宏。",
        "translate": ""
    },
    {
        "source": "supported tokens are a subset of the real `quote!`, but unquoting is different: instead of `$x`, this uses `(@ expr)`.",
        "suggest": "支持的 tokens 是实际 `quote!` 的子集，但解引用是不同的: 它使用 `(@ expr)` 代替 `$x`。",
        "translate": ""
    },
    {
        "source": "Quote a `TokenStream` into a `TokenStream`.",
        "suggest": "将 `TokenStream` 引用到 `TokenStream` 中。",
        "translate": ""
    },
    {
        "source": "This is the actual implementation of the `quote!()` proc macro.",
        "suggest": "这是 `quote!()` proc 宏的实际实现。",
        "translate": ""
    },
    {
        "source": "It is loaded by the compiler in `register_builtin_macros`.",
        "suggest": "它由 `register_builtin_macros` 中的编译器加载。",
        "translate": ""
    },
    {
        "source": "Quote a `Span` into a `TokenStream`.",
        "suggest": "将 `Span` 引用到 `TokenStream` 中。",
        "translate": ""
    },
    {
        "source": "This is needed to implement a custom quoter.",
        "suggest": "这是实现自定义引号所需的。",
        "translate": ""
    },
    {
        "source": "Good enough if it typechecks, since proc_macro::Punct can't exist in a test.",
        "suggest": "如果进行类型检查就足够了，因为 proc_macro::Punct 在测试中不存在。",
        "translate": ""
    },
    {
        "source": "Compiles the profiler part of the `compiler-rt` library.",
        "suggest": "编译 `compiler-rt` 库的探查器部分。",
        "translate": ""
    },
    {
        "source": "See the build.rs for libcompiler_builtins crate for details.",
        "suggest": "有关详细信息，请参见 libcompiler_builtins crate 的 build.rs。",
        "translate": ""
    },
    {
        "source": "`rerun-if-changed` directives are not currently emitted and the build script will not rerun on changes in these source files or headers included into them.",
        "suggest": "当前不发出 `rerun-if-changed` 指令，并且在这些源文件或其中包含的标头中进行更改时，构建脚本将不会重新运行。",
        "translate": ""
    },
    {
        "source": "This file was renamed in LLVM 10.",
        "suggest": "该文件在 LLVM 10 中被重命名。",
        "translate": ""
    },
    {
        "source": "These files were added in LLVM 11.",
        "suggest": "这些文件已添加到 LLVM 11 中。",
        "translate": ""
    },
    {
        "source": "Don't pull in extra libraries on MSVC",
        "suggest": "不要在 MSVC 上引入额外的库",
        "translate": ""
    },
    {
        "source": "Turn off various features of gcc and such, mostly copying compiler-rt's build system already",
        "suggest": "关闭 gcc 的各种功能，例如，大多数已经复制了编译器 - rt 的构建系统",
        "translate": ""
    },
    {
        "source": "Assume that the Unixes we are building this for have fnctl() available",
        "suggest": "假设我们为此构建的 Unix 具有 fnctl()",
        "translate": ""
    },
    {
        "source": "This should be a pretty good heuristic for when to set COMPILER_RT_HAS_ATOMICS",
        "suggest": "这对于何时设置 COMPILER_RT_HAS_ATOMICS 应该是一个很好的启发",
        "translate": ""
    },
    {
        "source": "Note that this should exist if we're going to run (otherwise we just don't build profiler builtins at all).",
        "suggest": "请注意，如果我们要运行该文件，则该文件应该存在 (否则，我们根本就不会构建探查器内建文件)。",
        "translate": ""
    },
    {
        "source": "See rustc-std-workspace-core for why this crate is needed.",
        "suggest": "有关为何需要此 crate 的信息，请参见 rustc-std-workspace-core。",
        "translate": ""
    },
    {
        "source": "Rename the crate to avoid conflicting with the alloc module in liballoc.",
        "suggest": "重命名 crate 以避免与 liballoc 中的 alloc 模块冲突。",
        "translate": ""
    },
    {
        "source": "The `rustc-std-workspace-core` crate",
        "suggest": "`rustc-std-workspace-core` crate",
        "translate": ""
    },
    {
        "source": "This crate is a shim and empty crate which simply depends on `libcore` and reexports all of its contents.",
        "suggest": "crate 是一个填充码，空的 crate 仅依赖于 `libcore` 并重导出其所有内容。",
        "translate": ""
    },
    {
        "source": "The crate is the crux of empowering the standard library to depend on crates from crates.io",
        "suggest": "crate 是授权标准库依赖 crates.io 的 crates 的关键",
        "translate": ""
    },
    {
        "source": "Crates on crates.io that the standard library depend on need to depend on the `rustc-std-workspace-core` crate from crates.io, which is empty.",
        "suggest": "标准库所依赖的 crates.io 上的 Crates 需要依赖于 crates.io 上的 `rustc-std-workspace-core` crate，它为空。",
        "translate": ""
    },
    {
        "source": "We use `[patch]` to override it to this crate in this repository.",
        "suggest": "我们使用 `[patch]` 将其覆盖到此仓库中的 crate。",
        "translate": ""
    },
    {
        "source": "As a result, crates on crates.io will draw a dependency edge to `libcore`, the version defined in this repository.",
        "suggest": "结果，crates.io 上的 crates 将向该仓库中定义的版本 `libcore` 绘制一个依赖项 edge。",
        "translate": ""
    },
    {
        "source": "That should draw all the dependency edges to ensure Cargo builds crates successfully!",
        "suggest": "那应该绘制所有依赖项 edges，以确保 Cargo 成功构建 crates!",
        "translate": ""
    },
    {
        "source": "Note that crates on crates.io need to depend on this crate with the name `core` for everything to work correctly.",
        "suggest": "请注意，crates.io 上的 crates 必须依赖于名称为 `core` 的 crate 才能正常工作。",
        "translate": ""
    },
    {
        "source": "To do that they can use:",
        "suggest": "为此，他们可以使用:",
        "translate": ""
    },
    {
        "source": "Through the use of the `package` key the crate is renamed to `core`, meaning it'll look like",
        "suggest": "通过使用 `package` 键，crate 重命名为 `core`，这意味着它看起来像",
        "translate": ""
    },
    {
        "source": "when Cargo invokes the compiler, satisfying the implicit `extern crate core` directive injected by the compiler.",
        "suggest": "当 Cargo 调用编译器时，满足了编译器注入的隐式 `extern crate core` 指令。",
        "translate": ""
    },
    {
        "source": "The `rustc-std-workspace-std` crate",
        "suggest": "`rustc-std-workspace-std` crate",
        "translate": ""
    },
    {
        "source": "See documentation for the `rustc-std-workspace-core` crate.",
        "suggest": "请参见 `rustc-std-workspace-core` crate 的文档。",
        "translate": ""
    },
    {
        "source": "These platforms don't have any special requirements.",
        "suggest": "这些平台没有任何特殊要求。",
        "translate": ""
    },
    {
        "source": "This is for Cargo's build-std support, to mark std as unstable for typically no_std platforms.",
        "suggest": "这是为了 Cargo 的 build-std 支持，以将 std 标记为对于典型的 no_std 平台不稳定。",
        "translate": ""
    },
    {
        "source": "This covers:",
        "suggest": "这包括:",
        "translate": ""
    },
    {
        "source": "JSON targets",
        "suggest": "JSON 目标",
        "translate": ""
    },
    {
        "source": "Any new targets that have not been explicitly added above.",
        "suggest": "上面未明确添加的所有新目标。",
        "translate": ""
    },
    {
        "source": "Dependencies of the `backtrace` crate",
        "suggest": "`backtrace` crate 的依赖项",
        "translate": ""
    },
    {
        "source": "Enable std_detect default features for stdarch/crates/std_detect:",
        "suggest": "为 stdarch/crates/std_detect 启用 std_detect 默认功能:",
        "translate": ""
    },
    {
        "source": "Maximum possible number of threads when testing",
        "suggest": "测试时最大可能的线程数",
        "translate": ""
    },
    {
        "source": "Maximum heap size",
        "suggest": "最大堆大小",
        "translate": ""
    },
    {
        "source": "This `Vec` will allocate memory through `GLOBAL` above",
        "suggest": "该 `Vec` 将通过上面的 `GLOBAL` 分配内存",
        "translate": ""
    },
    {
        "source": "Allocates from the system allocator.",
        "suggest": "从系统分配器分配。",
        "translate": ""
    },
    {
        "source": "Memory allocation APIs.",
        "suggest": "内存分配 API。",
        "translate": ""
    },
    {
        "source": "In a given program, the standard library has one “global” memory allocator that is used for example by `Box<T>` and `Vec<T>`.",
        "suggest": "在给定程序中，标准库具有一个 `global` 内存分配器，例如 `Box<T>` 和 `Vec<T>` 就会使用它。",
        "translate": ""
    },
    {
        "source": "Currently the default global allocator is unspecified.",
        "suggest": "当前未指定默认的分配器。",
        "translate": ""
    },
    {
        "source": "Libraries, however, like `cdylib`s and `staticlib`s are guaranteed to use the [`System`] by default.",
        "suggest": "但是，默认情况下，保证像 cdylib 和 staticlib 这样的库都使用 [`System`]。",
        "translate": ""
    },
    {
        "source": "The `#[global_allocator]` attribute",
        "suggest": "`#[global_allocator]` 属性",
        "translate": ""
    },
    {
        "source": "This attribute allows configuring the choice of global allocator.",
        "suggest": "此属性允许配置分配器的选择。",
        "translate": ""
    },
    {
        "source": "You can use this to implement a completely custom global allocator to route all default allocation requests to a custom object.",
        "suggest": "您可以使用它来实现一个完全自定义的 alloc 分配器，以将所有默认分配请求路由到自定义 object。",
        "translate": ""
    },
    {
        "source": "The attribute is used on a `static` item whose type implements the [`GlobalAlloc`] trait.",
        "suggest": "该属性用于其类型实现 [`GlobalAlloc`] trait 的 `static` 项。",
        "translate": ""
    },
    {
        "source": "This type can be provided by an external library:",
        "suggest": "可以由外部库提供此类型:",
        "translate": ""
    },
    {
        "source": "The `#[global_allocator]` can only be used once in a crate or its recursive dependencies.",
        "suggest": "`#[global_allocator]` 只能在 crate 或其递归依赖性中使用一次。",
        "translate": ""
    },
    {
        "source": "The default memory allocator provided by the operating system.",
        "suggest": "操作系统提供的默认内存分配器。",
        "translate": ""
    },
    {
        "source": "This is based on `malloc` on Unix platforms and `HeapAlloc` on Windows, plus related functions.",
        "suggest": "它基于 Unix 平台上的 `malloc` 和 Windows 上的 `HeapAlloc`，以及相关的函数。",
        "translate": ""
    },
    {
        "source": "This type implements the `GlobalAlloc` trait and Rust programs by default work as if they had this definition:",
        "suggest": "此类型默认情况下实现 `GlobalAlloc` trait 和 Rust 程序，就像它们具有以下定义一样:",
        "translate": ""
    },
    {
        "source": "You can also define your own wrapper around `System` if you'd like, such as keeping track of the number of all bytes allocated:",
        "suggest": "如果愿意，还可以围绕 `System` 定义自己的包装器，例如跟踪分配的所有字节数:",
        "translate": ""
    },
    {
        "source": "It can also be used directly to allocate memory independently of whatever global allocator has been selected for a Rust program.",
        "suggest": "它也可以直接用于独立于 Rust 程序选择的分配器来分配内存。",
        "translate": ""
    },
    {
        "source": "For example if a Rust program opts in to using jemalloc as the global allocator, `System` will still allocate memory using `malloc` and `HeapAlloc`.",
        "suggest": "例如，如果 Rust 程序选择使用 jemalloc 作为分配器，则 `System` 仍将使用 `malloc` 和 `HeapAlloc` 分配内存。",
        "translate": ""
    },
    {
        "source": "`new_size` is non-zero as `new_size` is greater than or equal to `old_size` as required by safety conditions and the `old_size == 0` case was handled in the previous match arm.",
        "suggest": "`new_size` 为非零值，因为 `new_size` 大于或等于安全条件所要求的 `old_size`，并且 `old_size == 0` 的情况在先前的匹配项 arm 中进行了处理。",
        "translate": ""
    },
    {
        "source": "The Allocator impl checks the layout size to be non-zero and forwards to the GlobalAlloc impl, which is in `std::sys::*::alloc`.",
        "suggest": "Allocator impl 检查布局大小是否为非零，并将其转发到 `std::sys::*::alloc` 中的 GlobalAlloc impl。",
        "translate": ""
    },
    {
        "source": "Registers a custom allocation error hook, replacing any that was previously registered.",
        "suggest": "注册一个自定义分配错误 hook，替换以前注册的任何错误。",
        "translate": ""
    },
    {
        "source": "The allocation error hook is invoked when an infallible memory allocation fails, before the runtime aborts.",
        "suggest": "当可靠的内存分配失败时 (在运行时中止之前)，将调用分配错误 hook。",
        "translate": ""
    },
    {
        "source": "The default hook prints a message to standard error, but this behavior can be customized with the [`set_alloc_error_hook`] and [`take_alloc_error_hook`] functions.",
        "suggest": "默认的 hook 将消息显示为标准错误，但是可以使用 [`set_alloc_error_hook`] 和 [`take_alloc_error_hook`] 函数自定义此行为。",
        "translate": ""
    },
    {
        "source": "The hook is provided with a `Layout` struct which contains information about the allocation that failed.",
        "suggest": "hook 带有 `Layout` 结构体，该结构体包含有关失败分配的信息。",
        "translate": ""
    },
    {
        "source": "The allocation error hook is a global resource.",
        "suggest": "分配错误 hook 是一个资源。",
        "translate": ""
    },
    {
        "source": "Unregisters the current allocation error hook, returning it.",
        "suggest": "注销当前分配错误 hook，将其返回。",
        "translate": ""
    },
    {
        "source": "See also the function [`set_alloc_error_hook`].",
        "suggest": "另请参见函数 [`set_alloc_error_hook`]。",
        "translate": ""
    },
    {
        "source": "If no custom hook is registered, the default hook will be returned.",
        "suggest": "如果未注册自定义 hook，则将返回默认的 hook。",
        "translate": ""
    },
    {
        "source": "These magic symbol names are used as a fallback for implementing the `__rust_alloc` etc symbols (see `src/liballoc/alloc.rs`) when there is no `#[global_allocator]` attribute.",
        "suggest": "当没有 `#[global_allocator]` 属性时，这些魔术符号名称将用作实现 `__rust_alloc` etc 符号 (请参见 `src/liballoc/alloc.rs`) 的后备。",
        "translate": ""
    },
    {
        "source": "for symbol names src/librustc_ast/expand/allocator.rs for signatures src/librustc_allocator/lib.rs",
        "suggest": "用于符号名称 src/librustc_ast/expand/allocator.rs 用于签名 src/librustc_allocator/lib.rs",
        "translate": ""
    },
    {
        "source": "linkage directives are provided as part of the current compiler allocator ABI",
        "suggest": "链接指令作为当前编译器分配器 ABI 的一部分提供",
        "translate": ""
    },
    {
        "source": "see the guarantees expected by `Layout::from_size_align` and `GlobalAlloc::alloc`.",
        "suggest": "请参见 `Layout::from_size_align` 和 `GlobalAlloc::alloc` 的预期保证。",
        "translate": ""
    },
    {
        "source": "see the guarantees expected by `Layout::from_size_align` and `GlobalAlloc::dealloc`.",
        "suggest": "请参见 `Layout::from_size_align` 和 `GlobalAlloc::dealloc` 的预期保证。",
        "translate": ""
    },
    {
        "source": "see the guarantees expected by `Layout::from_size_align` and `GlobalAlloc::realloc`.",
        "suggest": "请参见 `Layout::from_size_align` 和 `GlobalAlloc::realloc` 的预期保证。",
        "translate": ""
    },
    {
        "source": "see the guarantees expected by `Layout::from_size_align` and `GlobalAlloc::alloc_zeroed`.",
        "suggest": "请参见 `Layout::from_size_align` 和 `GlobalAlloc::alloc_zeroed` 的预期保证。",
        "translate": ""
    },
    {
        "source": "The [`AsciiExt`] trait provides methods that allow for character operations that only act on the ASCII subset and leave non-ASCII characters alone.",
        "suggest": "[`AsciiExt`] trait 提供了允许仅对 ASCII 子集起作用而仅使非 ASCII 字符不起作用的字符操作的方法。",
        "translate": ""
    },
    {
        "source": "Extension methods for ASCII-subset only operations.",
        "suggest": "仅 ASCII 子集操作的扩展方法。",
        "translate": ""
    },
    {
        "source": "Be aware that operations on seemingly non-ASCII characters can sometimes have unexpected results.",
        "suggest": "请注意，对看似非 ASCII 字符的操作有时会产生意外结果。",
        "translate": ""
    },
    {
        "source": "Consider this example:",
        "suggest": "考虑以下示例:",
        "translate": ""
    },
    {
        "source": "In the first example, the lowercased string is represented `\"cafe\\u{301}\"` (the last character is an acute accent [combining character]).",
        "suggest": "在第一个示例中，小写的字符串表示为 `\"cafe\\u{301}\"` (最后一个字符为重音符 [combining character])。",
        "translate": ""
    },
    {
        "source": "Unlike the other characters in the string, the combining character will not get mapped to an uppercase variant, resulting in `\"CAFE\\u{301}\"`.",
        "suggest": "与字符串中的其他字符不同，合并字符不会映射到大写成员，从而导致 `\"CAFE\\u{301}\"`。",
        "translate": ""
    },
    {
        "source": "In the second example, the lowercased string is represented `\"caf\\u{e9}\"` (the last character is a single Unicode character representing an 'e' with an acute accent).",
        "suggest": "在第二个示例中，小写的字符串表示为 `\"caf\\u{e9}\"` (最后一个字符是单个 Unicode 字符，表示带有尖音的 'e')。",
        "translate": ""
    },
    {
        "source": "Since the last character is defined outside the scope of ASCII, it will not get mapped to an uppercase variant, resulting in `\"CAF\\u{e9}\"`.",
        "suggest": "由于最后一个字符是在 ASCII 的作用域之外定义的，因此不会将其映射到大写成员，从而导致 `\"CAF\\u{e9}\"`。",
        "translate": ""
    },
    {
        "source": "Container type for copied ASCII characters.",
        "suggest": "复制的 ASCII 字符的容器类型。",
        "translate": ""
    },
    {
        "source": "This method is deprecated in favor of the identically-named inherent methods on `u8`, `char`, `[u8]` and `str`.",
        "suggest": "不推荐使用此方法，而推荐使用 `u8`，`char`，`[u8]` 和 `str` 上相同名称的固有方法。",
        "translate": ""
    },
    {
        "source": "To uppercase ASCII characters in addition to non-ASCII characters, use [`str::to_uppercase`].",
        "suggest": "要除非 ASCII 字符外还使用大写 ASCII 字符，请使用 [`str::to_uppercase`]。",
        "translate": ""
    },
    {
        "source": "To lowercase ASCII characters in addition to non-ASCII characters, use [`str::to_lowercase`].",
        "suggest": "要除非 ASCII 字符外还使用小写 ASCII 字符，请使用 [`str::to_lowercase`]。",
        "translate": ""
    },
    {
        "source": "Format the backtrace a second time, just to make sure lazily resolved state is stable",
        "suggest": "再次格式化回溯，只是为了确保延迟解析的状态是稳定的",
        "translate": ""
    },
    {
        "source": "Support for capturing a stack backtrace of an OS thread",
        "suggest": "支持捕获 OS 线程的栈回溯",
        "translate": ""
    },
    {
        "source": "This module contains the support necessary to capture a stack backtrace of a running OS thread from the OS thread itself.",
        "suggest": "该模块包含从 OS 线程本身捕获正在运行的 OS 线程的栈回溯所必需的支持。",
        "translate": ""
    },
    {
        "source": "The `Backtrace` type supports capturing a stack trace via the `Backtrace::capture` and `Backtrace::force_capture` functions.",
        "suggest": "`Backtrace` 类型支持通过 `Backtrace::capture` 和 `Backtrace::force_capture` 函数捕获栈跟踪。",
        "translate": ""
    },
    {
        "source": "A backtrace is typically quite handy to attach to errors (e.g. types implementing `std::error::Error`) to get a causal chain of where an error was generated.",
        "suggest": "回溯通常很容易附加到错误 (例如，实现 `std::error::Error` 的类型) 上，以获取产生错误的因果关系。",
        "translate": ""
    },
    {
        "source": "this module is unstable and is designed in [RFC 2504], and you",
        "suggest": "该模块是不稳定的，并且是在 [RFC 2504] 中设计的，因此您",
        "translate": ""
    },
    {
        "source": "can learn more about its status in the [tracking issue].",
        "suggest": "可以在 [tracking issue] 中了解有关其状态的更多信息。",
        "translate": ""
    },
    {
        "source": "Backtraces are attempted to be as accurate as possible, but no guarantees are provided about the exact accuracy of a backtrace.",
        "suggest": "回溯试图尽可能地准确，但不保证回溯的准确度。",
        "translate": ""
    },
    {
        "source": "Instruction pointers, symbol names, filenames, line numbers, etc, may all be incorrect when reported.",
        "suggest": "报告时，指令指针，符号名称，文件名，行号等可能都不正确。",
        "translate": ""
    },
    {
        "source": "Accuracy is attempted on a best-effort basis, however, and bugs are always welcome to indicate areas of improvement!",
        "suggest": "尽力而为，力求做到准确，但是，始终欢迎欢迎带错误的地方指出改进的地方!",
        "translate": ""
    },
    {
        "source": "For most platforms a backtrace with a filename/line number requires that programs be compiled with debug information.",
        "suggest": "对于大多数平台，带有 filename/line 编号的回溯要求使用调试信息编译程序。",
        "translate": ""
    },
    {
        "source": "Without debug information filenames/line numbers will not be reported.",
        "suggest": "没有调试信息，将不会报告 filenames/line 号。",
        "translate": ""
    },
    {
        "source": "Platform support",
        "suggest": "平台支持",
        "translate": ""
    },
    {
        "source": "Not all platforms that libstd compiles for support capturing backtraces.",
        "suggest": "并非所有 libstd 编译的平台都支持捕获回溯。",
        "translate": ""
    },
    {
        "source": "Some platforms simply do nothing when capturing a backtrace.",
        "suggest": "一些平台在捕获回溯时根本不执行任何操作。",
        "translate": ""
    },
    {
        "source": "To check whether the platform supports capturing backtraces you can consult the `BacktraceStatus` enum as a result of `Backtrace::status`.",
        "suggest": "要检查平台是否支持捕获回溯，您可以参考 `Backtrace::status` 作为 `Backtrace::status` 的枚举。",
        "translate": ""
    },
    {
        "source": "Like above with accuracy platform support is done on a best effort basis.",
        "suggest": "像上面一样，准确性平台的支持是尽力而为的。",
        "translate": ""
    },
    {
        "source": "Sometimes libraries may not be available at runtime or something may go wrong which would cause a backtrace to not be captured.",
        "suggest": "有时，库可能在运行时不可用，或者某些地方可能出错，这将导致无法捕获回溯。",
        "translate": ""
    },
    {
        "source": "Please feel free to report issues with platforms where a backtrace cannot be captured though!",
        "suggest": "请随时报告平台无法捕获回溯的问题!",
        "translate": ""
    },
    {
        "source": "Environment Variables",
        "suggest": "环境变量",
        "translate": ""
    },
    {
        "source": "The `Backtrace::capture` function may not actually capture a backtrace by default.",
        "suggest": "默认情况下，`Backtrace::capture` 函数可能实际上未捕获回溯。",
        "translate": ""
    },
    {
        "source": "Its behavior is governed by two environment variables:",
        "suggest": "它的行为受两个环境变量控制:",
        "translate": ""
    },
    {
        "source": "if this is set to `0` then `Backtrace::capture` will never capture a backtrace.",
        "suggest": "如果将其设置为 `0`，则 `Backtrace::capture` 将永远不会捕获回溯。",
        "translate": ""
    },
    {
        "source": "Any other value this is set to will enable `Backtrace::capture`.",
        "suggest": "设置为该值的任何其他值将启用 `Backtrace::capture`。",
        "translate": ""
    },
    {
        "source": "if `RUST_LIB_BACKTRACE` is not set, then this variable is consulted with the same rules of `RUST_LIB_BACKTRACE`.",
        "suggest": "如果未设置 `RUST_LIB_BACKTRACE`，则使用与 `RUST_LIB_BACKTRACE` 相同的规则查询该变量。",
        "translate": ""
    },
    {
        "source": "If neither of the above env vars are set, then `Backtrace::capture` will be disabled.",
        "suggest": "如果以上两个环境变量均未设置，则 `Backtrace::capture` 将被禁用。",
        "translate": ""
    },
    {
        "source": "Capturing a backtrace can be a quite expensive runtime operation, so the environment variables allow either forcibly disabling this runtime performance hit or allow selectively enabling it in some programs.",
        "suggest": "捕获回溯可能是相当昂贵的运行时操作，因此环境变量允许强制禁用此运行时性能命中值，或者允许在某些程序中有选择地启用它。",
        "translate": ""
    },
    {
        "source": "Note that the `Backtrace::force_capture` function can be used to ignore these environment variables.",
        "suggest": "注意，可以使用 `Backtrace::force_capture` 函数来忽略这些环境变量。",
        "translate": ""
    },
    {
        "source": "Also note that the state of environment variables is cached once the first backtrace is created, so altering `RUST_LIB_BACKTRACE` or `RUST_BACKTRACE` at runtime may not actually change how backtraces are captured.",
        "suggest": "还要注意，一旦创建了第一个回溯，环境变量的状态就会被缓存，因此在运行时更改 `RUST_LIB_BACKTRACE` 或 `RUST_BACKTRACE` 可能实际上并不会改变捕获回溯的方式。",
        "translate": ""
    },
    {
        "source": "A note on resolution of a backtrace:",
        "suggest": "关于解决回溯的说明:",
        "translate": ""
    },
    {
        "source": "Backtraces primarily happen in two steps, one is where we actually capture the stack backtrace, giving us a list of instruction pointers corresponding to stack frames.",
        "suggest": "回溯主要发生在两个步骤中，一个是我们实际捕获栈回溯的位置，从而为我们提供了与栈帧相对应的指令指针列表。",
        "translate": ""
    },
    {
        "source": "Next we take these instruction pointers and, one-by-one, turn them into a human readable name (like `main`).",
        "suggest": "接下来，我们使用这些指令指针，并将它们逐个转换为人类可读的名称 (例如 `main`)。",
        "translate": ""
    },
    {
        "source": "The first phase can be somewhat expensive (walking the stack), especially on MSVC where debug information is consulted to return inline frames each as their own frame.",
        "suggest": "第一阶段可能会有些昂贵 (遍历栈)，尤其是在 MSVC 上，在该 MSVC 上，将参考调试信息以将内联帧返回为各自的帧。",
        "translate": ""
    },
    {
        "source": "The second phase, however, is almost always extremely expensive (on the order of milliseconds sometimes) when it's consulting debug information.",
        "suggest": "但是，在咨询调试信息时，第二阶段几乎总是非常昂贵 (有时约数毫秒)。",
        "translate": ""
    },
    {
        "source": "We attempt to amortize this cost as much as possible by delaying resolution of an address to a human readable name for as long as possible.",
        "suggest": "我们试图通过尽可能长时间地将地址解析为人类可读的名称来尽可能摊销此费用。",
        "translate": ""
    },
    {
        "source": "When `Backtrace::create` is called to capture a backtrace it doesn't actually perform any symbol resolution, but rather we lazily resolve symbols only just before they're needed for printing.",
        "suggest": "当调用 `Backtrace::create` 捕获回溯时，它实际上并不执行任何符号解析，而是仅在需要打印符号之前才对它们进行延迟解析。",
        "translate": ""
    },
    {
        "source": "This way we can make capturing a backtrace and throwing it away much cheaper, but actually printing a backtrace is still basically the same cost.",
        "suggest": "这样，我们可以使捕获回溯并将其扔掉便宜得多，但实际上打印回溯仍基本上是相同的成本。",
        "translate": ""
    },
    {
        "source": "This strategy comes at the cost of some synchronization required inside of a `Backtrace`, but that's a relatively small price to pay relative to capturing a backtrace or actually symbolizing it.",
        "suggest": "这种策略是以 `Backtrace` 内部需要进行一些同步为代价的，但是相对于捕获回溯或实际对其进行符号化而言，这是一个相对较低的代价。",
        "translate": ""
    },
    {
        "source": "A captured OS thread stack backtrace.",
        "suggest": "捕获的 OS 线程栈回溯。",
        "translate": ""
    },
    {
        "source": "This type represents a stack backtrace for an OS thread captured at a previous point in time.",
        "suggest": "此类型表示在先前时间点捕获的 OS 线程的栈回溯。",
        "translate": ""
    },
    {
        "source": "In some instances the `Backtrace` type may internally be empty due to configuration.",
        "suggest": "在某些情况下，由于配置，`Backtrace` 类型在内部可能为空。",
        "translate": ""
    },
    {
        "source": "For more information see `Backtrace::capture`.",
        "suggest": "有关更多信息，请参见 `Backtrace::capture`。",
        "translate": ""
    },
    {
        "source": "The current status of a backtrace, indicating whether it was captured or whether it is empty for some other reason.",
        "suggest": "回溯的当前状态，指示它是否已捕获或由于其他原因而为空。",
        "translate": ""
    },
    {
        "source": "Capturing a backtrace is not supported, likely because it's not implemented for the current platform.",
        "suggest": "不支持捕获回溯，这可能是因为当前平台尚未实现。",
        "translate": ""
    },
    {
        "source": "Capturing a backtrace has been disabled through either the `RUST_LIB_BACKTRACE` or `RUST_BACKTRACE` environment variables.",
        "suggest": "通过 `RUST_LIB_BACKTRACE` 或 `RUST_BACKTRACE` 环境变量已禁用捕获回溯。",
        "translate": ""
    },
    {
        "source": "A backtrace has been captured and the `Backtrace` should print reasonable information when rendered.",
        "suggest": "回溯已被捕获，并且 `Backtrace` 在呈现时应打印合理的信息。",
        "translate": ""
    },
    {
        "source": "A single frame of a backtrace.",
        "suggest": "回溯的单个帧。",
        "translate": ""
    },
    {
        "source": "improve formatting:",
        "suggest": "改善格式:",
        "translate": ""
    },
    {
        "source": "Also, include column numbers into the debug format as Display already has them.",
        "suggest": "另外，将列号包括在调试格式中，因为 Display 已经拥有了它们。",
        "translate": ""
    },
    {
        "source": "Until there are stable per-frame accessors, the format shouldn't be changed:",
        "suggest": "在存在稳定的每帧访问器之前，不应更改格式:",
        "translate": ""
    },
    {
        "source": "Returns whether backtrace captures are enabled through environment variables.",
        "suggest": "返回是否通过环境变量启用回溯捕获。",
        "translate": ""
    },
    {
        "source": "Cache the result of reading the environment variables to make backtrace captures speedy, because otherwise reading environment variables every time can be somewhat slow.",
        "suggest": "高速缓存读取环境变量的结果以快速捕获回溯，因为否则每次读取环境变量都可能有些慢。",
        "translate": ""
    },
    {
        "source": "Capture a stack backtrace of the current thread.",
        "suggest": "捕获当前线程的栈回溯。",
        "translate": ""
    },
    {
        "source": "This function will capture a stack backtrace of the current OS thread of execution, returning a `Backtrace` type which can be later used to print the entire stack trace or render it to a string.",
        "suggest": "此函数将捕获当前 OS 执行线程的栈回溯，并返回 `Backtrace` 类型，该类型以后可用于打印整个栈跟踪或将其呈现为字符串。",
        "translate": ""
    },
    {
        "source": "This function will be a noop if the `RUST_BACKTRACE` or `RUST_LIB_BACKTRACE` backtrace variables are both not set.",
        "suggest": "如果没有同时设置 `RUST_BACKTRACE` 或 `RUST_LIB_BACKTRACE` backtrace 变量，则此函数将为 noop。",
        "translate": ""
    },
    {
        "source": "If either environment variable is set and enabled then this function will actually capture a backtrace.",
        "suggest": "如果设置并启用了任何一个环境变量，则此函数实际上将捕获回溯。",
        "translate": ""
    },
    {
        "source": "Capturing a backtrace can be both memory intensive and slow, so these environment variables allow liberally using `Backtrace::capture` and only incurring a slowdown when the environment variables are set.",
        "suggest": "捕获回溯可能会占用大量内存并且速度很慢，因此这些环境变量允许自由使用 `Backtrace::capture`，并且仅在设置环境变量时才会导致速度降低。",
        "translate": ""
    },
    {
        "source": "To forcibly capture a backtrace regardless of environment variables, use the `Backtrace::force_capture` function.",
        "suggest": "要强制捕获回溯，而不管环境变量如何，请使用 `Backtrace::force_capture` 函数。",
        "translate": ""
    },
    {
        "source": "Forcibly captures a full backtrace, regardless of environment variable configuration.",
        "suggest": "无论环境变量配置如何，都将强制捕获完整的回溯。",
        "translate": ""
    },
    {
        "source": "This function behaves the same as `capture` except that it ignores the values of the `RUST_BACKTRACE` and `RUST_LIB_BACKTRACE` environment variables, always capturing a backtrace.",
        "suggest": "此函数的行为与 `capture` 相同，不同之处在于它忽略 `RUST_BACKTRACE` 和 `RUST_LIB_BACKTRACE` 环境变量的值，始终捕获回溯。",
        "translate": ""
    },
    {
        "source": "Note that capturing a backtrace can be an expensive operation on some platforms, so this should be used with caution in performance-sensitive parts of code.",
        "suggest": "请注意，在某些平台上，捕获回溯可能是一项昂贵的操作，因此在对性能敏感的代码部分中应谨慎使用。",
        "translate": ""
    },
    {
        "source": "Forcibly captures a disabled backtrace, regardless of environment variable configuration.",
        "suggest": "无论环境变量配置如何，都将强制捕获禁用的回溯。",
        "translate": ""
    },
    {
        "source": "Capture a backtrace which start just before the function addressed by",
        "suggest": "捕获一个追溯，该追溯开始于由寻址的函数之前",
        "translate": ""
    },
    {
        "source": "We don't attempt to lock this reentrantly.",
        "suggest": "我们不会试图重新锁定它。",
        "translate": ""
    },
    {
        "source": "If no frames came out assume that this is an unsupported platform since `backtrace` doesn't provide a way of learning this right now, and this should be a good enough approximation.",
        "suggest": "如果没有框架出现，请假定这是不受支持的平台，因为 `backtrace` 目前尚无法提供学习该方法的平台，这应该是一个足够好的近似值。",
        "translate": ""
    },
    {
        "source": "Returns the status of this backtrace, indicating whether this backtrace request was unsupported, disabled, or a stack trace was actually captured.",
        "suggest": "返回此回溯的状态，指示此回溯请求是否不受支持，已禁用或是否实际捕获了栈跟踪。",
        "translate": ""
    },
    {
        "source": "Returns an iterator over the backtrace frames.",
        "suggest": "返回回溯帧上的迭代器。",
        "translate": ""
    },
    {
        "source": "This exclusive reference can't overlap with any others `Once` guarantees callers will block until this closure returns `Once` also guarantees only a single caller will enter this closure",
        "suggest": "此独家引用不能与任何其他 `Once` 重叠，以确保在此闭包返回之前，调用者将被阻止 `Once` 还保证只有一个调用者会进入此闭包",
        "translate": ""
    },
    {
        "source": "This shared reference can't overlap with the exclusive reference above",
        "suggest": "此共享的引用不能与上面的专有引用重叠",
        "translate": ""
    },
    {
        "source": "Access to the inner value is synchronized using a thread-safe `Once` So long as `Capture` is `Sync`, `LazilyResolvedCapture` is too",
        "suggest": "使用线程安全的 `Once` 同步访问内部值，只要 `Capture` 是 `Sync`，`LazilyResolvedCapture` 也是",
        "translate": ""
    },
    {
        "source": "If we're already resolved, nothing to do!",
        "suggest": "如果我们已经解决，则无事可做!",
        "translate": ""
    },
    {
        "source": "Use the global backtrace lock to synchronize this as it's a requirement of the `backtrace` crate, and then actually resolve everything.",
        "suggest": "根据 `backtrace` crate 的要求，使用 Backtrace 锁进行同步，然后实际解决所有问题。",
        "translate": ""
    },
    {
        "source": "By the way, ensure that cloning doesn't screw up the dropping.",
        "suggest": "顺便说一句，请确保克隆不会被丢弃。",
        "translate": ""
    },
    {
        "source": "Try this a few times to make sure we never screw up the hashmap's internal state.",
        "suggest": "尝试几次以确保我们永远不会破坏 hashmap 的内部状态。",
        "translate": ""
    },
    {
        "source": "remove forwards",
        "suggest": "删除 forwards",
        "translate": ""
    },
    {
        "source": "remove backwards",
        "suggest": "删除 backwards",
        "translate": ""
    },
    {
        "source": "Test for #19292",
        "suggest": "测试 #19292",
        "translate": ""
    },
    {
        "source": "Populate the map with some items.",
        "suggest": "在 map 中填充一些项。",
        "translate": ""
    },
    {
        "source": "Insert at capacity should cause allocation.",
        "suggest": "插入容量应引起分配。",
        "translate": ""
    },
    {
        "source": "Nonexistent key (insert)",
        "suggest": "不存在的键 (insert)",
        "translate": ""
    },
    {
        "source": "Ensure all lookup methods produce equivalent results.",
        "suggest": "确保所有查找方法均产生相同的结果。",
        "translate": ""
    },
    {
        "source": "Type inference lets us omit an explicit type signature (which would be `HashMap<String, String>` in this example).",
        "suggest": "通过类型推断，我们可以省略显式类型签名 (在本示例中为 `HashMap<String, String>`)。",
        "translate": ""
    },
    {
        "source": "Review some books.",
        "suggest": "复习一些书。",
        "translate": ""
    },
    {
        "source": "When collections store owned values (String), they can still be queried using references (&str).",
        "suggest": "当集合存储拥有的值 (String) 时，仍可以使用引用 (&str) 来查询它们。",
        "translate": ""
    },
    {
        "source": "Look up the values associated with some keys.",
        "suggest": "查找与某些键关联的值。",
        "translate": ""
    },
    {
        "source": "type inference lets us omit an explicit type signature (which would be `HashMap<&str, u8>` in this example).",
        "suggest": "通过类型推断，我们可以省略显式类型签名 (在本示例中为 `HashMap<&str, u8>`)。",
        "translate": ""
    },
    {
        "source": "Creates a new Viking.",
        "suggest": "创建一个新的 Viking。",
        "translate": ""
    },
    {
        "source": "Use a HashMap to store the vikings' health points.",
        "suggest": "使用 HashMap 存储 Viking 的健康点。",
        "translate": ""
    },
    {
        "source": "Use derived implementation to print the status of the vikings.",
        "suggest": "使用派生的实现来打印 Viking 的状态。",
        "translate": ""
    },
    {
        "source": "use the values stored in map",
        "suggest": "使用存储在 map 中的值",
        "translate": ""
    },
    {
        "source": "Update all values",
        "suggest": "更新所有值",
        "translate": ""
    },
    {
        "source": "Not possible with .iter()",
        "suggest": ".iter() 无法使用",
        "translate": ""
    },
    {
        "source": "Also replace the key with a handle to our other key.",
        "suggest": "同时用我们其他键的句柄代替键。",
        "translate": ""
    },
    {
        "source": "Initialise known strings, run program, etc.",
        "suggest": "初始化已知的字符串，运行程序等",
        "translate": ""
    },
    {
        "source": "Replaces the entry's key with our version of it in `known_strings`.",
        "suggest": "将条目的键替换为我们在 `known_strings` 中的版本。",
        "translate": ""
    },
    {
        "source": "A [hash map] implemented with quadratic probing and SIMD lookup.",
        "suggest": "通过二次探测和 SIMD 查找实现的 [hash map]。",
        "translate": ""
    },
    {
        "source": "By default, `HashMap` uses a hashing algorithm selected to provide resistance against HashDoS attacks.",
        "suggest": "默认情况下，`HashMap` 使用选择为提供对 HashDoS 攻击的抵抗力的哈希算法。",
        "translate": ""
    },
    {
        "source": "The algorithm is randomly seeded, and a reasonable best-effort is made to generate this seed from a high quality, secure source of randomness provided by the host without blocking the program.",
        "suggest": "该算法是随机播种的，并且做出了合理的努力以从主机提供的高质量，安全的随机性源生成此 seed，而不会阻塞程序。",
        "translate": ""
    },
    {
        "source": "Because of this, the randomness of the seed depends on the output quality of the system's random number generator when the seed is created.",
        "suggest": "因此，seed 的随机性取决于创建 seed 时系统随机数发生器的输出质量。",
        "translate": ""
    },
    {
        "source": "In particular, seeds generated when the system's entropy pool is abnormally low such as during system boot may be of a lower quality.",
        "suggest": "特别地，当系统的熵池异常低时 (例如在系统引导期间) 生成的种子可能具有较低的质量。",
        "translate": ""
    },
    {
        "source": "The default hashing algorithm is currently SipHash 1-3, though this is subject to change at any point in the future.",
        "suggest": "当前的默认哈希算法是 SipHash 1-3，尽管它可能会在 future 的任何位置进行更改。",
        "translate": ""
    },
    {
        "source": "While its performance is very competitive for medium sized keys, other hashing algorithms will outperform it for small keys such as integers as well as large keys such as long strings, though those algorithms will typically *not* protect against attacks such as HashDoS.",
        "suggest": "虽然它的性能对于中等大小的键非常有竞争力，但其他散列算法对于小键（如整数）和大键（如长字符串）的性能将优于它，尽管这些算法通常不能防止诸如 HashDoS 之类的攻击。",
        "translate": ""
    },
    {
        "source": "The hashing algorithm can be replaced on a per-`HashMap` basis using the [`default`], [`with_hasher`], and [`with_capacity_and_hasher`] methods.",
        "suggest": "可以使用 [`default`]，[`with_hasher`] 和 [`with_capacity_and_hasher`] 方法在每个 `HashMap` 的基础上替换哈希算法。",
        "translate": ""
    },
    {
        "source": "There are many alternative [hashing algorithms available on crates.io].",
        "suggest": "[hashing algorithms available on crates.io] 有很多替代方案。",
        "translate": ""
    },
    {
        "source": "It is required that the keys implement the [`Eq`] and [`Hash`] traits, although this can frequently be achieved by using `#[derive(PartialEq, Eq, Hash)]`.",
        "suggest": "尽管通常可以通过使用 `#[derive(PartialEq, Eq, Hash)]` 来实现，但要求键实现 [`Eq`] 和 [`Hash`] traits。",
        "translate": ""
    },
    {
        "source": "If you implement these yourself, it is important that the following property holds:",
        "suggest": "如果您自己实现这些，那么拥有以下属性非常重要:",
        "translate": ""
    },
    {
        "source": "In other words, if two keys are equal, their hashes must be equal.",
        "suggest": "换句话说，如果两个键相等，则它们的哈希值必须相等。",
        "translate": ""
    },
    {
        "source": "It is a logic error for a key to be modified in such a way that the key's hash, as determined by the [`Hash`] trait, or its equality, as determined by the [`Eq`] trait, changes while it is in the map.",
        "suggest": "以这样一种方式修改键是一个逻辑错误，即键的散列（由 [`Hash`] 特征确定）或其相等性（由 [`Eq`] 特征确定）在更改时发生变化在 map 上。",
        "translate": ""
    },
    {
        "source": "The hash table implementation is a Rust port of Google's [SwissTable].",
        "suggest": "哈希表实现是 Google [SwissTable] 的 Rust 端口。",
        "translate": ""
    },
    {
        "source": "The original C++ version of SwissTable can be found [here], and this [CppCon talk] gives an overview of how the algorithm works.",
        "suggest": "可以在 [这里][here] 找到 SwissTable 的原始 C++ 版本，而该 [CppCon talk] 概述了该算法的工作原理。",
        "translate": ""
    },
    {
        "source": "also implements an [`Entry API`](#method.entry), which allows for more complex methods of getting, setting, updating and removing keys and their values:",
        "suggest": "还实现了 [`Entry API`](#method.entry)，它允许使用更复杂的方法来获取，设置，更新和删除键及其值:",
        "translate": ""
    },
    {
        "source": "The easiest way to use `HashMap` with a custom key type is to derive [`Eq`] and [`Hash`].",
        "suggest": "将 `HashMap` 与自定义键类型一起使用的最简单方法是派生 [`Eq`] 和 [`Hash`]。",
        "translate": ""
    },
    {
        "source": "We must also derive [`PartialEq`].",
        "suggest": "我们还必须导出 [`PartialEq`]。",
        "translate": ""
    },
    {
        "source": "A `HashMap` with fixed list of elements can be initialized from an array:",
        "suggest": "具有固定元素列表的 `HashMap` 可以从数组中初始化:",
        "translate": ""
    },
    {
        "source": "Creates an empty `HashMap`.",
        "suggest": "创建一个空的 `HashMap`。",
        "translate": ""
    },
    {
        "source": "The hash map is initially created with a capacity of 0, so it will not allocate until it is first inserted into.",
        "suggest": "哈希 map 最初创建时的容量为 0，因此只有在首次插入时才分配。",
        "translate": ""
    },
    {
        "source": "Creates an empty `HashMap` with the specified capacity.",
        "suggest": "创建具有指定容量的空 `HashMap`。",
        "translate": ""
    },
    {
        "source": "The hash map will be able to hold at least `capacity` elements without reallocating.",
        "suggest": "哈希 map 将能够至少保留 `capacity` 个元素而无需重新分配。",
        "translate": ""
    },
    {
        "source": "If `capacity` is 0, the hash map will not allocate.",
        "suggest": "如果 `capacity` 为 0，则不会分配哈希 map。",
        "translate": ""
    },
    {
        "source": "Creates an empty `HashMap` which will use the given hash builder to hash keys.",
        "suggest": "创建一个空的 `HashMap`，它将使用给定的哈希生成器来哈希键。",
        "translate": ""
    },
    {
        "source": "The created map has the default initial capacity.",
        "suggest": "创建的 map 具有默认的初始容量。",
        "translate": ""
    },
    {
        "source": "Warning: `hash_builder` is normally randomly generated, and is designed to allow HashMaps to be resistant to attacks that cause many collisions and very poor performance.",
        "suggest": "警告: `hash_builder` 通常是随机生成的，旨在使 HashMaps 能够抵抗导致许多冲突和非常差的性能的攻击。",
        "translate": ""
    },
    {
        "source": "Setting it manually using this function can expose a DoS attack vector.",
        "suggest": "使用此函数手动设置它可能会导致 DoS 攻击 vector。",
        "translate": ""
    },
    {
        "source": "The `hash_builder` passed should implement the [`BuildHasher`] trait for the HashMap to be useful, see its documentation for details.",
        "suggest": "传递的 `hash_builder` 应该为 X0HashMap0Z 实现 [`BuildHasher`] trait 才有用，有关详细信息，请参见其文档。",
        "translate": ""
    },
    {
        "source": "Creates an empty `HashMap` with the specified capacity, using `hash_builder` to hash the keys.",
        "suggest": "创建一个具有指定容量的空 `HashMap`，使用 `hash_builder` 对键进行散列。",
        "translate": ""
    },
    {
        "source": "Returns the number of elements the map can hold without reallocating.",
        "suggest": "返回 map 无需重新分配即可容纳的元素数。",
        "translate": ""
    },
    {
        "source": "This number is a lower bound;",
        "suggest": "此数字是一个下限;",
        "translate": ""
    },
    {
        "source": "the `HashMap<K, V>` might be able to hold more, but is guaranteed to be able to hold at least this many.",
        "suggest": "`HashMap<K, V>` 可能可以容纳更多，但可以保证至少容纳这么多。",
        "translate": ""
    },
    {
        "source": "An iterator visiting all keys in arbitrary order.",
        "suggest": "一个迭代器，以任意顺序访问所有键。",
        "translate": ""
    },
    {
        "source": "The iterator element type is `&'a K`.",
        "suggest": "迭代器元素类型为 `&'a K`。",
        "translate": ""
    },
    {
        "source": "An iterator visiting all values in arbitrary order.",
        "suggest": "一个以任意顺序访问所有值的迭代器。",
        "translate": ""
    },
    {
        "source": "The iterator element type is `&'a V`.",
        "suggest": "迭代器元素类型为 `&'a V`。",
        "translate": ""
    },
    {
        "source": "An iterator visiting all values mutably in arbitrary order.",
        "suggest": "一个迭代器，它以任意顺序可变地访问所有值。",
        "translate": ""
    },
    {
        "source": "The iterator element type is `&'a mut V`.",
        "suggest": "迭代器元素类型为 `&'a mut V`。",
        "translate": ""
    },
    {
        "source": "An iterator visiting all key-value pairs in arbitrary order.",
        "suggest": "一个迭代器，以任意顺序访问所有键值对。",
        "translate": ""
    },
    {
        "source": "The iterator element type is `(&'a K, &'a V)`.",
        "suggest": "迭代器元素类型为 `(&'a K, &'a V)`。",
        "translate": ""
    },
    {
        "source": "An iterator visiting all key-value pairs in arbitrary order, with mutable references to the values.",
        "suggest": "一个迭代器，以任意顺序访问所有键值对，并且对值进行可变引用。",
        "translate": ""
    },
    {
        "source": "The iterator element type is `(&'a K, &'a mut V)`.",
        "suggest": "迭代器元素类型为 `(&'a K, &'a mut V)`。",
        "translate": ""
    },
    {
        "source": "Clears the map, returning all key-value pairs as an iterator.",
        "suggest": "清除 map，将所有键值对作为迭代器返回。",
        "translate": ""
    },
    {
        "source": "Keeps the allocated memory for reuse.",
        "suggest": "保留分配的内存以供重用。",
        "translate": ""
    },
    {
        "source": "If the closure returns true, the element is removed from the map and yielded.",
        "suggest": "如果闭包返回 true，则将元素从 map 中移除并产生。",
        "translate": ""
    },
    {
        "source": "If the closure returns false, or panics, the element remains in the map and will not be yielded.",
        "suggest": "如果闭包返回 false 或 panics，则该元素保留在 map 中，并且不会产生。",
        "translate": ""
    },
    {
        "source": "Note that `drain_filter` lets you mutate every value in the filter closure, regardless of whether you choose to keep or remove it.",
        "suggest": "请注意，无论选择保留还是删除 `drain_filter`，您都可以对过滤器闭包中的每个值进行可变的。",
        "translate": ""
    },
    {
        "source": "If the iterator is only partially consumed or not consumed at all, each of the remaining elements will still be subjected to the closure and removed and dropped if it returns true.",
        "suggest": "如果迭代器仅被部分使用或完全不使用，则其余所有元素仍将受到闭包的处理，如果返回 true，则将其删除并丢弃。",
        "translate": ""
    },
    {
        "source": "Clears the map, removing all key-value pairs.",
        "suggest": "清除 map，删除所有键值对。",
        "translate": ""
    },
    {
        "source": "Returns a reference to the map's [`BuildHasher`].",
        "suggest": "返回 map 的 [`BuildHasher`] 的引用。",
        "translate": ""
    },
    {
        "source": "Reserves capacity for at least `additional` more elements to be inserted in the `HashMap`.",
        "suggest": "保留至少 `additional` 个要插入 `HashMap` 中的更多元素的容量。",
        "translate": ""
    },
    {
        "source": "Panics if the new allocation size overflows [`usize`].",
        "suggest": "如果新的分配大小溢出 [`usize`]，则为 Panics。",
        "translate": ""
    },
    {
        "source": "Tries to reserve capacity for at least `additional` more elements to be inserted in the given `HashMap<K, V>`.",
        "suggest": "尝试为给 `HashMap<K, V>` 至少插入 `additional` 个元素保留容量。",
        "translate": ""
    },
    {
        "source": "Shrinks the capacity of the map as much as possible.",
        "suggest": "尽可能缩小 map 的容量。",
        "translate": ""
    },
    {
        "source": "It will drop down as much as possible while maintaining the internal rules and possibly leaving some space in accordance with the resize policy.",
        "suggest": "它会在保持内部规则的同时尽可能地丢弃，并可能根据调整大小策略留出一些空间。",
        "translate": ""
    },
    {
        "source": "Shrinks the capacity of the map with a lower limit.",
        "suggest": "降低 map 的容量。",
        "translate": ""
    },
    {
        "source": "It will drop down no lower than the supplied limit while maintaining the internal rules and possibly leaving some space in accordance with the resize policy.",
        "suggest": "它将降低不低于提供的限制，同时保持内部规则，并可能根据调整大小策略留下一些空间。",
        "translate": ""
    },
    {
        "source": "The key may be any borrowed form of the map's key type, but [`Hash`] and [`Eq`] on the borrowed form *must* match those for the key type.",
        "suggest": "键可以是 map 键类型的任何借用形式，但是借用形式上的 ['Hash`] 和 [`Eq`] 必须与键的类型匹配。",
        "translate": ""
    },
    {
        "source": "The supplied key may be any borrowed form of the map's key type, but [`Hash`] and [`Eq`] on the borrowed form *must* match those for the key type.",
        "suggest": "提供的键可以是 map 的键类型的任何借用形式，但是借用形式上的 [`Hash`] 和 [`Eq`] 必须与该键的类型匹配。",
        "translate": ""
    },
    {
        "source": "If the map did not have this key present, [`None`] is returned.",
        "suggest": "如果 map 不存在此键，则返回 [`None`]。",
        "translate": ""
    },
    {
        "source": "Creates a consuming iterator visiting all the keys in arbitrary order.",
        "suggest": "创建一个消费迭代器，以任意顺序访问所有键。",
        "translate": ""
    },
    {
        "source": "Creates a consuming iterator visiting all the values in arbitrary order.",
        "suggest": "创建一个消费迭代器，以任意顺序访问所有值。",
        "translate": ""
    },
    {
        "source": "Creates a raw entry builder for the HashMap.",
        "suggest": "为 HashMap 创建原始条目构建器。",
        "translate": ""
    },
    {
        "source": "Raw entries provide the lowest level of control for searching and manipulating a map.",
        "suggest": "原始条目为搜索和操作 map 提供了最低级别的控制。",
        "translate": ""
    },
    {
        "source": "They must be manually initialized with a hash and then manually searched.",
        "suggest": "必须使用哈希将其手动初始化，然后进行手动搜索。",
        "translate": ""
    },
    {
        "source": "After this, insertions into a vacant entry still require an owned key to be provided.",
        "suggest": "此后，插入空条目仍然需要提供一个拥有的键。",
        "translate": ""
    },
    {
        "source": "Raw entries are useful for such exotic situations as:",
        "suggest": "原始条目对于以下特殊情况很有用:",
        "translate": ""
    },
    {
        "source": "Hash memoization",
        "suggest": "哈希记忆",
        "translate": ""
    },
    {
        "source": "Deferring the creation of an owned key until it is known to be required",
        "suggest": "推迟创建拥有的键，直到知道它是必需的为止",
        "translate": ""
    },
    {
        "source": "Using a search key that doesn't work with the Borrow trait",
        "suggest": "使用不适用于借用 trait 的搜索键",
        "translate": ""
    },
    {
        "source": "Using custom comparison logic without newtype wrappers",
        "suggest": "在不使用 newtype 包装器的情况下使用自定义比较逻辑",
        "translate": ""
    },
    {
        "source": "Because raw entries provide much more low-level control, it's much easier to put the HashMap into an inconsistent state which, while memory-safe, will cause the map to produce seemingly random results.",
        "suggest": "因为原始条目提供了更多的灵活控制，所以将 HashMap 置于不一致状态要容易得多，这虽然具有内存安全性，但会导致 map 产生看似随机的结果。",
        "translate": ""
    },
    {
        "source": "Higher-level and more foolproof APIs like `entry` should be preferred when possible.",
        "suggest": "如果可能，应首选更高级别且更简单的 API，例如 `entry`。",
        "translate": ""
    },
    {
        "source": "In particular, the hash used to initialized the raw entry must still be consistent with the hash of the key that is ultimately stored in the entry.",
        "suggest": "特别是，用于初始化原始条目的哈希必须仍然与最终存储在条目中的键的哈希保持一致。",
        "translate": ""
    },
    {
        "source": "This is because implementations of HashMap may need to recompute hashes when resizing, at which point only the keys are available.",
        "suggest": "这是因为 HashMap 的实现在调整大小时可能需要重新计算哈希，此时只有键可用。",
        "translate": ""
    },
    {
        "source": "Raw entries give mutable access to the keys.",
        "suggest": "原始条目为变量提供了可变的访问权限。",
        "translate": ""
    },
    {
        "source": "This must not be used to modify how the key would compare or hash, as the map will not re-evaluate where the key should go, meaning the keys may become \"lost\" if their location does not reflect their state.",
        "suggest": "这不能用于修改键的比较或散列方式，因为映射不会重新评估键应该去的位置，这意味着如果它们的位置不反映它们的状态，它们可能会丢失。",
        "translate": ""
    },
    {
        "source": "For instance, if you change a key so that the map now contains keys which compare equal, search may start acting erratically, with two keys randomly masking each other.",
        "suggest": "例如，如果您更改一个键以使 map 现在包含比较相等的键，则搜索可能会开始不规律地进行，两个键彼此相互掩盖。",
        "translate": ""
    },
    {
        "source": "Implementations are free to assume this doesn't happen (within the limits of memory-safety).",
        "suggest": "实现可以自由地假设不会发生这种情况 (在内存安全性的范围内)。",
        "translate": ""
    },
    {
        "source": "Creates a raw immutable entry builder for the HashMap.",
        "suggest": "为 HashMap 创建一个原始的不可变条目构建器。",
        "translate": ""
    },
    {
        "source": "This is useful for",
        "suggest": "这对于",
        "translate": ""
    },
    {
        "source": "Unless you are in such a situation, higher-level and more foolproof APIs like `get` should be preferred.",
        "suggest": "除非您处于这种情况下，否则应首选更高级别且更简单的 API，例如 `get`。",
        "translate": ""
    },
    {
        "source": "Immutable raw entries have very limited use;",
        "suggest": "不可变的原始条目用途非常有限;",
        "translate": ""
    },
    {
        "source": "you might instead want `raw_entry_mut`.",
        "suggest": "您可能需要 `raw_entry_mut`。",
        "translate": ""
    },
    {
        "source": "Creates an empty `HashMap<K, V, S>`, with the `Default` value for the hasher.",
        "suggest": "创建一个空的 `HashMap<K, V, S>`，其哈希值为 `Default`。",
        "translate": ""
    },
    {
        "source": "Panics if the key is not present in the `HashMap`.",
        "suggest": "如果键不在 `HashMap` 中，则会 panic。",
        "translate": ""
    },
    {
        "source": "An iterator over the entries of a `HashMap`.",
        "suggest": "`HashMap` 条目上的迭代器。",
        "translate": ""
    },
    {
        "source": "This `struct` is created by the [`iter`] method on [`HashMap`].",
        "suggest": "该 `struct` 是通过 [`HashMap`] 上的 [`iter`] 方法创建的。",
        "translate": ""
    },
    {
        "source": "A mutable iterator over the entries of a `HashMap`.",
        "suggest": "`HashMap` 条目上的可变迭代器。",
        "translate": ""
    },
    {
        "source": "This `struct` is created by the [`iter_mut`] method on [`HashMap`].",
        "suggest": "该 `struct` 是通过 [`HashMap`] 上的 [`iter_mut`] 方法创建的。",
        "translate": ""
    },
    {
        "source": "Returns a iterator of references over the remaining items.",
        "suggest": "返回剩余项上的迭代器。",
        "translate": ""
    },
    {
        "source": "An owning iterator over the entries of a `HashMap`.",
        "suggest": "`HashMap` 条目上的所有者迭代器。",
        "translate": ""
    },
    {
        "source": "This `struct` is created by the [`into_iter`] method on [`HashMap`] (provided by the `IntoIterator` trait).",
        "suggest": "该 `struct` 是通过 [`HashMap`] (由 `IntoIterator` trait 提供) 上的 [`into_iter`] 方法创建的。",
        "translate": ""
    },
    {
        "source": "An iterator over the keys of a `HashMap`.",
        "suggest": "`HashMap` 的键上的迭代器。",
        "translate": ""
    },
    {
        "source": "This `struct` is created by the [`keys`] method on [`HashMap`].",
        "suggest": "该 `struct` 是通过 [`HashMap`] 上的 [`keys`] 方法创建的。",
        "translate": ""
    },
    {
        "source": "An iterator over the values of a `HashMap`.",
        "suggest": "`HashMap` 值的迭代器。",
        "translate": ""
    },
    {
        "source": "This `struct` is created by the [`values`] method on [`HashMap`].",
        "suggest": "该 `struct` 是通过 [`HashMap`] 上的 [`values`] 方法创建的。",
        "translate": ""
    },
    {
        "source": "A draining iterator over the entries of a `HashMap`.",
        "suggest": "`HashMap` 条目上的 draining 迭代器。",
        "translate": ""
    },
    {
        "source": "This `struct` is created by the [`drain`] method on [`HashMap`].",
        "suggest": "该 `struct` 是通过 [`HashMap`] 上的 [`drain`] 方法创建的。",
        "translate": ""
    },
    {
        "source": "A draining, filtering iterator over the entries of a `HashMap`.",
        "suggest": "draining，对 `HashMap` 的条目进行过滤迭代器。",
        "translate": ""
    },
    {
        "source": "This `struct` is created by the [`drain_filter`] method on [`HashMap`].",
        "suggest": "该 `struct` 是通过 [`HashMap`] 上的 [`drain_filter`] 方法创建的。",
        "translate": ""
    },
    {
        "source": "A mutable iterator over the values of a `HashMap`.",
        "suggest": "`HashMap` 的值上的可变迭代器。",
        "translate": ""
    },
    {
        "source": "This `struct` is created by the [`values_mut`] method on [`HashMap`].",
        "suggest": "该 `struct` 是通过 [`HashMap`] 上的 [`values_mut`] 方法创建的。",
        "translate": ""
    },
    {
        "source": "An owning iterator over the keys of a `HashMap`.",
        "suggest": "`HashMap` 的键上的拥有的迭代器。",
        "translate": ""
    },
    {
        "source": "This `struct` is created by the [`into_keys`] method on [`HashMap`].",
        "suggest": "该 `struct` 是通过 [`HashMap`] 上的 [`into_keys`] 方法创建的。",
        "translate": ""
    },
    {
        "source": "An owning iterator over the values of a `HashMap`.",
        "suggest": "`HashMap` 的值上的拥有的迭代器。",
        "translate": ""
    },
    {
        "source": "This `struct` is created by the [`into_values`] method on [`HashMap`].",
        "suggest": "该 `struct` 是通过 [`HashMap`] 上的 [`into_values`] 方法创建的。",
        "translate": ""
    },
    {
        "source": "A builder for computing where in a HashMap a key-value pair would be stored.",
        "suggest": "一个用于计算 HashMap 中的键值对将存储在哪里的构建器。",
        "translate": ""
    },
    {
        "source": "See the [`HashMap::raw_entry_mut`] docs for usage examples.",
        "suggest": "有关用法示例，请参见 [`HashMap::raw_entry_mut`] 文档。",
        "translate": ""
    },
    {
        "source": "This is a lower-level version of [`Entry`].",
        "suggest": "这是 [`Entry`] 的较低版本。",
        "translate": ""
    },
    {
        "source": "This `enum` is constructed through the [`raw_entry_mut`] method on [`HashMap`], then calling one of the methods of that [`RawEntryBuilderMut`].",
        "suggest": "该 `enum` 是通过 [`HashMap`] 上的 [`raw_entry_mut`] 方法构造的，然后调用该 [`RawEntryBuilderMut`] 的方法之一。",
        "translate": ""
    },
    {
        "source": "A view into an occupied entry in a `HashMap`.",
        "suggest": "`HashMap` 中已占用条目的视图。",
        "translate": ""
    },
    {
        "source": "It is part of the [`RawEntryMut`] enum.",
        "suggest": "它是 [`RawEntryMut`] 枚举的一部分。",
        "translate": ""
    },
    {
        "source": "A view into a vacant entry in a `HashMap`.",
        "suggest": "`HashMap` 中空闲条目的视图。",
        "translate": ""
    },
    {
        "source": "See the [`HashMap::raw_entry`] docs for usage examples.",
        "suggest": "有关用法示例，请参见 [`HashMap::raw_entry`] 文档。",
        "translate": ""
    },
    {
        "source": "Creates a `RawEntryMut` from the given key.",
        "suggest": "从给定的键创建一个 `RawEntryMut`。",
        "translate": ""
    },
    {
        "source": "Creates a `RawEntryMut` from the given key and its hash.",
        "suggest": "根据给定的键及其哈希值创建 `RawEntryMut`。",
        "translate": ""
    },
    {
        "source": "Creates a `RawEntryMut` from the given hash.",
        "suggest": "从给定的哈希创建 `RawEntryMut`。",
        "translate": ""
    },
    {
        "source": "Access an entry by key.",
        "suggest": "通过键访问条目。",
        "translate": ""
    },
    {
        "source": "Access an entry by a key and its hash.",
        "suggest": "通过键及其哈希值访问条目。",
        "translate": ""
    },
    {
        "source": "Access an entry by hash.",
        "suggest": "通过哈希访问条目。",
        "translate": ""
    },
    {
        "source": "Ensures a value is in the entry by inserting the default if empty, and returns mutable references to the key and value in the entry.",
        "suggest": "通过插入默认值 (如果为空) 来确保值在条目中，并向条目中的键和值返回可变引用。",
        "translate": ""
    },
    {
        "source": "Ensures a value is in the entry by inserting the result of the default function if empty, and returns mutable references to the key and value in the entry.",
        "suggest": "通过插入默认函数 (如果为空) 的结果来确保值在条目中，并在条目中的键和值上返回变量引用。",
        "translate": ""
    },
    {
        "source": "Gets a mutable reference to the key in the entry.",
        "suggest": "获取条目中键的可变引用。",
        "translate": ""
    },
    {
        "source": "Converts the entry into a mutable reference to the key in the entry with a lifetime bound to the map itself.",
        "suggest": "将条目转换为变量引用中的键，并将生命周期绑定到 map 本身。",
        "translate": ""
    },
    {
        "source": "Converts the `OccupiedEntry` into a mutable reference to the value in the entry with a lifetime bound to the map itself.",
        "suggest": "将 `OccupiedEntry` 转换为条目中带有生命周期绑定到 map 本身的值的变量引用。",
        "translate": ""
    },
    {
        "source": "Gets a reference to the key and value in the entry.",
        "suggest": "获取条目中键和值的引用。",
        "translate": ""
    },
    {
        "source": "Gets a mutable reference to the key and value in the entry.",
        "suggest": "获取条目中键和值的可变引用。",
        "translate": ""
    },
    {
        "source": "Converts the `OccupiedEntry` into a mutable reference to the key and value in the entry with a lifetime bound to the map itself.",
        "suggest": "将 `OccupiedEntry` 转换为条目中的键和值的变量引用，并将生命周期绑定到 map 本身。",
        "translate": ""
    },
    {
        "source": "Sets the value of the entry, and returns the entry's old value.",
        "suggest": "设置条目的值，并返回条目的旧值。",
        "translate": ""
    },
    {
        "source": "Takes the value out of the entry, and returns it.",
        "suggest": "从条目中取出值，然后将其返回。",
        "translate": ""
    },
    {
        "source": "Take the ownership of the key and value from the map.",
        "suggest": "从 map 获取键和值的所有权。",
        "translate": ""
    },
    {
        "source": "Sets the value of the entry with the VacantEntry's key, and returns a mutable reference to it.",
        "suggest": "使用 VacantEntry 的键设置条目的值，并为其返回变量引用。",
        "translate": ""
    },
    {
        "source": "This `enum` is constructed from the [`entry`] method on [`HashMap`].",
        "suggest": "`enum` 是根据 [`HashMap`] 上的 [`entry`] 方法构造的。",
        "translate": ""
    },
    {
        "source": "The error returned by [`try_insert`](HashMap::try_insert) when the key already exists.",
        "suggest": "当键已经存在时，由 [`try_insert`](HashMap::try_insert) 返回的错误。",
        "translate": ""
    },
    {
        "source": "Creates a consuming iterator, that is, one that moves each key-value pair out of the map in arbitrary order.",
        "suggest": "创建一个消耗迭代器，即一个将任意键值对以任意顺序移出 map 的迭代器。",
        "translate": ""
    },
    {
        "source": "Sets the value of the entry, and returns an `OccupiedEntry`.",
        "suggest": "设置条目的值，并返回 `OccupiedEntry`。",
        "translate": ""
    },
    {
        "source": "If you need a reference to the `OccupiedEntry` which may outlive the destruction of the `Entry` value, see [`into_mut`].",
        "suggest": "如果需要对 `OccupiedEntry` 的引用，而这可能会使 `Entry` 值的破坏失效，请参见 [`into_mut`]。",
        "translate": ""
    },
    {
        "source": "Replaces the entry, returning the old key and value.",
        "suggest": "替换条目，返回旧的键和值。",
        "translate": ""
    },
    {
        "source": "The new key in the hash map will be the key used to create this entry.",
        "suggest": "哈希 map 中的新键将是用于创建此条目的键。",
        "translate": ""
    },
    {
        "source": "Replaces the key in the hash map with the key used to create this entry.",
        "suggest": "用用于创建此条目的键替换哈希 map 中的键。",
        "translate": ""
    },
    {
        "source": "Gets a reference to the key that would be used when inserting a value through the `VacantEntry`.",
        "suggest": "获取对通过 `VacantEntry` 插入值时将使用的键的引用。",
        "translate": ""
    },
    {
        "source": "Sets the value of the entry with the `VacantEntry`'s key, and returns an `OccupiedEntry`.",
        "suggest": "使用 `VacantEntry` 的键设置条目的值，并返回 `OccupiedEntry`。",
        "translate": ""
    },
    {
        "source": "Inserts all new key-values from the iterator and replaces values with existing keys with new values returned from the iterator.",
        "suggest": "插入迭代器中的所有新键值，并用迭代器返回的新值替换现有键中的值。",
        "translate": ""
    },
    {
        "source": "hashbrown should implement this method.",
        "suggest": "hashbrown 应该实现此方法。",
        "translate": ""
    },
    {
        "source": "But until then, use the same reservation logic:",
        "suggest": "但在那之前，请使用相同的保留逻辑:",
        "translate": ""
    },
    {
        "source": "Reserve the entire hint lower bound if the map is empty.",
        "suggest": "如果 map 为空，则保留整个提示下限。",
        "translate": ""
    },
    {
        "source": "Otherwise reserve half the hint (rounded up), so the map will only resize twice in the worst case.",
        "suggest": "否则，保留一半的提示 (四舍五入)，因此 map 在最坏的情况下将仅调整两次大小。",
        "translate": ""
    },
    {
        "source": "is the default state for [`HashMap`] types.",
        "suggest": "是 [`HashMap`] 类型的默认状态。",
        "translate": ""
    },
    {
        "source": "A particular instance `RandomState` will create the same instances of [`Hasher`], but the hashers created by two different `RandomState` instances are unlikely to produce the same result for the same values.",
        "suggest": "特定的实例 `RandomState` 将创建 [`Hasher`] 的相同实例，但是由两个不同的 `RandomState` 实例创建的散列对于相同的值不太可能产生相同的结果。",
        "translate": ""
    },
    {
        "source": "Constructs a new `RandomState` that is initialized with random keys.",
        "suggest": "创建一个用随机键初始化的新 `RandomState`。",
        "translate": ""
    },
    {
        "source": "Historically this function did not cache keys from the OS and instead simply always called `rand::thread_rng().gen()` twice.",
        "suggest": "从历史上看，此函数不缓存操作系统中的键，而总是简单地两次调用 `rand::thread_rng().gen()`。",
        "translate": ""
    },
    {
        "source": "In #31356 it was discovered, however, that because we re-seed the thread-local RNG from the OS periodically that this can cause excessive slowdown when many hash maps are created on a thread.",
        "suggest": "但是，在 #31356 中发现，由于我们定期从操作系统重新 seed，所以在线程上创建许多 hashmap 时，这可能会导致速度过慢。",
        "translate": ""
    },
    {
        "source": "To solve this performance trap we cache the first set of randomly generated keys per-thread.",
        "suggest": "为了解决此性能陷阱，我们按线程缓存了第一组随机生成的密钥。",
        "translate": ""
    },
    {
        "source": "Later in #36481 it was discovered that exposing a deterministic iteration order allows a form of DOS attack.",
        "suggest": "后来在 #36481 中，发现确定性迭代顺序可以允许某种形式的 DOS 攻击。",
        "translate": ""
    },
    {
        "source": "To counter that we increment one of the seeds on every RandomState creation, giving every corresponding HashMap a different iteration order.",
        "suggest": "为了解决这个问题，我们在每次 RandomState 创建时增加一个种子，为每个对应的 HashMap 赋予不同的迭代顺序。",
        "translate": ""
    },
    {
        "source": "The default [`Hasher`] used by [`RandomState`].",
        "suggest": "[`RandomState`] 使用的默认 [`Hasher`]。",
        "translate": ""
    },
    {
        "source": "The internal algorithm is not specified, and so it and its hashes should not be relied upon over releases.",
        "suggest": "未指定内部算法，因此不应依赖其内部版本及其散列。",
        "translate": ""
    },
    {
        "source": "Creates a new `DefaultHasher`.",
        "suggest": "创建一个新的 `DefaultHasher`。",
        "translate": ""
    },
    {
        "source": "This hasher is not guaranteed to be the same as all other `DefaultHasher` instances, but is the same as all other `DefaultHasher` instances created through `new` or `default`.",
        "suggest": "不保证此哈希值与所有其他 `DefaultHasher` 实例相同，但与通过 `new` 或 `default` 创建的所有其他 `DefaultHasher` 实例相同。",
        "translate": ""
    },
    {
        "source": "Creates a new `DefaultHasher` using [`new`].",
        "suggest": "使用 [`new`] 创建一个新的 `DefaultHasher`。",
        "translate": ""
    },
    {
        "source": "Constructs a new `RandomState`.",
        "suggest": "创建一个新的 `RandomState`。",
        "translate": ""
    },
    {
        "source": "Unordered containers, implemented as hash-tables",
        "suggest": "无序容器，实现为哈希表",
        "translate": ""
    },
    {
        "source": "make a bigger than b",
        "suggest": "比 b 大",
        "translate": ""
    },
    {
        "source": "These constants once happened to expose a bug in insert().",
        "suggest": "这些常量曾经碰巧暴露了 insert() 中的错误。",
        "translate": ""
    },
    {
        "source": "I'm keeping them around to prevent a regression.",
        "suggest": "我将它们保留在周围以防止回归。",
        "translate": ""
    },
    {
        "source": "try this a bunch of times to make sure we don't screw up internal state.",
        "suggest": "尝试多次以确保我们不会破坏内部状态。",
        "translate": ""
    },
    {
        "source": "reset to try again.",
        "suggest": "重置以重试。",
        "translate": ""
    },
    {
        "source": "Type inference lets us omit an explicit type signature (which would be `HashSet<String>` in this example).",
        "suggest": "通过类型推断，我们可以省略显式类型签名 (在本示例中为 `HashSet<String>`)。",
        "translate": ""
    },
    {
        "source": "Use derived implementation to print the vikings.",
        "suggest": "使用派生的实现来打印 Viking。",
        "translate": ""
    },
    {
        "source": "use the values stored in the set",
        "suggest": "使用存储在集合中的值",
        "translate": ""
    },
    {
        "source": "Will print in an arbitrary order.",
        "suggest": "将以任意顺序打印。",
        "translate": ""
    },
    {
        "source": "print 1, 2, 3 in an arbitrary order",
        "suggest": "以任意顺序打印 1、2、3",
        "translate": ""
    },
    {
        "source": "Can be seen as `a - b`.",
        "suggest": "可以看作是 `a - b`。",
        "translate": ""
    },
    {
        "source": "Print 1",
        "suggest": "打印 1",
        "translate": ""
    },
    {
        "source": "Note that difference is not symmetric, and `b - a` means something else:",
        "suggest": "请注意，差异不是对称的，并且 `b - a` 表示其他含义:",
        "translate": ""
    },
    {
        "source": "Print 1, 4 in arbitrary order.",
        "suggest": "以任意顺序打印 1、4。",
        "translate": ""
    },
    {
        "source": "Print 2, 3 in arbitrary order.",
        "suggest": "以任意顺序打印 2，3。",
        "translate": ""
    },
    {
        "source": "Print 1, 2, 3, 4 in arbitrary order.",
        "suggest": "以任意顺序打印 1、2、3、4。",
        "translate": ""
    },
    {
        "source": "100 was inserted",
        "suggest": "插入了 100 个",
        "translate": ""
    },
    {
        "source": "a new \"fish\" was inserted",
        "suggest": "插入了新的 \"fish\"",
        "translate": ""
    },
    {
        "source": "Not possible to collect to a Vec<String> with a regular `.iter()`.",
        "suggest": "不能与常规 `.iter()` 一起收集到 Vec<String>。",
        "translate": ""
    },
    {
        "source": "Future Optimization (FIXME!)",
        "suggest": "Future 优化 (FIXME!)",
        "translate": ""
    },
    {
        "source": "Iteration over zero sized values is a noop.",
        "suggest": "对零大小的值进行迭代是是一个空操作。",
        "translate": ""
    },
    {
        "source": "There is no need for `bucket.val` in the case of HashSet.",
        "suggest": "HashSet 不需要 `bucket.val`。",
        "translate": ""
    },
    {
        "source": "I suppose we would need HKT to get rid of it properly.",
        "suggest": "我想我们需要 HKT 适当地消除它。",
        "translate": ""
    },
    {
        "source": "A [hash set] implemented as a `HashMap` where the value is `()`.",
        "suggest": "[hash set]，实现为 `HashMap`，其中值为 `()`。",
        "translate": ""
    },
    {
        "source": "As with the [`HashMap`] type, a `HashSet` requires that the elements implement the [`Eq`] and [`Hash`] traits.",
        "suggest": "与 [`HashMap`] 类型一样，`HashSet` 要求元素实现 [`Eq`] 和 [`Hash`] traits。",
        "translate": ""
    },
    {
        "source": "This can frequently be achieved by using `#[derive(PartialEq, Eq, Hash)]`.",
        "suggest": "这通常可以通过使用 `#[derive(PartialEq, Eq, Hash)]` 来实现。",
        "translate": ""
    },
    {
        "source": "It is a logic error for an item to be modified in such a way that the item's hash, as determined by the [`Hash`] trait, or its equality, as determined by the [`Eq`] trait, changes while it is in the set.",
        "suggest": "以某种方式修改项目的逻辑错误是由该项目的哈希值 (由 [`Hash`] trait 确定) 或其相等性 (由 [`Eq`] trait 确定) 在其位于集合中时发生变化的。",
        "translate": ""
    },
    {
        "source": "The easiest way to use `HashSet` with a custom type is to derive [`Eq`] and [`Hash`].",
        "suggest": "将 `HashSet` 与自定义类型一起使用的最简单方法是派生 [`Eq`] 和 [`Hash`]。",
        "translate": ""
    },
    {
        "source": "We must also derive [`PartialEq`], this will in the future be implied by [`Eq`].",
        "suggest": "我们还必须导出 [`PartialEq`]，这将在 [`Eq`] 中隐含在 future 中。",
        "translate": ""
    },
    {
        "source": "A `HashSet` with fixed list of elements can be initialized from an array:",
        "suggest": "具有固定元素列表的 `HashSet` 可以从数组中初始化:",
        "translate": ""
    },
    {
        "source": "Creates an empty `HashSet`.",
        "suggest": "创建一个空的 `HashSet`。",
        "translate": ""
    },
    {
        "source": "The hash set is initially created with a capacity of 0, so it will not allocate until it is first inserted into.",
        "suggest": "哈希集最初创建时的容量为 0，因此只有在首次插入时才分配。",
        "translate": ""
    },
    {
        "source": "Creates an empty `HashSet` with the specified capacity.",
        "suggest": "创建具有指定容量的空 `HashSet`。",
        "translate": ""
    },
    {
        "source": "The hash set will be able to hold at least `capacity` elements without reallocating.",
        "suggest": "哈希集将能够至少保留 `capacity` 个元素而无需重新分配。",
        "translate": ""
    },
    {
        "source": "If `capacity` is 0, the hash set will not allocate.",
        "suggest": "如果 `capacity` 为 0，则不会分配哈希集。",
        "translate": ""
    },
    {
        "source": "Returns the number of elements the set can hold without reallocating.",
        "suggest": "返回集合可以容纳而不重新分配的元素数。",
        "translate": ""
    },
    {
        "source": "An iterator visiting all elements in arbitrary order.",
        "suggest": "一个迭代器，以任意顺序访问所有元素。",
        "translate": ""
    },
    {
        "source": "The iterator element type is `&'a T`.",
        "suggest": "迭代器元素类型为 `&'a T`。",
        "translate": ""
    },
    {
        "source": "Clears the set, returning all elements in an iterator.",
        "suggest": "清除集合，返回迭代器中的所有元素。",
        "translate": ""
    },
    {
        "source": "Creates a new empty hash set which will use the given hasher to hash keys.",
        "suggest": "创建一个新的空哈希集，它将使用给定的哈希值来哈希键。",
        "translate": ""
    },
    {
        "source": "The hash set is also created with the default initial capacity.",
        "suggest": "还使用默认的初始容量创建哈希集。",
        "translate": ""
    },
    {
        "source": "Warning: `hasher` is normally randomly generated, and is designed to allow `HashSet`s to be resistant to attacks that cause many collisions and very poor performance.",
        "suggest": "警告: `hasher` 通常是随机生成的，旨在允许 HashSet 抵抗导致许多冲突和非常差的性能的攻击。",
        "translate": ""
    },
    {
        "source": "Creates an empty `HashSet` with the specified capacity, using `hasher` to hash the keys.",
        "suggest": "创建一个具有指定容量的空 `HashSet`，使用 `hasher` 对键进行散列。",
        "translate": ""
    },
    {
        "source": "Returns a reference to the set's [`BuildHasher`].",
        "suggest": "返回集合的 [`BuildHasher`] 的引用。",
        "translate": ""
    },
    {
        "source": "Reserves capacity for at least `additional` more elements to be inserted in the `HashSet`.",
        "suggest": "保留至少 `additional` 个要插入 `HashSet` 中的更多元素的容量。",
        "translate": ""
    },
    {
        "source": "Panics if the new allocation size overflows `usize`.",
        "suggest": "如果新的分配大小溢出 `usize`，则为 Panics。",
        "translate": ""
    },
    {
        "source": "Tries to reserve capacity for at least `additional` more elements to be inserted in the given `HashSet<K, V>`.",
        "suggest": "尝试为给 `HashSet<K, V>` 至少插入 `additional` 个元素保留容量。",
        "translate": ""
    },
    {
        "source": "Shrinks the capacity of the set as much as possible.",
        "suggest": "尽可能缩小设备的容量。",
        "translate": ""
    },
    {
        "source": "Shrinks the capacity of the set with a lower limit.",
        "suggest": "将集合的容量降低一个下限。",
        "translate": ""
    },
    {
        "source": "Visits the values representing the difference, i.e., the values that are in `self` but not in `other`.",
        "suggest": "访问表示差异的值，即，在 `self` 中但不在 `other` 中的值。",
        "translate": ""
    },
    {
        "source": "Visits the values representing the symmetric difference, i.e., the values that are in `self` or in `other` but not in both.",
        "suggest": "访问代表对称差异的值，即 `self` 或 `other` 中的值，但不能同时存在于两者中。",
        "translate": ""
    },
    {
        "source": "Visits the values representing the intersection, i.e., the values that are both in `self` and `other`.",
        "suggest": "访问表示相交的值，即 `self` 和 `other` 中的值。",
        "translate": ""
    },
    {
        "source": "Visits the values representing the union, i.e., all the values in `self` or `other`, without duplicates.",
        "suggest": "访问表示并集的值，即 `self` 或 `other` 中的所有值，没有重复项。",
        "translate": ""
    },
    {
        "source": "The value may be any borrowed form of the set's value type, but [`Hash`] and [`Eq`] on the borrowed form *must* match those for the value type.",
        "suggest": "该值可以是集合值类型的任何借用形式，但是借用形式上的 [`Hash`] 和 [`Eq`] 必须与值类型的那些匹配。",
        "translate": ""
    },
    {
        "source": "Inserts the given `value` into the set if it is not present, then returns a reference to the value in the set.",
        "suggest": "如果给定的 `value` 不存在，则将其插入集合中，然后对集合中的值返回引用。",
        "translate": ""
    },
    {
        "source": "Although the raw entry gives us `&mut T`, we only return `&T` to be consistent with `get`.",
        "suggest": "尽管原始条目为我们提供了 `&mut T`，但我们仅返回 `&T` 以与 `get` 保持一致。",
        "translate": ""
    },
    {
        "source": "Key mutation is \"raw\" because you're not supposed to affect `Eq` or `Hash`.",
        "suggest": "键可变的为 \"raw\"，因为您不应该影响 `Eq` 或 `Hash`。",
        "translate": ""
    },
    {
        "source": "Inserts an owned copy of the given `value` into the set if it is not present, then returns a reference to the value in the set.",
        "suggest": "如果不存在给定的 `value`，则将其拥有的副本插入到集合中，然后对集合中的值返回引用。",
        "translate": ""
    },
    {
        "source": "Inserts a value computed from `f` into the set if the given `value` is not present, then returns a reference to the value in the set.",
        "suggest": "如果不存在给定的 `value`，则将从 `f` 计算得出的值插入到集合中，然后对集合中的值返回引用。",
        "translate": ""
    },
    {
        "source": "If the set did have this value present, `false` is returned.",
        "suggest": "如果集合中确实存在该值，则返回 `false`。",
        "translate": ""
    },
    {
        "source": "Creates an empty `HashSet<T, S>` with the `Default` value for the hasher.",
        "suggest": "用哈希器的 `Default` 值创建一个空的 `HashSet<T, S>`。",
        "translate": ""
    },
    {
        "source": "Returns the union of `self` and `rhs` as a new `HashSet<T, S>`.",
        "suggest": "返回 `self` 和 `rhs` 的并集作为新的 `HashSet<T, S>`。",
        "translate": ""
    },
    {
        "source": "Returns the intersection of `self` and `rhs` as a new `HashSet<T, S>`.",
        "suggest": "将 `self` 和 `rhs` 的交集返回为新的 `HashSet<T, S>`。",
        "translate": ""
    },
    {
        "source": "Returns the symmetric difference of `self` and `rhs` as a new `HashSet<T, S>`.",
        "suggest": "返回 `self` 和 `rhs` 的对称差作为新的 `HashSet<T, S>`。",
        "translate": ""
    },
    {
        "source": "Returns the difference of `self` and `rhs` as a new `HashSet<T, S>`.",
        "suggest": "将 `self` 和 `rhs` 之差作为新的 `HashSet<T, S>` 返回。",
        "translate": ""
    },
    {
        "source": "An iterator over the items of a `HashSet`.",
        "suggest": "`HashSet` 项上的迭代器。",
        "translate": ""
    },
    {
        "source": "This `struct` is created by the [`iter`] method on [`HashSet`].",
        "suggest": "该 `struct` 是通过 [`HashSet`] 上的 [`iter`] 方法创建的。",
        "translate": ""
    },
    {
        "source": "An owning iterator over the items of a `HashSet`.",
        "suggest": "`HashSet` 项上的所属迭代器。",
        "translate": ""
    },
    {
        "source": "This `struct` is created by the [`into_iter`] method on [`HashSet`] (provided by the `IntoIterator` trait).",
        "suggest": "该 `struct` 是通过 [`HashSet`] (由 `IntoIterator` trait 提供) 上的 [`into_iter`] 方法创建的。",
        "translate": ""
    },
    {
        "source": "A draining iterator over the items of a `HashSet`.",
        "suggest": "`HashSet` 的项上的 draining 迭代器。",
        "translate": ""
    },
    {
        "source": "This `struct` is created by the [`drain`] method on [`HashSet`].",
        "suggest": "该 `struct` 是通过 [`HashSet`] 上的 [`drain`] 方法创建的。",
        "translate": ""
    },
    {
        "source": "A draining, filtering iterator over the items of a `HashSet`.",
        "suggest": "draining，在 `HashSet` 的项上过滤迭代器。",
        "translate": ""
    },
    {
        "source": "This `struct` is created by the [`drain_filter`] method on [`HashSet`].",
        "suggest": "该 `struct` 是通过 [`HashSet`] 上的 [`drain_filter`] 方法创建的。",
        "translate": ""
    },
    {
        "source": "A lazy iterator producing elements in the intersection of `HashSet`s.",
        "suggest": "一个惰性迭代器，它在 HashSet 的交集中生成元素。",
        "translate": ""
    },
    {
        "source": "This `struct` is created by the [`intersection`] method on [`HashSet`].",
        "suggest": "该 `struct` 是通过 [`HashSet`] 上的 [`intersection`] 方法创建的。",
        "translate": ""
    },
    {
        "source": "iterator of the first set",
        "suggest": "第一组的迭代器",
        "translate": ""
    },
    {
        "source": "the second set",
        "suggest": "第二组",
        "translate": ""
    },
    {
        "source": "A lazy iterator producing elements in the difference of `HashSet`s.",
        "suggest": "一个惰性迭代器，它产生与 HashSet 不同的元素。",
        "translate": ""
    },
    {
        "source": "This `struct` is created by the [`difference`] method on [`HashSet`].",
        "suggest": "该 `struct` 是通过 [`HashSet`] 上的 [`difference`] 方法创建的。",
        "translate": ""
    },
    {
        "source": "A lazy iterator producing elements in the symmetric difference of `HashSet`s.",
        "suggest": "一个惰性迭代器，它产生对称差异为 HashSet 的元素。",
        "translate": ""
    },
    {
        "source": "This `struct` is created by the [`symmetric_difference`] method on [`HashSet`].",
        "suggest": "该 `struct` 是通过 [`HashSet`] 上的 [`symmetric_difference`] 方法创建的。",
        "translate": ""
    },
    {
        "source": "A lazy iterator producing elements in the union of `HashSet`s.",
        "suggest": "一个惰性迭代器，在 `HashSet` 的并集中生成元素。",
        "translate": ""
    },
    {
        "source": "This `struct` is created by the [`union`] method on [`HashSet`].",
        "suggest": "该 `struct` 是通过 [`HashSet`] 上的 [`union`] 方法创建的。",
        "translate": ""
    },
    {
        "source": "Creates a consuming iterator, that is, one that moves each value out of the set in arbitrary order.",
        "suggest": "创建一个消耗迭代器，即将每个值以任意顺序移出集合的迭代器。",
        "translate": ""
    },
    {
        "source": "The set cannot be used after calling this.",
        "suggest": "调用此设置后将无法使用该设置。",
        "translate": ""
    },
    {
        "source": "A client of the bar.",
        "suggest": "酒吧客户端。",
        "translate": ""
    },
    {
        "source": "They have a blood alcohol level.",
        "suggest": "他们有血液中的酒精含量。",
        "translate": ""
    },
    {
        "source": "All the orders made to the bar, by client ID.",
        "suggest": "所有的订单都是按客户 ID 送到酒吧的。",
        "translate": ""
    },
    {
        "source": "Our clients.",
        "suggest": "我们的客户。",
        "translate": ""
    },
    {
        "source": "If this is the first time we've seen this customer, initialize them with no blood alcohol.",
        "suggest": "如果这是我们第一次见到此客户，请在不使用酒精的情况下初始化他们。",
        "translate": ""
    },
    {
        "source": "Otherwise, just retrieve them.",
        "suggest": "否则，只需检索它们。",
        "translate": ""
    },
    {
        "source": "Reduce their blood alcohol level.",
        "suggest": "降低他们的血液酒精含量。",
        "translate": ""
    },
    {
        "source": "It takes time to order and drink a beer!",
        "suggest": "订购和喝啤酒需要时间!",
        "translate": ""
    },
    {
        "source": "Check if they're sober enough to have another beer.",
        "suggest": "检查他们是否足够清醒，可以再喝一杯啤酒。",
        "translate": ""
    },
    {
        "source": "Too drunk...",
        "suggest": "太醉了...",
        "translate": ""
    },
    {
        "source": "for now.",
        "suggest": "目前。",
        "translate": ""
    },
    {
        "source": "Have another!",
        "suggest": "有另外一个!",
        "translate": ""
    },
    {
        "source": "we will compare `Foo`s by their `a` value only.",
        "suggest": "我们将仅通过它们的 `a` 值来比较 `Foo`。",
        "translate": ""
    },
    {
        "source": "we will hash `Foo`s by their `a` value only.",
        "suggest": "我们将仅通过 `a` 值对 Foo 进行哈希处理。",
        "translate": ""
    },
    {
        "source": "We already have a Foo with an a of 1, so this will be updating the value.",
        "suggest": "我们已经有一个 a 等于 1 的 Foo，因此这将更新该值。",
        "translate": ""
    },
    {
        "source": "The value has been updated...",
        "suggest": "该值已更新...",
        "translate": ""
    },
    {
        "source": "...but the key hasn't changed.",
        "suggest": "... 但是键没有变。",
        "translate": ""
    },
    {
        "source": "b is still \"baz\", not \"xyz\".",
        "suggest": "b 仍然是 \"baz\"，而不是 \"xyz\"。",
        "translate": ""
    },
    {
        "source": "Rust's standard collection library provides efficient implementations of the most common general purpose programming data structures.",
        "suggest": "Rust 的标准集合库提供了最常见的通用编程数据结构的有效实现。",
        "translate": ""
    },
    {
        "source": "By using the standard implementations, it should be possible for two libraries to communicate without significant data conversion.",
        "suggest": "通过使用标准实现，两个库在不进行大量数据转换的情况下就可以进行通信。",
        "translate": ""
    },
    {
        "source": "To get this out of the way: you should probably just use [`Vec`] or [`HashMap`].",
        "suggest": "为了避免这种情况: 您可能应该只使用 [`Vec`] 或 [`HashMap`]。",
        "translate": ""
    },
    {
        "source": "These two collections cover most use cases for generic data storage and processing.",
        "suggest": "这两个集合涵盖了泛型数据存储和处理的大多数用例。",
        "translate": ""
    },
    {
        "source": "They are exceptionally good at doing what they do.",
        "suggest": "他们非常擅长于做自己的工作。",
        "translate": ""
    },
    {
        "source": "All the other collections in the standard library have specific use cases where they are the optimal choice, but these cases are borderline *niche* in comparison.",
        "suggest": "标准库中的所有其他集合都具有特定的用例，在这些用例中它们是最佳选择，但相比之下，这些用例是边缘性的。",
        "translate": ""
    },
    {
        "source": "Even when `Vec` and `HashMap` are technically suboptimal, they're probably a good enough choice to get started.",
        "suggest": "即使 `Vec` 和 `HashMap` 在技术上不是最佳选择，它们也可能是入门的足够好选择。",
        "translate": ""
    },
    {
        "source": "Rust's collections can be grouped into four major categories:",
        "suggest": "Rust 的集合可以分为四个主要类别:",
        "translate": ""
    },
    {
        "source": "When Should You Use Which Collection?",
        "suggest": "什么时候应该使用哪个集合?",
        "translate": ""
    },
    {
        "source": "These are fairly high-level and quick break-downs of when each collection should be considered.",
        "suggest": "这些是应该何时考虑每个集合的较高层次且快速的细分。",
        "translate": ""
    },
    {
        "source": "Detailed discussions of strengths and weaknesses of individual collections can be found on their own documentation pages.",
        "suggest": "各个集合的优缺点的详细讨论可以在他们自己的文档页面上找到。",
        "translate": ""
    },
    {
        "source": "Use a `Vec` when:",
        "suggest": "在以下情况下，请使用 `Vec`:",
        "translate": ""
    },
    {
        "source": "You want to collect items up to be processed or sent elsewhere later, and don't care about any properties of the actual values being stored.",
        "suggest": "您想要收集项以供以后处理或发送到其他地方，而不必关心所存储的实际值的任何属性。",
        "translate": ""
    },
    {
        "source": "You want a sequence of elements in a particular order, and will only be appending to (or near) the end.",
        "suggest": "您需要按特定顺序排列的元素序列，并且只会附加到末尾 (或接近末尾)。",
        "translate": ""
    },
    {
        "source": "You want a stack.",
        "suggest": "您想要一个栈。",
        "translate": ""
    },
    {
        "source": "You want a resizable array.",
        "suggest": "您需要一个可调整大小的数组。",
        "translate": ""
    },
    {
        "source": "You want a heap-allocated array.",
        "suggest": "您需要一个堆分配的数组。",
        "translate": ""
    },
    {
        "source": "Use a `VecDeque` when:",
        "suggest": "在以下情况下，请使用 `VecDeque`:",
        "translate": ""
    },
    {
        "source": "You want a [`Vec`] that supports efficient insertion at both ends of the sequence.",
        "suggest": "您需要 [`Vec`] 支持序列两端的有效插入。",
        "translate": ""
    },
    {
        "source": "You want a queue.",
        "suggest": "您想要一个队列。",
        "translate": ""
    },
    {
        "source": "You want a double-ended queue (deque).",
        "suggest": "您需要一个双端队列 (deque)。",
        "translate": ""
    },
    {
        "source": "Use a `LinkedList` when:",
        "suggest": "在以下情况下，请使用 `LinkedList`:",
        "translate": ""
    },
    {
        "source": "You want a [`Vec`] or [`VecDeque`] of unknown size, and can't tolerate amortization.",
        "suggest": "您需要一个未知大小的 [`Vec`] 或 [`VecDeque`]，并且不能容忍摊销。",
        "translate": ""
    },
    {
        "source": "You want to efficiently split and append lists.",
        "suggest": "您想有效地拆分和追加列表。",
        "translate": ""
    },
    {
        "source": "You are *absolutely* certain you *really*, *truly*, want a doubly linked list.",
        "suggest": "您确实，想要一个双向链表。",
        "translate": ""
    },
    {
        "source": "Use a `HashMap` when:",
        "suggest": "在以下情况下，请使用 `HashMap`:",
        "translate": ""
    },
    {
        "source": "You want to associate arbitrary keys with an arbitrary value.",
        "suggest": "您想要将任意键与任意值相关联。",
        "translate": ""
    },
    {
        "source": "You want a cache.",
        "suggest": "您需要一个缓存。",
        "translate": ""
    },
    {
        "source": "You want a map, with no extra functionality.",
        "suggest": "您需要一个没有额外功能的 map。",
        "translate": ""
    },
    {
        "source": "Use a `BTreeMap` when:",
        "suggest": "在以下情况下，请使用 `BTreeMap`:",
        "translate": ""
    },
    {
        "source": "You want a map sorted by its keys.",
        "suggest": "您需要一个按其键排序的 map。",
        "translate": ""
    },
    {
        "source": "You want to be able to get a range of entries on-demand.",
        "suggest": "您希望能够按需获取一系列条目。",
        "translate": ""
    },
    {
        "source": "You're interested in what the smallest or largest key-value pair is.",
        "suggest": "您对最小或最大键值对是什么感兴趣。",
        "translate": ""
    },
    {
        "source": "You want to find the largest or smallest key that is smaller or larger than something.",
        "suggest": "您想要找到小于或大于某项的最大或最小键。",
        "translate": ""
    },
    {
        "source": "Use the `Set` variant of any of these `Map`s when:",
        "suggest": "在以下情况下，请使用任何 `Map` 的 `Set` 成员:",
        "translate": ""
    },
    {
        "source": "You just want to remember which keys you've seen.",
        "suggest": "您只想记住您所看到的键。",
        "translate": ""
    },
    {
        "source": "There is no meaningful value to associate with your keys.",
        "suggest": "与您的键关联没有任何有意义的值。",
        "translate": ""
    },
    {
        "source": "You just want a set.",
        "suggest": "您只想要一个 set。",
        "translate": ""
    },
    {
        "source": "Use a `BinaryHeap` when:",
        "suggest": "在以下情况下，请使用 `BinaryHeap`:",
        "translate": ""
    },
    {
        "source": "You want to store a bunch of elements, but only ever want to process the \"biggest\" or \"most important\" one at any given time.",
        "suggest": "您想存储一堆元素，但只想在任何给定时间处理 \"biggest\" 或 \"most important\"。",
        "translate": ""
    },
    {
        "source": "You want a priority queue.",
        "suggest": "您需要一个优先级队列。",
        "translate": ""
    },
    {
        "source": "Choosing the right collection for the job requires an understanding of what each collection is good at.",
        "suggest": "为工作选择合适的集合需要了解每个集合的特长。",
        "translate": ""
    },
    {
        "source": "Here we briefly summarize the performance of different collections for certain important operations.",
        "suggest": "在这里，我们简要总结了某些重要操作的不同集合的性能。",
        "translate": ""
    },
    {
        "source": "For further details, see each type's documentation, and note that the names of actual methods may differ from the tables below on certain collections.",
        "suggest": "有关更多详细信息，请参见每种类型的文档，并请注意，实际方法的名称可能与某些集合中的下表有所不同。",
        "translate": ""
    },
    {
        "source": "Throughout the documentation, we will follow a few conventions.",
        "suggest": "在整个文档中，我们将遵循一些约定。",
        "translate": ""
    },
    {
        "source": "For all operations, the collection's size is denoted by n.",
        "suggest": "对于所有操作，集合的大小用 n 表示。",
        "translate": ""
    },
    {
        "source": "If another collection is involved in the operation, it contains m elements.",
        "suggest": "如果该操作涉及另一个集合，则它包含 m 个元素。",
        "translate": ""
    },
    {
        "source": "Operations which have an *amortized* cost are suffixed with a `*`.",
        "suggest": "具有 `amortized` 成本的操作以 `*` 为后缀。",
        "translate": ""
    },
    {
        "source": "Operations with an *expected* cost are suffixed with a `~`.",
        "suggest": "具有 `expected` 成本的操作以 `~` 为后缀。",
        "translate": ""
    },
    {
        "source": "All amortized costs are for the potential need to resize when capacity is exhausted.",
        "suggest": "所有摊销成本均用于容量耗尽时可能需要调整的大小。",
        "translate": ""
    },
    {
        "source": "If a resize occurs it will take *O*(*n*) time.",
        "suggest": "如果发生调整大小，则将花费 *O*(*n*) 时间。",
        "translate": ""
    },
    {
        "source": "Our collections never automatically shrink, so removal operations aren't amortized.",
        "suggest": "我们的集合永远不会自动收缩，因此移除操作不会摊销。",
        "translate": ""
    },
    {
        "source": "Over a sufficiently large series of operations, the average cost per operation will deterministically equal the given cost.",
        "suggest": "在足够多的工序系列中，每次工序的平均成本将确定性地等于给定成本。",
        "translate": ""
    },
    {
        "source": "Only [`HashMap`] has expected costs, due to the probabilistic nature of hashing.",
        "suggest": "由于哈希的概率性质，只有 [`HashMap`] 具有预期的成本。",
        "translate": ""
    },
    {
        "source": "It is theoretically possible, though very unlikely, for [`HashMap`] to experience worse performance.",
        "suggest": "从理论上讲，[`HashMap`] 可能会出现性能下降的情况，尽管可能性很小。",
        "translate": ""
    },
    {
        "source": "Note that where ties occur, [`Vec`] is generally going to be faster than [`VecDeque`], and [`VecDeque`] is generally going to be faster than [`LinkedList`].",
        "suggest": "请注意，在发生联系的地方，[`Vec`] 通常比 [`VecDeque`] 快，而 [`VecDeque`] 通常比 [`LinkedList`] 快。",
        "translate": ""
    },
    {
        "source": "For Sets, all operations have the cost of the equivalent Map operation.",
        "suggest": "对于集合，所有操作的成本均等价于 Map 操作。",
        "translate": ""
    },
    {
        "source": "Correct and Efficient Usage of Collections",
        "suggest": "正确有效地使用集合",
        "translate": ""
    },
    {
        "source": "Of course, knowing which collection is the right one for the job doesn't instantly permit you to use it correctly.",
        "suggest": "当然，知道哪种集合最适合该工作并不能立即使您正确使用它。",
        "translate": ""
    },
    {
        "source": "Here are some quick tips for efficient and correct usage of the standard collections in general.",
        "suggest": "以下是一般有效和正确使用标准集合的一些快速技巧。",
        "translate": ""
    },
    {
        "source": "If you're interested in how to use a specific collection in particular, consult its documentation for detailed discussion and code examples.",
        "suggest": "如果您特别对如何使用特定集合感兴趣，请查阅其文档以获取详细的讨论和代码示例。",
        "translate": ""
    },
    {
        "source": "Capacity Management",
        "suggest": "容量管理",
        "translate": ""
    },
    {
        "source": "Many collections provide several constructors and methods that refer to \"capacity\".",
        "suggest": "许多集合提供了一些引用 \"capacity\" 的构造函数和方法。",
        "translate": ""
    },
    {
        "source": "These collections are generally built on top of an array.",
        "suggest": "这些集合通常构建在数组的顶部。",
        "translate": ""
    },
    {
        "source": "Optimally, this array would be exactly the right size to fit only the elements stored in the collection, but for the collection to do this would be very inefficient.",
        "suggest": "理想情况下，此数组的大小恰好适合仅适合存储在集合中的元素，但是对于集合而言，这样做效率很低。",
        "translate": ""
    },
    {
        "source": "If the backing array was exactly the right size at all times, then every time an element is inserted, the collection would have to grow the array to fit it.",
        "suggest": "如果支持数组始终正确大小，则每次插入元素时，集合都必须增大数组以适合它。",
        "translate": ""
    },
    {
        "source": "Due to the way memory is allocated and managed on most computers, this would almost surely require allocating an entirely new array and copying every single element from the old one into the new one.",
        "suggest": "由于在大多数计算机上分配和管理内存的方式，几乎肯定需要分配一个全新的数组，并将每个元素从旧元素复制到新元素中。",
        "translate": ""
    },
    {
        "source": "Hopefully you can see that this wouldn't be very efficient to do on every operation.",
        "suggest": "希望您能看到这样做并不是在每个操作上都非常有效。",
        "translate": ""
    },
    {
        "source": "Most collections therefore use an *amortized* allocation strategy.",
        "suggest": "因此，大多数集合使用 `amortized` 分配策略。",
        "translate": ""
    },
    {
        "source": "They generally let themselves have a fair amount of unoccupied space so that they only have to grow on occasion.",
        "suggest": "它们通常让自己拥有大量的空闲空间，因此它们仅需要偶尔增长。",
        "translate": ""
    },
    {
        "source": "When they do grow, they allocate a substantially larger array to move the elements into so that it will take a while for another grow to be required.",
        "suggest": "当它们确实增长时，它们会分配一个更大的数组来将元素移入，以便需要一段时间才能进行另一个增长。",
        "translate": ""
    },
    {
        "source": "While this strategy is great in general, it would be even better if the collection *never* had to resize its backing array.",
        "suggest": "尽管此策略总体上不错，但如果必须 * 绝不调整其支持数组的大小，那就更好了。",
        "translate": ""
    },
    {
        "source": "Unfortunately, the collection itself doesn't have enough information to do this itself.",
        "suggest": "不幸的是，集合本身没有足够的信息来执行此操作。",
        "translate": ""
    },
    {
        "source": "Therefore, it is up to us programmers to give it hints.",
        "suggest": "因此，由我们的程序员来提供提示。",
        "translate": ""
    },
    {
        "source": "Any `with_capacity` constructor will instruct the collection to allocate enough space for the specified number of elements.",
        "suggest": "任何 `with_capacity` 构造函数都将指示该集合为指定数量的元素分配足够的空间。",
        "translate": ""
    },
    {
        "source": "Ideally this will be for exactly that many elements, but some implementation details may prevent this.",
        "suggest": "理想情况下，这将恰好适用于许多元素，但是某些实现细节可能会阻止这种情况。",
        "translate": ""
    },
    {
        "source": "See collection-specific documentation for details.",
        "suggest": "有关详细信息，请参见特定于集合的文档。",
        "translate": ""
    },
    {
        "source": "In general, use `with_capacity` when you know exactly how many elements will be inserted, or at least have a reasonable upper-bound on that number.",
        "suggest": "通常，当您确切知道要插入多少个元素，或者至少在该数目上具有合理的上限时，请使用 `with_capacity`。",
        "translate": ""
    },
    {
        "source": "When anticipating a large influx of elements, the `reserve` family of methods can be used to hint to the collection how much room it should make for the coming items.",
        "suggest": "当预期大量元素涌入时，`reserve` 系列方法可用于向集合暗示应该为即将到来的项目腾出多少空间。",
        "translate": ""
    },
    {
        "source": "As with `with_capacity`, the precise behavior of these methods will be specific to the collection of interest.",
        "suggest": "与 `with_capacity` 一样，这些方法的精确行为将特定于感兴趣的集合。",
        "translate": ""
    },
    {
        "source": "For optimal performance, collections will generally avoid shrinking themselves.",
        "suggest": "为了获得最佳性能，集合通常会避免自身收缩。",
        "translate": ""
    },
    {
        "source": "If you believe that a collection will not soon contain any more elements, or just really need the memory, the `shrink_to_fit` method prompts the collection to shrink the backing array to the minimum size capable of holding its elements.",
        "suggest": "如果您认为某个集合将很快不再包含任何其他元素，或者仅真的需要内存，则 `shrink_to_fit` 方法将提示该集合将后备数组缩小到能够容纳其元素的最小大小。",
        "translate": ""
    },
    {
        "source": "Finally, if ever you're interested in what the actual capacity of the collection is, most collections provide a `capacity` method to query this information on demand.",
        "suggest": "最后，如果您对集合的实际容量感兴趣，则大多数集合都会提供 `capacity` 方法来按需查询此信息。",
        "translate": ""
    },
    {
        "source": "This can be useful for debugging purposes, or for use with the `reserve` methods.",
        "suggest": "这对于调试目的或与 `reserve` 方法一起使用可能很有用。",
        "translate": ""
    },
    {
        "source": "Iterators are a powerful and robust mechanism used throughout Rust's standard libraries.",
        "suggest": "迭代器是 Rust 的标准库中使用的强大而强大的机制。",
        "translate": ""
    },
    {
        "source": "Iterators provide a sequence of values in a generic, safe, efficient and convenient way.",
        "suggest": "迭代器以泛型，安全，有效和方便的方式提供一系列值。",
        "translate": ""
    },
    {
        "source": "The contents of an iterator are usually *lazily* evaluated, so that only the values that are actually needed are ever actually produced, and no allocation need be done to temporarily store them.",
        "suggest": " 迭代器的内容通常是惰性求值的，因此只有实际需要的值才会实际产生，而不需要进行任何分配来临时存储它们。",
        "translate": ""
    },
    {
        "source": "Iterators are primarily consumed using a `for` loop, although many functions also take iterators where a collection or sequence of values is desired.",
        "suggest": "迭代器主要通过 `for` 循环使用，尽管许多函数也将迭代器用于需要集合或值序列的地方。",
        "translate": ""
    },
    {
        "source": "All of the standard collections provide several iterators for performing bulk manipulation of their contents.",
        "suggest": "所有标准集合都提供了几个用于对其内容进行批量操作的迭代器。",
        "translate": ""
    },
    {
        "source": "The three primary iterators almost every collection should provide are `iter`, `iter_mut`, and `into_iter`.",
        "suggest": "几乎每个集合应提供的三个主要迭代器是 `iter`，`iter_mut` 和 `into_iter`。",
        "translate": ""
    },
    {
        "source": "Some of these are not provided on collections where it would be unsound or unreasonable to provide them.",
        "suggest": "其中的某些未在集合中提供，因此提供它们是不合理的或不合理的。",
        "translate": ""
    },
    {
        "source": "provides an iterator of immutable references to all the contents of a collection in the most \"natural\" order.",
        "suggest": "提供一个以 \"natural\" 最高顺序对集合的所有内容进行不可变变量引用的迭代器。",
        "translate": ""
    },
    {
        "source": "For sequence collections like [`Vec`], this means the items will be yielded in increasing order of index starting at 0.",
        "suggest": "对于像 [`Vec`] 这样的序列集合，这意味着该项将以索引从 0 开始的递增顺序产生。",
        "translate": ""
    },
    {
        "source": "For ordered collections like [`BTreeMap`], this means that the items will be yielded in sorted order.",
        "suggest": "对于 [`BTreeMap`] 之类的有序集合，这意味着该项将按排序顺序产生。",
        "translate": ""
    },
    {
        "source": "For unordered collections like [`HashMap`], the items will be yielded in whatever order the internal representation made most convenient.",
        "suggest": "对于 [`HashMap`] 之类的无序集合，将以内部表示最方便的任何顺序产生该项。",
        "translate": ""
    },
    {
        "source": "This is great for reading through all the contents of the collection.",
        "suggest": "这对于通读集合的所有内容非常有用。",
        "translate": ""
    },
    {
        "source": "provides an iterator of *mutable* references in the same order as `iter`.",
        "suggest": "提供与 `iter` 相同的 *变量* 引用的迭代器。",
        "translate": ""
    },
    {
        "source": "This is great for mutating all the contents of the collection.",
        "suggest": "这对于更改集合的所有内容非常有用。",
        "translate": ""
    },
    {
        "source": "transforms the actual collection into an iterator over its contents by-value.",
        "suggest": "将实际的集合转换为按其内容按值的迭代器。",
        "translate": ""
    },
    {
        "source": "This is great when the collection itself is no longer needed, and the values are needed elsewhere.",
        "suggest": "当不再需要集合本身并且在其他地方需要这些值时，这非常好。",
        "translate": ""
    },
    {
        "source": "Using `extend` with `into_iter` is the main way that contents of one collection are moved into another.",
        "suggest": "将 `extend` 与 `into_iter` 一起使用是将一个集合的内容移入另一个集合的主要方法。",
        "translate": ""
    },
    {
        "source": "automatically calls `into_iter`, and takes any `T: `[`IntoIterator`].",
        "suggest": "自动调用 `into_iter`，并使用任何 `T: `[`IntoIterator`]。",
        "translate": ""
    },
    {
        "source": "Calling `collect` on an iterator itself is also a great way to convert one collection into another.",
        "suggest": "在迭代器本身上调用 `collect` 也是将一个集合转换为另一个集合的好方法。",
        "translate": ""
    },
    {
        "source": "Both of these methods should internally use the capacity management tools discussed in the previous section to do this as efficiently as possible.",
        "suggest": "这两种方法都应在内部使用上一节中讨论的容量管理工具来尽可能高效地执行此操作。",
        "translate": ""
    },
    {
        "source": "Iterators also provide a series of *adapter* methods for performing common threads to sequences.",
        "suggest": "迭代器还提供了一系列 *adapter* 方法，用于对序列执行通用线程。",
        "translate": ""
    },
    {
        "source": "Among the adapters are functional favorites like `map`, `fold`, `skip` and `take`.",
        "suggest": "在适配器中，有功能最喜欢的适配器，例如 `map`，`fold`，`skip` 和 `take`。",
        "translate": ""
    },
    {
        "source": "Of particular interest to collections is the `rev` adapter, that reverses any iterator that supports this operation.",
        "suggest": "集合特别令人感兴趣的是 `rev` 适配器，它可以反转支持该操作的所有迭代器。",
        "translate": ""
    },
    {
        "source": "Most collections provide reversible iterators as the way to iterate over them in reverse order.",
        "suggest": "大多数集合都提供可逆迭代器，作为以相反顺序对其进行迭代的方式。",
        "translate": ""
    },
    {
        "source": "Several other collection methods also return iterators to yield a sequence of results but avoid allocating an entire collection to store the result in.",
        "suggest": "其他几种集合方法还返回迭代器以产生结果序列，但避免分配整个集合来存储结果。",
        "translate": ""
    },
    {
        "source": "This provides maximum flexibility as `collect` or `extend` can be called to \"pipe\" the sequence into any collection if desired.",
        "suggest": "这提供了最大的灵活性，因为可以根据需要将 `collect` 或 `extend` 调用到 \"pipe\" 序列中的任何集合中。",
        "translate": ""
    },
    {
        "source": "Otherwise, the sequence can be looped over with a `for` loop.",
        "suggest": "否则，可以使用 `for` 循环将序列循环。",
        "translate": ""
    },
    {
        "source": "The iterator can also be discarded after partial use, preventing the computation of the unused items.",
        "suggest": "迭代器在部分使用后也可以丢弃，从而避免了未使用项的计算。",
        "translate": ""
    },
    {
        "source": "The `entry` API is intended to provide an efficient mechanism for manipulating the contents of a map conditionally on the presence of a key or not.",
        "suggest": "`entry` API 旨在提供一种有效的机制，用于根据是否存在键来有条件地操纵 map 的内容。",
        "translate": ""
    },
    {
        "source": "The primary motivating use case for this is to provide efficient accumulator maps.",
        "suggest": "这样做的主要动机是提供有效的累加器 maps。",
        "translate": ""
    },
    {
        "source": "For instance, if one wishes to maintain a count of the number of times each key has been seen, they will have to perform some conditional logic on whether this is the first time the key has been seen or not.",
        "suggest": "例如，如果希望保持对每个键被看到的次数的计数，则他们将必须执行一些条件逻辑来确定这是否是第一次被看到。",
        "translate": ""
    },
    {
        "source": "Normally, this would require a `find` followed by an `insert`, effectively duplicating the search effort on each insertion.",
        "suggest": "通常，这需要先插入 `find`，然后再插入 `insert`，以有效地重复每次插入时的搜索工作。",
        "translate": ""
    },
    {
        "source": "When a user calls `map.entry(&key)`, the map will search for the key and then yield a variant of the `Entry` enum.",
        "suggest": "当用户调用 `map.entry(&key)` 时，map 将搜索键，然后产生 `Entry` 枚举的成员。",
        "translate": ""
    },
    {
        "source": "If a `Vacant(entry)` is yielded, then the key *was not* found.",
        "suggest": "如果产生 `Vacant(entry)`，则没有找到键。",
        "translate": ""
    },
    {
        "source": "In this case the only valid operation is to `insert` a value into the entry.",
        "suggest": "在这种情况下，唯一有效的操作是将值 `insert` 放入条目中。",
        "translate": ""
    },
    {
        "source": "When this is done, the vacant entry is consumed and converted into a mutable reference to the value that was inserted.",
        "suggest": "完成此操作后，将使用空条目并将其转换为所插入值的变量引用。",
        "translate": ""
    },
    {
        "source": "This allows for further manipulation of the value beyond the lifetime of the search itself.",
        "suggest": "这允许对超出搜索本身生命周期的值进行进一步操作。",
        "translate": ""
    },
    {
        "source": "This is useful if complex logic needs to be performed on the value regardless of whether the value was just inserted.",
        "suggest": "如果无论是否插入值，都需要对值执行复杂的逻辑，这将很有用。",
        "translate": ""
    },
    {
        "source": "If an `Occupied(entry)` is yielded, then the key *was* found.",
        "suggest": "如果产生 `Occupied(entry)`，则找到键 *。",
        "translate": ""
    },
    {
        "source": "In this case, the user has several options: they can `get`, `insert` or `remove` the value of the occupied entry.",
        "suggest": "在这种情况下，用户有几个选项: 他们可以 `get`，`insert` 或 `remove` 占用的条目的值。",
        "translate": ""
    },
    {
        "source": "Additionally, they can convert the occupied entry into a mutable reference to its value, providing symmetry to the vacant `insert` case.",
        "suggest": "此外，他们可以将占用的条目转换为其值的变量引用，从而为空缺的 `insert` 情况提供对称性。",
        "translate": ""
    },
    {
        "source": "Here are the two primary ways in which `entry` is used.",
        "suggest": "这是使用 `entry` 的两种主要方法。",
        "translate": ""
    },
    {
        "source": "First, a simple example where the logic performed on the values is trivial.",
        "suggest": "首先，一个简单的示例，其中对值执行的逻辑很简单。",
        "translate": ""
    },
    {
        "source": "Counting the number of times each character in a string occurs",
        "suggest": "计算字符串中每个字符出现的次数",
        "translate": ""
    },
    {
        "source": "When the logic to be performed on the value is more complex, we may simply use the `entry` API to ensure that the value is initialized and perform the logic afterwards.",
        "suggest": "当要对该值执行的逻辑比较复杂时，我们可以简单地使用 `entry` API 来确保该值已初始化，然后再执行该逻辑。",
        "translate": ""
    },
    {
        "source": "Tracking the inebriation of customers at a bar",
        "suggest": "跟踪酒吧顾客的醉酒情况",
        "translate": ""
    },
    {
        "source": "Insert and complex keys",
        "suggest": "插入复杂的键",
        "translate": ""
    },
    {
        "source": "If we have a more complex key, calls to `insert` will not update the value of the key.",
        "suggest": "如果我们拥有更复杂的键，则对 `insert` 的调用将不会更新键的值。",
        "translate": ""
    },
    {
        "source": "The deprecation here is only theoretical, and does not actually produce a warning.",
        "suggest": "这里的弃用只是理论上的，实际上并不会产生警告。",
        "translate": ""
    },
    {
        "source": "A hash map implemented with quadratic probing and SIMD lookup.",
        "suggest": "通过二次探测和 SIMD 查找实现的哈希 map。",
        "translate": ""
    },
    {
        "source": "A hash set implemented as a `HashMap` where the value is `()`.",
        "suggest": "实现为 `HashMap` 的哈希集，其中值为 `()`。",
        "translate": ""
    },
    {
        "source": "Hard to test this function",
        "suggest": "很难测试这个函数",
        "translate": ""
    },
    {
        "source": "We will iterate through the references to the element returned by env::vars();",
        "suggest": "我们将通过引用迭代到 env::vars () ; 返回的元素。",
        "translate": ""
    },
    {
        "source": "We will iterate through the references to the element returned by env::vars_os();",
        "suggest": "我们将通过引用迭代到 env::vars_os () ; 返回的元素。",
        "translate": ""
    },
    {
        "source": "Prints each argument on a separate line",
        "suggest": "在单独的行上打印每个参数",
        "translate": ""
    },
    {
        "source": "Inspection and manipulation of the process's environment.",
        "suggest": "检查和操作进程的环境。",
        "translate": ""
    },
    {
        "source": "This module contains functions to inspect various aspects such as environment variables, process arguments, the current directory, and various other important directories.",
        "suggest": "该模块包含用于检查各个方面的函数，例如环境变量，进程参数，当前目录以及各种其他重要目录。",
        "translate": ""
    },
    {
        "source": "There are several functions and structs in this module that have a counterpart ending in `os`.",
        "suggest": "该模块中有几个函数和结构体，它们的对应部分以 `os` 结尾。",
        "translate": ""
    },
    {
        "source": "Those ending in `os` will return an [`OsString`] and those without will return a [`String`].",
        "suggest": "以 `os` 结尾的那些将返回 [`OsString`]，而没有以 `os` 结尾的那些将返回 [`String`]。",
        "translate": ""
    },
    {
        "source": "Returns the current working directory as a [`PathBuf`].",
        "suggest": "返回当前的工作目录为 [`PathBuf`]。",
        "translate": ""
    },
    {
        "source": "Returns an [`Err`] if the current working directory value is invalid.",
        "suggest": "如果当前工作目录值无效，则返回 [`Err`]。",
        "translate": ""
    },
    {
        "source": "Possible cases:",
        "suggest": "可能的情况:",
        "translate": ""
    },
    {
        "source": "Current directory does not exist.",
        "suggest": "当前目录不存在。",
        "translate": ""
    },
    {
        "source": "There are insufficient permissions to access the current directory.",
        "suggest": "没有足够的权限来访问当前目录。",
        "translate": ""
    },
    {
        "source": "Changes the current working directory to the specified path.",
        "suggest": "将当前工作目录更改为指定的路径。",
        "translate": ""
    },
    {
        "source": "Returns an [`Err`] if the operation fails.",
        "suggest": "如果操作失败，则返回 [`Err`]。",
        "translate": ""
    },
    {
        "source": "An iterator over a snapshot of the environment variables of this process.",
        "suggest": "在此进程的环境变量的快照上进行迭代的迭代器。",
        "translate": ""
    },
    {
        "source": "This structure is created by [`env::vars()`].",
        "suggest": "该结构体由 [`env::vars()`] 创建。",
        "translate": ""
    },
    {
        "source": "This structure is created by [`env::vars_os()`].",
        "suggest": "该结构体由 [`env::vars_os()`] 创建。",
        "translate": ""
    },
    {
        "source": "Returns an iterator of (variable, value) pairs of strings, for all the environment variables of the current process.",
        "suggest": "返回当前进程的所有环境变量的字符串 (变量，值) 对的迭代器。",
        "translate": ""
    },
    {
        "source": "The returned iterator contains a snapshot of the process's environment variables at the time of this invocation.",
        "suggest": "返回的迭代器包含此调用时进程环境变量的快照。",
        "translate": ""
    },
    {
        "source": "Modifications to environment variables afterwards will not be reflected in the returned iterator.",
        "suggest": "之后对环境变量的修改将不会反映在返回的迭代器中。",
        "translate": ""
    },
    {
        "source": "While iterating, the returned iterator will panic if any key or value in the environment is not valid unicode.",
        "suggest": "进行迭代时，如果环境中的任何键或值不是有效的 unicode，则返回的迭代器将为 panic。",
        "translate": ""
    },
    {
        "source": "If this is not desired, consider using [`env::vars_os()`].",
        "suggest": "如果不希望这样做，请考虑使用 [`env::vars_os()`]。",
        "translate": ""
    },
    {
        "source": "Returns an iterator of (variable, value) pairs of OS strings, for all the environment variables of the current process.",
        "suggest": "对于当前进程的所有环境变量，返回 OS 字符串对 (变量，值) 对的迭代器。",
        "translate": ""
    },
    {
        "source": "Fetches the environment variable `key` from the current process.",
        "suggest": "从当前进程中获取环境变量 `key`。",
        "translate": ""
    },
    {
        "source": "Environment variable is not present",
        "suggest": "环境变量不存在",
        "translate": ""
    },
    {
        "source": "Environment variable is not valid unicode",
        "suggest": "环境变量无效的 unicode",
        "translate": ""
    },
    {
        "source": "This function may panic if `key` is empty, contains an ASCII equals sign `'='` or the NUL character `'\\0'`, or when the value contains the NUL character.",
        "suggest": "如果 `key` 为空，包含 ASCII 等于 `'='` 或 NUL 字符 `'\\0'` 或值包含 NUL 字符，则此函数可能为 panic。",
        "translate": ""
    },
    {
        "source": "Fetches the environment variable `key` from the current process, returning [`None`] if the variable isn't set.",
        "suggest": "从当前进程中获取环境变量 `key`，如果未设置该变量，则返回 [`None`]。",
        "translate": ""
    },
    {
        "source": "The error type for operations interacting with environment variables.",
        "suggest": "与环境变量交互的操作的错误类型。",
        "translate": ""
    },
    {
        "source": "Possibly returned from [`env::var()`].",
        "suggest": "可能是从 [`env::var()`] 返回的。",
        "translate": ""
    },
    {
        "source": "The specified environment variable was not present in the current process's environment.",
        "suggest": "当前进程的环境中不存在指定的环境变量。",
        "translate": ""
    },
    {
        "source": "The specified environment variable was found, but it did not contain valid unicode data.",
        "suggest": "找到了指定的环境变量，但是它不包含有效的 unicode 数据。",
        "translate": ""
    },
    {
        "source": "The found data is returned as a payload of this variant.",
        "suggest": "找到的数据作为该成员的有效负载返回。",
        "translate": ""
    },
    {
        "source": "Sets the environment variable `k` to the value `v` for the currently running process.",
        "suggest": "将当前正在运行的进程的环境变量 `k` 设置为值 `v`。",
        "translate": ""
    },
    {
        "source": "Note that while concurrent access to environment variables is safe in Rust, some platforms only expose inherently unsafe non-threadsafe APIs for inspecting the environment.",
        "suggest": "请注意，虽然在 Rust 中对环境变量进行并发访问是安全的，但某些平台仅公开本质上不安全的非线程安全 API 来检查环境。",
        "translate": ""
    },
    {
        "source": "As a result, extra care needs to be taken when auditing calls to unsafe external FFI functions to ensure that any external environment accesses are properly synchronized with accesses in Rust.",
        "suggest": "因此，在审核对不安全的外部 FFI 函数的调用时，需要格外小心，以确保所有外部环境访问均与 Rust 中的访问正确同步。",
        "translate": ""
    },
    {
        "source": "Discussion of this unsafety on Unix may be found in:",
        "suggest": "有关 Unix 上这种不安全性的讨论，请参见:",
        "translate": ""
    },
    {
        "source": "Removes an environment variable from the environment of the currently running process.",
        "suggest": "从当前正在运行的进程的环境中删除环境变量。",
        "translate": ""
    },
    {
        "source": "As a result extra care needs to be taken when auditing calls to unsafe external FFI functions to ensure that any external environment accesses are properly synchronized with accesses in Rust.",
        "suggest": "因此，在审核对不安全的外部 FFI 函数的调用时，需要格外小心，以确保所有外部环境访问都与 Rust 中的访问正确同步。",
        "translate": ""
    },
    {
        "source": "An iterator that splits an environment variable into paths according to platform-specific conventions.",
        "suggest": "一个迭代器，该迭代器根据特定于平台的约定将环境变量拆分为路径。",
        "translate": ""
    },
    {
        "source": "The iterator element type is [`PathBuf`].",
        "suggest": "迭代器元素类型为 [`PathBuf`]。",
        "translate": ""
    },
    {
        "source": "This structure is created by [`env::split_paths()`].",
        "suggest": "该结构体由 [`env::split_paths()`] 创建。",
        "translate": ""
    },
    {
        "source": "Parses input according to platform conventions for the `PATH` environment variable.",
        "suggest": "根据平台约定对 `PATH` 环境变量解析输入。",
        "translate": ""
    },
    {
        "source": "Returns an iterator over the paths contained in `unparsed`.",
        "suggest": "返回 `unparsed` 中包含的路径上的迭代器。",
        "translate": ""
    },
    {
        "source": "The error type for operations on the `PATH` variable.",
        "suggest": "`PATH` 变量上的操作的错误类型。",
        "translate": ""
    },
    {
        "source": "Possibly returned from [`env::join_paths()`].",
        "suggest": "可能是从 [`env::join_paths()`] 返回的。",
        "translate": ""
    },
    {
        "source": "Joins a collection of [`Path`]s appropriately for the `PATH` environment variable.",
        "suggest": "为 `PATH` 环境变量适当地加入 [Path] 的集合。",
        "translate": ""
    },
    {
        "source": "Returns an [`Err`] (containing an error message) if one of the input [`Path`]s contains an invalid character for constructing the `PATH` variable (a double quote on Windows or a colon on Unix).",
        "suggest": "如果输入 [Path] 之一包含用于构造 `PATH` 变量的无效字符 (Windows 上的双引号或 Unix 上的冒号)，则返回 [`Err`] (包含错误消息)。",
        "translate": ""
    },
    {
        "source": "Joining paths on a Unix-like platform:",
        "suggest": "在类似 Unix 的平台上的连接路径:",
        "translate": ""
    },
    {
        "source": "Joining a path containing a colon on a Unix-like platform results in an error:",
        "suggest": "在类似 Unix 的平台上加入包含冒号的路径会导致错误:",
        "translate": ""
    },
    {
        "source": "Using `env::join_paths()` with [`env::split_paths()`] to append an item to the `PATH` environment variable:",
        "suggest": "将 `env::join_paths()` 与 [`env::split_paths()`] 结合使用，可以将项附加到 `PATH` 环境变量中:",
        "translate": ""
    },
    {
        "source": "Returns the path of the current user's home directory if known.",
        "suggest": "返回当前用户主目录的路径 (如果已知)。",
        "translate": ""
    },
    {
        "source": "Returns the value of the 'HOME' environment variable if it is set (including to an empty string).",
        "suggest": "返回 'HOME' 环境变量的值 (如果已设置) (包括一个空字符串)。",
        "translate": ""
    },
    {
        "source": "Otherwise, it tries to determine the home directory by invoking the `getpwuid_r` function using the UID of the current user.",
        "suggest": "否则，它将尝试通过使用当前用户的 UID 调用 `getpwuid_r` 函数来确定主目录。",
        "translate": ""
    },
    {
        "source": "An empty home directory field returned from the `getpwuid_r` function is considered to be a valid value.",
        "suggest": "从 `getpwuid_r` 函数返回的空主目录字段被视为有效值。",
        "translate": ""
    },
    {
        "source": "Returns `None` if the current user has no entry in the /etc/passwd file.",
        "suggest": "如果当前用户在 /etc/passwd 文件中没有条目，则返回 `None`。",
        "translate": ""
    },
    {
        "source": "Otherwise, returns the value of the 'USERPROFILE' environment variable if it is set (including to an empty string).",
        "suggest": "否则，返回 'USERPROFILE' 环境变量的值 (如果已设置) (包括一个空字符串)。",
        "translate": ""
    },
    {
        "source": "If both do not exist, [`GetUserProfileDirectory`][msdn] is used to return the path.",
        "suggest": "如果两者都不存在，则使用 [`GetUserProfileDirectory`][msdn] 返回路径。",
        "translate": ""
    },
    {
        "source": "Returns the path of a temporary directory.",
        "suggest": "返回临时目录的路径。",
        "translate": ""
    },
    {
        "source": "The temporary directory may be shared among users, or between processes with different privileges;",
        "suggest": "临时目录可以在用户之间共享，也可以在具有不同权限的进程之间共享;",
        "translate": ""
    },
    {
        "source": "thus, the creation of any files or directories in the temporary directory must use a secure method to create a uniquely named file.",
        "suggest": "因此，在临时目录中创建任何文件或目录都必须使用安全方法来创建唯一命名的文件。",
        "translate": ""
    },
    {
        "source": "Creating a file or directory with a fixed or predictable name may result in \"insecure temporary file\" security vulnerabilities.",
        "suggest": "使用固定或可预测的名称创建文件或目录可能会导致 \"insecure temporary file\" 安全漏洞。",
        "translate": ""
    },
    {
        "source": "Consider using a crate that securely creates temporary files or directories.",
        "suggest": "考虑使用安全创建临时文件或目录的 crate。",
        "translate": ""
    },
    {
        "source": "Returns the value of the `TMPDIR` environment variable if it is set, otherwise for non-Android it returns `/tmp`.",
        "suggest": "返回 `TMPDIR` 环境变量的值 (如果已设置)，否则返回 `/tmp` (对于非 Android)。",
        "translate": ""
    },
    {
        "source": "If Android, since there is no global temporary folder (it is usually allocated per-app), it returns `/data/local/tmp`.",
        "suggest": "如果为 Android，则由于没有临时文件夹 (通常是按应用分配的)，它将返回 `/data/local/tmp`。",
        "translate": ""
    },
    {
        "source": "Returns the value of, in order, the `TMP`, `TEMP`, `USERPROFILE` environment variable if any are set and not the empty string.",
        "suggest": "如果设置了环境变量，则按顺序返回 `TMP`，`TEMP`，`USERPROFILE` 的值，而不是空字符串。",
        "translate": ""
    },
    {
        "source": "Otherwise, `temp_dir` returns the path of the Windows directory.",
        "suggest": "否则，`temp_dir` 返回 Windows 目录的路径。",
        "translate": ""
    },
    {
        "source": "This behavior is identical to that of [`GetTempPath`][msdn], which this function uses internally.",
        "suggest": "此行为与该函数在内部使用的 [`GetTempPath`][msdn] 相同。",
        "translate": ""
    },
    {
        "source": "Returns the full filesystem path of the current running executable.",
        "suggest": "返回当前正在运行的可执行文件的完整文件系统路径。",
        "translate": ""
    },
    {
        "source": "Platform-specific behavior",
        "suggest": "平台特定的行为",
        "translate": ""
    },
    {
        "source": "If the executable was invoked through a symbolic link, some platforms will return the path of the symbolic link and other platforms will return the path of the symbolic link’s target.",
        "suggest": "如果可执行文件是通过符号链接调用的，则某些平台将返回符号链接的路径，而其他平台将返回符号链接目标的路径。",
        "translate": ""
    },
    {
        "source": "Acquiring the path of the current executable is a platform-specific operation that can fail for a good number of reasons.",
        "suggest": "获取当前可执行文件的路径是特定于平台的操作，由于多种原因，该操作可能会失败。",
        "translate": ""
    },
    {
        "source": "Some errors can include, but not be limited to, filesystem operations failing or general syscall failures.",
        "suggest": "一些错误可能包括但不限于文件系统操作失败或常规 syscall 错误。",
        "translate": ""
    },
    {
        "source": "The output of this function should not be used in anything that might have security implications.",
        "suggest": "此函数的输出不应在可能涉及安全性的任何情况下使用。",
        "translate": ""
    },
    {
        "source": "On Linux systems, if this is compiled as `foo`:",
        "suggest": "在 Linux 系统上，如果将其编译为 `foo`:",
        "translate": ""
    },
    {
        "source": "And you make a hard link of the program:",
        "suggest": "然后您对该程序进行了硬链接:",
        "translate": ""
    },
    {
        "source": "When you run it, you won’t get the path of the original executable, you’ll get the path of the hard link:",
        "suggest": "运行它时，您将不会获得原始可执行文件的路径，而会获得硬链接的路径:",
        "translate": ""
    },
    {
        "source": "This sort of behavior has been known to [lead to privilege escalation] when used incorrectly.",
        "suggest": "如果不正确使用 [lead to privilege escalation]，这种行为是已知的。",
        "translate": ""
    },
    {
        "source": "An iterator over the arguments of a process, yielding a [`String`] value for each argument.",
        "suggest": "进程参数的迭代器，为每个参数产生 [`String`] 值。",
        "translate": ""
    },
    {
        "source": "This struct is created by [`env::args()`].",
        "suggest": "该结构体由 [`env::args()`] 创建。",
        "translate": ""
    },
    {
        "source": "The first element is traditionally the path of the executable, but it can be set to arbitrary text, and may not even exist.",
        "suggest": "传统上，第一个元素是可执行文件的路径，但可以将其设置为任意文本，甚至可能不存在。",
        "translate": ""
    },
    {
        "source": "This means this property should not be relied upon for security purposes.",
        "suggest": "这意味着出于安全目的，不应依赖此属性。",
        "translate": ""
    },
    {
        "source": "An iterator over the arguments of a process, yielding an [`OsString`] value for each argument.",
        "suggest": "一个进程参数的迭代器，为每个参数产生 [`OsString`] 值。",
        "translate": ""
    },
    {
        "source": "This struct is created by [`env::args_os()`].",
        "suggest": "该结构体由 [`env::args_os()`] 创建。",
        "translate": ""
    },
    {
        "source": "Returns the arguments that this program was started with (normally passed via the command line).",
        "suggest": "返回此程序开始的参数 (通常通过命令行传递)。",
        "translate": ""
    },
    {
        "source": "On Unix systems the shell usually expands unquoted arguments with glob patterns (such as `*` and `?`).",
        "suggest": "在 Unix 系统上，shell 通常使用 glob 模式 (例如 `*` 和 `?`) 来扩展不带引号的参数。",
        "translate": ""
    },
    {
        "source": "On Windows this is not done, and such arguments are passed as-is.",
        "suggest": "在 Windows 上，这没有完成，并且此类参数按原样传递。",
        "translate": ""
    },
    {
        "source": "On glibc Linux systems, arguments are retrieved by placing a function in `.init_array`.",
        "suggest": "在 glibc Linux 系统上，可以通过在 `.init_array` 中放置一个函数来检索参数。",
        "translate": ""
    },
    {
        "source": "Glibc passes `argc`, `argv`, and `envp` to functions in `.init_array`, as a non-standard extension.",
        "suggest": "Glibc 将 `argc`，`argv` 和 `envp` 作为非标准扩展传递给 `.init_array` 中的函数。",
        "translate": ""
    },
    {
        "source": "This allows `std::env::args` to work even in a `cdylib` or `staticlib`, as it does on macOS and Windows.",
        "suggest": "这使得 `std::env::args` 甚至可以在 `cdylib` 或 `staticlib` 上工作，就像在 macOS 和 Windows 上一样。",
        "translate": ""
    },
    {
        "source": "The returned iterator will panic during iteration if any argument to the process is not valid unicode.",
        "suggest": "如果该进程的任何参数不是有效的 unicode，则返回的迭代器将在迭代过程中 panic。",
        "translate": ""
    },
    {
        "source": "If this is not desired, use the [`args_os`] function instead.",
        "suggest": "如果不希望这样做，请改用 [`args_os`] 函数。",
        "translate": ""
    },
    {
        "source": "Returns the arguments which this program was started with (normally passed via the command line).",
        "suggest": "返回此程序开始的参数 (通常通过命令行传递)。",
        "translate": ""
    },
    {
        "source": "The first element is traditionally the path of the executable, but it can be set to arbitrary text, and it may not even exist, so this property should not be relied upon for security purposes.",
        "suggest": "传统上，第一个元素是可执行文件的路径，但是可以将其设置为任意文本，甚至可能不存在，因此出于安全目的不应依赖此属性。",
        "translate": ""
    },
    {
        "source": "On glibc Linux systems, arguments are retrieved by placing a function in \".init_array\".",
        "suggest": "在 glibc Linux 系统上，可以通过在 \".init_array\" 中放置一个函数来检索参数。",
        "translate": ""
    },
    {
        "source": "Glibc passes argc, argv, and envp to functions in \".init_array\", as a non-standard extension.",
        "suggest": "Glibc 将 argc，argv 和 envp 作为非标准扩展传递给 \".init_array\" 中的函数。",
        "translate": ""
    },
    {
        "source": "Constants associated with the current target",
        "suggest": "与当前目标关联的常量",
        "translate": ""
    },
    {
        "source": "A string describing the architecture of the CPU that is currently in use.",
        "suggest": "一个字符串，描述当前正在使用的 CPU 的体系结构。",
        "translate": ""
    },
    {
        "source": "Some possible values:",
        "suggest": "一些可能的值:",
        "translate": ""
    },
    {
        "source": "The family of the operating system.",
        "suggest": "操作系统的家族。",
        "translate": ""
    },
    {
        "source": "Example value is `unix`.",
        "suggest": "示例值为 `unix`。",
        "translate": ""
    },
    {
        "source": "A string describing the specific operating system in use.",
        "suggest": "描述正在使用的特定操作系统的字符串。",
        "translate": ""
    },
    {
        "source": "Example value is `linux`.",
        "suggest": "示例值为 `linux`。",
        "translate": ""
    },
    {
        "source": "Specifies the filename prefix used for shared libraries on this platform.",
        "suggest": "指定用于此平台上的共享库的文件名前缀。",
        "translate": ""
    },
    {
        "source": "Example value is `lib`.",
        "suggest": "示例值为 `lib`。",
        "translate": ""
    },
    {
        "source": "(an empty string)",
        "suggest": "(一个空字符串)",
        "translate": ""
    },
    {
        "source": "Specifies the filename suffix used for shared libraries on this platform.",
        "suggest": "指定此平台上共享库使用的文件名后缀。",
        "translate": ""
    },
    {
        "source": "Example value is `.so`.",
        "suggest": "示例值为 `.so`。",
        "translate": ""
    },
    {
        "source": "Specifies the file extension used for shared libraries on this platform that goes after the dot.",
        "suggest": "指定此平台上共享库所用的文件扩展名，该扩展名位于点后。",
        "translate": ""
    },
    {
        "source": "Example value is `so`.",
        "suggest": "示例值为 `so`。",
        "translate": ""
    },
    {
        "source": "Specifies the filename suffix used for executable binaries on this platform.",
        "suggest": "指定用于此平台上的可执行二进制文件的文件名后缀。",
        "translate": ""
    },
    {
        "source": "Example value is `.exe`.",
        "suggest": "示例值为 `.exe`。",
        "translate": ""
    },
    {
        "source": "Specifies the file extension, if any, used for executable binaries on this platform.",
        "suggest": "指定用于此平台上的可执行二进制文件的文件扩展名 (如果有)。",
        "translate": ""
    },
    {
        "source": "Example value is `exe`.",
        "suggest": "示例值为 `exe`。",
        "translate": ""
    },
    {
        "source": "Print `e` itself, no need for description().",
        "suggest": "打印 `e` 本身，不需要 description()。",
        "translate": ""
    },
    {
        "source": "let err : Box<Error> = b.into();",
        "suggest": "令 err: Box<Error> = b.into();",
        "translate": ""
    },
    {
        "source": "// or",
        "suggest": "// 或者",
        "translate": ""
    },
    {
        "source": "Traits for working with Errors.",
        "suggest": "Traits 用于处理错误。",
        "translate": ""
    },
    {
        "source": "A note about crates and the facade:",
        "suggest": "关于 crates 和 facade 的笔记:",
        "translate": ""
    },
    {
        "source": "Originally, the `Error` trait was defined in libcore, and the impls were scattered about.",
        "suggest": "最初，`Error` trait 在 libcore 中定义，并且 impls 分散在周围。",
        "translate": ""
    },
    {
        "source": "However, coherence objected to this arrangement, because to create the blanket impls for `Box` required knowing that `&str: !Error`, and we have no means to deal with that sort of conflict just now.",
        "suggest": "但是，连贯性反对这种安排，因为要为 `Box` 创建毯式实现需要知道 `&str: !Error`，而我们现在还没有办法解决这种冲突。",
        "translate": ""
    },
    {
        "source": "Therefore, for the time being, we have moved the `Error` trait into libstd.",
        "suggest": "因此，暂时将 `Error` trait 移到 libstd 中。",
        "translate": ""
    },
    {
        "source": "As we evolve a sol'n to the coherence challenge (e.g., specialization, neg impls, etc) we can reconsider what crate these items belong in.",
        "suggest": "随着我们解决连贯性挑战 (例如，专业化，否定的影响等)，我们可以重新考虑这些项目所属的 crate。",
        "translate": ""
    },
    {
        "source": "is a trait representing the basic expectations for error values, i.e., values of type `E` in [`Result<T, E>`].",
        "suggest": "是 trait，表示对错误值 (即 [`Result<T, E>`] 中的 `E` 类型的值) 的基本期望。",
        "translate": ""
    },
    {
        "source": "Errors must describe themselves through the [`Display`] and [`Debug`] traits, and may provide cause chain information:",
        "suggest": "错误必须通过 [`Display`] 和 [`Debug`] traits 进行自我描述，并可能提供原因链信息:",
        "translate": ""
    },
    {
        "source": "is generally used when errors cross \"abstraction boundaries\".",
        "suggest": "当错误跨越 \"abstraction boundaries\" 时通常使用。",
        "translate": ""
    },
    {
        "source": "If one module must report an error that is caused by an error from a lower-level module, it can allow accessing that error via [`Error::source()`].",
        "suggest": "如果一个模块必须报告由下级模块的错误引起的错误，则它可以允许通过 [`Error::source()`] 访问该错误。",
        "translate": ""
    },
    {
        "source": "This makes it possible for the high-level module to provide its own errors while also revealing some of the implementation for debugging via `source` chains.",
        "suggest": "这使得高级模块可以提供自己的错误，同时还可以公开一些通过 `source` 链进行调试的实现。",
        "translate": ""
    },
    {
        "source": "The lower-level source of this error, if any.",
        "suggest": "此错误的下级来源 (如果有)。",
        "translate": ""
    },
    {
        "source": "Returns a stack backtrace, if available, of where this error occurred.",
        "suggest": "返回发生错误的栈回溯 (如果有)。",
        "translate": ""
    },
    {
        "source": "This function allows inspecting the location, in code, of where an error happened.",
        "suggest": "该函数允许检查代码中发生错误的位置。",
        "translate": ""
    },
    {
        "source": "The returned `Backtrace` contains information about the stack trace of the OS thread of execution of where the error originated from.",
        "suggest": "返回的 `Backtrace` 包含有关执行错误来源的 OS 线程的栈跟踪的信息。",
        "translate": ""
    },
    {
        "source": "Note that not all errors contain a `Backtrace`.",
        "suggest": "请注意，并非所有错误都包含 `Backtrace`。",
        "translate": ""
    },
    {
        "source": "Also note that a `Backtrace` may actually be empty.",
        "suggest": "另请注意，`Backtrace` 实际上可能为空。",
        "translate": ""
    },
    {
        "source": "For more information consult the `Backtrace` type itself.",
        "suggest": "有关更多信息，请查阅 `Backtrace` 类型本身。",
        "translate": ""
    },
    {
        "source": "This is a hack to prevent `type_id` from being overridden by `Error` implementations, since that can enable unsound downcasting.",
        "suggest": "这是防止 `type_id` 被 `Error` 实现覆盖的黑客，因为这可能会导致不正确的向下转换。",
        "translate": ""
    },
    {
        "source": "Converts a type of [`Error`] into a box of dyn [`Error`].",
        "suggest": "将 [`Error`] 的类型转换为 dyn [`Error`] 的 box。",
        "translate": ""
    },
    {
        "source": "Converts a type of [`Error`] + [`Send`] + [`Sync`] into a box of dyn [`Error`] + [`Send`] + [`Sync`].",
        "suggest": "将 [`Error`] + [`Send`] + [`Sync`] 的类型转换为 Dyn [`Error`] + [`Send`] + [`Sync`] 的 box。",
        "translate": ""
    },
    {
        "source": "Converts a [`String`] into a box of dyn [`Error`] + [`Send`] + [`Sync`].",
        "suggest": "将 [`String`] 转换为 Dyn [`Error`] + [`Send`] + [`Sync`] 的 box。",
        "translate": ""
    },
    {
        "source": "Purposefully skip printing \"StringError(..)\"",
        "suggest": "有意跳过打印 \"StringError(..)\"",
        "translate": ""
    },
    {
        "source": "Converts a [`String`] into a box of dyn [`Error`].",
        "suggest": "将 [`String`] 转换为 dyn [`Error`] 的 box。",
        "translate": ""
    },
    {
        "source": "Converts a [`str`] into a box of dyn [`Error`] + [`Send`] + [`Sync`].",
        "suggest": "将 [`str`] 转换为 Dyn [`Error`] + [`Send`] + [`Sync`] 的 box。",
        "translate": ""
    },
    {
        "source": "Converts a [`str`] into a box of dyn [`Error`].",
        "suggest": "将 [`str`] 转换为 dyn [`Error`] 的 box。",
        "translate": ""
    },
    {
        "source": "Converts a [`Cow`] into a box of dyn [`Error`] + [`Send`] + [`Sync`].",
        "suggest": "将 [`Cow`] 转换为 Dyn [`Error`] + [`Send`] + [`Sync`] 的 box。",
        "translate": ""
    },
    {
        "source": "Converts a [`Cow`] into a box of dyn [`Error`].",
        "suggest": "将 [`Cow`] 转换为 dyn [`Error`] 的 box。",
        "translate": ""
    },
    {
        "source": "Copied from `any.rs`.",
        "suggest": "从 `any.rs` 复制。",
        "translate": ""
    },
    {
        "source": "Returns `true` if the boxed type is the same as `T`",
        "suggest": "如果 boxed 类型与 `T` 相同，则返回 `true`",
        "translate": ""
    },
    {
        "source": "Get `TypeId` of the type in the trait object.",
        "suggest": "在 trait object 中获取类型的 `TypeId`。",
        "translate": ""
    },
    {
        "source": "Forwards to the method defined on the type `dyn Error`.",
        "suggest": "转发到在 `dyn Error` 类型上定义的方法。",
        "translate": ""
    },
    {
        "source": "Attempts to downcast the box to a concrete type.",
        "suggest": "尝试将 box 转换为具体类型。",
        "translate": ""
    },
    {
        "source": "Returns an iterator starting with the current error and continuing with recursively calling [`Error::source`].",
        "suggest": "返回一个迭代器，该迭代器从当前错误开始，然后以递归方式调用 [`Error::source`]。",
        "translate": ""
    },
    {
        "source": "If you want to omit the current error and only use its sources, use `skip(1)`.",
        "suggest": "如果要忽略当前错误并仅使用其来源，请使用 `skip(1)`。",
        "translate": ""
    },
    {
        "source": "An iterator over an [`Error`] and its sources.",
        "suggest": "[`Error`] 及其源上的迭代器。",
        "translate": ""
    },
    {
        "source": "If you want to omit the initial error and only process its sources, use `skip(1)`.",
        "suggest": "如果要忽略初始错误并仅处理其错误源，请使用 `skip(1)`。",
        "translate": ""
    },
    {
        "source": "Reapply the `Send` marker.",
        "suggest": "重新应用 `Send` 标记。",
        "translate": ""
    },
    {
        "source": "Reapply the `Send + Sync` marker.",
        "suggest": "重新应用 `Send + Sync` 标记。",
        "translate": ""
    },
    {
        "source": "regression test for the catastrophic cancellation fixed in 72486",
        "suggest": "于 72486 中修复的灾难性取消的回归测试",
        "translate": ""
    },
    {
        "source": "Check that NaNs roundtrip their bits regardless of signaling-ness",
        "suggest": "检查 NaN 是否往返传输其比特，而不管信令大小如何",
        "translate": ""
    },
    {
        "source": "is 0b1010;",
        "suggest": "是 0b1010;",
        "translate": ""
    },
    {
        "source": "0x5 is 0b0101 -- so these two together clobbers all the mantissa bits",
        "suggest": "0x5 是 0b0101 - 因此这两个一起拖尾了所有的尾数位",
        "translate": ""
    },
    {
        "source": "limitation due to round-off error",
        "suggest": "由于舍入误差而造成的限制",
        "translate": ""
    }
]
