[
    {
        "source": "Vector Shift Right Arithmetic Rounded",
        "suggest": "Vector 右移算术四舍五入",
        "translate": ""
    },
    {
        "source": "The elements in vector `a` (sixteen signed 8-bit integer numbers) are shifted right arithmetic by the number of bits the elements in vector `b` (sixteen signed 8-bit integer numbers) specify modulo the size of the element in bits.The most significant discarded bit is added to the shifted value (for rounding) and the result is written to vector (sixteen signed 8-bit integer numbers).",
        "suggest": "vector `a` (十六个带符号的 8 位整数) 中的元素按 vector `b` (十六个带符号的 8 位整数) 中元素的位数右移算术，以 bits.The 最高有效舍弃位中的元素大小为模被加到移位值上 (用于四舍五入)，并将结果写入 vector (十六个带符号的 8 位整数)。",
        "translate": ""
    },
    {
        "source": "The elements in vector `a` (eight signed 16-bit integer numbers) are shifted right arithmetic by the number of bits the elements in vector `b` (eight signed 16-bit integer numbers) specify modulo the size of the element in bits.The most significant discarded bit is added to the shifted value (for rounding) and the result is written to vector (eight signed 16-bit integer numbers).",
        "suggest": "vector `a` (八个带符号的 16 位整数) 中的元素按 vector `b` (八个带符号的 16 位整数) 中元素的位数右移算术，以 bits.The 最高有效舍弃位中的元素大小为模被加到移位后的值 (用于四舍五入)，并将结果写入 vector (八个带符号的 16 位整数)。",
        "translate": ""
    },
    {
        "source": "The elements in vector `a` (four signed 32-bit integer numbers) are shifted right arithmetic by the number of bits the elements in vector `b` (four signed 32-bit integer numbers) specify modulo the size of the element in bits.The most significant discarded bit is added to the shifted value (for rounding) and the result is written to vector (four signed 32-bit integer numbers).",
        "suggest": "vector `a` (四个带符号的 32 位整数) 中的元素按 vector `b` (四个带符号的 32 位整数) 中的元素右移的位数指定以 bits.The 中最高有效舍弃位的元素大小为模被加到移位值上 (用于四舍五入)，并将结果写入 vector (四个带符号的 32 位整数)。",
        "translate": ""
    },
    {
        "source": "The elements in vector `a` (two signed 64-bit integer numbers) are shifted right arithmetic by the number of bits the elements in vector `b` (two signed 64-bit integer numbers) specify modulo the size of the element in bits.The most significant discarded bit is added to the shifted value (for rounding) and the result is written to vector (two signed 64-bit integer numbers).",
        "suggest": "vector `a` (两个带符号的 64 位整数) 中的元素按算术右移 vector `b` (两个带符号的 64 位整数) 中的元素以模数形式指定 bits.The 中最高有效舍弃位的元素大小被加到移位值上 (用于四舍五入)，并将结果写入 vector (两个带符号的 64 位整数)。",
        "translate": ""
    },
    {
        "source": "Immediate Shift Right Arithmetic Rounded",
        "suggest": "Immediate 右移算术四舍五入",
        "translate": ""
    },
    {
        "source": "The elements in vector `a` (sixteen signed 8-bit integer numbers) are shifted right arithmetic by `imm3` bits.The most significant discarded bit is added to the shifted value (for rounding) and the result is written to vector (sixteen signed 8-bit integer numbers).",
        "suggest": "`imm3` bits.The 将 vector `a` (十六个带符号的 8 位整数) 中的元素右移，将最高有效舍弃位加到移位值 (用于舍入)，并将结果写入 vector (十六个带符号的 8 位整数。)。",
        "translate": ""
    },
    {
        "source": "The elements in vector `a` (eight signed 16-bit integer numbers) are shifted right arithmetic by `imm4` bits.The most significant discarded bit is added to the shifted value (for rounding) and the result is written to vector (eight signed 16-bit integer numbers).",
        "suggest": "`imm4` bits.The 将 vector `a` (八个带符号的 16 位整数) 中的元素右移，将最高有效舍弃位加到移位值 (用于舍入)，并将结果写入 vector (八个带符号的 16 位整数。)。",
        "translate": ""
    },
    {
        "source": "The elements in vector `a` (four signed 32-bit integer numbers) are shifted right arithmetic by `imm5` bits.The most significant discarded bit is added to the shifted value (for rounding) and the result is written to vector (four signed 32-bit integer numbers).",
        "suggest": "`imm5` bits.The 将 vector `a` (四个带符号的 32 位整数) 中的元素右移，将最高有效舍弃位加到移位值 (用于舍入)，并将结果写入 vector (四个带符号的 32 位整数。)。",
        "translate": ""
    },
    {
        "source": "The elements in vector `a` (two signed 64-bit integer numbers) are shifted right arithmetic by `imm6` bits.The most significant discarded bit is added to the shifted value (for rounding) and the result is written to vector (two signed 64-bit integer numbers).",
        "suggest": "`imm6` bits.The 将 vector `a` (两个带符号的 64 位整数) 中的元素右移，将最高有效舍弃位加到移位值 (用于舍入)，并将结果写入 vector (两个带符号的 64 位整数。)。",
        "translate": ""
    },
    {
        "source": "Vector Shift Right Logical",
        "suggest": "Vector 右移逻辑",
        "translate": ""
    },
    {
        "source": "The elements in vector `a` (sixteen signed 8-bit integer numbers) are shifted right logical by the number of bits the elements in vector `b` (sixteen signed 8-bit integer numbers) specify modulo the size of the element in bits.The result is written to vector (sixteen signed 8-bit integer numbers).",
        "suggest": "vector `a` (十六个带符号的 8 位整数) 中的元素向右逻辑移位 vector `b` (十六个带符号的 8 位整数) 中的元素的位数，以模方式指定将 bits.The 结果中的元素的大小写入 vector (十六个带符号的 8 位整数)。",
        "translate": ""
    },
    {
        "source": "The elements in vector `a` (eight signed 16-bit integer numbers) are shifted right logical by the number of bits the elements in vector `b` (eight signed 16-bit integer numbers) specify modulo the size of the element in bits.The result is written to vector (eight signed 16-bit integer numbers).",
        "suggest": "vector `a` (八个带符号的 16 位整数) 中的元素向右逻辑移位 vector `b` (八个带符号的 16 位整数) 中的元素的位数，以模为单位，指定将 bits.The 结果中的元素的大小写入其中 vector (八个带符号的 16 位整数)。",
        "translate": ""
    },
    {
        "source": "The elements in vector `a` (four signed 32-bit integer numbers) are shifted right logical by the number of bits the elements in vector `b` (four signed 32-bit integer numbers) specify modulo the size of the element in bits.The result is written to vector (four signed 32-bit integer numbers).",
        "suggest": "vector `a` (四个带符号的 32 位整数) 中的元素向右逻辑移位 vector `b` (四个带符号的 32 位整数) 中的元素的位数，以模方式指定 bits.The 结果中元素的大小写入 vector (四个带符号的 32 位整数)。",
        "translate": ""
    },
    {
        "source": "The elements in vector `a` (two signed 64-bit integer numbers) are shifted right logical by the number of bits the elements in vector `b` (two signed 64-bit integer numbers) specify modulo the size of the element in bits.The result is written to vector (two signed 64-bit integer numbers).",
        "suggest": "vector `a` (两个带符号的 64 位整数) 中的元素向右逻辑移位 vector `b` (两个带符号的 64 位整数) 中的元素的位数，以模为单位，指定将 bits.The 结果中的元素的大小写入其中 vector (两个带符号的 64 位整数)。",
        "translate": ""
    },
    {
        "source": "Immediate Shift Right Logical",
        "suggest": "Immediate 右移逻辑",
        "translate": ""
    },
    {
        "source": "The elements in vector `a` (sixteen signed 8-bit integer numbers) are shifted right logical by `imm4` bits.",
        "suggest": "vector `a` 中的元素 (十六个带符号的 8 位整数) 向逻辑上右移 `imm4` 位。",
        "translate": ""
    },
    {
        "source": "The elements in vector `a` (eight signed 16-bit integer numbers) are shifted right logical by `imm3` bits.",
        "suggest": "vector `a` (八个带符号的 16 位整数) 中的元素在逻辑上右移 `imm3` 位。",
        "translate": ""
    },
    {
        "source": "The elements in vector `a` (four signed 32-bit integer numbers) are shifted right logical by `imm2` bits.",
        "suggest": "vector `a` (四个带符号的 32 位整数) 中的元素在逻辑上右移 `imm2` 位。",
        "translate": ""
    },
    {
        "source": "The elements in vector `a` (two signed 64-bit integer numbers) are shifted right logical by `imm1` bits.",
        "suggest": "vector `a` (两个带符号的 64 位整数) 中的元素在逻辑上右移 `imm1` 位。",
        "translate": ""
    },
    {
        "source": "Vector Shift Right Logical Rounded",
        "suggest": "Vector 右移逻辑舍入",
        "translate": ""
    },
    {
        "source": "The elements in vector `a` (sixteen signed 8-bit integer numbers) are shifted right logical by the number of bits the elements in vector `b` (sixteen signed 8-bit integer numbers) specify modulo the size of the element in bits.The most significant discarded bit is added to the shifted value (for rounding) and the result is written to vector (sixteen signed 8-bit integer numbers).",
        "suggest": "vector `a` (十六个带符号的 8 位整数) 中的元素按逻辑逻辑右移 vector `b` (十六个带符号的 8 位整数) 中的元素以模数形式指定 bits.The 最高有效舍弃位中元素的大小被加到移位值上 (用于四舍五入)，并将结果写入 vector (十六个带符号的 8 位整数)。",
        "translate": ""
    },
    {
        "source": "The elements in vector `a` (eight signed 16-bit integer numbers) are shifted right logical by the number of bits the elements in vector `b` (eight signed 16-bit integer numbers) specify modulo the size of the element in bits.The most significant discarded bit is added to the shifted value (for rounding) and the result is written to vector (eight signed 16-bit integer numbers).",
        "suggest": "vector `a` (八个带符号的 16 位整数) 中的元素按逻辑右移 vector `b` (八个带符号的 16 位整数) 中的元素的位数，以模数形式指定 bits.The 中最高有效舍弃位的元素大小被加到移位后的值 (用于四舍五入)，结果被写入 vector (八个带符号的 16 位整数)。",
        "translate": ""
    },
    {
        "source": "The elements in vector `a` (four signed 32-bit integer numbers) are shifted right logical by the number of bits the elements in vector `b` (four signed 32-bit integer numbers) specify modulo the size of the element in bits.The most significant discarded bit is added to the shifted value (for rounding) and the result is written to vector (four signed 32-bit integer numbers).",
        "suggest": "vector `a` (四个带符号的 32 位整数) 中的元素按逻辑右移 vector `b` (四个带符号的 32 位整数) 中的元素的位数，以模数形式指定 bits.The 中最高有效舍弃位的元素大小被加到移位值上 (用于四舍五入)，并将结果写入 vector (四个带符号的 32 位整数)。",
        "translate": ""
    },
    {
        "source": "The elements in vector `a` (two signed 64-bit integer numbers) are shifted right logical by the number of bits the elements in vector `b` (two signed 64-bit integer numbers) specify modulo the size of the element in bits.The most significant discarded bit is added to the shifted value (for rounding) and the result is written to vector (two signed 64-bit integer numbers).",
        "suggest": "vector `a` (两个带符号的 64 位整数) 中的元素向右逻辑移位 vector `b` (两个带符号的 64 位整数) 中的元素的位数，以模数形式指定 bits.The 中最高有效舍弃位的元素大小被加到移位值上 (用于四舍五入)，并将结果写入 vector (两个带符号的 64 位整数)。",
        "translate": ""
    },
    {
        "source": "Immediate Shift Right Logical Rounded",
        "suggest": "Immediate 右移逻辑舍入",
        "translate": ""
    },
    {
        "source": "The elements in vector `a` (sixteen signed 8-bit integer numbers) are shifted right logical by `imm6` bits.The most significant discarded bit is added to the shifted value (for rounding) and the result is written to vector (sixteen signed 8-bit integer numbers).",
        "suggest": "`a` 将 vector `a` (十六个带符号的 8 位整数) 中的元素右移逻辑 `imm6` bits.The 将最高有效舍弃位添加到移位值中 (用于舍入)，并将结果写入 vector (十六个带符号的 8 位整数中) )。",
        "translate": ""
    },
    {
        "source": "The elements in vector `a` (eight signed 16-bit integer numbers) are shifted right logical by `imm6` bits.The most significant discarded bit is added to the shifted value (for rounding) and the result is written to vector (eight signed 16-bit integer numbers).",
        "suggest": "`imm6` bits.The 将 vector `a` (八个带符号的 16 位整数) 中的元素右移逻辑，将最高有效舍弃位加到移位值 (用于舍入)，并将结果写入 vector (八个带符号的 16 位整数。)。",
        "translate": ""
    },
    {
        "source": "The elements in vector `a` (four signed 32-bit integer numbers) are shifted right logical by `imm6` bits.The most significant discarded bit is added to the shifted value (for rounding) and the result is written to vector (four signed 32-bit integer numbers).",
        "suggest": "vector `a` 中的元素 (四个带符号的 32 位整数) 通过 `imm6` bits.The 进行逻辑右移。最高有效舍弃位被添加到移位值中 (用于舍入)，结果被写入 vector (四个带符号的 32 位整数)。)。",
        "translate": ""
    },
    {
        "source": "The elements in vector `a` (two signed 64-bit integer numbers) are shifted right logical by `imm6` bits.The most significant discarded bit is added to the shifted value (for rounding) and the result is written to vector (two signed 64-bit integer numbers).",
        "suggest": "vector `a` (两个带符号的 64 位整数) 中的元素被逻辑右移 `imm6` bits.The 最高有效舍弃位被加到移位值 (用于舍入)，结果被写入 vector (两个带符号的 64 位整数。)。",
        "translate": ""
    },
    {
        "source": "Vector Store",
        "suggest": "Vector 商店",
        "translate": ""
    },
    {
        "source": "The WRLEN / 8 bytes in vector `a` (sixteen signed 8-bit integer numbers) are stored as elements of data format df at the effective memory location addressed by the base `mem_addr` and the 10-bit signed immediate offset `imm_s10`.",
        "suggest": "vector `a` 中的 WRLEN/8 字节 (十六个带符号的 8 位整数) 作为数据格式 df 的元素存储在基本 `mem_addr` 和 10 位带符号的 immediate 偏移量 `imm_s10` 寻址的有效存储位置。",
        "translate": ""
    },
    {
        "source": "The WRLEN / 8 bytes in vector `a` (eight signed 16-bit integer numbers) are stored as elements of data format df at the effective memory location addressed by the base `mem_addr` and the 11-bit signed immediate offset `imm_s11`.",
        "suggest": "vector `a` 中的 WRLEN/8 字节 (八个带符号的 16 位整数) 作为数据格式 df 的元素存储在基本 `mem_addr` 和 11 位带符号 immediate 偏移量 `imm_s11` 寻址的有效存储位置。",
        "translate": ""
    },
    {
        "source": "The WRLEN / 8 bytes in vector `a` (four signed 32-bit integer numbers) are stored as elements of data format df at the effective memory location addressed by the base `mem_addr` and the 12-bit signed immediate offset `imm_s12`.",
        "suggest": "vector `a` 中的 WRLEN/8 字节 (四个带符号的 32 位整数) 作为数据格式 df 的元素存储在基本 `mem_addr` 和 12 位带符号 immediate 偏移量 `imm_s12` 寻址的有效存储位置。",
        "translate": ""
    },
    {
        "source": "The WRLEN / 8 bytes in vector `a` (two signed 64-bit integer numbers) are stored as elements of data format df at the effective memory location addressed by the base `mem_addr` and the 13-bit signed immediate offset `imm_s13`.",
        "suggest": "vector `a` 中的 WRLEN/8 字节 (两个带符号的 64 位整数) 作为数据格式 df 的元素存储在基本 `mem_addr` 和 13 位带符号 immediate 偏移量 `imm_s13` 寻址的有效存储位置。",
        "translate": ""
    },
    {
        "source": "Vector Signed Saturated Subtract of Signed Values",
        "suggest": "Vector 有符号值的饱和减法",
        "translate": ""
    },
    {
        "source": "The elements in vector `b` (sixteen signed 8-bit integer numbers) are subtracted from the elements in vector `a` (sixteen signed 8-bit integer numbers).",
        "suggest": "从 vector `a` (十六个带符号的 8 位整数) 中减去 vector `b` 中的元素 (十六个带符号的 8 位整数)。",
        "translate": ""
    },
    {
        "source": "The elements in vector `b` (eight signed 16-bit integer numbers) are subtracted from the elements in vector `a` (eight signed 16-bit integer numbers).",
        "suggest": "从 vector `a` (八个带符号的 16 位整数) 中减去 vector `b` (八个带符号的 16 位整数) 中的元素。",
        "translate": ""
    },
    {
        "source": "The elements in vector `b` (four signed 32-bit integer numbers) are subtracted from the elements in vector `a` (four signed 32-bit integer numbers).",
        "suggest": "从 vector `a` (四个带符号的 32 位整数) 中减去 vector `b` (四个带符号的 32 位整数) 中的元素。",
        "translate": ""
    },
    {
        "source": "The elements in vector `b` (two signed 64-bit integer numbers) are subtracted from the elements in vector `a` (two signed 64-bit integer numbers).",
        "suggest": "从 vector `a` (两个带符号的 64 位整数) 中的元素减去 vector `b` (两个带符号的 64 位整数) 中的元素。",
        "translate": ""
    },
    {
        "source": "Vector Unsigned Saturated Subtract of Unsigned Values",
        "suggest": "Vector 无符号值的无符号饱和减",
        "translate": ""
    },
    {
        "source": "The elements in vector `b` (sixteen unsigned 8-bit integer numbers) are subtracted from the elements in vector `a` (sixteen unsigned 8-bit integer numbers).",
        "suggest": "从 vector `a` 中的元素 (十六个无符号的 8 位整数) 中减去 vector `b` 中的元素 (十六个无符号 8 位整数)。",
        "translate": ""
    },
    {
        "source": "Unsigned arithmetic is performed and under-flows clamp to 0 before writing the result to vector (sixteen unsigned 8-bit integer numbers).",
        "suggest": "在将结果写入 vector (十六个无符号的 8 位整数) 之前，将执行无符号算术并将下溢钳位为 0。",
        "translate": ""
    },
    {
        "source": "The elements in vector `b` (eight unsigned 16-bit integer numbers) are subtracted from the elements in vector `a` (eight unsigned 16-bit integer numbers).",
        "suggest": "从 vector `a` (八个无符号 16 位整数) 中减去 vector `b` 中的元素 (八个无符号 16 位整数)。",
        "translate": ""
    },
    {
        "source": "Unsigned arithmetic is performed and under-flows clamp to 0 before writing the result to vector (eight unsigned 16-bit integer numbers).",
        "suggest": "在将结果写入 vector (八个无符号的 16 位整数) 之前，将执行无符号算术并将下溢钳位为 0。",
        "translate": ""
    },
    {
        "source": "The elements in vector `b` (four unsigned 32-bit integer numbers) are subtracted from the elements in vector `a` (four unsigned 32-bit integer numbers).",
        "suggest": "从 vector `a` (四个无符号 32 位整数) 中减去 vector `b` 中的元素 (四个无符号 32 位整数)。",
        "translate": ""
    },
    {
        "source": "Unsigned arithmetic is performed and under-flows clamp to 0 before writing the result to vector (four unsigned 32-bit integer numbers).",
        "suggest": "在将结果写入 vector (四个无符号的 32 位整数) 之前，将执行无符号算术并将下溢钳位为 0。",
        "translate": ""
    },
    {
        "source": "The elements in vector `b` (two unsigned 64-bit integer numbers) are subtracted from the elements in vector `a` (two unsigned 64-bit integer numbers).",
        "suggest": "从 vector `a` (两个无符号 64 位整数) 中减去 vector `b` (两个无符号 64 位整数) 中的元素。",
        "translate": ""
    },
    {
        "source": "Unsigned arithmetic is performed and under-flows clamp to 0 before writing the result to vector (two unsigned 64-bit integer numbers).",
        "suggest": "在将结果写入 vector (两个无符号的 64 位整数) 之前，将执行无符号算术并将下溢钳位为 0。",
        "translate": ""
    },
    {
        "source": "Vector Unsigned Saturated Subtract of Signed from Unsigned",
        "suggest": "Vector 无符号的无符号饱和减法",
        "translate": ""
    },
    {
        "source": "The signed elements in vector `b` (sixteen signed 8-bit integer numbers) are subtracted from the unsigned elements in vector `a` (sixteen unsigned 8-bit integer numbers).",
        "suggest": "vector `b` (十六个带符号的 8 位整数) 中的有符号元素被从 vector `a` (十六个无符号的 8 位整数中) 的无符号元素中减去。",
        "translate": ""
    },
    {
        "source": "The signed result is unsigned saturated and written to to vector (sixteen unsigned 8-bit integer numbers).",
        "suggest": "带符号的结果被无符号饱和，并写入 vector (十六个无符号的 8 位整数)。",
        "translate": ""
    },
    {
        "source": "The signed elements in vector `b` (eight signed 16-bit integer numbers) are subtracted from the unsigned elements in vector `a` (eight unsigned 16-bit integer numbers).",
        "suggest": "vector `b` (八个带符号的 16 位整数) 中的有符号元素被从 vector `a` (八个无符号的 16 位整数) 中的无符号元素中减去。",
        "translate": ""
    },
    {
        "source": "The signed result is unsigned saturated and written to to vector (eight unsigned 16-bit integer numbers).",
        "suggest": "带符号的结果被无符号饱和，并写入 vector (八个无符号的 16 位整数)。",
        "translate": ""
    },
    {
        "source": "The signed elements in vector `b` (four signed 6432it integer numbers) are subtracted from the unsigned elements in vector `a` (four unsigned 32-bit integer numbers).",
        "suggest": "从 vector `a` 中的无符号元素 (四个无符号 32 位整数) 中减去 vector `b` 中的有符号元素 (四个有符号 6432it 整数)。",
        "translate": ""
    },
    {
        "source": "The signed result is unsigned saturated and written to to vector (four unsigned 32-bit integer numbers).",
        "suggest": "带符号的结果被无符号饱和，并写入 vector (四个无符号的 32 位整数)。",
        "translate": ""
    },
    {
        "source": "The signed elements in vector `b` (two signed 64-bit integer numbers) are subtracted from the unsigned elements in vector `a` (two unsigned 64-bit integer numbers).",
        "suggest": "从 vector `a` (两个无符号 64 位整数) 中的未有符号元素中减去 vector `b` (两个有符号 64 位整数) 中的有符号元素。",
        "translate": ""
    },
    {
        "source": "The signed result is unsigned saturated and written to to vector (two unsigned 64-bit integer numbers).",
        "suggest": "带符号的结果被无符号饱和，并写入 vector (两个无符号的 64 位整数)。",
        "translate": ""
    },
    {
        "source": "Vector Signed Saturated Subtract of Unsigned Values",
        "suggest": "Vector 有符号饱和值的有符号减法",
        "translate": ""
    },
    {
        "source": "The unsigned elements in vector `b` (sixteen unsigned 8-bit integer numbers) are subtracted from the unsigned elements in vector `a` (sixteen unsigned 8-bit integer numbers).",
        "suggest": "从 vector `a` (十六个无符号 8 位整数) 中减去 vector `b` 中的无符号元素 (十六个无符号 8 位整数)。",
        "translate": ""
    },
    {
        "source": "The signed result is signed saturated and written to to vector (sixteen unsigned 8-bit integer numbers).",
        "suggest": "带符号的结果被饱和并写入 vector (十六个无符号的 8 位整数)。",
        "translate": ""
    },
    {
        "source": "The unsigned elements in vector `b` (eight unsigned 16-bit integer numbers) are subtracted from the unsigned elements in vector `a` (eight unsigned 16-bit integer numbers).",
        "suggest": "vector `b` 中的无符号元素 (八个无符号 16 位整数) 从 vector `a` 中的无符号元素 (八个无符号 16 位整数) 中减去。",
        "translate": ""
    },
    {
        "source": "The signed result is signed saturated and written to to vector (eight unsigned 16-bit integer numbers).",
        "suggest": "将带符号的结果进行饱和并写入 vector (八个无符号的 16 位整数)。",
        "translate": ""
    },
    {
        "source": "The unsigned elements in vector `b` (four unsigned 32-bit integer numbers) are subtracted from the unsigned elements in vector `a` (four unsigned 32-bit integer numbers).",
        "suggest": "vector `b` 中的无符号元素 (四个无符号 32 位整数) 从 vector `a` 中的无符号元素 (四个无符号 32 位整数) 中减去。",
        "translate": ""
    },
    {
        "source": "The signed result is signed saturated and written to to vector (four unsigned 32-bit integer numbers).",
        "suggest": "带符号的结果被饱和并写入 vector (四个无符号的 32 位整数)。",
        "translate": ""
    },
    {
        "source": "The unsigned elements in vector `b` (two unsigned 64-bit integer numbers) are subtracted from the unsigned elements in vector `a` (two unsigned 64-bit integer numbers).",
        "suggest": "vector `b` 中的无符号元素 (两个无符号 64 位整数) 从 vector `a` 中的无符号元素 (两个无符号 64 位整数) 中减去。",
        "translate": ""
    },
    {
        "source": "The signed result is signed saturated and written to to vector (two unsigned 64-bit integer numbers).",
        "suggest": "带符号的结果被饱和并写入 vector (两个无符号的 64 位整数)。",
        "translate": ""
    },
    {
        "source": "Vector Subtract",
        "suggest": "Vector 减法",
        "translate": ""
    },
    {
        "source": "Immediate Subtract",
        "suggest": "Immediate 减法",
        "translate": ""
    },
    {
        "source": "The 5-bit immediate unsigned value `imm5` are subtracted from the elements in vector `a` (sixteen signed 8-bit integer numbers).",
        "suggest": "从 vector `a` 中的元素中减去 5 位 immediate 无符号值 `imm5` (16 个有符号 8 位整数)。",
        "translate": ""
    },
    {
        "source": "The 5-bit immediate unsigned value `imm5` are subtracted from the elements in vector `a` (eight signed 16-bit integer numbers).",
        "suggest": "从 vector `a` 中的元素中减去 5 位 immediate 无符号值 `imm5` (8 个有符号的 16 位整数)。",
        "translate": ""
    },
    {
        "source": "The 5-bit immediate unsigned value `imm5` are subtracted from the elements in vector `a` (four signed 32-bit integer numbers).",
        "suggest": "从 vector `a` 中的元素中减去 5 位 immediate 无符号值 `imm5` (四个有符号的 32 位整数)。",
        "translate": ""
    },
    {
        "source": "The 5-bit immediate unsigned value `imm5` are subtracted from the elements in vector `a` (two signed 64-bit integer numbers).",
        "suggest": "从 vector `a` 中的元素中减去 5 位 immediate 无符号值 `imm5` (两个有符号的 64 位整数)。",
        "translate": ""
    },
    {
        "source": "Vector Data Preserving Shuffle",
        "suggest": "Vector 数据保持随机",
        "translate": ""
    },
    {
        "source": "The vector shuffle instructions selectively copy data elements from the concatenation of vectors `b` (sixteen signed 8-bit integer numbers) and `c` (sixteen signed 8-bit integer numbers) in to vector `a` (sixteen signed 8-bit integer numbers) based on the corresponding control element in `a`.",
        "suggest": "vector 重排指令基于 vectors `b` (十六个带符号的 8 位整数) 和 `c` (十六个带符号的 8 位整数) 的组合，将数据元素选择性地复制到 vector `a` (十六个带符号的 8 位整数) 中。`a` 中相应的控制元素。",
        "translate": ""
    },
    {
        "source": "The least significant 6 bits in `a` control elements modulo the number of elements in the concatenated vectors `b`, `a` specify the index of the source element.",
        "suggest": "`a` 控制元素中的最低有效 6 位以级联 vectors `b`，`a` 中元素的数量为模，指定源元素的索引。",
        "translate": ""
    },
    {
        "source": "If bit 6 or bit 7 is 1, there will be no copy, but rather the destination element is set to 0.",
        "suggest": "如果位 6 或位 7 为 1，将没有副本，而是将目标元素设置为 0。",
        "translate": ""
    },
    {
        "source": "The vector shuffle instructions selectively copy data elements from the concatenation of vectors `b` (eight signed 16-bit integer numbers) and `c` (eight signed 16-bit integer numbers) in to vector `a` (eight signed 16-bit integer numbers) based on the corresponding control element in `a`.",
        "suggest": "vector 重排指令根据 vectors `b` (八个带符号的 16 位整数) 和 `c` (八个带符号的 16 位整数) 的连接，有选择地将数据元素复制到 vector `a` (八个带符号的 16 位整数)。`a` 中相应的控制元素。",
        "translate": ""
    },
    {
        "source": "The vector shuffle instructions selectively copy data elements from the concatenation of vectors `b` (four signed 32-bit integer numbers) and `c` (four signed 32-bit integer numbers) in to vector `a` (four signed 32-bit integer numbers) based on the corresponding control element in `a`.",
        "suggest": "vector 重排指令基于 vectors `b` (四个带符号的 32 位整数) 和 `c` (四个带符号的 32 位整数) 的连接，有选择地将数据元素复制到 vector `a` (四个带符号的 32 位整数) 中。`a` 中相应的控制元素。",
        "translate": ""
    },
    {
        "source": "The vector shuffle instructions selectively copy data elements from the concatenation of vectors `b` (two signed 64-bit integer numbers) and `c` (two signed 64-bit integer numbers) in to vector `a` (two signed 64-bit integer numbers) based on the corresponding control element in `a`.",
        "suggest": "vector 重排指令根据 vectors `b` (两个带符号的 64 位整数) 和 `c` (两个带符号的 64 位整数) 的连接，有选择地将数据元素复制到 vector `a` (两个带符号的 64 位整数)。`a` 中相应的控制元素。",
        "translate": ""
    },
    {
        "source": "Vector Logical Exclusive Or",
        "suggest": "Vector 逻辑异或",
        "translate": ""
    },
    {
        "source": "Each bit of vector `a` (sixteen unsigned 8-bit integer numbers) is combined with the corresponding bit of vector `b` (sixteen unsigned 8-bit integer numbers) in a bitwise logical XOR operation.",
        "suggest": "vector `a` 的每个位 (十六个无符号的 8 位整数) 与 vector `b` 的对应位 (十六个无符号的 8 位整数) 在按位逻辑 XOR 运算中组合在一起。",
        "translate": ""
    },
    {
        "source": "Immediate Logical Exclusive Or",
        "suggest": "Immediate 逻辑异或",
        "translate": ""
    },
    {
        "source": "Each byte of vector `a` (sixteen unsigned 8-bit integer numbers) is combined with the 8-bit immediate `imm8` in a bitwise logical XOR operation.",
        "suggest": "vector `a` 的每个字节 (十六个无符号的 8 位整数) 与 8 位 immediate  `imm8` 进行按位逻辑 XOR 运算组合。",
        "translate": ""
    },
    {
        "source": "If target type is i64, negative immediate loses the sign Test passes if 4294967293 is used instead -3 in vector `a`",
        "suggest": "如果目标类型为 i64，则负 immediate 将丢失符号如果使用 4294967293 而不是 vector `a` 中的 -3，则测试通过",
        "translate": ""
    },
    {
        "source": "If target type is i64, negative immediate loses the sign",
        "suggest": "如果目标类型为 i64，则负 immediate 将丢失符号",
        "translate": ""
    },
    {
        "source": "is represented as 4294967293",
        "suggest": "表示为 4294967293",
        "translate": ""
    },
    {
        "source": "Only observed beahiour should be SIGFPE signal Can not be tested",
        "suggest": "仅观察到的信号应该是 SIGFPE 信号无法测试",
        "translate": ""
    },
    {
        "source": "If target type is i64, negative immediate loses the sign Test passes if 4294967185 is used instead -111 in vector `r`",
        "suggest": "如果目标类型为 i64，则负 immediate 将丢失符号如果使用 4294967185 而不是 vector `r` 中的 -111，则测试通过",
        "translate": ""
    },
    {
        "source": "If target type is i64, negative immediate loses the sign Test passes if 4294967293 is used instead -3 in vector `r`",
        "suggest": "如果目标类型为 i64，则负 immediate 将丢失符号如果使用 4294967293 而不是 vector `r` 中的 -3，则测试通过",
        "translate": ""
    },
    {
        "source": "Platform-specific intrinsics for the `x86` platform.",
        "suggest": "`x86` 平台的平台特定的内联函数。",
        "translate": ""
    },
    {
        "source": "See the [module documentation](../index.html) for more details.",
        "suggest": "有关更多详细信息，请参见 [module documentation](../index.html)。",
        "translate": ""
    },
    {
        "source": "Platform-specific intrinsics for the `x86_64` platform.",
        "suggest": "`x86_64` 平台的平台特定的内联函数。",
        "translate": ""
    },
    {
        "source": "Platform-specific intrinsics for the `arm` platform.",
        "suggest": "`arm` 平台的平台特定的内联函数。",
        "translate": ""
    },
    {
        "source": "Platform-specific intrinsics for the `aarch64` platform.",
        "suggest": "`aarch64` 平台的平台特定的内联函数。",
        "translate": ""
    },
    {
        "source": "Platform-specific intrinsics for the `wasm32` platform.",
        "suggest": "`wasm32` 平台的平台特定的内联函数。",
        "translate": ""
    },
    {
        "source": "This module provides intrinsics specific to the WebAssembly architecture.",
        "suggest": "该模块提供特定于 WebAssembly 体系结构的内联函数。",
        "translate": ""
    },
    {
        "source": "Here you'll find intrinsics necessary for leveraging WebAssembly proposals such as [atomics] and [simd].",
        "suggest": "在这里，您将发现利用 [atomics] 和 [simd] 等 WebAssembly 建议所必需的内联函数。",
        "translate": ""
    },
    {
        "source": "These proposals are evolving over time and as such the support here is unstable and requires the nightly channel.",
        "suggest": "这些建议随着时间的推移而发展，因此这里的支持是不稳定的，需要每晚进行一次通道。",
        "translate": ""
    },
    {
        "source": "As WebAssembly proposals stabilize these functions will also become stable.",
        "suggest": "随着 WebAssembly 提案的稳定，这些函数也将变得稳定。",
        "translate": ""
    },
    {
        "source": "See the [module documentation](../index.html) for general information about the `arch` module and platform intrinsics.",
        "suggest": "有关 `arch` 模块和平台内联函数的一般信息，请参见 [module documentation](../index.html)。",
        "translate": ""
    },
    {
        "source": "The [threads proposal][atomics] for WebAssembly adds a number of instructions for dealing with multithreaded programs.",
        "suggest": "[线程提案][atomics] for WebAssembly 添加了许多有关处理多线程程序的指令。",
        "translate": ""
    },
    {
        "source": "Atomic instructions can all be generated through `std::sync::atomic` types, but some instructions have no equivalent in Rust such as `memory.atomic.notify` so this module will provide these intrinsics.",
        "suggest": "原子指令都可以通过 `std::sync::atomic` 类型生成，但是某些指令在 Rust 中没有等效项，例如 `memory.atomic.notify`，因此该模块将提供这些内联函数。",
        "translate": ""
    },
    {
        "source": "At this time, however, these intrinsics are only available **when the standard library itself is compiled with atomics**.",
        "suggest": "但是，此时，这些内联函数仅在 **标准库本身使用原子编译时才可用**。",
        "translate": ""
    },
    {
        "source": "Compiling with atomics is not enabled by default and requires passing `-Ctarget-feature=+atomics` to rustc.",
        "suggest": "默认情况下，不启用原子编译，并且需要将 `-Ctarget-feature=+atomics` 传递给 rustc。",
        "translate": ""
    },
    {
        "source": "The standard library shipped via `rustup` is not compiled with atomics.",
        "suggest": "`rustup` 随附的标准库未使用原子编译。",
        "translate": ""
    },
    {
        "source": "To get access to these intrinsics you'll need to compile the standard library from source with the requisite compiler flags.",
        "suggest": "要访问这些内联函数，您需要使用必需的编译器标志从源代码编译标准库。",
        "translate": ""
    },
    {
        "source": "The [simd proposal][simd] for WebAssembly adds a new `v128` type for a",
        "suggest": "用于 WebAssembly 的 [SIMD 提案][simd] 为",
        "translate": ""
    },
    {
        "source": "128-bit SIMD register.",
        "suggest": "128 位 SIMD 寄存器。",
        "translate": ""
    },
    {
        "source": "It also adds a large array of instructions to operate on the `v128` type to perform data processing.",
        "suggest": "它还添加了大量指令，以对 `v128` 类型进行操作以执行数据处理。",
        "translate": ""
    },
    {
        "source": "The SIMD proposal has been in progress for quite some time and many instructions have come and gone.",
        "suggest": "SIMD 提案已经进行了相当长的时间，许多说明也来了又去了。",
        "translate": ""
    },
    {
        "source": "This module attempts to keep up with the proposal, but if you notice anything awry please feel free to [open an issue](https://github.com/rust-lang/stdarch/issues/new).",
        "suggest": "该模块试图跟上建议，但是如果您发现任何问题，请随时打开 [issue](https://github.com/rust-lang/stdarch/issues/new)。",
        "translate": ""
    },
    {
        "source": "It's important to be aware that the current state of development of SIMD in WebAssembly is still somewhat early days.",
        "suggest": "重要的是要意识到，WebAssembly 中 SIMD 的当前开发状态还处于初期。",
        "translate": ""
    },
    {
        "source": "There's lots of pieces to demo and prototype with, but discussions and support are still in progress.",
        "suggest": "有很多部分可以演示和制作原型，但是讨论和支持仍在进行中。",
        "translate": ""
    },
    {
        "source": "There's a number of pitfalls and gotchas in various places, which will attempt to be documented here, but there may be others lurking!",
        "suggest": "在不同的地方有许多缺陷和陷阱，将在此处进行记录，但可能还有其他隐患!",
        "translate": ""
    },
    {
        "source": "Using SIMD is intended to be similar to as you would on `x86_64`, for example.",
        "suggest": "例如，使用 SIMD 的目的与在 `x86_64` 上的目的类似。",
        "translate": ""
    },
    {
        "source": "You'd write a function such as:",
        "suggest": "您将编写一个函数，例如:",
        "translate": ""
    },
    {
        "source": "Unlike `x86_64`, however, WebAssembly does not currently have dynamic detection at runtime as to whether SIMD is supported (this is one of the motivators for the [conditional sections proposal][condsections], but that is still pretty early days).",
        "suggest": "但是，与 `x86_64` 不同，WebAssembly 当前在运行时无法动态检测是否支持 SIMD (这是 [有条件的部分提案][condsections] 的动机之一，但这还处于初期阶段)。",
        "translate": ""
    },
    {
        "source": "This means that your binary will either have SIMD and can only run on engines which support SIMD, or it will not have SIMD at all.",
        "suggest": "这意味着您的二进制文件将具有 SIMD，并且只能在支持 SIMD 的引擎上运行，或者根本不具有 SIMD。",
        "translate": ""
    },
    {
        "source": "For compatibility the standard library itself does not use any SIMD internally.",
        "suggest": "为了兼容，标准库本身内部未使用任何 SIMD。",
        "translate": ""
    },
    {
        "source": "Determining how best to ship your WebAssembly binary with SIMD is largely left up to you as it can can be pretty nuanced depending on your situation.",
        "suggest": "确定如何最好地将 WebAssembly 二进制文件与 SIMD 一起交付，很大程度上取决于您的情况，具体取决于您的情况。",
        "translate": ""
    },
    {
        "source": "To enable SIMD support at compile time you need to do one of two things:",
        "suggest": "要在编译时启用 SIMD 支持，您需要执行以下两项操作之一:",
        "translate": ""
    },
    {
        "source": "First you can annotate functions with `#[target_feature(enable = \"simd128\")]`.",
        "suggest": "首先，您可以使用 `#[target_feature(enable = \"simd128\")]` 注解函数。",
        "translate": ""
    },
    {
        "source": "This causes just that one function to have SIMD support available to it, and intrinsics will get inlined as usual in this situation.",
        "suggest": "这将导致仅一个函数可以使用 SIMD 支持，并且在这种情况下，内联函数将像往常一样被内联。",
        "translate": ""
    },
    {
        "source": "Second you can compile your program with `-Ctarget-feature=+simd128`.",
        "suggest": "其次，您可以使用 `-Ctarget-feature=+simd128` 编译程序。",
        "translate": ""
    },
    {
        "source": "This compilation flag blanket enables SIMD support for your entire compilation.",
        "suggest": "该编译标志毯可为您的整个编译提供 SIMD 支持。",
        "translate": ""
    },
    {
        "source": "Note that this does not include the standard library unless you recompile the standard library.",
        "suggest": "请注意，除非您重新编译标准库，否则这不包括标准库。",
        "translate": ""
    },
    {
        "source": "If you enable SIMD via either of these routes then you'll have a WebAssembly binary that uses SIMD instructions, and you'll need to ship that accordingly.",
        "suggest": "如果通过这两种途径之一启用 SIMD，那么您将拥有一个使用 SIMD 指令的 WebAssembly 二进制文件，并且需要相应地进行运送。",
        "translate": ""
    },
    {
        "source": "Also note that if you call SIMD intrinsics but don't enable SIMD via either of these mechanisms, you'll still have SIMD generated in your program.",
        "suggest": "还要注意，如果您调用 SIMD 内联函数但未通过这两种机制之一启用 SIMD，则程序中仍将生成 SIMD。",
        "translate": ""
    },
    {
        "source": "This means to generate a binary without SIMD you'll need to avoid both options above plus calling into any intrinsics in this module.",
        "suggest": "这意味着要生成没有 SIMD 的二进制文件，您将需要避免上述两个选项以及调用此模块中的任何内联函数。",
        "translate": ""
    },
    {
        "source": "Due to",
        "suggest": "由于",
        "translate": ""
    },
    {
        "source": "it's recommended to compile your entire program with SIMD support",
        "suggest": "建议在 SIMD 支持下编译整个程序",
        "translate": ""
    },
    {
        "source": "(using `RUSTFLAGS`) or otherwise functions may not be inlined",
        "suggest": "(使用 `RUSTFLAGS`)，否则可能无法内联函数",
        "translate": ""
    },
    {
        "source": "LLVM's SIMD support is actually split into two features:",
        "suggest": "LLVM 的 SIMD 支持实际上分为两个功能:",
        "translate": ""
    },
    {
        "source": "and `unimplemented-simd128`.",
        "suggest": "和 `unimplemented-simd128`。",
        "translate": ""
    },
    {
        "source": "Rust code can enable `simd128`",
        "suggest": "Rust 代码可以启用 `simd128`",
        "translate": ""
    },
    {
        "source": "with `#[target_feature]` (and test for it with `#[cfg(target_feature =",
        "suggest": "使用 `#[target_feature]` (并使用 `#[cfg (target_feature=",
        "translate": ""
    },
    {
        "source": "\"simd128\")]`, but it cannot enable `unimplemented-simd128`. The only",
        "suggest": "`simd128`) ]`，但无法启用 `unimplemented-simd128`。只有",
        "translate": ""
    },
    {
        "source": "way to enable this feature is to compile with",
        "suggest": "启用此功能的方法是使用",
        "translate": ""
    },
    {
        "source": "This second",
        "suggest": "第二个",
        "translate": ""
    },
    {
        "source": "feature enables more recent instructions implemented in LLVM which",
        "suggest": "该功能启用了在 LLVM 中实现的最新指令",
        "translate": ""
    },
    {
        "source": "haven't always had enough time to make their way to runtimes.",
        "suggest": "并非总是有足够的时间进入运行时。",
        "translate": ""
    },
    {
        "source": "Platform-specific intrinsics for the `mips` platform.",
        "suggest": "`mips` 平台的平台特定的内联函数。",
        "translate": ""
    },
    {
        "source": "Platform-specific intrinsics for the `mips64` platform.",
        "suggest": "`mips64` 平台的平台特定的内联函数。",
        "translate": ""
    },
    {
        "source": "Platform-specific intrinsics for the `PowerPC` platform.",
        "suggest": "`PowerPC` 平台的平台特定的内联函数。",
        "translate": ""
    },
    {
        "source": "Platform-specific intrinsics for the `PowerPC64` platform.",
        "suggest": "`PowerPC64` 平台的平台特定的内联函数。",
        "translate": ""
    },
    {
        "source": "Platform-specific intrinsics for the `NVPTX` platform.",
        "suggest": "`NVPTX` 平台的平台特定的内联函数。",
        "translate": ""
    },
    {
        "source": "NVPTX intrinsics (experimental)",
        "suggest": "NVPTX 内联函数 (experimental)",
        "translate": ""
    },
    {
        "source": "These intrinsics form the foundation of the CUDA programming model.",
        "suggest": "这些内联函数构成了 CUDA 编程模型的基础。",
        "translate": ""
    },
    {
        "source": "The reference is the [CUDA C Programming Guide][cuda_c].",
        "suggest": "引用的是 [CUDA C Programming Guide][cuda_c]。",
        "translate": ""
    },
    {
        "source": "Relevant is also the [LLVM NVPTX Backend documentation][llvm_docs].",
        "suggest": "也与 [LLVM NVPTX 后端文档][llvm_docs] 有关。",
        "translate": ""
    },
    {
        "source": "Synchronizes all threads in the block.",
        "suggest": "同步块中的所有线程。",
        "translate": ""
    },
    {
        "source": "x-th thread-block dimension.",
        "suggest": "第 x 个线程块维度。",
        "translate": ""
    },
    {
        "source": "y-th thread-block dimension.",
        "suggest": "第 y 个线程块的维度。",
        "translate": ""
    },
    {
        "source": "z-th thread-block dimension.",
        "suggest": "第 z 个线程块的维度。",
        "translate": ""
    },
    {
        "source": "x-th thread-block index.",
        "suggest": "第 x 个线程块索引。",
        "translate": ""
    },
    {
        "source": "y-th thread-block index.",
        "suggest": "第 y 个线程块索引。",
        "translate": ""
    },
    {
        "source": "z-th thread-block index.",
        "suggest": "第 z 个线程块索引。",
        "translate": ""
    },
    {
        "source": "x-th block-grid dimension.",
        "suggest": "第 x 个块网格尺寸。",
        "translate": ""
    },
    {
        "source": "y-th block-grid dimension.",
        "suggest": "第 y 个块网格尺寸。",
        "translate": ""
    },
    {
        "source": "z-th block-grid dimension.",
        "suggest": "第 z 个块网格尺寸。",
        "translate": ""
    },
    {
        "source": "x-th thread index.",
        "suggest": "第 x 个线程索引。",
        "translate": ""
    },
    {
        "source": "y-th thread index.",
        "suggest": "第 y 个线程索引。",
        "translate": ""
    },
    {
        "source": "z-th thread index.",
        "suggest": "第 z 个线程索引。",
        "translate": ""
    },
    {
        "source": "Generates the trap instruction `TRAP`",
        "suggest": "生成陷阱指令 `TRAP`",
        "translate": ""
    },
    {
        "source": "Basic CUDA syscall declarations.",
        "suggest": "基本的 CUDA syscall 声明。",
        "translate": ""
    },
    {
        "source": "Print formatted output from a kernel to a host-side output stream.",
        "suggest": "将格式化的输出从内核打印到主机端输出流。",
        "translate": ""
    },
    {
        "source": "Syscall arguments:",
        "suggest": "Syscall 参数:",
        "translate": ""
    },
    {
        "source": "The status value that is returned by `vprintf`.",
        "suggest": "`vprintf` 返回的状态值。",
        "translate": ""
    },
    {
        "source": "A pointer to the format specifier input (uses common `printf` format).",
        "suggest": "指向格式说明符输入的指针 (使用通用 `printf` 格式)。",
        "translate": ""
    },
    {
        "source": "A pointer to the valist input.",
        "suggest": "指向 valist 输入的指针。",
        "translate": ""
    },
    {
        "source": "Sources: [Programming Guide](https://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html#formatted-output),",
        "suggest": "资料来源: [编程指南](https://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html#formatted-output)，",
        "translate": ""
    },
    {
        "source": "Allocate memory dynamically from a fixed-size heap in global memory.",
        "suggest": "从固定大小的堆中动态分配内存。",
        "translate": ""
    },
    {
        "source": "The CUDA in-kernel `malloc()` function allocates at least `size` bytes from the device heap and returns a pointer to the allocated memory or `NULL` if insufficient memory exists to fulfill the request.",
        "suggest": "CUDA 内核 `malloc()` 函数从设备堆中分配至少 `size` 字节，并返回指向分配的内存的指针; 如果内存不足，无法返回请求，则返回 `NULL`。",
        "translate": ""
    },
    {
        "source": "The returned pointer is guaranteed to be aligned to a 16-byte boundary.",
        "suggest": "返回的指针保证与 16 字节边界对齐。",
        "translate": ""
    },
    {
        "source": "The memory allocated by a given CUDA thread via `malloc()` remains allocated for the lifetime of the CUDA context, or until it is explicitly released by a call to `free()`.",
        "suggest": "给定 CUDA 线程通过 `malloc()` 分配的内存将保持分配给 CUDA 上下文的生命周期，或者直到被调用显式释放到 `free()` 为止。",
        "translate": ""
    },
    {
        "source": "It can be used by any other CUDA threads even from subsequent kernel launches.",
        "suggest": "它可以被其他任何 CUDA 线程使用，即使随后的内核启动也可以使用。",
        "translate": ""
    },
    {
        "source": "Sources: [Programming Guide](https://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html#dynamic-global-memory-allocation-and-operations),",
        "suggest": "资料来源: [编程指南](https://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html#dynamic-global-memory-allocation-and-operations)，",
        "translate": ""
    },
    {
        "source": "assign `malloc` and `nothrow` attributes.",
        "suggest": "分配 `malloc` 和 `nothrow` 属性。",
        "translate": ""
    },
    {
        "source": "Free previously dynamically allocated memory.",
        "suggest": "释放以前动态分配的内存。",
        "translate": ""
    },
    {
        "source": "The CUDA in-kernel `free()` function deallocates the memory pointed to by `ptr`, which must have been returned by a previous call to `malloc()`.",
        "suggest": "CUDA 内核 `free()` 函数将 `ptr` 指向的内存释放，该内存必须由先前的调用返回给 `malloc()`。",
        "translate": ""
    },
    {
        "source": "If `ptr` is NULL, the call to `free()` is ignored.",
        "suggest": "如果 `ptr` 为 NULL，则忽略对 `free()` 的调用。",
        "translate": ""
    },
    {
        "source": "Any CUDA thread may free memory allocated by another thread, but care should be taken to ensure that the same pointer is not freed more than once.",
        "suggest": "任何 CUDA 线程都可以释放另一个线程分配的内存，但应注意确保同一指针不会被释放超过一次。",
        "translate": ""
    },
    {
        "source": "Repeated calls to `free()` with the same `ptr` has undefined behavior.",
        "suggest": "使用相同的 `ptr` 重复调用 `free()` 具有未定义的行为。",
        "translate": ""
    },
    {
        "source": "assign `nothrow` attribute.",
        "suggest": "分配 `nothrow` 属性。",
        "translate": ""
    },
    {
        "source": "Internal declaration of the syscall.",
        "suggest": "syscall 的内部声明。",
        "translate": ""
    },
    {
        "source": "Exported variant has the `char_size` parameter set to `1` (single char size in bytes).",
        "suggest": "导出的成员的 `char_size` 参数设置为 `1` (单个字符大小，以字节为单位)。",
        "translate": ""
    },
    {
        "source": "Syscall to be used whenever the *assert expression produces a `false` value*.",
        "suggest": "*assert expression 产生 `false` 值* 时将使用 Syscall。",
        "translate": ""
    },
    {
        "source": "The pointer to the string that should be output.",
        "suggest": "指向应该输出的字符串的指针。",
        "translate": ""
    },
    {
        "source": "The pointer to the file name string associated with the assert.",
        "suggest": "指向与断言关联的文件名字符串的指针。",
        "translate": ""
    },
    {
        "source": "The line number associated with the assert.",
        "suggest": "与断言关联的行号。",
        "translate": ""
    },
    {
        "source": "The pointer to the function name string associated with the assert.",
        "suggest": "指向与断言关联的函数名称字符串的指针。",
        "translate": ""
    },
    {
        "source": "AltiVec intrinsics.",
        "suggest": "AltiVec 内联函数。",
        "translate": ""
    },
    {
        "source": "AltiVec is a brandname trademarked by Freescale (previously Motorola) for the standard `Category:Vector` part of the Power ISA v.2.03 specification.",
        "suggest": "AltiVec 是飞思卡尔 (以前是摩托罗拉) 的商标，用于 Power ISA v.2.03 规范的标准 `Category:Vector` 部分。",
        "translate": ""
    },
    {
        "source": "This Category is also known as VMX (used by IBM), and \"Velocity Engine\" (a brand name previously used by Apple).",
        "suggest": "此类别也称为 VMX (由 IBM 使用) 和 \"Velocity Engine\" (先前由 Apple 使用的品牌名称)。",
        "translate": ""
    },
    {
        "source": "The references are: [POWER ISA v2.07B (for POWER8 & POWER8 with NVIDIA NVlink)] and [POWER ISA v3.0B (for POWER9)].",
        "suggest": "引用的是: [POWER ISA v2.07B (for POWER8 & POWER8 with NVIDIA NVlink)] 和 [POWER ISA v3.0B (for POWER9)]。",
        "translate": ""
    },
    {
        "source": "PowerPC-specific 128-bit wide vector of sixteen packed `i8`",
        "suggest": "PowerPC 专用的十六个包装 `i8` 的 128 位宽 vector",
        "translate": ""
    },
    {
        "source": "PowerPC-specific 128-bit wide vector of sixteen packed `u8`",
        "suggest": "PowerPC 专用的十六个包装 `u8` 的 128 位宽 vector",
        "translate": ""
    },
    {
        "source": "PowerPC-specific 128-bit wide vector mask of sixteen packed elements",
        "suggest": "PowerPC 专用的 16 个包装元素的 128 位宽 vector 掩码",
        "translate": ""
    },
    {
        "source": "PowerPC-specific 128-bit wide vector of eight packed `i16`",
        "suggest": "八个包装的 `i16` 的 PowerPC 特定的 128 位宽 vector",
        "translate": ""
    },
    {
        "source": "PowerPC-specific 128-bit wide vector of eight packed `u16`",
        "suggest": "八个包装的 `u16` 的 PowerPC 特定的 128 位宽 vector",
        "translate": ""
    },
    {
        "source": "PowerPC-specific 128-bit wide vector mask of eight packed elements",
        "suggest": "PowerPC 专用的八个包装元素的 128 位宽 vector 掩码",
        "translate": ""
    },
    {
        "source": "pub struct vector_pixel(???);",
        "suggest": "pub 结构体 vector_pixel(???);",
        "translate": ""
    },
    {
        "source": "PowerPC-specific 128-bit wide vector of four packed `i32`",
        "suggest": "PowerPC 特定的 128 位宽的 vector，四个包装的 `i32`",
        "translate": ""
    },
    {
        "source": "PowerPC-specific 128-bit wide vector of four packed `u32`",
        "suggest": "PowerPC 特定的 128 位宽的 vector，四个包装的 `u32`",
        "translate": ""
    },
    {
        "source": "PowerPC-specific 128-bit wide vector mask of four packed elements",
        "suggest": "PowerPC 专用的四个包装元素的 128 位宽 vector 掩码",
        "translate": ""
    },
    {
        "source": "PowerPC-specific 128-bit wide vector of four packed `f32`",
        "suggest": "PowerPC 特定的 128 位宽的 vector，四个包装的 `f32`",
        "translate": ""
    },
    {
        "source": "Vector ld.",
        "suggest": "Vector ld。",
        "translate": ""
    },
    {
        "source": "Vector floor.",
        "suggest": "Vector floor。",
        "translate": ""
    },
    {
        "source": "Vector expte.",
        "suggest": "Vector expte。",
        "translate": ""
    },
    {
        "source": "Vector cmplt.",
        "suggest": "Vector cmplt。",
        "translate": ""
    },
    {
        "source": "Vector cmple.",
        "suggest": "Vector cmple。",
        "translate": ""
    },
    {
        "source": "Vector cmpgt.",
        "suggest": "Vector cmpgt。",
        "translate": ""
    },
    {
        "source": "Vector cmpge.",
        "suggest": "Vector cmpge。",
        "translate": ""
    },
    {
        "source": "Vector cmpeq.",
        "suggest": "Vector cmpeq。",
        "translate": ""
    },
    {
        "source": "Vector cmpb.",
        "suggest": "Vector cmpb。",
        "translate": ""
    },
    {
        "source": "Vector avg.",
        "suggest": "Vector avg。",
        "translate": ""
    },
    {
        "source": "Vector andc.",
        "suggest": "Vector andc。",
        "translate": ""
    },
    {
        "source": "Vector and.",
        "suggest": "Vector and。",
        "translate": ""
    },
    {
        "source": "Vector adds.",
        "suggest": "Vector adds。",
        "translate": ""
    },
    {
        "source": "Vector addc.",
        "suggest": "Vector addc。",
        "translate": ""
    },
    {
        "source": "Vector abs.",
        "suggest": "Vector abs。",
        "translate": ""
    },
    {
        "source": "Vector abss.",
        "suggest": "Vector abss。",
        "translate": ""
    },
    {
        "source": "Vector splats.",
        "suggest": "Vector splats。",
        "translate": ""
    },
    {
        "source": "Vector sub.",
        "suggest": "Vector sub。",
        "translate": ""
    },
    {
        "source": "Vector subs.",
        "suggest": "Vector subs。",
        "translate": ""
    },
    {
        "source": "Vector min.",
        "suggest": "Vector min",
        "translate": ""
    },
    {
        "source": "Vector max.",
        "suggest": "Vector max。",
        "translate": ""
    },
    {
        "source": "Endian-biased intrinsics",
        "suggest": "偏于尾数的内联函数",
        "translate": ""
    },
    {
        "source": "Vector permute.",
        "suggest": "Vector permute。",
        "translate": ""
    },
    {
        "source": "vperm has big-endian bias",
        "suggest": "vperm 有大端偏差",
        "translate": ""
    },
    {
        "source": "Xor the mask and flip the arguments",
        "suggest": "掩码 Xor 并翻转参数",
        "translate": ""
    },
    {
        "source": "Vector Sum Across Partial (1/2) Saturated",
        "suggest": "Vector 部分 (1/2) 的总和已饱和",
        "translate": ""
    },
    {
        "source": "vsum2sws has big-endian bias",
        "suggest": "vsum2sws 有大端偏差",
        "translate": ""
    },
    {
        "source": "swap the even b elements with the odd ones",
        "suggest": "将奇数 b 个元素交换为奇数个",
        "translate": ""
    },
    {
        "source": "Even and Odd are swapped in little-endian",
        "suggest": "偶数和奇数以小端顺序交换",
        "translate": ""
    },
    {
        "source": "Vector Multiply Even",
        "suggest": "Vector 乘以偶数",
        "translate": ""
    },
    {
        "source": "Vector Multiply Odd",
        "suggest": "Vector 乘以奇数",
        "translate": ""
    },
    {
        "source": "Vector Multiply Add Saturated",
        "suggest": "Vector 乘以饱和",
        "translate": ""
    },
    {
        "source": "Vector Multiply Low and Add Unsigned Half Word",
        "suggest": "Vector 乘以低并加无符号半字",
        "translate": ""
    },
    {
        "source": "Vector Multiply Round and Add Saturated",
        "suggest": "Vector 乘以四舍五入并添加饱和",
        "translate": ""
    },
    {
        "source": "Vector Multiply Sum",
        "suggest": "Vector 乘和",
        "translate": ""
    },
    {
        "source": "Vector Multiply Sum Saturated",
        "suggest": "Vector 乘和总和",
        "translate": ""
    },
    {
        "source": "Vector Multiply Add",
        "suggest": "Vector 相乘",
        "translate": ""
    },
    {
        "source": "Vector Negative Multiply Subtract",
        "suggest": "Vector 负相减",
        "translate": ""
    },
    {
        "source": "Vector Sum Across Partial (1/4) Saturated",
        "suggest": "Vector 部分 (1/4) 的总和已饱和",
        "translate": ""
    },
    {
        "source": "Vector Scalar eXtensions (VSX) intrinsics.",
        "suggest": "Vector 标量扩展 (VSX) 内联函数。",
        "translate": ""
    },
    {
        "source": "PowerPC-specific 128-bit wide vector of two packed `i64`",
        "suggest": "两个包装的 `i64` 的 PowerPC 特定的 128 位宽 vector",
        "translate": ""
    },
    {
        "source": "PowerPC-specific 128-bit wide vector of two packed `u64`",
        "suggest": "两个包装的 `u64` 的 PowerPC 特定的 128 位宽 vector",
        "translate": ""
    },
    {
        "source": "PowerPC-specific 128-bit wide vector mask of two elements",
        "suggest": "PowerPC 专用的两个元素的 128 位宽 vector 掩码",
        "translate": ""
    },
    {
        "source": "PowerPC-specific 128-bit wide vector of two packed `f64`",
        "suggest": "两个包装的 `f64` 的 PowerPC 特定的 128 位宽 vector",
        "translate": ""
    },
    {
        "source": "xxpermdi has an big-endian bias and extended mnemonics",
        "suggest": "xxpermdi 具有大尾数偏向和扩展的助记符",
        "translate": ""
    },
    {
        "source": "The reference is the [64-Bit ELF V2 ABI Specification - Power Architecture].",
        "suggest": "引用的是 [64-Bit ELF V2 ABI Specification - Power Architecture]。",
        "translate": ""
    },
    {
        "source": "Internal `#[repr(simd)]` types",
        "suggest": "内部 `#[repr(simd)]` 类型",
        "translate": ""
    },
    {
        "source": "Workaround rust@60637",
        "suggest": "解决方法 rust@60637",
        "translate": ""
    },
    {
        "source": "16-bit wide types:",
        "suggest": "16 位宽类型:",
        "translate": ""
    },
    {
        "source": "32-bit wide types:",
        "suggest": "32 位宽类型:",
        "translate": ""
    },
    {
        "source": "64-bit wide types:",
        "suggest": "64 位宽类型:",
        "translate": ""
    },
    {
        "source": "128-bit wide types:",
        "suggest": "128 位宽类型:",
        "translate": ""
    },
    {
        "source": "256-bit wide types:",
        "suggest": "256 位宽类型:",
        "translate": ""
    },
    {
        "source": "512-bit wide types:",
        "suggest": "512 位宽类型:",
        "translate": ""
    },
    {
        "source": "LLVM's SIMD platform intrinsics",
        "suggest": "LLVM 的 SIMD 平台内联函数",
        "translate": ""
    },
    {
        "source": "64-bit wide vector types",
        "suggest": "64 位宽 vector 类型",
        "translate": ""
    },
    {
        "source": "A 64-bit vector with 2 `f32` lanes.",
        "suggest": "具有 2 个 `f32` 通道的 64 位 vector。",
        "translate": ""
    },
    {
        "source": "A 64-bit vector with 2 `u32` lanes.",
        "suggest": "具有 2 个 `u32` 通道的 64 位 vector。",
        "translate": ""
    },
    {
        "source": "Intrinsics associated with WebAssembly's upcoming threads proposal.",
        "suggest": "与 WebAssembly 即将发布的线程建议相关的内部特性。",
        "translate": ""
    },
    {
        "source": "These intrinsics are all unstable because they're not actually stable in WebAssembly itself yet.",
        "suggest": "这些内联函数都是不稳定的，因为它们实际上在 WebAssembly 本身中还不稳定。",
        "translate": ""
    },
    {
        "source": "The signatures may change as [the specification][spec] is updated.",
        "suggest": "[规范][spec] 更新时，有符号可能会更改。",
        "translate": ""
    },
    {
        "source": "Corresponding intrinsic to wasm's [`memory.atomic.wait32` instruction][instr]",
        "suggest": "对应 wasm 的 [`memory.atomic.wait32` 指令][instr]",
        "translate": ""
    },
    {
        "source": "This function, when called, will block the current thread if the memory pointed to by `ptr` is equal to `expression` (performing this action atomically).",
        "suggest": "如果 `ptr` 指向的内存等于 `expression` (原子执行此操作)，则调用此函数时，它将阻塞当前线程。",
        "translate": ""
    },
    {
        "source": "The argument `timeout_ns` is a maxinum number of nanoseconds the calling thread will be blocked for, if it blocks.",
        "suggest": "参数 `timeout_ns` 是调用线程 (如果阻塞) 将被阻塞的最大纳秒数。",
        "translate": ""
    },
    {
        "source": "If the timeout is negative then the calling thread will be blocked forever.",
        "suggest": "如果超时为负，则调用线程将永远被阻塞。",
        "translate": ""
    },
    {
        "source": "The calling thread can only be woken up with a call to the `wake` intrinsic once it has been blocked.",
        "suggest": "一旦被阻塞，调用线程只能用 `wake` 内联函数的调用来唤醒。",
        "translate": ""
    },
    {
        "source": "Changing the memory behind `ptr` will not wake the thread once it's blocked.",
        "suggest": "一旦线程被阻塞，在 `ptr` 后面更改内存将不会唤醒线程。",
        "translate": ""
    },
    {
        "source": "0 - indicates that the thread blocked and then was woken up",
        "suggest": "0 - 表示线程被阻塞，然后被唤醒",
        "translate": ""
    },
    {
        "source": "1 - the loaded value from `ptr` didn't match `expression`, the thread didn't block",
        "suggest": "1-`ptr` 的加载值与 `expression` 不匹配，线程未阻塞",
        "translate": ""
    },
    {
        "source": "2 - the thread blocked, but the timeout expired.",
        "suggest": "2 - 线程被阻塞，但超时已过期。",
        "translate": ""
    },
    {
        "source": "This intrinsic is only available **when the standard library itself is compiled with the `atomics` target feature**.",
        "suggest": "仅在 使用 `atomics` 目标功能编译标准库本身时，此内联函数才可用。",
        "translate": ""
    },
    {
        "source": "This version of the standard library is not obtainable via `rustup`, but rather will require the standard library to be compiled from source.",
        "suggest": "无法通过 `rustup` 获得此版本的标准库，而是需要从源代码编译标准库。",
        "translate": ""
    },
    {
        "source": "Corresponding intrinsic to wasm's [`memory.atomic.wait64` instruction][instr]",
        "suggest": "对应 wasm 的 [`memory.atomic.wait64` 指令][instr]",
        "translate": ""
    },
    {
        "source": "Corresponding intrinsic to wasm's [`memory.atomic.notify` instruction][instr]",
        "suggest": "对应 wasm 的 [`memory.atomic.notify` 指令][instr]",
        "translate": ""
    },
    {
        "source": "This function will notify a number of threads blocked on the address indicated by `ptr`.",
        "suggest": "该函数将通知 `ptr` 指示的地址上阻塞的多个线程。",
        "translate": ""
    },
    {
        "source": "Threads previously blocked with the `i32_atomic_wait` and `i64_atomic_wait` functions above will be woken up.",
        "suggest": "先前被上述 `i32_atomic_wait` 和 `i64_atomic_wait` 函数阻塞的线程将被唤醒。",
        "translate": ""
    },
    {
        "source": "The `waiters` argument indicates how many waiters should be woken up (a maximum).",
        "suggest": "`waiters` 参数指示应唤醒的等待者数量 (最大值)。",
        "translate": ""
    },
    {
        "source": "If the value is zero no waiters are woken up.",
        "suggest": "如果值为零，则不会唤醒任何等待者。",
        "translate": ""
    },
    {
        "source": "Returns the number of waiters which were actually notified.",
        "suggest": "返回实际被通知的等待者的数量。",
        "translate": ""
    },
    {
        "source": "Corresponding intrinsic to wasm's [`memory.size` instruction][instr]",
        "suggest": "对应 wasm 的 [`memory.size` 指令][instr]",
        "translate": ""
    },
    {
        "source": "This function, when called, will return the current memory size in units of pages.",
        "suggest": "调用此函数时，它将以页为单位返回当前的内存大小。",
        "translate": ""
    },
    {
        "source": "The current WebAssembly page size is 65536 bytes (64 KB).",
        "suggest": "当前的 WebAssembly 页面大小为 65536 字节 (64 KB)。",
        "translate": ""
    },
    {
        "source": "The argument `mem` is the numerical index of which memory to return the size of.",
        "suggest": "参数 `mem` 是要返回其大小的内存的数字索引。",
        "translate": ""
    },
    {
        "source": "Note that currently the WebAssembly specification only supports one memory, so it is required that zero is passed in.",
        "suggest": "请注意，当前 WebAssembly 规范仅支持一个内存，因此要求传入零。",
        "translate": ""
    },
    {
        "source": "The argument is present to be forward-compatible with future WebAssembly revisions.",
        "suggest": "该参数与 future WebAssembly 修订版向前兼容。",
        "translate": ""
    },
    {
        "source": "If a nonzero argument is passed to this function it will currently unconditionally abort.",
        "suggest": "如果将非零参数传递给此函数，则它将当前无条件终止。",
        "translate": ""
    },
    {
        "source": "Corresponding intrinsic to wasm's [`memory.grow` instruction][instr]",
        "suggest": "对应 wasm 的 [`memory.grow` 指令][instr]",
        "translate": ""
    },
    {
        "source": "This function, when called, will attempt to grow the default linear memory by the specified `delta` of pages.",
        "suggest": "调用此函数时，它将尝试通过指定的 `delta` 页增长默认的线性内存。",
        "translate": ""
    },
    {
        "source": "The current WebAssembly page size is",
        "suggest": "当前的 WebAssembly 页面大小为",
        "translate": ""
    },
    {
        "source": "65536 bytes (64 KB).",
        "suggest": "65536 字节 (64 KB)。",
        "translate": ""
    },
    {
        "source": "If memory is successfully grown then the previous size of memory, in pages, is returned.",
        "suggest": "如果成功增加了内存，则将返回先前的内存大小 (以页为单位)。",
        "translate": ""
    },
    {
        "source": "If memory cannot be grown then `usize::MAX` is returned.",
        "suggest": "如果无法增加内存，则返回 `usize::MAX`。",
        "translate": ""
    },
    {
        "source": "Generates the trap instruction `UNREACHABLE`",
        "suggest": "生成陷阱指令 `UNREACHABLE`",
        "translate": ""
    },
    {
        "source": "This module implements the [WebAssembly `SIMD128` ISA].",
        "suggest": "该模块实现了 [WebAssembly `SIMD128` ISA]。",
        "translate": ""
    },
    {
        "source": "WASM-specific 128-bit wide SIMD vector type.",
        "suggest": "WASM 特定的 128 位宽 SIMD vector 类型。",
        "translate": ""
    },
    {
        "source": "N.B., internals here are arbitrary.",
        "suggest": "注意，这里的内部结构是任意的。",
        "translate": ""
    },
    {
        "source": "Loads a `v128` vector from the given heap address.",
        "suggest": "从给定的堆地址加载 `v128` vector。",
        "translate": ""
    },
    {
        "source": "Load eight 8-bit integers and sign extend each one to a 16-bit lane",
        "suggest": "加载 8 个 8 位整数，并将每个符号扩展到 16 位通道",
        "translate": ""
    },
    {
        "source": "Load eight 8-bit integers and zero extend each one to a 16-bit lane",
        "suggest": "加载 8 个 8 位整数，零加载每个整数至 16 位通道",
        "translate": ""
    },
    {
        "source": "Load four 16-bit integers and sign extend each one to a 32-bit lane",
        "suggest": "加载四个 16 位整数，并将每个符号扩展到 32 位通道",
        "translate": ""
    },
    {
        "source": "Load four 16-bit integers and zero extend each one to a 32-bit lane",
        "suggest": "加载四个 16 位整数，零加载一个整数到 32 位通道",
        "translate": ""
    },
    {
        "source": "Load two 32-bit integers and sign extend each one to a 64-bit lane",
        "suggest": "加载两个 32 位整数并将每个符号扩展到 64 位通道",
        "translate": ""
    },
    {
        "source": "Load two 32-bit integers and zero extend each one to a 64-bit lane",
        "suggest": "加载两个 32 位整数，零加载每个整数到 64 位通道",
        "translate": ""
    },
    {
        "source": "Load a single element and splat to all lanes of a v128 vector.",
        "suggest": "加载单个元素，然后将其放置到 v128 vector 的所有通道中。",
        "translate": ""
    },
    {
        "source": "Stores a `v128` vector to the given heap address.",
        "suggest": "将 `v128` vector 存储到给定的堆地址。",
        "translate": ""
    },
    {
        "source": "Materializes a constant SIMD value from the immediate operands.",
        "suggest": "从 immediate 操作数中实现一个常量 SIMD 值。",
        "translate": ""
    },
    {
        "source": "This function generates a `v128.const` instruction as if the generated vector was interpreted as sixteen 8-bit integers.",
        "suggest": "该函数将生成 `v128.const` 指令，就像将生成的 vector 解释为 16 个 8 位整数一样。",
        "translate": ""
    },
    {
        "source": "This function generates a `v128.const` instruction as if the generated vector was interpreted as eight 16-bit integers.",
        "suggest": "该函数将生成 `v128.const` 指令，就像将生成的 vector 解释为八个 16 位整数一样。",
        "translate": ""
    },
    {
        "source": "This function generates a `v128.const` instruction as if the generated vector was interpreted as four 32-bit integers.",
        "suggest": "该函数将生成 `v128.const` 指令，就像将生成的 vector 解释为四个 32 位整数一样。",
        "translate": ""
    },
    {
        "source": "This function generates a `v128.const` instruction as if the generated vector was interpreted as two 64-bit integers.",
        "suggest": "该函数生成 `v128.const` 指令，就像生成的 vector 被解释为两个 64 位整数一样。",
        "translate": ""
    },
    {
        "source": "This function generates a `v128.const` instruction as if the generated vector was interpreted as four 32-bit floats.",
        "suggest": "该函数生成 `v128.const` 指令，就好像生成的 vector 被解释为四个 32 位浮点数一样。",
        "translate": ""
    },
    {
        "source": "This function generates a `v128.const` instruction as if the generated vector was interpreted as two 64-bit floats.",
        "suggest": "该函数生成 `v128.const` 指令，就像生成的 vector 被解释为两个 64 位浮点数一样。",
        "translate": ""
    },
    {
        "source": "Returns a new vector with lanes selected from the lanes of the two input vectors `$a` and `$b` specified in the 16 immediate operands.",
        "suggest": "返回一个新的 vector，其通道从 16 个 immediate 操作数中指定的两个输入 vectors `$a` 和 `$b` 的通道中选择。",
        "translate": ""
    },
    {
        "source": "The `$a` and `$b` expressions must have type `v128`, and this macro generates a wasm instruction that is encoded with 16 bytes providing the indices of the elements to return.",
        "suggest": "`$a` 和 `$b` 表达式必须具有 `v128` 类型，并且此宏会生成 wasm 指令，该指令将以 16 个字节进行编码，以提供要返回的元素的索引。",
        "translate": ""
    },
    {
        "source": "The indices `i` in range [0, 15] select the `i`-th element of `a`.",
        "suggest": "范围 [0, 15] 中的索引 `i` 选择 `a` 的第 i 个元素。",
        "translate": ""
    },
    {
        "source": "The indices in range [16, 31] select the `i -",
        "suggest": "[16, 31] 范围内的索引选择 `i -",
        "translate": ""
    },
    {
        "source": "16`-th element of `b`.",
        "suggest": "`b` 的第 16 个元素。",
        "translate": ""
    },
    {
        "source": "Note that this is a macro due to the codegen requirements of all of the index expressions `$i*` must be constant.",
        "suggest": "请注意，由于所有索引表达式 `$i*` 的代码生成要求必须为常量，因此这是一个宏。",
        "translate": ""
    },
    {
        "source": "A compiler error will be generated if any of the expressions are not constant.",
        "suggest": "如果任何表达式不是常量，将生成编译器错误。",
        "translate": ""
    },
    {
        "source": "All indexes `$i*` must have the type `u32`.",
        "suggest": "所有索引 `$i*` 必须具有 `u32` 类型。",
        "translate": ""
    },
    {
        "source": "Same as [`v8x16_shuffle`], except operates as if the inputs were eight",
        "suggest": "与 [`v8x16_shuffle`] 相同，不同之处在于输入好像是八个",
        "translate": ""
    },
    {
        "source": "16-bit integers, only taking 8 indices to shuffle.",
        "suggest": "16 位整数，仅需 8 个索引即可重排。",
        "translate": ""
    },
    {
        "source": "Indices in the range [0, 7] select from `a` while [8, 15] select from `b`.",
        "suggest": "[0, 7] 范围内的索引从 `a` 中选择，而 [8, 15] 则从 `b` 中选择。",
        "translate": ""
    },
    {
        "source": "Note that this will generate the `v8x16.shuffle` instruction, since there is no native `v16x8.shuffle` instruction (there is no need for one since `v8x16.shuffle` suffices).",
        "suggest": "注意，这将生成 `v8x16.shuffle` 指令，因为没有原生的 `v16x8.shuffle` 指令 (因为 `v8x16.shuffle` 就足够了，因此不需要一个)。",
        "translate": ""
    },
    {
        "source": "Same as [`v8x16_shuffle`], except operates as if the inputs were four",
        "suggest": "与 [`v8x16_shuffle`] 相同，不同之处在于输入好像是四个",
        "translate": ""
    },
    {
        "source": "32-bit integers, only taking 4 indices to shuffle.",
        "suggest": "32 位整数，仅需 4 个索引即可重排。",
        "translate": ""
    },
    {
        "source": "Indices in the range [0, 3] select from `a` while [4, 7] select from `b`.",
        "suggest": "[0, 3] 范围内的索引从 `a` 中选择，而 [4, 7] 则从 `b` 中选择。",
        "translate": ""
    },
    {
        "source": "Note that this will generate the `v8x16.shuffle` instruction, since there is no native `v32x4.shuffle` instruction (there is no need for one since `v8x16.shuffle` suffices).",
        "suggest": "注意，这将生成 `v8x16.shuffle` 指令，因为没有原生的 `v32x4.shuffle` 指令 (因为 `v8x16.shuffle` 就足够了，因此不需要一个)。",
        "translate": ""
    },
    {
        "source": "Same as [`v8x16_shuffle`], except operates as if the inputs were two",
        "suggest": "与 [`v8x16_shuffle`] 相同，不同之处在于输入好像是两个",
        "translate": ""
    },
    {
        "source": "64-bit integers, only taking 2 indices to shuffle.",
        "suggest": "64 位整数，仅需 2 个索引即可重排。",
        "translate": ""
    },
    {
        "source": "Indices in the range [0, 1] select from `a` while [2, 3] select from `b`.",
        "suggest": "[0, 1] 范围内的索引从 `a` 中选择，而 [2, 3] 则从 `b` 中选择。",
        "translate": ""
    },
    {
        "source": "Note that this will generate the `v8x16.shuffle` instruction, since there is no native `v64x2.shuffle` instruction (there is no need for one since `v8x16.shuffle` suffices).",
        "suggest": "注意，这将生成 `v8x16.shuffle` 指令，因为没有原生的 `v64x2.shuffle` 指令 (因为 `v8x16.shuffle` 就足够了，因此不需要一个)。",
        "translate": ""
    },
    {
        "source": "Returns a new vector with lanes selected from the lanes of the first input vector `a` specified in the second input vector `s`.",
        "suggest": "返回带有从第二个输入 vector `s` 中指定的第一个输入 vector `a` 的通道中选择的通道的新 vector。",
        "translate": ""
    },
    {
        "source": "Creates a vector with identical lanes.",
        "suggest": "创建具有相同通道的 vector。",
        "translate": ""
    },
    {
        "source": "Constructs a vector with `x` replicated to all 16 lanes.",
        "suggest": "创建一个 vector，其中 `x` 复制到所有 16 个通道。",
        "translate": ""
    },
    {
        "source": "Construct a vector with `x` replicated to all 8 lanes.",
        "suggest": "创建一个 `x` 复制到所有 8 条通道的 vector。",
        "translate": ""
    },
    {
        "source": "Constructs a vector with `x` replicated to all 4 lanes.",
        "suggest": "创建一个 vector，其中 `x` 复制到所有 4 个通道。",
        "translate": ""
    },
    {
        "source": "Construct a vector with `x` replicated to all 2 lanes.",
        "suggest": "创建一个 `x` 复制到所有 2 条通道的 vector。",
        "translate": ""
    },
    {
        "source": "Constructs a vector with `x` replicated to all 2 lanes.",
        "suggest": "创建一个 vector，其中 `x` 复制到所有 2 个通道。",
        "translate": ""
    },
    {
        "source": "Extracts a lane from a 128-bit vector interpreted as 16 packed i8 numbers.",
        "suggest": "从解释为 16 个包装的 i8 数字的 128 位 vector 中提取通道。",
        "translate": ""
    },
    {
        "source": "Extracts the scalar value of lane specified in the immediate mode operand `N` from `a`.",
        "suggest": "从 `a` 中提取在即时模式操作数 `N` 中指定的通道的标量值。",
        "translate": ""
    },
    {
        "source": "If `N` is out of bounds then it is a compile time error.",
        "suggest": "如果 `N` 越界，则是编译时错误。",
        "translate": ""
    },
    {
        "source": "Replaces a lane from a 128-bit vector interpreted as 16 packed i8 numbers.",
        "suggest": "替换 128 位 vector 中的通道，该通道被解释为 16 个包装的 i8 数字。",
        "translate": ""
    },
    {
        "source": "Replaces the scalar value of lane specified in the immediate mode operand `N` from `a`.",
        "suggest": "从 `a` 替换在即时模式操作数 `N` 中指定的通道的标量值。",
        "translate": ""
    },
    {
        "source": "Extracts a lane from a 128-bit vector interpreted as 8 packed i16 numbers.",
        "suggest": "从解释为 8 个包装的 i16 数字的 128 位 vector 中提取通道。",
        "translate": ""
    },
    {
        "source": "Extracts a the scalar value of lane specified in the immediate mode operand `N` from `a`.",
        "suggest": "从 `a` 中提取在即时模式操作数 `N` 中指定的通道的标量值。",
        "translate": ""
    },
    {
        "source": "Replaces a lane from a 128-bit vector interpreted as 8 packed i16 numbers.",
        "suggest": "从解释为 8 个包装的 i16 编号的 128 位 vector 替换一个通道。",
        "translate": ""
    },
    {
        "source": "Extracts a lane from a 128-bit vector interpreted as 4 packed i32 numbers.",
        "suggest": "从解释为 4 个包装的 i32 数字的 128 位 vector 中提取通道。",
        "translate": ""
    },
    {
        "source": "Replaces a lane from a 128-bit vector interpreted as 4 packed i32 numbers.",
        "suggest": "从解释为 4 个包装的 i32 编号的 128 位 vector 替换一个通道。",
        "translate": ""
    },
    {
        "source": "Extracts a lane from a 128-bit vector interpreted as 2 packed i64 numbers.",
        "suggest": "从解释为 2 个包装的 i64 编号的 128 位 vector 中提取通道。",
        "translate": ""
    },
    {
        "source": "Replaces a lane from a 128-bit vector interpreted as 2 packed i64 numbers.",
        "suggest": "从一个解释为 2 个包装的 i64 编号的 128 位 vector 替换一个通道。",
        "translate": ""
    },
    {
        "source": "Extracts a lane from a 128-bit vector interpreted as 4 packed f32 numbers.",
        "suggest": "从解释为 4 个包装的 f32 数字的 128 位 vector 中提取通道。",
        "translate": ""
    },
    {
        "source": "Extracts the scalar value of lane specified fn the immediate mode operand `N` from `a`.",
        "suggest": "从 `a` 中提取在即时模式操作数 `N` 中指定的通道的标量值。",
        "translate": ""
    },
    {
        "source": "Replaces a lane from a 128-bit vector interpreted as 4 packed f32 numbers.",
        "suggest": "从解释为 4 个包装的 f32 编号的 128 位 vector 替换一个通道。",
        "translate": ""
    },
    {
        "source": "Replaces the scalar value of lane specified fn the immediate mode operand `N` from `a`.",
        "suggest": "从 `a` 替换在即时模式操作数 `N` 中指定的通道的标量值。",
        "translate": ""
    },
    {
        "source": "Extracts a lane from a 128-bit vector interpreted as 2 packed f64 numbers.",
        "suggest": "从解释为 2 个包装的 f64 编号的 128 位 vector 中提取通道。",
        "translate": ""
    },
    {
        "source": "If `N` fs out of bounds then it is a compile time error.",
        "suggest": "如果 `N` fs 越界，则是编译时错误。",
        "translate": ""
    },
    {
        "source": "Replaces a lane from a 128-bit vector interpreted as 2 packed f64 numbers.",
        "suggest": "从一个解释为 2 包装的 f64 编号的 128 位 vector 替换一个通道。",
        "translate": ""
    },
    {
        "source": "Compares two 128-bit vectors as if they were two vectors of 16 eight-bit integers.",
        "suggest": "比较两个 128 位 vectors，就好像它们是 16 个 8 位整数的两个 vectors 一样。",
        "translate": ""
    },
    {
        "source": "Returns a new vector where each lane is all ones if the pairwise elements were equal, or all zeros if the elements were not equal.",
        "suggest": "返回一个新的 vector，如果成对元素相等，则每个通道全为 1; 如果元素不相等，则全通道为全零。",
        "translate": ""
    },
    {
        "source": "Returns a new vector where each lane is all ones if the pairwise elements were not equal, or all zeros if the elements were equal.",
        "suggest": "返回一个新的 vector，如果成对元素不相等，则每个通道全为 1; 如果元素相等，则全零。",
        "translate": ""
    },
    {
        "source": "Compares two 128-bit vectors as if they were two vectors of 16 eight-bit signed integers.",
        "suggest": "比较两个 128 位 vectors，就好像它们是 16 个 8 位有符号整数的两个 vectors 一样。",
        "translate": ""
    },
    {
        "source": "Returns a new vector where each lane is all ones if the pairwise left element is less than the pairwise right element, or all zeros otherwise.",
        "suggest": "返回一个新的 vector，如果成对的左元素小于成对的右元素，则每个通道全为 1，否则为全零。",
        "translate": ""
    },
    {
        "source": "Compares two 128-bit vectors as if they were two vectors of 16 eight-bit unsigned integers.",
        "suggest": "比较两个 128 位 vectors，就好像它们是 16 个 8 位无符号整数的两个 vectors 一样。",
        "translate": ""
    },
    {
        "source": "Returns a new vector where each lane is all ones if the pairwise left element is greater than the pairwise right element, or all zeros otherwise.",
        "suggest": "返回一个新的 vector，如果成对的左元素大于成对的右元素，则每个通道全为 1，否则为全零。",
        "translate": ""
    },
    {
        "source": "Compares two 128-bit vectors as if they were two vectors of 8 sixteen-bit integers.",
        "suggest": "比较两个 128 位 vectors，就好像它们是 8 个 16 位整数的两个 vectors 一样。",
        "translate": ""
    },
    {
        "source": "Compares two 128-bit vectors as if they were two vectors of 8 sixteen-bit signed integers.",
        "suggest": "比较两个 128 位 vectors，就好像它们是 8 个 16 位带符号整数的两个 vectors 一样。",
        "translate": ""
    },
    {
        "source": "Compares two 128-bit vectors as if they were two vectors of 8 sixteen-bit unsigned integers.",
        "suggest": "比较两个 128 位 vectors，就好像它们是 8 个 16 位无符号整数的两个 vectors 一样。",
        "translate": ""
    },
    {
        "source": "Compares two 128-bit vectors as if they were two vectors of 4 thirty-two-bit integers.",
        "suggest": "比较两个 128 位 vectors，就好像它们是 4 个 32 位整数的两个 vectors 一样。",
        "translate": ""
    },
    {
        "source": "Compares two 128-bit vectors as if they were two vectors of 4 thirty-two-bit signed integers.",
        "suggest": "比较两个 128 位 vectors，就好像它们是 4 个 32 位有符号整数的两个 vectors 一样。",
        "translate": ""
    },
    {
        "source": "Compares two 128-bit vectors as if they were two vectors of 4 thirty-two-bit unsigned integers.",
        "suggest": "比较两个 128 位 vectors，就好像它们是 4 个 32 位无符号整数的两个 vectors 一样。",
        "translate": ""
    },
    {
        "source": "Compares two 128-bit vectors as if they were two vectors of 4 thirty-two-bit floating point numbers.",
        "suggest": "比较两个 128 位 vectors，就好像它们是 4 个 32 位浮点数的两个 vectors 一样。",
        "translate": ""
    },
    {
        "source": "Compares two 128-bit vectors as if they were two vectors of 2 sixty-four-bit floating point numbers.",
        "suggest": "比较两个 128 位 vectors，就好像它们是 2 个 64 位浮点数的两个 vectors 一样。",
        "translate": ""
    },
    {
        "source": "Flips each bit of the 128-bit input vector.",
        "suggest": "翻转 128 位输入 vector 的每个位。",
        "translate": ""
    },
    {
        "source": "Performs a bitwise and of the two input 128-bit vectors, returning the resulting vector.",
        "suggest": "对两个输入的 128 位 vectors 进行按位和运算，返回结果 vector。",
        "translate": ""
    },
    {
        "source": "Bitwise AND of bits of `a` and the logical inverse of bits of `b`.",
        "suggest": "`a` 的位按位与与 `b` 的位进行逻辑逆。",
        "translate": ""
    },
    {
        "source": "This operation is equivalent to `v128.and(a, v128.not(b))`",
        "suggest": "此操作等效于 `v128.and(a, v128.not(b))`",
        "translate": ""
    },
    {
        "source": "Performs a bitwise or of the two input 128-bit vectors, returning the resulting vector.",
        "suggest": "对两个输入的 128 位 vectors 进行按位或逻辑运算，返回结果 vector。",
        "translate": ""
    },
    {
        "source": "Performs a bitwise xor of the two input 128-bit vectors, returning the resulting vector.",
        "suggest": "对两个输入的 128 位 vectors 进行按位异或，返回结果 vector。",
        "translate": ""
    },
    {
        "source": "Use the bitmask in `c` to select bits from `v1` when 1 and `v2` when 0.",
        "suggest": "使用 `c` 中的位掩码在 1 时从 `v1` 中选择位，在 0 时从 `v2` 中选择位。",
        "translate": ""
    },
    {
        "source": "Lane-wise wrapping absolute value.",
        "suggest": "逐行包装绝对值。",
        "translate": ""
    },
    {
        "source": "FIXME support not in our LLVM yet",
        "suggest": "FIXME 支持不在我们的 LLVM 中",
        "translate": ""
    },
    {
        "source": "Negates a 128-bit vectors intepreted as sixteen 8-bit signed integers",
        "suggest": "取反一个 16 位 8 位带符号整数的 128 位 vectors",
        "translate": ""
    },
    {
        "source": "Returns 1 if any lane is nonzero or 0 if all lanes are zero.",
        "suggest": "如果任何通道都不为零，则返回 1; 如果所有通道为零，则返回 0。",
        "translate": ""
    },
    {
        "source": "Returns 1 if all lanes are nonzero or 0 if any lane is nonzero.",
        "suggest": "如果所有通道都不为零，则返回 1; 如果任何通道都不为零，则返回 0。",
        "translate": ""
    },
    {
        "source": "not available in our LLVM yet /// Extracts the high bit for each lane in `a` and produce a scalar mask with",
        "suggest": "在我们的 LLVM 中尚不可用 //// 提取 `a` 中每个通道的高位，并生成具有以下内容的标量掩码:",
        "translate": ""
    },
    {
        "source": "/// all bits concatenated.",
        "suggest": "/// 所有位串联在一起。",
        "translate": ""
    },
    {
        "source": "Converts two input vectors into a smaller lane vector by narrowing each lane.",
        "suggest": "通过使每个通道变窄，将两个输入 vectors 转换为较小的通道 vector。",
        "translate": ""
    },
    {
        "source": "Signed saturation to 0x7f or 0x80 is used and the input lanes are always interpreted as signed integers.",
        "suggest": "使用 0x7f 或 0x80 的带符号饱和，并且输入通道始终被解释为带符号整数。",
        "translate": ""
    },
    {
        "source": "Signed saturation to 0x00 or 0xff is used and the input lanes are always interpreted as signed integers.",
        "suggest": "使用 0x00 或 0xff 的带符号饱和，并且输入通道始终被解释为带符号整数。",
        "translate": ""
    },
    {
        "source": "Shifts each lane to the left by the specified number of bits.",
        "suggest": "将每个通道向左移动指定的位数。",
        "translate": ""
    },
    {
        "source": "Only the low bits of the shift amount are used if the shift amount is greater than the lane width.",
        "suggest": "如果移位量大于通道宽度，则仅使用移位量的低位。",
        "translate": ""
    },
    {
        "source": "Shifts each lane to the right by the specified number of bits, sign extending.",
        "suggest": "将每个通道向右移动指定的位数，并扩展符号。",
        "translate": ""
    },
    {
        "source": "Shifts each lane to the right by the specified number of bits, shifting in zeros.",
        "suggest": "将每个通道向右移动指定的位数，以零为单位。",
        "translate": ""
    },
    {
        "source": "Adds two 128-bit vectors as if they were two packed sixteen 8-bit integers.",
        "suggest": "将两个 128 位 vectors 相加，就好像它们是两个包装的 16 个 8 位整数一样。",
        "translate": ""
    },
    {
        "source": "Adds two 128-bit vectors as if they were two packed sixteen 8-bit signed integers, saturating on overflow to `i8::MAX`.",
        "suggest": "将两个 128 位 vectors 相加，就好像它们是两个包装的 16 个 8 位有符号整数一样，在溢出到 `i8::MAX` 时会饱和。",
        "translate": ""
    },
    {
        "source": "Adds two 128-bit vectors as if they were two packed sixteen 8-bit unsigned integers, saturating on overflow to `u8::MAX`.",
        "suggest": "将两个 128 位 vectors 相加，就好像它们是两个包装的 16 个 8 位无符号整数一样，在溢出到 `u8::MAX` 时会饱和。",
        "translate": ""
    },
    {
        "source": "Subtracts two 128-bit vectors as if they were two packed sixteen 8-bit integers.",
        "suggest": "将两个 128 位 vectors 相减，就好像它们是两个包装的 16 个 8 位整数一样。",
        "translate": ""
    },
    {
        "source": "Subtracts two 128-bit vectors as if they were two packed sixteen 8-bit signed integers, saturating on overflow to `i8::MIN`.",
        "suggest": "将两个 128 位 vectors 相减，就好像它们是两个包装的 16 个 8 位有符号整数一样，在溢出到 `i8::MIN` 时会饱和。",
        "translate": ""
    },
    {
        "source": "Subtracts two 128-bit vectors as if they were two packed sixteen 8-bit unsigned integers, saturating on overflow to 0.",
        "suggest": "将两个 128 位 vectors 相减，就好像它们是两个包装的 16 个 8 位无符号整数一样，溢出时饱和为 0。",
        "translate": ""
    },
    {
        "source": "Compares lane-wise signed integers, and returns the minimum of each pair.",
        "suggest": "比较通道有符号整数，并返回每对中的最小值。",
        "translate": ""
    },
    {
        "source": "Compares lane-wise unsigned integers, and returns the minimum of each pair.",
        "suggest": "比较通道无符号整数，并返回每对中的最小值。",
        "translate": ""
    },
    {
        "source": "Compares lane-wise signed integers, and returns the maximum of each pair.",
        "suggest": "比较通道有符号整数，并返回每对的最大值。",
        "translate": ""
    },
    {
        "source": "Compares lane-wise unsigned integers, and returns the maximum of each pair.",
        "suggest": "比较通道无符号整数，并返回每对的最大值。",
        "translate": ""
    },
    {
        "source": "Lane-wise rounding average.",
        "suggest": "逐行舍入平均值。",
        "translate": ""
    },
    {
        "source": "Negates a 128-bit vectors intepreted as eight 16-bit signed integers",
        "suggest": "取反一个 8 位 16 位带符号整数的 128 位 vectors",
        "translate": ""
    },
    {
        "source": "Signed saturation to 0x7fff or 0x8000 is used and the input lanes are always interpreted as signed integers.",
        "suggest": "使用 0x7fff 或 0x8000 的带符号饱和，并且输入通道始终被解释为带符号整数。",
        "translate": ""
    },
    {
        "source": "Signed saturation to 0x0000 or 0xffff is used and the input lanes are always interpreted as signed integers.",
        "suggest": "使用 0x0000 或 0xffff 的带符号饱和，并且输入通道始终被解释为带符号整数。",
        "translate": ""
    },
    {
        "source": "Converts low half of the smaller lane vector to a larger lane vector, sign extended.",
        "suggest": "将较小通道 vector 的下半部分转换为较大通道 vector，并扩展符号。",
        "translate": ""
    },
    {
        "source": "Converts high half of the smaller lane vector to a larger lane vector, sign extended.",
        "suggest": "将较小通道 vector 的高一半转换为较大通道 vector，并对其进行符号扩展。",
        "translate": ""
    },
    {
        "source": "Converts low half of the smaller lane vector to a larger lane vector, zero extended.",
        "suggest": "将较小通道 vector 的下半部分转换为较大通道 vector，扩展为零。",
        "translate": ""
    },
    {
        "source": "Converts high half of the smaller lane vector to a larger lane vector, zero extended.",
        "suggest": "将较小通道 vector 的高一半转换为较大通道 vector，扩展为零。",
        "translate": ""
    },
    {
        "source": "Adds two 128-bit vectors as if they were two packed eight 16-bit integers.",
        "suggest": "将两个 128 位 vectors 相加，就好像它们是两个包装的八个 16 位整数一样。",
        "translate": ""
    },
    {
        "source": "Adds two 128-bit vectors as if they were two packed eight 16-bit signed integers, saturating on overflow to `i16::MAX`.",
        "suggest": "将两个 128 位 vectors 相加，就好像它们是两个包装的八个 16 位有符号整数一样，在溢出到 `i16::MAX` 时会饱和。",
        "translate": ""
    },
    {
        "source": "Adds two 128-bit vectors as if they were two packed eight 16-bit unsigned integers, saturating on overflow to `u16::MAX`.",
        "suggest": "将两个 128 位 vectors 相加，就好像它们是两个包装的八个 16 位无符号整数一样，在溢出到 `u16::MAX` 时会饱和。",
        "translate": ""
    },
    {
        "source": "Subtracts two 128-bit vectors as if they were two packed eight 16-bit integers.",
        "suggest": "将两个 128 位 vectors 相减，就好像它们是两个包装的八个 16 位整数一样。",
        "translate": ""
    },
    {
        "source": "Subtracts two 128-bit vectors as if they were two packed eight 16-bit signed integers, saturating on overflow to `i16::MIN`.",
        "suggest": "将两个 128 位 vectors 相减，就好像它们是两个包装的八个 16 位有符号整数一样，在溢出到 `i16::MIN` 时会饱和。",
        "translate": ""
    },
    {
        "source": "Subtracts two 128-bit vectors as if they were two packed eight 16-bit unsigned integers, saturating on overflow to 0.",
        "suggest": "将两个 128 位 vectors 相减，就好像它们是两个包装的八个 16 位无符号整数一样，溢出时饱和为 0。",
        "translate": ""
    },
    {
        "source": "Multiplies two 128-bit vectors as if they were two packed eight 16-bit signed integers.",
        "suggest": "将两个 128 位 vectors 相乘，就好像它们是两个包装的八个 16 位有符号整数一样。",
        "translate": ""
    },
    {
        "source": "Negates a 128-bit vectors intepreted as four 32-bit signed integers",
        "suggest": "取反一个 128 位 vectors，该 vectors 解释为四个 32 位带符号整数",
        "translate": ""
    },
    {
        "source": "Adds two 128-bit vectors as if they were two packed four 32-bit integers.",
        "suggest": "将两个 128 位 vectors 相加，就好像它们是两个包装的四个 32 位整数一样。",
        "translate": ""
    },
    {
        "source": "Subtracts two 128-bit vectors as if they were two packed four 32-bit integers.",
        "suggest": "将两个 128 位 vectors 相减，就好像它们是两个包装的四个 32 位整数一样。",
        "translate": ""
    },
    {
        "source": "Multiplies two 128-bit vectors as if they were two packed four 32-bit signed integers.",
        "suggest": "将两个 128 位 vectors 相乘，就好像它们是两个包装的四个 32 位有符号整数一样。",
        "translate": ""
    },
    {
        "source": "Negates a 128-bit vectors intepreted as two 64-bit signed integers",
        "suggest": "取反被解释为两个 64 位有符号整数的 128 位 vectors",
        "translate": ""
    },
    {
        "source": "Adds two 128-bit vectors as if they were two packed two 64-bit integers.",
        "suggest": "将两个 128 位 vectors 相加，就好像它们是两个包装的两个 64 位整数一样。",
        "translate": ""
    },
    {
        "source": "Subtracts two 128-bit vectors as if they were two packed two 64-bit integers.",
        "suggest": "将两个 128 位 vectors 相减，就好像它们是两个包装的两个 64 位整数一样。",
        "translate": ""
    },
    {
        "source": "Multiplies two 128-bit vectors as if they were two packed two 64-bit integers.",
        "suggest": "将两个 128 位 vectors 相乘，就好像它们是两个包装的两个 64 位整数一样。",
        "translate": ""
    },
    {
        "source": "FIXME: not present in our LLVM",
        "suggest": "FIXME: 在我们的 LLVM 中不存在",
        "translate": ""
    },
    {
        "source": "Calculates the absolute value of each lane of a 128-bit vector interpreted as four 32-bit floating point numbers.",
        "suggest": "计算一个 128 位 vector 的每个通道的绝对值，该绝对值解释为四个 32 位浮点数。",
        "translate": ""
    },
    {
        "source": "Negates each lane of a 128-bit vector interpreted as four 32-bit floating point numbers.",
        "suggest": "对解释为四个 32 位浮点数的 128 位向量的每个通道求反。",
        "translate": ""
    },
    {
        "source": "Calculates the square root of each lane of a 128-bit vector interpreted as four 32-bit floating point numbers.",
        "suggest": "计算一个 128 位 vector 的每个通道的平方根，该 vector 解释为四个 32 位浮点数。",
        "translate": ""
    },
    {
        "source": "Adds pairwise lanes of two 128-bit vectors interpreted as four 32-bit floating point numbers.",
        "suggest": "将两个 128 位 vectors 的成对通道相加，将其解释为四个 32 位浮点数。",
        "translate": ""
    },
    {
        "source": "Subtracts pairwise lanes of two 128-bit vectors interpreted as four 32-bit floating point numbers.",
        "suggest": "减去两个 128 位 vectors 的成对通道，它们被解释为四个 32 位浮点数。",
        "translate": ""
    },
    {
        "source": "Multiplies pairwise lanes of two 128-bit vectors interpreted as four 32-bit floating point numbers.",
        "suggest": "将两个 128 位 vectors 的成对通道相乘，将其解释为四个 32 位浮点数。",
        "translate": ""
    },
    {
        "source": "Divides pairwise lanes of two 128-bit vectors interpreted as four 32-bit floating point numbers.",
        "suggest": "将两个 128 位 vectors 的成对通道划分为四个 32 位浮点数。",
        "translate": ""
    },
    {
        "source": "Calculates the minimum of pairwise lanes of two 128-bit vectors interpreted as four 32-bit floating point numbers.",
        "suggest": "计算两个解释为四个 32 位浮点数的 128 位 vectors 的成对通道的最小值。",
        "translate": ""
    },
    {
        "source": "Calculates the maximum of pairwise lanes of two 128-bit vectors interpreted as four 32-bit floating point numbers.",
        "suggest": "计算两个解释为四个 32 位浮点数的 128 位 vectors 的成对通道的最大值。",
        "translate": ""
    },
    {
        "source": "Calculates the absolute value of each lane of a 128-bit vector interpreted as two 64-bit floating point numbers.",
        "suggest": "计算被解释为两个 64 位浮点数的 128 位 vector 的每个通道的绝对值。",
        "translate": ""
    },
    {
        "source": "Negates each lane of a 128-bit vector interpreted as two 64-bit floating point numbers.",
        "suggest": "取反解释为两个 64 位浮点数的 128 位 vector 的每个通道。",
        "translate": ""
    },
    {
        "source": "Calculates the square root of each lane of a 128-bit vector interpreted as two 64-bit floating point numbers.",
        "suggest": "计算一个 128 位 vector 的每个通道的平方根，该 vector 解释为两个 64 位浮点数。",
        "translate": ""
    },
    {
        "source": "Adds pairwise lanes of two 128-bit vectors interpreted as two 64-bit floating point numbers.",
        "suggest": "将两个 128 位 vectors 的成对通道相加，将其解释为两个 64 位浮点数。",
        "translate": ""
    },
    {
        "source": "Subtracts pairwise lanes of two 128-bit vectors interpreted as two 64-bit floating point numbers.",
        "suggest": "减去两个 128 位 vectors 的成对通道，它们被解释为两个 64 位浮点数。",
        "translate": ""
    },
    {
        "source": "Multiplies pairwise lanes of two 128-bit vectors interpreted as two 64-bit floating point numbers.",
        "suggest": "将两个解释为两个 64 位浮点数的 128 位 vectors 的成对通道相乘。",
        "translate": ""
    },
    {
        "source": "Divides pairwise lanes of two 128-bit vectors interpreted as two 64-bit floating point numbers.",
        "suggest": "将两个 128 位 vectors 的成对通道划分为两个 64 位浮点数。",
        "translate": ""
    },
    {
        "source": "Calculates the minimum of pairwise lanes of two 128-bit vectors interpreted as two 64-bit floating point numbers.",
        "suggest": "计算两个解释为两个 64 位浮点数的 128 位 vectors 的成对通道的最小值。",
        "translate": ""
    },
    {
        "source": "Calculates the maximum of pairwise lanes of two 128-bit vectors interpreted as two 64-bit floating point numbers.",
        "suggest": "计算两个解释为两个 64 位浮点数的 128 位 vectors 的成对通道的最大值。",
        "translate": ""
    },
    {
        "source": "Converts a 128-bit vector interpreted as four 32-bit floating point numbers into a 128-bit vector of four 32-bit signed integers.",
        "suggest": "将解释为四个 32 位浮点数的 128 位 vector 转换为包含四个 32 位带符号整数的 128 位 vector。",
        "translate": ""
    },
    {
        "source": "NaN is converted to 0 and if it's out of bounds it becomes the nearest representable intger.",
        "suggest": "NaN 会转换为 0，如果越界，它将成为最接近的可表示整数。",
        "translate": ""
    },
    {
        "source": "Converts a 128-bit vector interpreted as four 32-bit floating point numbers into a 128-bit vector of four 32-bit unsigned integers.",
        "suggest": "将解释为四个 32 位浮点数的 128 位 vector 转换为四个 32 位无符号整数的 128 位 vector。",
        "translate": ""
    },
    {
        "source": "Converts a 128-bit vector interpreted as four 32-bit signed integers into a",
        "suggest": "将解释为四个 32 位有符号整数的 128 位 vector 转换为",
        "translate": ""
    },
    {
        "source": "128-bit vector of four 32-bit floating point numbers.",
        "suggest": "四个 32 位浮点数的 128 位 vector。",
        "translate": ""
    },
    {
        "source": "Converts a 128-bit vector interpreted as four 32-bit unsigned integers into a",
        "suggest": "将解释为四个 32 位无符号整数的 128 位 vector 转换为",
        "translate": ""
    },
    {
        "source": "tests extract and replace lanes",
        "suggest": "测试提取和替换 lanes",
        "translate": ""
    },
    {
        "source": "create a vector from array and check that the indices contain the same values as in the array:",
        "suggest": "从数组创建一个 vector 并检查索引是否包含与数组相同的值:",
        "translate": ""
    },
    {
        "source": "this fails, and produces 0 instead of saturating at i32::MAX",
        "suggest": "这将失败，并产生 0 而不是在 i32::MAX 处饱和",
        "translate": ""
    },
    {
        "source": "add other saturating tests",
        "suggest": "添加其他饱和测试",
        "translate": ""
    },
    {
        "source": "Advanced Bit Manipulation (ABM) instructions",
        "suggest": "高级位操作 (ABM) 指令",
        "translate": ""
    },
    {
        "source": "The POPCNT and LZCNT have their own CPUID bits to indicate support.",
        "suggest": "POPCNT 和 LZCNT 具有自己的 CPUID 位以指示支持。",
        "translate": ""
    },
    {
        "source": "The references are:",
        "suggest": "引用的是:",
        "translate": ""
    },
    {
        "source": "[性",
        "suggest": "[Intel 64 和 IA-32 体系结构软件开发人员手册卷 2:",
        "translate": ""
    },
    {
        "source": "Instruction Set Reference, A-Z][intel64_ref].",
        "suggest": "指令集引用，AZ][intel64_ref]。",
        "translate": ""
    },
    {
        "source": "provides a quick overview of the instructions available.",
        "suggest": "提供有关可用说明的快速概述。",
        "translate": ""
    },
    {
        "source": "Counts the leading most significant zero bits.",
        "suggest": "计算前导最高有效零位。",
        "translate": ""
    },
    {
        "source": "When the operand is zero, it returns its size in bits.",
        "suggest": "当操作数为零时，它将返回其大小 (以位为单位)。",
        "translate": ""
    },
    {
        "source": "Counts the bits that are set.",
        "suggest": "计算设置的位。",
        "translate": ""
    },
    {
        "source": "Adds unsigned 32-bit integers `a` and `b` with unsigned 8-bit carry-in `c_in` (carry flag), and store the unsigned 32-bit result in `out`, and the carry-out is returned (carry or overflow flag).",
        "suggest": "将无符号的 32 位整数 `a` 和 `b` 与无符号的 8 位进位 `c_in` (进位标志) 相加，并将无符号的 32 位结果存储在 `out` 中，并返回进位 (进位或溢出标志)。",
        "translate": ""
    },
    {
        "source": "Adds unsigned 32-bit integers `a` and `b` with unsigned 8-bit carry-in `c_in` (carry or overflow flag), and store the unsigned 32-bit result in `out`, and the carry-out is returned (carry or overflow flag).",
        "suggest": "将无符号的 32 位整数 `a` 和 `b` 与无符号的 8 位进位 `c_in` (进位或溢出标志) 相加，并将无符号的 32 位结果存储在 `out` 中，并返回进位 (进位或溢出标志)。",
        "translate": ""
    },
    {
        "source": "AES New Instructions (AES-NI)",
        "suggest": "AES 新指令 (AES-NI)",
        "translate": ""
    },
    {
        "source": "The intrinsics here correspond to those in the `wmmintrin.h` C header.",
        "suggest": "这里的内联函数对应于 `wmmintrin.h` C 头文件中的内联函数。",
        "translate": ""
    },
    {
        "source": "The reference is [Intel 64 and IA-32 Architectures Software Developer's Manual Volume 2: Instruction Set Reference, A-Z][intel64_ref].",
        "suggest": "引用的是 [Intel 64 and IA-32 Architectures Software Developer's Manual Volume 2: Instruction Set Reference, A-Z][intel64_ref]。",
        "translate": ""
    },
    {
        "source": "Performs one round of an AES decryption flow on data (state) in `a`.",
        "suggest": "对 `a` 中的数据 (state) 执行一轮 AES 解密流程。",
        "translate": ""
    },
    {
        "source": "Performs the last round of an AES decryption flow on data (state) in `a`.",
        "suggest": "对 `a` 中的数据 (state) 执行 AES 解密流的最后一轮。",
        "translate": ""
    },
    {
        "source": "Performs one round of an AES encryption flow on data (state) in `a`.",
        "suggest": "对 `a` 中的数据 (state) 执行一轮 AES 加密流程。",
        "translate": ""
    },
    {
        "source": "Performs the last round of an AES encryption flow on data (state) in `a`.",
        "suggest": "对 `a` 中的数据 (state) 执行最后一轮 AES 加密流程。",
        "translate": ""
    },
    {
        "source": "Performs the `InvMixColumns` transformation on `a`.",
        "suggest": "在 `a` 上执行 `InvMixColumns` 转换。",
        "translate": ""
    },
    {
        "source": "Assist in expanding the AES cipher key.",
        "suggest": "协助扩展 AES 密钥。",
        "translate": ""
    },
    {
        "source": "Assist in expanding the AES cipher key by computing steps towards generating a round key for encryption cipher using data from `a` and an",
        "suggest": "通过计算以下步骤来协助扩展 AES 密码密钥: 使用 `a` 和",
        "translate": ""
    },
    {
        "source": "8-bit round constant `imm8`.",
        "suggest": "8 位圆形常量 `imm8`。",
        "translate": ""
    },
    {
        "source": "The constants in the tests below are just bit patterns.",
        "suggest": "以下测试中的常量只是位模式。",
        "translate": ""
    },
    {
        "source": "They should not be interpreted as integers;",
        "suggest": "不应将它们解释为整数。",
        "translate": ""
    },
    {
        "source": "signedness does not make sense for them, but __m128i happens to be defined in terms of signed integers.",
        "suggest": "符号性对它们没有意义，但是 __m128i 恰好是根据有符号整数定义的。",
        "translate": ""
    },
    {
        "source": "Constants taken from https://msdn.microsoft.com/en-us/library/cc664949.aspx.",
        "suggest": "从 https://msdn.microsoft.com/en-us/library/cc664949.aspx 获取的常量。",
        "translate": ""
    },
    {
        "source": "Constants taken from https://msdn.microsoft.com/en-us/library/cc714178.aspx.",
        "suggest": "从 https://msdn.microsoft.com/en-us/library/cc714178.aspx 获取的常量。",
        "translate": ""
    },
    {
        "source": "Constants taken from https://msdn.microsoft.com/en-us/library/cc664810.aspx.",
        "suggest": "从 https://msdn.microsoft.com/en-us/library/cc664810.aspx 获取的常量。",
        "translate": ""
    },
    {
        "source": "Constants taken from https://msdn.microsoft.com/en-us/library/cc714136.aspx.",
        "suggest": "从 https://msdn.microsoft.com/en-us/library/cc714136.aspx 获取的常量。",
        "translate": ""
    },
    {
        "source": "Constants taken from https://msdn.microsoft.com/en-us/library/cc714195.aspx.",
        "suggest": "从 https://msdn.microsoft.com/en-us/library/cc714195.aspx 获取的常量。",
        "translate": ""
    },
    {
        "source": "Constants taken from https://msdn.microsoft.com/en-us/library/cc714138.aspx.",
        "suggest": "从 https://msdn.microsoft.com/en-us/library/cc714138.aspx 获取的常量。",
        "translate": ""
    },
    {
        "source": "Advanced Vector Extensions (AVX)",
        "suggest": "高级的 Vector 扩展 (AVX)",
        "translate": ""
    },
    {
        "source": "Adds packed double-precision (64-bit) floating-point elements in `a` and `b`.",
        "suggest": "在 `a` 和 `b` 中添加包装的双精度 (64-bit) 浮点元素。",
        "translate": ""
    },
    {
        "source": "Adds packed single-precision (32-bit) floating-point elements in `a` and `b`.",
        "suggest": "在 `a` 和 `b` 中添加包装的单精度 (32-bit) 浮点元素。",
        "translate": ""
    },
    {
        "source": "Computes the bitwise AND of a packed double-precision (64-bit) floating-point elements in `a` and `b`.",
        "suggest": "计算 `a` 和 `b` 中包装的双精度 (64-bit) 浮点元素的按位与。",
        "translate": ""
    },
    {
        "source": "Should be 'vandpd' instuction.",
        "suggest": "应该是 'vandpd' 指令。",
        "translate": ""
    },
    {
        "source": "Computes the bitwise AND of packed single-precision (32-bit) floating-point elements in `a` and `b`.",
        "suggest": "计算 `a` 和 `b` 中包装的单精度 (32-bit) 浮点元素的按位与。",
        "translate": ""
    },
    {
        "source": "Computes the bitwise OR packed double-precision (64-bit) floating-point elements in `a` and `b`.",
        "suggest": "计算 `a` 和 `b` 中按位或包装的双精度 (64-bit) 浮点元素。",
        "translate": ""
    },
    {
        "source": "should be `vorpd` instuction.",
        "suggest": "应该是 `vorpd` 指令。",
        "translate": ""
    },
    {
        "source": "See <https://github.com/rust-lang/stdarch/issues/71>.",
        "suggest": "请参见 <https://github.com/rust-lang/stdarch/issues/71>。",
        "translate": ""
    },
    {
        "source": "Computes the bitwise OR packed single-precision (32-bit) floating-point elements in `a` and `b`.",
        "suggest": "计算 `a` 和 `b` 中按位或包装的单精度 (32-bit) 浮点元素。",
        "translate": ""
    },
    {
        "source": "Shuffles double-precision (64-bit) floating-point elements within 128-bit lanes using the control in `imm8`.",
        "suggest": "使用 `imm8` 中的控件对 128 位通道中的双精度 (64-bit) 浮点元素进行混洗。",
        "translate": ""
    },
    {
        "source": "Shuffles single-precision (32-bit) floating-point elements in `a` within",
        "suggest": "将 `a` 中的单精度 (32-bit) 浮点元素改组为",
        "translate": ""
    },
    {
        "source": "128-bit lanes using the control in `imm8`.",
        "suggest": "使用 `imm8` 中的控件的 128 位通道。",
        "translate": ""
    },
    {
        "source": "Computes the bitwise NOT of packed double-precision (64-bit) floating-point elements in `a`, and then AND with `b`.",
        "suggest": "计算 `a` 中包装的双精度 (64-bit) 浮点元素的按位 NOT，然后计算 `b` 的 AND。",
        "translate": ""
    },
    {
        "source": "should be `vandnpd` instruction.",
        "suggest": "应该是 `vandnpd` 指令。",
        "translate": ""
    },
    {
        "source": "Computes the bitwise NOT of packed single-precision (32-bit) floating-point elements in `a` and then AND with `b`.",
        "suggest": "计算 `a` 中包装的单精度 (32-bit) 浮点元素的按位非，然后计算 `b` 的 AND。",
        "translate": ""
    },
    {
        "source": "Compares packed double-precision (64-bit) floating-point elements in `a` and `b`, and returns packed maximum values",
        "suggest": "比较 `a` 和 `b` 中的包装的双精度 (64-bit) 浮点元素，并返回包装的最大值",
        "translate": ""
    },
    {
        "source": "Compares packed single-precision (32-bit) floating-point elements in `a` and `b`, and returns packed maximum values",
        "suggest": "比较 `a` 和 `b` 中的包装的单精度 (32-bit) 浮点元素，并返回包装的最大值",
        "translate": ""
    },
    {
        "source": "Compares packed double-precision (64-bit) floating-point elements in `a` and `b`, and returns packed minimum values",
        "suggest": "比较 `a` 和 `b` 中的包装的双精度 (64-bit) 浮点元素，并返回包装的最小值",
        "translate": ""
    },
    {
        "source": "Compares packed single-precision (32-bit) floating-point elements in `a` and `b`, and returns packed minimum values",
        "suggest": "比较 `a` 和 `b` 中的包装的单精度 (32-bit) 浮点元素，并返回包装的最小值",
        "translate": ""
    },
    {
        "source": "Multiplies packed double-precision (64-bit) floating-point elements in `a` and `b`.",
        "suggest": "将 `a` 和 `b` 中的包装的双精度 (64-bit) 浮点元素相乘。",
        "translate": ""
    },
    {
        "source": "Multiplies packed single-precision (32-bit) floating-point elements in `a` and `b`.",
        "suggest": "将 `a` 和 `b` 中的包装的单精度 (32-bit) 浮点元素相乘。",
        "translate": ""
    },
    {
        "source": "Alternatively adds and subtracts packed double-precision (64-bit) floating-point elements in `a` to/from packed elements in `b`.",
        "suggest": "或者，将`a`中的包装双精度（64位）浮点元素与`b`中的包装元素进行加减。",
        "translate": ""
    },
    {
        "source": "Alternatively adds and subtracts packed single-precision (32-bit) floating-point elements in `a` to/from packed elements in `b`.",
        "suggest": "或者，将`a`中的包装的单精度（32位）浮点元素与`b`中的包装的元素进行加减。",
        "translate": ""
    },
    {
        "source": "Subtracts packed double-precision (64-bit) floating-point elements in `b` from packed elements in `a`.",
        "suggest": "从 `a` 中的包装的元素中减去 `b` 中的包装后的双精度 (64-bit) 浮点元素。",
        "translate": ""
    },
    {
        "source": "Subtracts packed single-precision (32-bit) floating-point elements in `b` from packed elements in `a`.",
        "suggest": "从 `a` 中的包装元素中减去 `b` 中的包装的单精度 (32-bit) 浮点元素。",
        "translate": ""
    },
    {
        "source": "Computes the division of each of the 8 packed 32-bit floating-point elements in `a` by the corresponding packed elements in `b`.",
        "suggest": "计算 `a` 中的 8 个包装的 32 位浮点元素中的每一个除以 `b` 中相应的封装元素的除法。",
        "translate": ""
    },
    {
        "source": "Computes the division of each of the 4 packed 64-bit floating-point elements in `a` by the corresponding packed elements in `b`.",
        "suggest": "计算 `a` 中的 4 个包装的 64 位浮点元素中的每一个除以 `b` 中相应的封装元素的除法。",
        "translate": ""
    },
    {
        "source": "Rounds packed double-precision (64-bit) floating point elements in `a` according to the flag `b`.",
        "suggest": "根据标志 `b` 对 `a` 中的包装后的双精度 (64-bit) 浮点元素进行四舍五入。",
        "translate": ""
    },
    {
        "source": "The value of `b` may be as follows:",
        "suggest": "`b` 的值可能如下:",
        "translate": ""
    },
    {
        "source": "Round to the nearest whole number.",
        "suggest": "四舍五入到最接近的整数。",
        "translate": ""
    },
    {
        "source": "Round down, toward negative infinity.",
        "suggest": "向下舍入，朝负无穷大方向移动。",
        "translate": ""
    },
    {
        "source": "Round up, toward positive infinity.",
        "suggest": "向上取整，朝正无穷大方向移动。",
        "translate": ""
    },
    {
        "source": "Truncate the values.",
        "suggest": "截断值。",
        "translate": ""
    },
    {
        "source": "For a complete list of options, check [the LLVM docs][llvm_docs].",
        "suggest": "有关选项的完整列表，请检查 [LLVM 文档][llvm_docs]。",
        "translate": ""
    },
    {
        "source": "Rounds packed double-precision (64-bit) floating point elements in `a` toward positive infinity.",
        "suggest": "将 `a` 中的包装的双精度 (64-bit) 浮点元素四舍五入为正无穷大。",
        "translate": ""
    },
    {
        "source": "Rounds packed double-precision (64-bit) floating point elements in `a` toward negative infinity.",
        "suggest": "将 `a` 中的包装的双精度 (64-bit) 浮点元素四舍五入为负无穷大。",
        "translate": ""
    },
    {
        "source": "Rounds packed single-precision (32-bit) floating point elements in `a` according to the flag `b`.",
        "suggest": "根据标志 `b`，对 `a` 中的包装的单精度 (32-bit) 浮点元素进行四舍五入。",
        "translate": ""
    },
    {
        "source": "Rounds packed single-precision (32-bit) floating point elements in `a` toward positive infinity.",
        "suggest": "将 `a` 中的包装的单精度 (32-bit) 浮点元素四舍五入为正无穷大。",
        "translate": ""
    },
    {
        "source": "Rounds packed single-precision (32-bit) floating point elements in `a` toward negative infinity.",
        "suggest": "将 `a` 中的包装的单精度 (32-bit) 浮点元素四舍五入为负无穷大。",
        "translate": ""
    },
    {
        "source": "Returns the square root of packed single-precision (32-bit) floating point elements in `a`.",
        "suggest": "返回 `a` 中包装的单精度 (32-bit) 浮点元素的平方根。",
        "translate": ""
    },
    {
        "source": "Returns the square root of packed double-precision (64-bit) floating point elements in `a`.",
        "suggest": "返回 `a` 中包装的双精度 (64-bit) 浮点元素的平方根。",
        "translate": ""
    },
    {
        "source": "Blends packed double-precision (64-bit) floating-point elements from `a` and `b` using control mask `imm8`.",
        "suggest": "使用控制掩码 `imm8` 混合来自 `a` 和 `b` 的包装后的双精度 (64-bit) 浮点元素。",
        "translate": ""
    },
    {
        "source": "LLVM7 prefers single-precision blend instructions when",
        "suggest": "LLVM7 在以下情况下更喜欢单精度混合指令",
        "translate": ""
    },
    {
        "source": "possible, see:",
        "suggest": "可能，请参见:",
        "translate": ""
    },
    {
        "source": "Blends packed single-precision (32-bit) floating-point elements from `a` and `b` using control mask `imm8`.",
        "suggest": "使用控制掩码 `imm8` 混合来自 `a` 和 `b` 的包装的单精度 (32-bit) 浮点元素。",
        "translate": ""
    },
    {
        "source": "Blends packed double-precision (64-bit) floating-point elements from `a` and `b` using `c` as a mask.",
        "suggest": "使用 `c` 作为掩码，混合来自 `a` 和 `b` 的包装后的双精度 (64-bit) 浮点元素。",
        "translate": ""
    },
    {
        "source": "Blends packed single-precision (32-bit) floating-point elements from `a` and `b` using `c` as a mask.",
        "suggest": "使用 `c` 作为掩码，混合来自 `a` 和 `b` 的包装的单精度 (32-bit) 浮点元素。",
        "translate": ""
    },
    {
        "source": "Conditionally multiplies the packed single-precision (32-bit) floating-point elements in `a` and `b` using the high 4 bits in `imm8`, sum the four products, and conditionally return the sum using the low 4 bits of `imm8`.",
        "suggest": "使用 `imm8` 的高 4 位有条件地将 `a` 和 `b` 中的包装的单精度 (32-bit) 浮点元素相乘，对四个乘积求和，并使用 `imm8` 的低 4 位有条件地返回总和。",
        "translate": ""
    },
    {
        "source": "Horizontal addition of adjacent pairs in the two packed vectors of 4 64-bit floating points `a` and `b`.",
        "suggest": "在 4 个 64 位浮点 `a` 和 `b` 的两个包装的 vectors 中水平相加相邻对。",
        "translate": ""
    },
    {
        "source": "In the result, sums of elements from `a` are returned in even locations, while sums of elements from `b` are returned in odd locations.",
        "suggest": "结果，来自 `a` 的元素之和在偶数位置返回，而来自 `b` 的元素之和在奇数位置返回。",
        "translate": ""
    },
    {
        "source": "Horizontal addition of adjacent pairs in the two packed vectors of 8 32-bit floating points `a` and `b`.",
        "suggest": "在 8 个 32 位浮点 `a` 和 `b` 的两个包装的 vectors 中水平相加相邻对。",
        "translate": ""
    },
    {
        "source": "In the result, sums of elements from `a` are returned in locations of indices 0, 1, 4, 5;",
        "suggest": "结果，来自 `a` 的元素之和返回到索引 0、1、4、5 的位置;",
        "translate": ""
    },
    {
        "source": "while sums of elements from `b` are locations",
        "suggest": "而 `b` 中的元素总和是位置",
        "translate": ""
    },
    {
        "source": "Horizontal subtraction of adjacent pairs in the two packed vectors of 4 64-bit floating points `a` and `b`.",
        "suggest": "在 4 个 64 位浮点 `a` 和 `b` 的两个包装的 vectors 中对相邻对进行水平减法。",
        "translate": ""
    },
    {
        "source": "Horizontal subtraction of adjacent pairs in the two packed vectors of 8 32-bit floating points `a` and `b`.",
        "suggest": "将 8 个 32 位浮点 `a` 和 `b` 的两个包装的 vectors 中的相邻对进行水平减法。",
        "translate": ""
    },
    {
        "source": "Computes the bitwise XOR of packed double-precision (64-bit) floating-point elements in `a` and `b`.",
        "suggest": "计算 `a` 和 `b` 中包装的双精度 (64-bit) 浮点元素的按位 XOR。",
        "translate": ""
    },
    {
        "source": "FIXME Should be 'vxorpd' instruction.",
        "suggest": "FIXME 应该是 'vxorpd' 指令。",
        "translate": ""
    },
    {
        "source": "Computes the bitwise XOR of packed single-precision (32-bit) floating-point elements in `a` and `b`.",
        "suggest": "计算 `a` 和 `b` 中包装的单精度 (32-bit) 浮点元素的按位 XOR。",
        "translate": ""
    },
    {
        "source": "Equal (ordered, non-signaling)",
        "suggest": "相等 (有序，无信号)",
        "translate": ""
    },
    {
        "source": "Less-than (ordered, signaling)",
        "suggest": "小于 (有序，发信号)",
        "translate": ""
    },
    {
        "source": "Less-than-or-equal (ordered, signaling)",
        "suggest": "小于或等于 (有序，发信号)",
        "translate": ""
    },
    {
        "source": "Unordered (non-signaling)",
        "suggest": "无序 (无信号)",
        "translate": ""
    },
    {
        "source": "Not-equal (unordered, non-signaling)",
        "suggest": "不相等 (无序，无信号)",
        "translate": ""
    },
    {
        "source": "Not-less-than (unordered, signaling)",
        "suggest": "不少于 (无序，发信号)",
        "translate": ""
    },
    {
        "source": "Not-less-than-or-equal (unordered, signaling)",
        "suggest": "不小于等于 (无序，发信号)",
        "translate": ""
    },
    {
        "source": "Ordered (non-signaling)",
        "suggest": "订购 (无信号)",
        "translate": ""
    },
    {
        "source": "Equal (unordered, non-signaling)",
        "suggest": "相等 (无序，无信号)",
        "translate": ""
    },
    {
        "source": "Not-greater-than-or-equal (unordered, signaling)",
        "suggest": "不大于等于 (无序，发信号)",
        "translate": ""
    },
    {
        "source": "Not-greater-than (unordered, signaling)",
        "suggest": "不大于 (无序，发信号)",
        "translate": ""
    },
    {
        "source": "False (ordered, non-signaling)",
        "suggest": "错误 (有序，无信号)",
        "translate": ""
    },
    {
        "source": "Not-equal (ordered, non-signaling)",
        "suggest": "不相等 (有序，无信号)",
        "translate": ""
    },
    {
        "source": "Greater-than-or-equal (ordered, signaling)",
        "suggest": "大于或等于 (有序，发信号)",
        "translate": ""
    },
    {
        "source": "Greater-than (ordered, signaling)",
        "suggest": "大于 (有序，发信号)",
        "translate": ""
    },
    {
        "source": "True (unordered, non-signaling)",
        "suggest": "真 (无序，无信号)",
        "translate": ""
    },
    {
        "source": "Equal (ordered, signaling)",
        "suggest": "相等 (有序，发信号)",
        "translate": ""
    },
    {
        "source": "Less-than (ordered, non-signaling)",
        "suggest": "小于 (有序，无信号)",
        "translate": ""
    },
    {
        "source": "Less-than-or-equal (ordered, non-signaling)",
        "suggest": "小于或等于 (有序，无信号)",
        "translate": ""
    },
    {
        "source": "Unordered (signaling)",
        "suggest": "无序 (发信号)",
        "translate": ""
    },
    {
        "source": "Not-equal (unordered, signaling)",
        "suggest": "不相等 (无序，发信号)",
        "translate": ""
    },
    {
        "source": "Not-less-than (unordered, non-signaling)",
        "suggest": "不少于 (无序，无信号)",
        "translate": ""
    },
    {
        "source": "Not-less-than-or-equal (unordered, non-signaling)",
        "suggest": "不小于等于 (无序，无信号)",
        "translate": ""
    },
    {
        "source": "Ordered (signaling)",
        "suggest": "订购 (发信号)",
        "translate": ""
    },
    {
        "source": "Equal (unordered, signaling)",
        "suggest": "相等 (无序，发信号)",
        "translate": ""
    },
    {
        "source": "Not-greater-than-or-equal (unordered, non-signaling)",
        "suggest": "不大于等于 (无序，无信号)",
        "translate": ""
    },
    {
        "source": "Not-greater-than (unordered, non-signaling)",
        "suggest": "不大于 (无序，无信号)",
        "translate": ""
    },
    {
        "source": "False (ordered, signaling)",
        "suggest": "错误 (有序，发信号)",
        "translate": ""
    },
    {
        "source": "Not-equal (ordered, signaling)",
        "suggest": "不相等 (有序，发信号)",
        "translate": ""
    },
    {
        "source": "Greater-than-or-equal (ordered, non-signaling)",
        "suggest": "大于或等于 (有序，无信号)",
        "translate": ""
    },
    {
        "source": "Greater-than (ordered, non-signaling)",
        "suggest": "大于 (有序，无信号)",
        "translate": ""
    },
    {
        "source": "True (unordered, signaling)",
        "suggest": "真 (无序，发信号)",
        "translate": ""
    },
    {
        "source": "Compares packed double-precision (64-bit) floating-point elements in `a` and `b` based on the comparison operand specified by `imm8`.",
        "suggest": "根据 `imm8` 指定的比较操作数，比较 `a` 和 `b` 中的包装的双精度 (64-bit) 浮点元素。",
        "translate": ""
    },
    {
        "source": "TODO Validate vcmppd",
        "suggest": "TODO 验证 vcmppd",
        "translate": ""
    },
    {
        "source": "Compares packed single-precision (32-bit) floating-point elements in `a` and `b` based on the comparison operand specified by `imm8`.",
        "suggest": "根据 `imm8` 指定的比较操作数，比较 `a` 和 `b` 中的包装单精度 (32-bit) 浮点元素。",
        "translate": ""
    },
    {
        "source": "TODO Validate vcmpps",
        "suggest": "TODO 验证 vcmpps",
        "translate": ""
    },
    {
        "source": "Compares the lower double-precision (64-bit) floating-point element in `a` and `b` based on the comparison operand specified by `imm8`, store the result in the lower element of returned vector, and copies the upper element from `a` to the upper element of returned vector.",
        "suggest": "根据 `imm8` 指定的比较操作数比较 `a` 和 `b` 中较低的双精度 (64-bit) 浮点元素，将结果存储在返回的 vector 的下部元素中，并将较高的元素从 `a` 复制到返回的 vector 的上部元素。",
        "translate": ""
    },
    {
        "source": "TODO Validate vcmpsd",
        "suggest": "TODO 验证 vcmpsd",
        "translate": ""
    },
    {
        "source": "Compares the lower single-precision (32-bit) floating-point element in `a` and `b` based on the comparison operand specified by `imm8`, store the result in the lower element of returned vector, and copies the upper 3 packed elements from `a` to the upper elements of returned vector.",
        "suggest": "根据 `imm8` 指定的比较操作数比较 `a` 和 `b` 中的较低单精度 (32-bit) 浮点元素，将结果存储在返回的 vector 的较低元素中，并将较高的 3 个包装的元素从 `a` 复制到返回的较高元素 vector。",
        "translate": ""
    },
    {
        "source": "TODO Validate vcmpss",
        "suggest": "TODO 验证 vcmpss",
        "translate": ""
    },
    {
        "source": "Converts packed 32-bit integers in `a` to packed double-precision (64-bit) floating-point elements.",
        "suggest": "将 `a` 中的包装的 32 位整数转换为包装的双精度 (64-bit) 浮点元素。",
        "translate": ""
    },
    {
        "source": "Converts packed 32-bit integers in `a` to packed single-precision (32-bit) floating-point elements.",
        "suggest": "将 `a` 中的包装的 32 位整数转换为包装的单精度 (32-bit) 浮点元素。",
        "translate": ""
    },
    {
        "source": "Converts packed double-precision (64-bit) floating-point elements in `a` to packed single-precision (32-bit) floating-point elements.",
        "suggest": "将 `a` 中的包装的双精度 (64-bit) 浮点元素转换为包装的单精度 (32-bit) 浮点元素。",
        "translate": ""
    },
    {
        "source": "Converts packed single-precision (32-bit) floating-point elements in `a` to packed 32-bit integers.",
        "suggest": "将 `a` 中的包装的单精度 (32-bit) 浮点元素转换为包装的 32 位整数。",
        "translate": ""
    },
    {
        "source": "Converts packed single-precision (32-bit) floating-point elements in `a` to packed double-precision (64-bit) floating-point elements.",
        "suggest": "将 `a` 中的包装的单精度 (32-bit) 浮点元素转换为包装的双精度 (64-bit) 浮点元素。",
        "translate": ""
    },
    {
        "source": "Converts packed double-precision (64-bit) floating-point elements in `a` to packed 32-bit integers with truncation.",
        "suggest": "将 `a` 中的包装的双精度 (64-bit) 浮点元素转换为带截断的包装的 32 位整数。",
        "translate": ""
    },
    {
        "source": "Converts packed double-precision (64-bit) floating-point elements in `a` to packed 32-bit integers.",
        "suggest": "将 `a` 中的包装的双精度 (64-bit) 浮点元素转换为包装的 32 位整数。",
        "translate": ""
    },
    {
        "source": "Converts packed single-precision (32-bit) floating-point elements in `a` to packed 32-bit integers with truncation.",
        "suggest": "将 `a` 中的包装的单精度 (32-bit) 浮点元素转换为带截断的包装的 32 位整数。",
        "translate": ""
    },
    {
        "source": "Extracts 128 bits (composed of 4 packed single-precision (32-bit) floating-point elements) from `a`, selected with `imm8`.",
        "suggest": "从 `a` 提取 128 位 (由 4 个包装的单精度 (32-bit) 浮点元素组成)，并用 `imm8` 选择。",
        "translate": ""
    },
    {
        "source": "Extracts 128 bits (composed of 2 packed double-precision (64-bit) floating-point elements) from `a`, selected with `imm8`.",
        "suggest": "从 `a` 提取 128 位 (由 2 个包装的双精度 (64-bit) 浮点元素组成)，并使用 `imm8` 进行选择。",
        "translate": ""
    },
    {
        "source": "Extracts 128 bits (composed of integer data) from `a`, selected with `imm8`.",
        "suggest": "从 `a` 中提取 128 位 (由整数数据组成)，并用 `imm8` 选择。",
        "translate": ""
    },
    {
        "source": "Zeroes the contents of all XMM or YMM registers.",
        "suggest": "将所有 XMM 或 YMM 寄存器的内容清零。",
        "translate": ""
    },
    {
        "source": "Zeroes the upper 128 bits of all YMM registers;",
        "suggest": "将所有 YMM 寄存器的高 128 位清零;",
        "translate": ""
    },
    {
        "source": "the lower 128-bits of the registers are unmodified.",
        "suggest": "寄存器的低 128 位保持不变。",
        "translate": ""
    },
    {
        "source": "Shuffles single-precision (32-bit) floating-point elements in `a` within 128-bit lanes using the control in `b`.",
        "suggest": "使用 `b` 中的控件在 128 位通道内对 `a` 中的单精度 (32-bit) 浮点元素进行混洗。",
        "translate": ""
    },
    {
        "source": "Shuffles single-precision (32-bit) floating-point elements in `a` using the control in `b`.",
        "suggest": "使用 `b` 中的控件对 `a` 中的单精度 (32-bit) 浮点元素进行混洗。",
        "translate": ""
    },
    {
        "source": "Shuffles single-precision (32-bit) floating-point elements in `a` within 128-bit lanes using the control in `imm8`.",
        "suggest": "使用 `imm8` 中的控件在 128 位通道内对 `a` 中的单精度 (32-bit) 浮点元素进行混洗。",
        "translate": ""
    },
    {
        "source": "Shuffles single-precision (32-bit) floating-point elements in `a` using the control in `imm8`.",
        "suggest": "使用 `imm8` 中的控件对 `a` 中的单精度 (32-bit) 浮点元素进行混洗。",
        "translate": ""
    },
    {
        "source": "Shuffles double-precision (64-bit) floating-point elements in `a` within 256-bit lanes using the control in `b`.",
        "suggest": "使用 `b` 中的控件在 256 位通道内对 `a` 中的双精度 (64-bit) 浮点元素进行混洗。",
        "translate": ""
    },
    {
        "source": "Shuffles double-precision (64-bit) floating-point elements in `a` using the control in `b`.",
        "suggest": "使用 `b` 中的控件对 `a` 中的双精度 (64-bit) 浮点元素进行混洗。",
        "translate": ""
    },
    {
        "source": "Shuffles double-precision (64-bit) floating-point elements in `a` within 128-bit lanes using the control in `imm8`.",
        "suggest": "使用 `imm8` 中的控件在 128 位通道内对 `a` 中的双精度 (64-bit) 浮点元素进行混洗。",
        "translate": ""
    },
    {
        "source": "Shuffles double-precision (64-bit) floating-point elements in `a` using the control in `imm8`.",
        "suggest": "使用 `imm8` 中的控件对 `a` 中的双精度 (64-bit) 浮点元素进行混洗。",
        "translate": ""
    },
    {
        "source": "Shuffles 256 bits (composed of 8 packed single-precision (32-bit) floating-point elements) selected by `imm8` from `a` and `b`.",
        "suggest": "混洗 256 位 (由 8 个包装的单精度 (32-bit) 浮点元素组成)，由 `imm8` 从 `a` 和 `b` 中选择。",
        "translate": ""
    },
    {
        "source": "Shuffles 256 bits (composed of 4 packed double-precision (64-bit) floating-point elements) selected by `imm8` from `a` and `b`.",
        "suggest": "混洗 256 位 (由 4 个包装的双精度 (64-bit) 浮点元素组成)，由 `imm8` 从 `a` 和 `b` 中选择。",
        "translate": ""
    },
    {
        "source": "Shuffles 128-bits (composed of integer data) selected by `imm8` from `a` and `b`.",
        "suggest": "重排 `imm8` 从 `a` 和 `b` 选择的 128 位 (由整数数据组成)。",
        "translate": ""
    },
    {
        "source": "Broadcasts a single-precision (32-bit) floating-point element from memory to all elements of the returned vector.",
        "suggest": "从内存向返回的 vector 的所有元素广播单精度 (32-bit) 浮点元素。",
        "translate": ""
    },
    {
        "source": "Broadcasts a double-precision (64-bit) floating-point element from memory to all elements of the returned vector.",
        "suggest": "从内存向返回的 vector 的所有元素广播双精度 (64-bit) 浮点元素。",
        "translate": ""
    },
    {
        "source": "Broadcasts 128 bits from memory (composed of 4 packed single-precision (32-bit) floating-point elements) to all elements of the returned vector.",
        "suggest": "从内存 (由 4 个包装的单精度 (32-bit) 浮点元素组成) 向广播的 vector 的所有元素广播 128 位。",
        "translate": ""
    },
    {
        "source": "Broadcasts 128 bits from memory (composed of 2 packed double-precision (64-bit) floating-point elements) to all elements of the returned vector.",
        "suggest": "将内存中的 128 位 (由 2 个包装的双精度 (64-bit) 浮点元素组成) 广播到返回的 vector 的所有元素。",
        "translate": ""
    },
    {
        "source": "Copies `a` to result, then inserts 128 bits (composed of 4 packed single-precision (32-bit) floating-point elements) from `b` into result at the location specified by `imm8`.",
        "suggest": "将 `a` 复制到结果中，然后将 `b` 中的 128 位 (由 4 个包装的单精度 (32-bit) 浮点元素组成) 插入 `imm8` 指定的位置的结果中。",
        "translate": ""
    },
    {
        "source": "Copies `a` to result, then inserts 128 bits (composed of 2 packed double-precision (64-bit) floating-point elements) from `b` into result at the location specified by `imm8`.",
        "suggest": "将 `a` 复制到结果中，然后将 `b` 中的 128 位 (由 2 个包装的双精度 (64-bit) 浮点元素组成) 插入 `imm8` 指定的位置的结果中。",
        "translate": ""
    },
    {
        "source": "Copies `a` to result, then inserts 128 bits from `b` into result at the location specified by `imm8`.",
        "suggest": "复制 `a` 到结果，然后将 `b` 中的 128 位插入到 `imm8` 指定的位置的结果中。",
        "translate": ""
    },
    {
        "source": "Copies `a` to result, and inserts the 8-bit integer `i` into result at the location specified by `index`.",
        "suggest": "复制 `a` 到结果，并在 `index` 指定的位置将 8 位整数 `i` 插入到结果中。",
        "translate": ""
    },
    {
        "source": "This intrinsic has no corresponding instruction.",
        "suggest": "此内联函数没有相应的指令。",
        "translate": ""
    },
    {
        "source": "Copies `a` to result, and inserts the 16-bit integer `i` into result at the location specified by `index`.",
        "suggest": "复制 `a` 到结果，并在 `index` 指定的位置将 16 位整数 `i` 插入到 result 中。",
        "translate": ""
    },
    {
        "source": "Copies `a` to result, and inserts the 32-bit integer `i` into result at the location specified by `index`.",
        "suggest": "复制 `a` 到结果，然后在 `index` 指定的位置将 32 位整数 `i` 插入到结果中。",
        "translate": ""
    },
    {
        "source": "Loads 256-bits (composed of 4 packed double-precision (64-bit) floating-point elements) from memory into result.",
        "suggest": "从内存中将 256 位 (由 4 个包装的双精度 (64-bit) 浮点元素组成) 加载到结果中。",
        "translate": ""
    },
    {
        "source": "must be aligned on a 32-byte boundary or a general-protection exception may be generated.",
        "suggest": "必须在 32 字节边界上对齐，否则可能会产生一般保护异常。",
        "translate": ""
    },
    {
        "source": "FIXME vmovapd expected",
        "suggest": "FIXME vmovapd 预期",
        "translate": ""
    },
    {
        "source": "Stores 256-bits (composed of 4 packed double-precision (64-bit) floating-point elements) from `a` into memory.",
        "suggest": "将来自 `a` 的 256 位 (由 4 个包装的双精度 (64-bit) 浮点元素组成) 存储到内存中。",
        "translate": ""
    },
    {
        "source": "Loads 256-bits (composed of 8 packed single-precision (32-bit) floating-point elements) from memory into result.",
        "suggest": "从内存中将 256 位 (由 8 个包装的单精度 (32-bit) 浮点元素组成) 加载到结果中。",
        "translate": ""
    },
    {
        "source": "Stores 256-bits (composed of 8 packed single-precision (32-bit) floating-point elements) from `a` into memory.",
        "suggest": "将来自 `a` 的 256 位 (由 8 个包装的单精度 (32-bit) 浮点元素组成) 存储到内存中。",
        "translate": ""
    },
    {
        "source": "does not need to be aligned on any particular boundary.",
        "suggest": "不需要在任何特定边界上对齐。",
        "translate": ""
    },
    {
        "source": "FIXME vmovupd expected",
        "suggest": "FIXME vmovupd 预期",
        "translate": ""
    },
    {
        "source": "Loads 256-bits of integer data from memory into result.",
        "suggest": "从内存中将 256 位整数数据加载到结果中。",
        "translate": ""
    },
    {
        "source": "FIXME vmovdqa expected",
        "suggest": "FIXME vmovdqa 预期",
        "translate": ""
    },
    {
        "source": "Stores 256-bits of integer data from `a` into memory.",
        "suggest": "将来自 `a` 的 256 位整数数据存储到内存中。",
        "translate": ""
    },
    {
        "source": "FIXME vmovdqu expected",
        "suggest": "FIXME vmovdqu 预期",
        "translate": ""
    },
    {
        "source": "Loads packed double-precision (64-bit) floating-point elements from memory into result using `mask` (elements are zeroed out when the high bit of the corresponding element is not set).",
        "suggest": "使用 `mask` 将包装的双精度 (64-bit) 浮点元素从内存加载到结果中 (当未设置相应元素的高位时，元素清零)。",
        "translate": ""
    },
    {
        "source": "Stores packed double-precision (64-bit) floating-point elements from `a` into memory using `mask`.",
        "suggest": "使用 `mask` 将包装的双精度 (64-bit) 浮点元素从 `a` 存储到内存中。",
        "translate": ""
    },
    {
        "source": "Loads packed single-precision (32-bit) floating-point elements from memory into result using `mask` (elements are zeroed out when the high bit of the corresponding element is not set).",
        "suggest": "使用 `mask` 将包装的单精度 (32-bit) 浮点元素从内存加载到结果中 (当未设置相应元素的高位时，元素清零)。",
        "translate": ""
    },
    {
        "source": "Stores packed single-precision (32-bit) floating-point elements from `a` into memory using `mask`.",
        "suggest": "使用 `mask` 将包装的单精度 (32-bit) 浮点元素从 `a` 存储到内存中。",
        "translate": ""
    },
    {
        "source": "Duplicate odd-indexed single-precision (32-bit) floating-point elements from `a`, and returns the results.",
        "suggest": "从 `a` 复制奇数索引的单精度 (32-bit) 浮点元素，并返回结果。",
        "translate": ""
    },
    {
        "source": "Duplicate even-indexed single-precision (32-bit) floating-point elements from `a`, and returns the results.",
        "suggest": "从 `a` 复制偶数索引的单精度 (32-bit) 浮点元素，并返回结果。",
        "translate": ""
    },
    {
        "source": "Duplicate even-indexed double-precision (64-bit) floating-point elements from `a`, and returns the results.",
        "suggest": "从 `a` 复制偶数索引的双精度 (64-bit) 浮点元素，并返回结果。",
        "translate": ""
    },
    {
        "source": "Loads 256-bits of integer data from unaligned memory into result.",
        "suggest": "从未对齐的内存中将 256 位整数数据加载到结果中。",
        "translate": ""
    },
    {
        "source": "This intrinsic may perform better than `_mm256_loadu_si256` when the data crosses a cache line boundary.",
        "suggest": "当数据越过缓存行边界时，此内联函数可能比 `_mm256_loadu_si256` 更好。",
        "translate": ""
    },
    {
        "source": "Moves integer data from a 256-bit integer vector to a 32-byte aligned memory location.",
        "suggest": "将整数数据从 256 位整数 vector 移动到 32 字节对齐的内存位置。",
        "translate": ""
    },
    {
        "source": "To minimize caching, the data is flagged as non-temporal (unlikely to be used again soon)",
        "suggest": "为了最大程度地减少缓存，数据被标记为非时间性的 (不太可能很快再次使用)",
        "translate": ""
    },
    {
        "source": "Moves double-precision values from a 256-bit vector of `[4 x double]` to a 32-byte aligned memory location.",
        "suggest": "将双精度值从 `[4 x double]` 的 256 位 vector 移动到 32 字节对齐的内存位置。",
        "translate": ""
    },
    {
        "source": "To minimize caching, the data is flagged as non-temporal (unlikely to be used again soon).",
        "suggest": "为了最大程度地减少缓存，数据被标记为非时间性的 (不太可能很快再次使用)。",
        "translate": ""
    },
    {
        "source": "Moves single-precision floating point values from a 256-bit vector of `[8 x float]` to a 32-byte aligned memory location.",
        "suggest": "将单精度浮点值从 `[8 x float]` 的 256 位 vector 移到 32 字节对齐的内存位置。",
        "translate": ""
    },
    {
        "source": "Computes the approximate reciprocal of packed single-precision (32-bit) floating-point elements in `a`, and returns the results.",
        "suggest": "计算 `a` 中包装的单精度 (32-bit) 浮点元素的近似倒数，并返回结果。",
        "translate": ""
    },
    {
        "source": "The maximum relative error for this approximation is less than 1.5*2^-12.",
        "suggest": "该近似值的最大相对误差小于 1.5*2^-12。",
        "translate": ""
    },
    {
        "source": "Computes the approximate reciprocal square root of packed single-precision (32-bit) floating-point elements in `a`, and returns the results.",
        "suggest": "计算 `a` 中包装的单精度 (32-bit) 浮点元素的近似倒数平方根，并返回结果。",
        "translate": ""
    },
    {
        "source": "Unpacks and interleave double-precision (64-bit) floating-point elements from the high half of each 128-bit lane in `a` and `b`.",
        "suggest": "从 `a` 和 `b` 中每个 128 位通道的上半部分解包并交织双精度 (64-bit) 浮点元素。",
        "translate": ""
    },
    {
        "source": "Unpacks and interleave single-precision (32-bit) floating-point elements from the high half of each 128-bit lane in `a` and `b`.",
        "suggest": "从 `a` 和 `b` 中每个 128 位通道的高半部分解包并交织单精度 (32-bit) 浮点元素。",
        "translate": ""
    },
    {
        "source": "Unpacks and interleave double-precision (64-bit) floating-point elements from the low half of each 128-bit lane in `a` and `b`.",
        "suggest": "从 `a` 和 `b` 中每个 128 位通道的下半部分解包并交织双精度 (64-bit) 浮点元素。",
        "translate": ""
    },
    {
        "source": "Unpacks and interleave single-precision (32-bit) floating-point elements from the low half of each 128-bit lane in `a` and `b`.",
        "suggest": "从 `a` 和 `b` 中每个 128 位通道的下半部分解包并交织单精度 (32-bit) 浮点元素。",
        "translate": ""
    },
    {
        "source": "Computes the bitwise AND of 256 bits (representing integer data) in `a` and `b`, and set `ZF` to 1 if the result is zero, otherwise set `ZF` to 0.",
        "suggest": "计算 `a` 和 `b` 中 256 位 (表示整数数据) 的按位与，如果结果为零，则将 `ZF` 设置为 1，否则将 `ZF` 设置为 0。",
        "translate": ""
    },
    {
        "source": "Computes the bitwise NOT of `a` and then AND with `b`, and set `CF` to 1 if the result is zero, otherwise set `CF` to 0.",
        "suggest": "计算 `a` 的按位 NOT，然后计算 `b` 的 AND，如果结果为零，则将 `CF` 设置为 1，否则将 `CF` 设置为 0。",
        "translate": ""
    },
    {
        "source": "Return the `ZF` value.",
        "suggest": "返回 `ZF` 值。",
        "translate": ""
    },
    {
        "source": "Return 1 if both the `ZF` and `CF` values are zero, otherwise return 0.",
        "suggest": "如果 `ZF` 和 `CF` 的值均为零，则返回 1，否则返回 0。",
        "translate": ""
    },
    {
        "source": "Computes the bitwise AND of 256 bits (representing double-precision (64-bit) floating-point elements) in `a` and `b`, producing an intermediate 256-bit value, and set `ZF` to 1 if the sign bit of each 64-bit element in the intermediate value is zero, otherwise set `ZF` to 0.",
        "suggest": "计算 `a` 和 `b` 中 256 位 (表示双精度 (64-bit) 浮点元素) 的按位与，生成中间 256 位值，如果中间值中每个 64 位元素的符号位都将 `ZF` 设置为 1 为零，否则将 `ZF` 设置为 0。",
        "translate": ""
    },
    {
        "source": "Compute the bitwise NOT of `a` and then AND with `b`, producing an intermediate value, and set `CF` to 1 if the sign bit of each 64-bit element in the intermediate value is zero, otherwise set `CF` to 0.",
        "suggest": "计算 `a` 的按位 NOT，然后与 `b` 进行与运算，得到一个中间值，如果中间值中每个 64 位元素的符号位为零，则将 `CF` 设置为 1，否则将 `CF` 设置为 0。",
        "translate": ""
    },
    {
        "source": "Return the `CF` value.",
        "suggest": "返回 `CF` 值。",
        "translate": ""
    },
    {
        "source": "Computes the bitwise AND of 128 bits (representing double-precision (64-bit) floating-point elements) in `a` and `b`, producing an intermediate 128-bit value, and set `ZF` to 1 if the sign bit of each 64-bit element in the intermediate value is zero, otherwise set `ZF` to 0.",
        "suggest": "计算 `a` 和 `b` 中 128 位 (表示双精度 (64-bit) 浮点元素) 的按位与，产生中间 128 位值，如果中间值中每个 64 位元素的符号位都将 `ZF` 设置为 1 为零，否则将 `ZF` 设置为 0。",
        "translate": ""
    },
    {
        "source": "Computes the bitwise AND of 256 bits (representing single-precision (32-bit) floating-point elements) in `a` and `b`, producing an intermediate 256-bit value, and set `ZF` to 1 if the sign bit of each 32-bit element in the intermediate value is zero, otherwise set `ZF` to 0.",
        "suggest": "计算 `a` 和 `b` 中 256 位 (表示单精度 (32-bit) 浮点元素) 的按位与，生成中间 256 位值，如果中间值中每个 32 位元素的符号位都将 `ZF` 设置为 1 为零，否则将 `ZF` 设置为 0。",
        "translate": ""
    },
    {
        "source": "Compute the bitwise NOT of `a` and then AND with `b`, producing an intermediate value, and set `CF` to 1 if the sign bit of each 32-bit element in the intermediate value is zero, otherwise set `CF` to 0.",
        "suggest": "计算 `a` 的按位非，然后与 `b` 进行与运算，产生一个中间值，如果中间值中每个 32 位元素的符号位为零，则将 `CF` 设置为 1，否则将 `CF` 设置为 0。",
        "translate": ""
    },
    {
        "source": "Computes the bitwise AND of 128 bits (representing single-precision (32-bit) floating-point elements) in `a` and `b`, producing an intermediate 128-bit value, and set `ZF` to 1 if the sign bit of each 32-bit element in the intermediate value is zero, otherwise set `ZF` to 0.",
        "suggest": "计算 `a` 和 `b` 中 128 位 (代表单精度 (32-bit) 浮点元素) 的 128 位按位与，生成中间 128 位值，如果中间值中每个 32 位元素的符号位都将 `ZF` 设置为 1 为零，否则将 `ZF` 设置为 0。",
        "translate": ""
    },
    {
        "source": "Sets each bit of the returned mask based on the most significant bit of the corresponding packed double-precision (64-bit) floating-point element in `a`.",
        "suggest": "根据 `a` 中相应的包装的双精度 (64-bit) 浮点元素的最高有效位设置返回掩码的每一位。",
        "translate": ""
    },
    {
        "source": "Sets each bit of the returned mask based on the most significant bit of the corresponding packed single-precision (32-bit) floating-point element in `a`.",
        "suggest": "基于 `a` 中相应的包装单精度 (32-bit) 浮点元素的最高有效位来设置返回掩码的每一位。",
        "translate": ""
    },
    {
        "source": "Returns vector of type __m256d with all elements set to zero.",
        "suggest": "返回 __m256d 类型的 vector，所有元素均设置为零。",
        "translate": ""
    },
    {
        "source": "FIXME vxorpd expected",
        "suggest": "FIXME vxorpd 预期",
        "translate": ""
    },
    {
        "source": "Returns vector of type __m256 with all elements set to zero.",
        "suggest": "返回 __m256 类型的 vector，所有元素都设置为零。",
        "translate": ""
    },
    {
        "source": "Returns vector of type __m256i with all elements set to zero.",
        "suggest": "返回类型为 __m256i 的 vector，所有元素均设置为零。",
        "translate": ""
    },
    {
        "source": "Sets packed double-precision (64-bit) floating-point elements in returned vector with the supplied values.",
        "suggest": "使用提供的值在返回的 vector 中设置包装的双精度 (64-bit) 浮点元素。",
        "translate": ""
    },
    {
        "source": "Sets packed single-precision (32-bit) floating-point elements in returned vector with the supplied values.",
        "suggest": "使用提供的值在返回的 vector 中设置包装的单精度 (32-bit) 浮点元素。",
        "translate": ""
    },
    {
        "source": "Sets packed 8-bit integers in returned vector with the supplied values in reverse order.",
        "suggest": "在返回的 vector 中设置包装的 8 位整数，并以相反的顺序提供所提供的值。",
        "translate": ""
    },
    {
        "source": "Sets packed 16-bit integers in returned vector with the supplied values.",
        "suggest": "使用提供的值在返回的 vector 中设置包装的 16 位整数。",
        "translate": ""
    },
    {
        "source": "Sets packed 32-bit integers in returned vector with the supplied values.",
        "suggest": "使用提供的值在返回的 vector 中设置包装的 32 位整数。",
        "translate": ""
    },
    {
        "source": "Sets packed 64-bit integers in returned vector with the supplied values.",
        "suggest": "使用提供的值在返回的 vector 中设置包装的 64 位整数。",
        "translate": ""
    },
    {
        "source": "Sets packed double-precision (64-bit) floating-point elements in returned vector with the supplied values in reverse order.",
        "suggest": "在返回的 vector 中使用反向提供的值设置包装的双精度 (64-bit) 浮点元素。",
        "translate": ""
    },
    {
        "source": "Sets packed single-precision (32-bit) floating-point elements in returned vector with the supplied values in reverse order.",
        "suggest": "在返回的 vector 中使用反向提供的值设置包装的单精度 (32-bit) 浮点元素。",
        "translate": ""
    },
    {
        "source": "Sets packed 16-bit integers in returned vector with the supplied values in reverse order.",
        "suggest": "在返回的 vector 中设置包装的 16 位整数，其提供的值的顺序相反。",
        "translate": ""
    },
    {
        "source": "Sets packed 32-bit integers in returned vector with the supplied values in reverse order.",
        "suggest": "在返回的 vector 中设置包装的 32 位整数，并以相反的顺序提供所提供的值。",
        "translate": ""
    },
    {
        "source": "Sets packed 64-bit integers in returned vector with the supplied values in reverse order.",
        "suggest": "在返回的 vector 中设置包装的 64 位整数，其提供的值的顺序相反。",
        "translate": ""
    },
    {
        "source": "Broadcasts double-precision (64-bit) floating-point value `a` to all elements of returned vector.",
        "suggest": "向返回的 vector 的所有元素广播双精度 (64-bit) 浮点值 `a`。",
        "translate": ""
    },
    {
        "source": "Broadcasts single-precision (32-bit) floating-point value `a` to all elements of returned vector.",
        "suggest": "向返回的 vector 的所有元素广播单精度 (32-bit) 浮点值 `a`。",
        "translate": ""
    },
    {
        "source": "Broadcasts 8-bit integer `a` to all elements of returned vector.",
        "suggest": "向返回的 vector 的所有元素广播 8 位整数 `a`。",
        "translate": ""
    },
    {
        "source": "This intrinsic may generate the `vpbroadcastb`.",
        "suggest": "此内联函数可能会生成 `vpbroadcastb`。",
        "translate": ""
    },
    {
        "source": "Broadcasts 16-bit integer `a` to all all elements of returned vector.",
        "suggest": "向返回的 vector 的所有所有元素广播 16 位整数 `a`。",
        "translate": ""
    },
    {
        "source": "This intrinsic may generate the `vpbroadcastw`.",
        "suggest": "此内联函数可能会生成 `vpbroadcastw`。",
        "translate": ""
    },
    {
        "source": "Broadcasts 32-bit integer `a` to all elements of returned vector.",
        "suggest": "向返回的 vector 的所有元素广播 32 位整数 `a`。",
        "translate": ""
    },
    {
        "source": "This intrinsic may generate the `vpbroadcastd`.",
        "suggest": "此内联函数可能会生成 `vpbroadcastd`。",
        "translate": ""
    },
    {
        "source": "Broadcasts 64-bit integer `a` to all elements of returned vector.",
        "suggest": "向返回的 vector 的所有元素广播 64 位整数 `a`。",
        "translate": ""
    },
    {
        "source": "This intrinsic may generate the `vpbroadcastq`.",
        "suggest": "此内联函数可能会生成 `vpbroadcastq`。",
        "translate": ""
    },
    {
        "source": "Cast vector of type __m256d to type __m256.",
        "suggest": "将类型为 __m256d 的 vector 强制转换为类型为 __m256 的 vector。",
        "translate": ""
    },
    {
        "source": "This intrinsic is only used for compilation and does not generate any instructions, thus it has zero latency.",
        "suggest": "此内联函数仅用于编译，不会生成任何指令，因此延迟为零。",
        "translate": ""
    },
    {
        "source": "Cast vector of type __m256 to type __m256d.",
        "suggest": "将类型为 __m256 的 vector 强制转换为类型为 __m256d 的 vector。",
        "translate": ""
    },
    {
        "source": "Casts vector of type __m256 to type __m256i.",
        "suggest": "将类型为 __m256 的 vector 强制转换为类型为 __m256i 的 vector。",
        "translate": ""
    },
    {
        "source": "Casts vector of type __m256i to type __m256.",
        "suggest": "将类型为 __m256i 的 vector 强制转换为类型为 __m256 的 vector。",
        "translate": ""
    },
    {
        "source": "Casts vector of type __m256d to type __m256i.",
        "suggest": "将类型为 __m256d 的 vector 强制转换为类型为 __m256i 的 vector。",
        "translate": ""
    },
    {
        "source": "Casts vector of type __m256i to type __m256d.",
        "suggest": "将类型为 __m256i 的 vector 强制转换为类型为 __m256d 的 vector。",
        "translate": ""
    },
    {
        "source": "Casts vector of type __m256 to type __m128.",
        "suggest": "将类型为 __m256 的 vector 强制转换为类型为 __m128 的 vector。",
        "translate": ""
    },
    {
        "source": "Casts vector of type __m256d to type __m128d.",
        "suggest": "将类型为 __m256d 的 vector 强制转换为类型为 __m128d 的 vector。",
        "translate": ""
    },
    {
        "source": "Casts vector of type __m256i to type __m128i.",
        "suggest": "将类型为 __m256i 的 vector 强制转换为类型为 __m128i 的 vector。",
        "translate": ""
    },
    {
        "source": "Casts vector of type __m128 to type __m256;",
        "suggest": "将类型 __m128 的 vector 转换为 __m256 类型;",
        "translate": ""
    },
    {
        "source": "the upper 128 bits of the result are undefined.",
        "suggest": "结果的高 128 位未定义。",
        "translate": ""
    },
    {
        "source": "Casts vector of type __m128d to type __m256d;",
        "suggest": "将类型 __m128d 的 vector 转换为 __m256d 类型;",
        "translate": ""
    },
    {
        "source": "Casts vector of type __m128i to type __m256i;",
        "suggest": "将类型为 __m128i 的 vector 强制转换为类型 __m256i;",
        "translate": ""
    },
    {
        "source": "Constructs a 256-bit floating-point vector of `[8 x float]` from a",
        "suggest": "从 a 创建一个 `[8 x float]` 的 256 位浮点 vector",
        "translate": ""
    },
    {
        "source": "128-bit floating-point vector of `[4 x float]`.",
        "suggest": "`[4 x float]` 的 128 位浮点 vector。",
        "translate": ""
    },
    {
        "source": "The lower 128 bits contain the value of the source vector.",
        "suggest": "低 128 位包含源 vector 的值。",
        "translate": ""
    },
    {
        "source": "The upper 128 bits are set to zero.",
        "suggest": "高 128 位设置为零。",
        "translate": ""
    },
    {
        "source": "Constructs a 256-bit integer vector from a 128-bit integer vector.",
        "suggest": "从 128 位整数 vector 创建一个 256 位整数 vector。",
        "translate": ""
    },
    {
        "source": "128 bits are set to zero.",
        "suggest": "128 位设置为零。",
        "translate": ""
    },
    {
        "source": "Constructs a 256-bit floating-point vector of `[4 x double]` from a",
        "suggest": "从 a 创建一个 `[4 x double]` 的 256 位浮点 vector",
        "translate": ""
    },
    {
        "source": "128-bit floating-point vector of `[2 x double]`.",
        "suggest": "`[2 x double]` 的 128 位浮点 vector。",
        "translate": ""
    },
    {
        "source": "Returns vector of type `__m256` with undefined elements.",
        "suggest": "返回带有未定义元素的 `__m256` 类型的 vector。",
        "translate": ""
    },
    {
        "source": "Returns vector of type `__m256d` with undefined elements.",
        "suggest": "返回带有未定义元素的 `__m256d` 类型的 vector。",
        "translate": ""
    },
    {
        "source": "Returns vector of type __m256i with undefined elements.",
        "suggest": "返回带有未定义元素的 __m256i 类型的 vector。",
        "translate": ""
    },
    {
        "source": "this function should return MaybeUninit<__m256i>",
        "suggest": "该函数应返回 MaybeUninit<__m256i>",
        "translate": ""
    },
    {
        "source": "Sets packed __m256 returned vector with the supplied values.",
        "suggest": "设置包装的 __m256 返回的 vector 与提供的值。",
        "translate": ""
    },
    {
        "source": "Sets packed __m256d returned vector with the supplied values.",
        "suggest": "设置包装的 __m256d 返回的 vector 具有提供的值。",
        "translate": ""
    },
    {
        "source": "Sets packed __m256i returned vector with the supplied values.",
        "suggest": "包装的 __m256i 集合使用提供的值返回 vector。",
        "translate": ""
    },
    {
        "source": "Loads two 128-bit values (composed of 4 packed single-precision (32-bit) floating-point elements) from memory, and combine them into a 256-bit value.",
        "suggest": "从内存中加载两个 128 位值 (由 4 个包装的单精度 (32-bit) 浮点元素组成)，并将它们组合为 256 位值。",
        "translate": ""
    },
    {
        "source": "and `loaddr` do not need to be aligned on any particular boundary.",
        "suggest": "`loaddr` 和 `loaddr` 不需要在任何特定边界上对齐。",
        "translate": ""
    },
    {
        "source": "Loads two 128-bit values (composed of 2 packed double-precision (64-bit) floating-point elements) from memory, and combine them into a 256-bit value.",
        "suggest": "从内存中加载两个 128 位值 (由 2 个包装的双精度 (64-bit) 浮点元素组成)，并将它们组合为 256 位值。",
        "translate": ""
    },
    {
        "source": "Loads two 128-bit values (composed of integer data) from memory, and combine them into a 256-bit value.",
        "suggest": "从内存中加载两个 128 位值 (由整数数据组成)，并将它们组合为 256 位值。",
        "translate": ""
    },
    {
        "source": "Stores the high and low 128-bit halves (each composed of 4 packed single-precision (32-bit) floating-point elements) from `a` into memory two different 128-bit locations.",
        "suggest": "将来自 `a` 的高和低 128 位半部分 (每个半部分由 4 个包装的单精度 (32-bit) 浮点元素组成) 存储到内存中两个不同的 128 位位置。",
        "translate": ""
    },
    {
        "source": "Stores the high and low 128-bit halves (each composed of 2 packed double-precision (64-bit) floating-point elements) from `a` into memory two different 128-bit locations.",
        "suggest": "将来自 `a` 的高和低 128 位半部分 (每个半部分由 2 个包装的双精度 (64-bit) 浮点元素组成) 存储到内存中两个不同的 128 位位置。",
        "translate": ""
    },
    {
        "source": "Stores the high and low 128-bit halves (each composed of integer data) from `a` into memory two different 128-bit locations.",
        "suggest": "将来自 `a` 的高 128 位和低 128 位 (分别由整数数据组成) 存储到内存中两个不同的 128 位位置。",
        "translate": ""
    },
    {
        "source": "Returns the first element of the input vector of `[8 x float]`.",
        "suggest": "返回 `[8 x float]` 的输入 vector 的第一个元素。",
        "translate": ""
    },
    {
        "source": "LLVM intrinsics used in the above functions",
        "suggest": "以上函数中使用的 LLVM 内联函数",
        "translate": ""
    },
    {
        "source": "if the most significant bit of b is set, then the destination byte is set to 0.",
        "suggest": "如果设置了 b 的最高有效位，则目标字节设置为 0。",
        "translate": ""
    },
    {
        "source": "Advanced Vector Extensions 2 (AVX)",
        "suggest": "高级 Vector 扩展 2 (AVX)",
        "translate": ""
    },
    {
        "source": "expands most AVX commands to 256-bit wide vector registers and adds [FMA](https://en.wikipedia.org/wiki/Fused_multiply-accumulate).",
        "suggest": "将大多数 AVX 命令扩展到 256 位宽的 vector 寄存器，并添加 [FMA](https://en.wikipedia.org/wiki/Fused_multiply-accumulate)。",
        "translate": ""
    },
    {
        "source": "Wikipedia's [AVX][wiki_avx] and [FMA][wiki_fma] pages provide a quick overview of the instructions available.",
        "suggest": "Wikipedia 的 [AVX][wiki_avx] 和 [FMA][wiki_fma] 页面提供了对可用说明的快速概述。",
        "translate": ""
    },
    {
        "source": "Computes the absolute values of packed 32-bit integers in `a`.",
        "suggest": "计算 `a` 中包装的 32 位整数的绝对值。",
        "translate": ""
    },
    {
        "source": "Computes the absolute values of packed 16-bit integers in `a`.",
        "suggest": "计算 `a` 中包装的 16 位整数的绝对值。",
        "translate": ""
    },
    {
        "source": "Computes the absolute values of packed 8-bit integers in `a`.",
        "suggest": "计算 `a` 中包装的 8 位整数的绝对值。",
        "translate": ""
    },
    {
        "source": "Adds packed 64-bit integers in `a` and `b`.",
        "suggest": "在 `a` 和 `b` 中添加包装的 64 位整数。",
        "translate": ""
    },
    {
        "source": "Adds packed 32-bit integers in `a` and `b`.",
        "suggest": "在 `a` 和 `b` 中添加包装的 32 位整数。",
        "translate": ""
    },
    {
        "source": "Adds packed 16-bit integers in `a` and `b`.",
        "suggest": "在 `a` 和 `b` 中添加包装的 16 位整数。",
        "translate": ""
    },
    {
        "source": "Adds packed 8-bit integers in `a` and `b`.",
        "suggest": "在 `a` 和 `b` 中添加包装的 8 位整数。",
        "translate": ""
    },
    {
        "source": "Adds packed 8-bit integers in `a` and `b` using saturation.",
        "suggest": "使用饱和度在 `a` 和 `b` 中添加包装的 8 位整数。",
        "translate": ""
    },
    {
        "source": "Adds packed 16-bit integers in `a` and `b` using saturation.",
        "suggest": "使用饱和度在 `a` 和 `b` 中添加包装的 16 位整数。",
        "translate": ""
    },
    {
        "source": "Adds packed unsigned 8-bit integers in `a` and `b` using saturation.",
        "suggest": "使用饱和度在 `a` 和 `b` 中添加包装的无符号 8 位整数。",
        "translate": ""
    },
    {
        "source": "Adds packed unsigned 16-bit integers in `a` and `b` using saturation.",
        "suggest": "使用饱和度在 `a` 和 `b` 中添加包装的无符号 16 位整数。",
        "translate": ""
    },
    {
        "source": "Concatenates pairs of 16-byte blocks in `a` and `b` into a 32-byte temporary result, shifts the result right by `n` bytes, and returns the low 16 bytes.",
        "suggest": "将 `a` 和 `b` 中的 16 字节块对连接成一个 32 字节的临时结果，将结果右移 `n` 字节，然后返回低 16 字节。",
        "translate": ""
    },
    {
        "source": "If `palignr` is shifting the pair of vectors more than the size of two lanes, emit zero.",
        "suggest": "如果 `palignr` 对 vectors 的偏移量大于两个通道的大小，则发出零。",
        "translate": ""
    },
    {
        "source": "If `palignr` is shifting the pair of input vectors more than one lane, but less than two lanes, convert to shifting in zeroes.",
        "suggest": "如果 `palignr` 将一对输入 vectors 移位多于一个通道，但少于两个通道，则转换为移位为零。",
        "translate": ""
    },
    {
        "source": "Computes the bitwise AND of 256 bits (representing integer data) in `a` and `b`.",
        "suggest": "计算 `a` 和 `b` 中 256 位 (代表整数数据) 的按位与。",
        "translate": ""
    },
    {
        "source": "Computes the bitwise NOT of 256 bits (representing integer data) in `a` and then AND with `b`.",
        "suggest": "计算 `a` 中 256 位 (代表整数数据) 的按位非，然后计算 `b` 的与。",
        "translate": ""
    },
    {
        "source": "Averages packed unsigned 16-bit integers in `a` and `b`.",
        "suggest": "`a` 和 `b` 中的包装无符号 16 位整数的平均值。",
        "translate": ""
    },
    {
        "source": "Averages packed unsigned 8-bit integers in `a` and `b`.",
        "suggest": "`a` 和 `b` 中的包装无符号 8 位整数的平均值。",
        "translate": ""
    },
    {
        "source": "Blends packed 32-bit integers from `a` and `b` using control mask `imm8`.",
        "suggest": "使用控制掩码 `imm8` 混合 `a` 和 `b` 中的包装 32 位整数。",
        "translate": ""
    },
    {
        "source": "Blends packed 16-bit integers from `a` and `b` using control mask `imm8`.",
        "suggest": "使用控制掩码 `imm8` 混合来自 `a` 和 `b` 的包装的 16 位整数。",
        "translate": ""
    },
    {
        "source": "Blends packed 8-bit integers from `a` and `b` using `mask`.",
        "suggest": "使用 `mask` 混合来自 `a` 和 `b` 的包装的 8 位整数。",
        "translate": ""
    },
    {
        "source": "Broadcasts the low packed 8-bit integer from `a` to all elements of the 128-bit returned value.",
        "suggest": "将 `a` 的低位包装 8 位整数广播到 128 位返回值的所有元素。",
        "translate": ""
    },
    {
        "source": "Broadcasts the low packed 8-bit integer from `a` to all elements of the 256-bit returned value.",
        "suggest": "将 `a` 的低位包装 8 位整数广播到 256 位返回值的所有元素。",
        "translate": ""
    },
    {
        "source": "N.B., `simd_shuffle4` with integer data types for `a` and `b` is often compiled to `vbroadcastss`.",
        "suggest": "注意，对于 `a` 和 `b`，具有整数数据类型的 `simd_shuffle4` 通常被编译为 `vbroadcastss`。",
        "translate": ""
    },
    {
        "source": "Broadcasts the low packed 32-bit integer from `a` to all elements of the 128-bit returned value.",
        "suggest": "将 `a` 的低位包装 32 位整数广播到 128 位返回值的所有元素。",
        "translate": ""
    },
    {
        "source": "N.B., `simd_shuffle4`` with integer data types for `a` and `b` is often compiled to `vbroadcastss`.",
        "suggest": "注意，对于 `a` 和 `b`，具有整数数据类型的 `simd_shuffle4`` 通常被编译为 `vbroadcastss`。",
        "translate": ""
    },
    {
        "source": "Broadcasts the low packed 32-bit integer from `a` to all elements of the 256-bit returned value.",
        "suggest": "将 `a` 的低位包装 32 位整数广播到 256 位返回值的所有元素。",
        "translate": ""
    },
    {
        "source": "Broadcasts the low packed 64-bit integer from `a` to all elements of the 128-bit returned value.",
        "suggest": "将 `a` 的低位包装 64 位整数广播到 128 位返回值的所有元素。",
        "translate": ""
    },
    {
        "source": "Broadcasts the low packed 64-bit integer from `a` to all elements of the 256-bit returned value.",
        "suggest": "将 `a` 的低位包装 64 位整数广播到 256 位返回值的所有元素。",
        "translate": ""
    },
    {
        "source": "Broadcasts the low double-precision (64-bit) floating-point element from `a` to all elements of the 128-bit returned value.",
        "suggest": "将低双精度 (64-bit) 浮点元素从 `a` 广播到 128 位返回值的所有元素。",
        "translate": ""
    },
    {
        "source": "Broadcasts the low double-precision (64-bit) floating-point element from `a` to all elements of the 256-bit returned value.",
        "suggest": "将低双精度 (64-bit) 浮点元素从 `a` 广播到 256 位返回值的所有元素。",
        "translate": ""
    },
    {
        "source": "N.B., `broadcastsi128_si256` is often compiled to `vinsertf128` or `vbroadcastf128`.",
        "suggest": "注意，`broadcastsi128_si256` 通常被编译为 `vinsertf128` 或 `vbroadcastf128`。",
        "translate": ""
    },
    {
        "source": "Broadcasts 128 bits of integer data from a to all 128-bit lanes in the 256-bit returned value.",
        "suggest": "从 a 广播 128 位整数数据到 256 位返回值中的所有 128 位通道。",
        "translate": ""
    },
    {
        "source": "Broadcasts the low single-precision (32-bit) floating-point element from `a` to all elements of the 128-bit returned value.",
        "suggest": "将低单精度 (32-bit) 浮点元素从 `a` 广播到 128 位返回值的所有元素。",
        "translate": ""
    },
    {
        "source": "Broadcasts the low single-precision (32-bit) floating-point element from `a` to all elements of the 256-bit returned value.",
        "suggest": "将低单精度 (32-bit) 浮点元素从 `a` 广播到 256 位返回值的所有元素。",
        "translate": ""
    },
    {
        "source": "Broadcasts the low packed 16-bit integer from a to all elements of the 128-bit returned value",
        "suggest": "将低包装的 16 位整数从 a 广播到 128 位返回值的所有元素",
        "translate": ""
    },
    {
        "source": "Broadcasts the low packed 16-bit integer from a to all elements of the 256-bit returned value",
        "suggest": "将低位包装的 16 位整数从 a 广播到 256 位返回值的所有元素",
        "translate": ""
    },
    {
        "source": "Compares packed 64-bit integers in `a` and `b` for equality.",
        "suggest": "比较 `a` 和 `b` 中的包装 64 位整数是否相等。",
        "translate": ""
    },
    {
        "source": "Compares packed 32-bit integers in `a` and `b` for equality.",
        "suggest": "比较 `a` 和 `b` 中的包装 32 位整数是否相等。",
        "translate": ""
    },
    {
        "source": "Compares packed 16-bit integers in `a` and `b` for equality.",
        "suggest": "比较 `a` 和 `b` 中的包装的 16 位整数是否相等。",
        "translate": ""
    },
    {
        "source": "Compares packed 8-bit integers in `a` and `b` for equality.",
        "suggest": "比较 `a` 和 `b` 中的包装 8 位整数是否相等。",
        "translate": ""
    },
    {
        "source": "Compares packed 64-bit integers in `a` and `b` for greater-than.",
        "suggest": "比较 `a` 和 `b` 中的包装 64 位整数是否大于。",
        "translate": ""
    },
    {
        "source": "Compares packed 32-bit integers in `a` and `b` for greater-than.",
        "suggest": "比较 `a` 和 `b` 中的包装的 32 位整数是否大于。",
        "translate": ""
    },
    {
        "source": "Compares packed 16-bit integers in `a` and `b` for greater-than.",
        "suggest": "比较 `a` 和 `b` 中的包装的 16 位整数是否大于。",
        "translate": ""
    },
    {
        "source": "Compares packed 8-bit integers in `a` and `b` for greater-than.",
        "suggest": "比较 `a` 和 `b` 中的包装的 8 位整数是否大于。",
        "translate": ""
    },
    {
        "source": "Sign-extend 16-bit integers to 32-bit integers.",
        "suggest": "将 16 位整数符号扩展为 32 位整数。",
        "translate": ""
    },
    {
        "source": "Sign-extend 16-bit integers to 64-bit integers.",
        "suggest": "将 16 位整数符号扩展为 64 位整数。",
        "translate": ""
    },
    {
        "source": "Sign-extend 32-bit integers to 64-bit integers.",
        "suggest": "将 32 位整数符号扩展为 64 位整数。",
        "translate": ""
    },
    {
        "source": "Sign-extend 8-bit integers to 16-bit integers.",
        "suggest": "将 8 位整数符号扩展为 16 位整数。",
        "translate": ""
    },
    {
        "source": "Sign-extend 8-bit integers to 32-bit integers.",
        "suggest": "将 8 位整数符号扩展为 32 位整数。",
        "translate": ""
    },
    {
        "source": "Sign-extend 8-bit integers to 64-bit integers.",
        "suggest": "将 8 位整数符号扩展为 64 位整数。",
        "translate": ""
    },
    {
        "source": "Zeroes extend packed unsigned 16-bit integers in `a` to packed 32-bit integers, and stores the results in `dst`.",
        "suggest": "零将 `a` 中的包装的无符号 16 位整数扩展为包装的 32 位整数，并将结果存储在 `dst` 中。",
        "translate": ""
    },
    {
        "source": "Zero-extend the lower four unsigned 16-bit integers in `a` to 64-bit integers.",
        "suggest": "将 `a` 中的低四位无符号 16 位整数零扩展到 64 位整数。",
        "translate": ""
    },
    {
        "source": "The upper four elements of `a` are unused.",
        "suggest": "`a` 的前四个元素未使用。",
        "translate": ""
    },
    {
        "source": "Zero-extend unsigned 32-bit integers in `a` to 64-bit integers.",
        "suggest": "将 `a` 中的无符号 32 位整数零扩展为 64 位整数。",
        "translate": ""
    },
    {
        "source": "Zero-extend unsigned 8-bit integers in `a` to 16-bit integers.",
        "suggest": "将 `a` 中的无符号 8 位整数零扩展为 16 位整数。",
        "translate": ""
    },
    {
        "source": "Zero-extend the lower eight unsigned 8-bit integers in `a` to 32-bit integers.",
        "suggest": "将 `a` 中的低八位无符号 8 位整数零扩展为 32 位整数。",
        "translate": ""
    },
    {
        "source": "The upper eight elements of `a` are unused.",
        "suggest": "`a` 的前八个元素未使用。",
        "translate": ""
    },
    {
        "source": "Zero-extend the lower four unsigned 8-bit integers in `a` to 64-bit integers.",
        "suggest": "将 `a` 中的低四位无符号 8 位整数零扩展到 64 位整数。",
        "translate": ""
    },
    {
        "source": "The upper twelve elements of `a` are unused.",
        "suggest": "`a` 的前十二个元素未使用。",
        "translate": ""
    },
    {
        "source": "Extracts 128 bits (of integer data) from `a` selected with `imm8`.",
        "suggest": "从 `imm8` 选择的 `a` 中提取 128 位 (整数数据)。",
        "translate": ""
    },
    {
        "source": "Horizontally adds adjacent pairs of 16-bit integers in `a` and `b`.",
        "suggest": "在 `a` 和 `b` 中水平添加相邻的 16 位整数对。",
        "translate": ""
    },
    {
        "source": "Horizontally adds adjacent pairs of 32-bit integers in `a` and `b`.",
        "suggest": "在 `a` 和 `b` 中水平添加相邻的 32 位整数对。",
        "translate": ""
    },
    {
        "source": "Horizontally adds adjacent pairs of 16-bit integers in `a` and `b` using saturation.",
        "suggest": "使用饱和度在 `a` 和 `b` 中水平添加相邻的 16 位整数对。",
        "translate": ""
    },
    {
        "source": "Horizontally subtract adjacent pairs of 16-bit integers in `a` and `b`.",
        "suggest": "水平减去 `a` 和 `b` 中相邻的 16 位整数对。",
        "translate": ""
    },
    {
        "source": "Horizontally subtract adjacent pairs of 32-bit integers in `a` and `b`.",
        "suggest": "水平减去 `a` 和 `b` 中相邻的 32 位整数对。",
        "translate": ""
    },
    {
        "source": "Horizontally subtract adjacent pairs of 16-bit integers in `a` and `b` using saturation.",
        "suggest": "使用饱和度水平减去 `a` 和 `b` 中相邻的 16 位整数对。",
        "translate": ""
    },
    {
        "source": "Returns values from `slice` at offsets determined by `offsets * scale`, where `scale` should be 1, 2, 4 or 8.",
        "suggest": "从 `slice` 返回由 `offsets * scale` 确定的偏移量的值，其中 `scale` 应该为 1、2、4 或 8。",
        "translate": ""
    },
    {
        "source": "If mask is set, load the value from `src` in that position instead.",
        "suggest": "如果设置了掩码，请从该位置从 `src` 加载值。",
        "translate": ""
    },
    {
        "source": "Returns values from `slice` at offsets determined by `offsets * scale`, where `scale` should be 1, 2, 4 and 8.",
        "suggest": "从 `slice` 返回由 `offsets * scale` 确定的偏移量的值，其中 `scale` 应为 1、2、4 和 8。",
        "translate": ""
    },
    {
        "source": "Copies `a` to `dst`, then insert 128 bits (of integer data) from `b` at the location specified by `imm8`.",
        "suggest": "将 `a` 复制到 `dst`，然后在 `imm8` 指定的位置插入 `b` 的 128 位 (整数数据)。",
        "translate": ""
    },
    {
        "source": "Multiplies packed signed 16-bit integers in `a` and `b`, producing intermediate signed 32-bit integers.",
        "suggest": "将 `a` 和 `b` 中包装的带符号的 16 位整数相乘，产生中间的带符号的 32 位整数。",
        "translate": ""
    },
    {
        "source": "Horizontally add adjacent pairs of intermediate 32-bit integers.",
        "suggest": "水平添加相邻的中间 32 位整数对。",
        "translate": ""
    },
    {
        "source": "Vertically multiplies each unsigned 8-bit integer from `a` with the corresponding signed 8-bit integer from `b`, producing intermediate signed 16-bit integers.",
        "suggest": "将 `a` 中的每个无符号 8 位整数与 `b` 中的相应带符号 8 位整数垂直相乘，生成中间带符号的 16 位整数。",
        "translate": ""
    },
    {
        "source": "Horizontally add adjacent pairs of intermediate signed 16-bit integers",
        "suggest": "水平相加相邻的中间带符号的 16 位整数对",
        "translate": ""
    },
    {
        "source": "Loads packed 32-bit integers from memory pointed by `mem_addr` using `mask` (elements are zeroed out when the highest bit is not set in the corresponding element).",
        "suggest": "使用 `mask` 从 `mem_addr` 指向的内存中加载包装的 32 位整数 (当未在相应元素中设置最高位时，元素清零)。",
        "translate": ""
    },
    {
        "source": "Loads packed 64-bit integers from memory pointed by `mem_addr` using `mask` (elements are zeroed out when the highest bit is not set in the corresponding element).",
        "suggest": "使用 `mask` 从 `mem_addr` 指向的内存中加载包装的 64 位整数 (当未在相应元素中设置最高位时，元素清零)。",
        "translate": ""
    },
    {
        "source": "Stores packed 32-bit integers from `a` into memory pointed by `mem_addr` using `mask` (elements are not stored when the highest bit is not set in the corresponding element).",
        "suggest": "使用 `mask` 将 `a` 中的包装后的 32 位整数存储到 `mem_addr` 指向的内存中 (当在相应元素中未设置最高位时，不存储元素)。",
        "translate": ""
    },
    {
        "source": "Stores packed 64-bit integers from `a` into memory pointed by `mem_addr` using `mask` (elements are not stored when the highest bit is not set in the corresponding element).",
        "suggest": "使用 `mask` 将 `a` 中的包装 64 位整数存储到 `mem_addr` 指向的内存中 (当未在相应元素中设置最高位时，不存储元素)。",
        "translate": ""
    },
    {
        "source": "Compares packed 16-bit integers in `a` and `b`, and returns the packed maximum values.",
        "suggest": "比较 `a` 和 `b` 中的包装的 16 位整数，并返回包装的最大值。",
        "translate": ""
    },
    {
        "source": "Compares packed 32-bit integers in `a` and `b`, and returns the packed maximum values.",
        "suggest": "比较 `a` 和 `b` 中的包装的 32 位整数，并返回包装的最大值。",
        "translate": ""
    },
    {
        "source": "Compares packed 8-bit integers in `a` and `b`, and returns the packed maximum values.",
        "suggest": "比较 `a` 和 `b` 中的包装的 8 位整数，并返回包装的最大值。",
        "translate": ""
    },
    {
        "source": "Compares packed unsigned 16-bit integers in `a` and `b`, and returns the packed maximum values.",
        "suggest": "比较 `a` 和 `b` 中包装的无符号 16 位整数，并返回包装的最大值。",
        "translate": ""
    },
    {
        "source": "Compares packed unsigned 32-bit integers in `a` and `b`, and returns the packed maximum values.",
        "suggest": "比较 `a` 和 `b` 中的包装的无符号 32 位整数，并返回包装的最大值。",
        "translate": ""
    },
    {
        "source": "Compares packed unsigned 8-bit integers in `a` and `b`, and returns the packed maximum values.",
        "suggest": "比较 `a` 和 `b` 中包装的无符号 8 位整数，并返回包装的最大值。",
        "translate": ""
    },
    {
        "source": "Compares packed 16-bit integers in `a` and `b`, and returns the packed minimum values.",
        "suggest": "比较 `a` 和 `b` 中包装的 16 位整数，并返回包装的最小值。",
        "translate": ""
    },
    {
        "source": "Compares packed 32-bit integers in `a` and `b`, and returns the packed minimum values.",
        "suggest": "比较 `a` 和 `b` 中的包装的 32 位整数，并返回包装的最小值。",
        "translate": ""
    },
    {
        "source": "Compares packed 8-bit integers in `a` and `b`, and returns the packed minimum values.",
        "suggest": "比较 `a` 和 `b` 中的包装的 8 位整数，并返回包装的最小值。",
        "translate": ""
    },
    {
        "source": "Compares packed unsigned 16-bit integers in `a` and `b`, and returns the packed minimum values.",
        "suggest": "比较 `a` 和 `b` 中包装的无符号 16 位整数，并返回包装的最小值。",
        "translate": ""
    },
    {
        "source": "Compares packed unsigned 32-bit integers in `a` and `b`, and returns the packed minimum values.",
        "suggest": "比较 `a` 和 `b` 中包装的无符号 32 位整数，并返回包装的最小值。",
        "translate": ""
    },
    {
        "source": "Compares packed unsigned 8-bit integers in `a` and `b`, and returns the packed minimum values.",
        "suggest": "比较 `a` 和 `b` 中包装的无符号 8 位整数，并返回包装的最小值。",
        "translate": ""
    },
    {
        "source": "Creates mask from the most significant bit of each 8-bit element in `a`, return the result.",
        "suggest": "从 `a` 中每个 8 位元素的最高有效位创建掩码，并返回结果。",
        "translate": ""
    },
    {
        "source": "Computes the sum of absolute differences (SADs) of quadruplets of unsigned",
        "suggest": "计算无符号四元组的绝对差之和 (SADs)",
        "translate": ""
    },
    {
        "source": "8-bit integers in `a` compared to those in `b`, and stores the 16-bit results in dst.",
        "suggest": "`a` 中的 8 位整数与 `b` 中的 8 位整数相比较，并将 16 位结果存储在 dst 中。",
        "translate": ""
    },
    {
        "source": "Eight SADs are performed for each 128-bit lane using one quadruplet from `b` and eight quadruplets from `a`.",
        "suggest": "使用来自 `b` 的一个四元组和来自 `a` 的八个四元组，对每个 128 位通道执行八个 SAD。",
        "translate": ""
    },
    {
        "source": "One quadruplet is selected from `b` starting at on the offset specified in `imm8`.",
        "suggest": "从 `b` 中指定的偏移量开始，从 `b` 中选择一个四元组。",
        "translate": ""
    },
    {
        "source": "Eight quadruplets are formed from sequential 8-bit integers selected from `a` starting at the offset specified in `imm8`.",
        "suggest": "从 `a` 中选择的有序 8 位整数开始的 8 个四元组，起始于 `imm8` 中指定的偏移量。",
        "translate": ""
    },
    {
        "source": "Multiplies the low 32-bit integers from each packed 64-bit element in `a` and `b`",
        "suggest": "将 `a` 和 `b` 中每个包装的 64 位元素的低位 32 位整数相乘",
        "translate": ""
    },
    {
        "source": "Returns the 64-bit results.",
        "suggest": "返回 64 位结果。",
        "translate": ""
    },
    {
        "source": "Multiplies the low unsigned 32-bit integers from each packed 64-bit element in `a` and `b`",
        "suggest": "将 `a` 和 `b` 中每个包装的 64 位元素的低位无符号 32 位整数相乘",
        "translate": ""
    },
    {
        "source": "Returns the unsigned 64-bit results.",
        "suggest": "返回无符号的 64 位结果。",
        "translate": ""
    },
    {
        "source": "Multiplies the packed 16-bit integers in `a` and `b`, producing intermediate 32-bit integers and returning the high 16 bits of the intermediate integers.",
        "suggest": "将 `a` 和 `b` 中的包装的 16 位整数相乘，产生 32 位中间整数，并返回中间整数的高 16 位。",
        "translate": ""
    },
    {
        "source": "Multiplies the packed unsigned 16-bit integers in `a` and `b`, producing intermediate 32-bit integers and returning the high 16 bits of the intermediate integers.",
        "suggest": "将 `a` 和 `b` 中包装的无符号 16 位整数相乘，生成中间的 32 位整数，并返回中间整数的高 16 位。",
        "translate": ""
    },
    {
        "source": "Multiplies the packed 16-bit integers in `a` and `b`, producing intermediate 32-bit integers, and returns the low 16 bits of the intermediate integers",
        "suggest": "将 `a` 和 `b` 中的包装的 16 位整数相乘，产生 32 位中间整数，并返回中间整数的低 16 位",
        "translate": ""
    },
    {
        "source": "Multiplies the packed 32-bit integers in `a` and `b`, producing intermediate 64-bit integers, and returns the low 32 bits of the intermediate integers",
        "suggest": "将 `a` 和 `b` 中的包装的 32 位整数相乘，生成中间 64 位整数，并返回中间整数的低 32 位",
        "translate": ""
    },
    {
        "source": "Multiplies packed 16-bit integers in `a` and `b`, producing intermediate signed 32-bit integers.",
        "suggest": "将 `a` 和 `b` 中的包装的 16 位整数相乘，生成中间带符号的 32 位整数。",
        "translate": ""
    },
    {
        "source": "Truncate each intermediate integer to the 18 most significant bits, round by adding 1, and return bits `[16:1]`.",
        "suggest": "将每个中间整数截断为 18 个最高有效位，再加 1 取整，然后返回 `[16:1]` 位。",
        "translate": ""
    },
    {
        "source": "Computes the bitwise OR of 256 bits (representing integer data) in `a` and `b`",
        "suggest": "计算 `a` 和 `b` 中 256 位 (表示整数数据) 的按位或",
        "translate": ""
    },
    {
        "source": "Converts packed 16-bit integers from `a` and `b` to packed 8-bit integers using signed saturation",
        "suggest": "使用带符号的饱和度将包装的 16 位整数从 `a` 和 `b` 转换为包装的 8 位整数",
        "translate": ""
    },
    {
        "source": "Converts packed 32-bit integers from `a` and `b` to packed 16-bit integers using signed saturation",
        "suggest": "使用带符号的饱和度将包装的 32 位整数从 `a` 和 `b` 转换为包装的 16 位整数",
        "translate": ""
    },
    {
        "source": "Converts packed 16-bit integers from `a` and `b` to packed 8-bit integers using unsigned saturation",
        "suggest": "使用无符号饱和度将包装的 16 位整数从 `a` 和 `b` 转换为包装的 8 位整数",
        "translate": ""
    },
    {
        "source": "Converts packed 32-bit integers from `a` and `b` to packed 16-bit integers using unsigned saturation",
        "suggest": "使用无符号饱和度将包装的 32 位整数从 `a` 和 `b` 转换为包装的 16 位整数",
        "translate": ""
    },
    {
        "source": "Permutes packed 32-bit integers from `a` according to the content of `b`.",
        "suggest": "根据 `b` 的内容，对 `a` 的 32 位整数进行包装的排列。",
        "translate": ""
    },
    {
        "source": "The last 3 bits of each integer of `b` are used as addresses into the 8 integers of `a`.",
        "suggest": "`b` 的每个整数的最后 3 位用作 `a` 的 8 个整数的地址。",
        "translate": ""
    },
    {
        "source": "Permutes 64-bit integers from `a` using control mask `imm8`.",
        "suggest": "使用控制掩码 `imm8` 从 `a` 置换 64 位整数。",
        "translate": ""
    },
    {
        "source": "Shuffles 128-bits of integer data selected by `imm8` from `a` and `b`.",
        "suggest": "打乱由 `imm8` 从 `a` 和 `b` 选择的 128 位整数数据。",
        "translate": ""
    },
    {
        "source": "Shuffles 64-bit floating-point elements in `a` across lanes using the control in `imm8`.",
        "suggest": "使用 `imm8` 中的控件对 `a` 中的 64 位浮点元素进行打乱。",
        "translate": ""
    },
    {
        "source": "Shuffles eight 32-bit foating-point elements in `a` across lanes using the corresponding 32-bit integer index in `idx`.",
        "suggest": "使用 `idx` 中相应的 32 位整数索引跨通道对 `a` 中的八个 32 位浮点元素进行打乱。",
        "translate": ""
    },
    {
        "source": "Computes the absolute differences of packed unsigned 8-bit integers in `a` and `b`, then horizontally sum each consecutive 8 differences to produce four unsigned 16-bit integers, and pack these unsigned 16-bit integers in the low 16 bits of the 64-bit return value",
        "suggest": "计算 `a` 和 `b` 中包装的无符号 8 位整数的绝对差，然后将每个连续的 8 个差水平求和，产生四个无符号的 16 位整数，并将这些无符号的 16 位整数包装在 64 位返回值的低 16 位中",
        "translate": ""
    },
    {
        "source": "Shuffles bytes from `a` according to the content of `b`.",
        "suggest": "根据 `b` 的内容，打乱 `a` 中的字节。",
        "translate": ""
    },
    {
        "source": "The last 4 bits of each byte of `b` are used as addresses into the 32 bytes of `a`.",
        "suggest": "`b` 的每个字节的后 4 位用作 `a` 的 32 个字节的地址。",
        "translate": ""
    },
    {
        "source": "In addition, if the highest significant bit of a byte of `b` is set, the respective destination byte is set to 0.",
        "suggest": "此外，如果设置了 `b` 字节的最高有效位，则相应的目标字节将设置为 0。",
        "translate": ""
    },
    {
        "source": "The low and high halves of the vectors are shuffled separately.",
        "suggest": "分别打乱 vectors 的低半部分和高半部分。",
        "translate": ""
    },
    {
        "source": "Picturing `a` and `b` as `[u8; 32]`, `_mm256_shuffle_epi8` is logically equivalent to:",
        "suggest": "将 `a` 和 `b` 描绘为 `[u8; 32]`，`_mm256_shuffle_epi8` 在逻辑上等效于:",
        "translate": ""
    },
    {
        "source": "Shuffles 32-bit integers in 128-bit lanes of `a` using the control in `imm8`.",
        "suggest": "使用 `imm8` 中的控件，在 `a` 的 128 位通道中打乱 32 位整数。",
        "translate": ""
    },
    {
        "source": "simd_shuffleX requires that its selector parameter be made up of constant values, but we can't enforce that here.",
        "suggest": "simd_shuffleX 要求其选择器参数由常量值组成，但我们不能在此处强制实现。",
        "translate": ""
    },
    {
        "source": "In spirit, we need to write a `match` on all possible values of a byte, and for each value, hard-code the correct `simd_shuffleX` call using only constants.",
        "suggest": "从本质上讲，我们需要在一个字节的所有可能值上写一个 `match`，对于每个值，仅使用常量硬编码正确的 `simd_shuffleX` 调用。",
        "translate": ""
    },
    {
        "source": "We then hope for LLVM to do the rest.",
        "suggest": "然后，我们希望 LLVM 可以完成其余的工作。",
        "translate": ""
    },
    {
        "source": "Of course, that's...",
        "suggest": "当然是...",
        "translate": ""
    },
    {
        "source": "awful. So we try to use macros to do it for us.",
        "suggest": "可怕。因此，我们尝试使用宏为我们做到这一点。",
        "translate": ""
    },
    {
        "source": "Shuffles 16-bit integers in the high 64 bits of 128-bit lanes of `a` using the control in `imm8`.",
        "suggest": "使用 `imm8` 中的控件，在 `a` 的 128 位通道的高 64 位中打乱 16 位整数。",
        "translate": ""
    },
    {
        "source": "The low 64 bits of 128-bit lanes of `a` are copied to the output.",
        "suggest": "`a` 的 128 位通道的低 64 位被复制到输出中。",
        "translate": ""
    },
    {
        "source": "Shuffles 16-bit integers in the low 64 bits of 128-bit lanes of `a` using the control in `imm8`.",
        "suggest": "使用 `imm8` 中的控件在 `a` 的 128 位通道的低 64 位中打乱 16 位整数。",
        "translate": ""
    },
    {
        "source": "The high 64 bits of 128-bit lanes of `a` are copied to the output.",
        "suggest": "`a` 的 128 位通道的高 64 位被复制到输出中。",
        "translate": ""
    },
    {
        "source": "Negates packed 16-bit integers in `a` when the corresponding signed",
        "suggest": "当相应的带符号时，将 `a` 中的 16 位整数包装为无效",
        "translate": ""
    },
    {
        "source": "16-bit integer in `b` is negative, and returns the results.",
        "suggest": "`b` 中的 16 位整数为负，并返回结果。",
        "translate": ""
    },
    {
        "source": "Results are zeroed out when the corresponding element in `b` is zero.",
        "suggest": "当 `b` 中的相应元素为零时，结果归零。",
        "translate": ""
    },
    {
        "source": "Negates packed 32-bit integers in `a` when the corresponding signed",
        "suggest": "当相应的带符号时，将 `a` 中的包装的 32 位整数取反",
        "translate": ""
    },
    {
        "source": "32-bit integer in `b` is negative, and returns the results.",
        "suggest": "`b` 中的 32 位整数为负，并返回结果。",
        "translate": ""
    },
    {
        "source": "Negates packed 8-bit integers in `a` when the corresponding signed",
        "suggest": "当相应的带符号时，将 `a` 中的包装的 8 位整数取反",
        "translate": ""
    },
    {
        "source": "8-bit integer in `b` is negative, and returns the results.",
        "suggest": "`b` 中的 8 位整数为负，并返回结果。",
        "translate": ""
    },
    {
        "source": "Shifts packed 16-bit integers in `a` left by `count` while shifting in zeros, and returns the result",
        "suggest": "将 `count` 左移的 `a` 中的包装的 16 位整数移位，同时移零，并返回结果",
        "translate": ""
    },
    {
        "source": "Shifts packed 32-bit integers in `a` left by `count` while shifting in zeros, and returns the result",
        "suggest": "将 `count` 左移的 `a` 中的包装的 32 位整数移位，同时移零，并返回结果",
        "translate": ""
    },
    {
        "source": "Shifts packed 64-bit integers in `a` left by `count` while shifting in zeros, and returns the result",
        "suggest": "将 `count` 左移的 `a` 中的包装的 64 位整数移位，同时移零，并返回结果",
        "translate": ""
    },
    {
        "source": "Shifts packed 16-bit integers in `a` left by `imm8` while shifting in zeros, return the results;",
        "suggest": "`imm8` 向左移动 `a` 中的包装的 16 位整数，同时向零移动，返回结果;",
        "translate": ""
    },
    {
        "source": "Shifts packed 32-bit integers in `a` left by `imm8` while shifting in zeros, return the results;",
        "suggest": "`imm8` 向左移动 `a` 中的包装的 32 位整数，同时向零移动，返回结果;",
        "translate": ""
    },
    {
        "source": "Shifts packed 64-bit integers in `a` left by `imm8` while shifting in zeros, return the results;",
        "suggest": "`imm8` 向左移动 `a` 中的包装的 64 位整数，同时向零移动，返回结果;",
        "translate": ""
    },
    {
        "source": "Shifts 128-bit lanes in `a` left by `imm8` bytes while shifting in zeros.",
        "suggest": "将 `a` 中的 128 位通道向左移 `imm8` 字节，同时向零移位。",
        "translate": ""
    },
    {
        "source": "Shifts packed 32-bit integers in `a` left by the amount specified by the corresponding element in `count` while shifting in zeros, and returns the result.",
        "suggest": "将 `a` 中的包装的 32 位整数左移 `count` 中相应元素所指定的数量，同时将零移位，并返回结果。",
        "translate": ""
    },
    {
        "source": "Shifts packed 64-bit integers in `a` left by the amount specified by the corresponding element in `count` while shifting in zeros, and returns the result.",
        "suggest": "将 `a` 中的包装的 64 位整数左移 `count` 中相应元素所指定的数量，同时将零移位，并返回结果。",
        "translate": ""
    },
    {
        "source": "Shifts packed 16-bit integers in `a` right by `count` while shifting in sign bits.",
        "suggest": "将符号位移入时，将 `a` 中的包装的 16 位整数右移 `count`。",
        "translate": ""
    },
    {
        "source": "Shifts packed 32-bit integers in `a` right by `count` while shifting in sign bits.",
        "suggest": "将符号位移位时，将 `a` 中的包装的 32 位整数右移 `count`。",
        "translate": ""
    },
    {
        "source": "Shifts packed 16-bit integers in `a` right by `imm8` while shifting in sign bits.",
        "suggest": "将符号位移入时，将 `a` 中的包装的 16 位整数右移 `imm8`。",
        "translate": ""
    },
    {
        "source": "Shifts packed 32-bit integers in `a` right by `imm8` while shifting in sign bits.",
        "suggest": "将符号位移位时，将 `a` 中的包装的 32 位整数右移 `imm8`。",
        "translate": ""
    },
    {
        "source": "Shifts packed 32-bit integers in `a` right by the amount specified by the corresponding element in `count` while shifting in sign bits.",
        "suggest": "将 `a` 中的32位整数向右移动，移动量由 `count` 中的相应元素指定，同时移入符号位。",
        "translate": ""
    },
    {
        "source": "Shifts 128-bit lanes in `a` right by `imm8` bytes while shifting in zeros.",
        "suggest": "将 `a` 中的 128 位通道右移 `imm8` 字节，同时将其移位为零。",
        "translate": ""
    },
    {
        "source": "Shifts packed 16-bit integers in `a` right by `count` while shifting in zeros.",
        "suggest": "将 `a` 中的包装的 16 位整数右移 `count`，同时将零移位。",
        "translate": ""
    },
    {
        "source": "Shifts packed 32-bit integers in `a` right by `count` while shifting in zeros.",
        "suggest": "将 `a` 中的包装的 32 位整数右移 `count`，同时将零移位。",
        "translate": ""
    },
    {
        "source": "Shifts packed 64-bit integers in `a` right by `count` while shifting in zeros.",
        "suggest": "将 `a` 中的包装的 64 位整数右移 `count`，同时将零移位。",
        "translate": ""
    },
    {
        "source": "Shifts packed 16-bit integers in `a` right by `imm8` while shifting in zeros",
        "suggest": "将 `a` 中的包装的 16 位整数右移 `imm8`，同时将零移位",
        "translate": ""
    },
    {
        "source": "Shifts packed 32-bit integers in `a` right by `imm8` while shifting in zeros",
        "suggest": "将 `a` 中的包装的 32 位整数右移 `imm8`，同时将零移位",
        "translate": ""
    },
    {
        "source": "Shifts packed 64-bit integers in `a` right by `imm8` while shifting in zeros",
        "suggest": "将 `a` 中的包装的 64 位整数右移 `imm8`，同时将零移位",
        "translate": ""
    },
    {
        "source": "Shifts packed 32-bit integers in `a` right by the amount specified by the corresponding element in `count` while shifting in zeros,",
        "suggest": "将 `a` 中的包装的 32 位整数右移 `count` 中相应元素所指定的数量，同时将零移位，",
        "translate": ""
    },
    {
        "source": "Shifts packed 64-bit integers in `a` right by the amount specified by the corresponding element in `count` while shifting in zeros,",
        "suggest": "将 `a` 中的包装的 64 位整数右移 `count` 中相应元素所指定的数量，同时将零移位，",
        "translate": ""
    },
    {
        "source": "Subtract packed 16-bit integers in `b` from packed 16-bit integers in `a`",
        "suggest": "从 `a` 中的包装的 16 位整数减去 `b` 中的包装的 16 位整数",
        "translate": ""
    },
    {
        "source": "Subtract packed 32-bit integers in `b` from packed 32-bit integers in `a`",
        "suggest": "从 `a` 中的包装的 32 位整数减去 `b` 中的包装的 32 位整数",
        "translate": ""
    },
    {
        "source": "Subtract packed 64-bit integers in `b` from packed 64-bit integers in `a`",
        "suggest": "从 `a` 中的包装的 64 位整数减去 `b` 中的包装的 64 位整数",
        "translate": ""
    },
    {
        "source": "Subtract packed 8-bit integers in `b` from packed 8-bit integers in `a`",
        "suggest": "从 `a` 中的包装的 8 位整数中减去 `b` 中的包装的 8 位整数",
        "translate": ""
    },
    {
        "source": "Subtract packed 16-bit integers in `b` from packed 16-bit integers in `a` using saturation.",
        "suggest": "使用饱和度从 `a` 的包装的 16 位整数减去 `b` 的包装的 16 位整数。",
        "translate": ""
    },
    {
        "source": "Subtract packed 8-bit integers in `b` from packed 8-bit integers in `a` using saturation.",
        "suggest": "使用饱和度从 `a` 的包装的 8 位整数减去 `b` 的包装的 8 位整数。",
        "translate": ""
    },
    {
        "source": "Subtract packed unsigned 16-bit integers in `b` from packed 16-bit integers in `a` using saturation.",
        "suggest": "使用饱和度从 `a` 的包装的 16 位整数减去 `b` 的包装的无符号 16 位整数。",
        "translate": ""
    },
    {
        "source": "Subtract packed unsigned 8-bit integers in `b` from packed 8-bit integers in `a` using saturation.",
        "suggest": "使用饱和度从 `a` 的包装的 8 位整数减去 `b` 的包装的无符号 8 位整数。",
        "translate": ""
    },
    {
        "source": "Unpacks and interleave 8-bit integers from the high half of each",
        "suggest": "从每个高位的一半拆包并交织 8 位整数",
        "translate": ""
    },
    {
        "source": "128-bit lane in `a` and `b`.",
        "suggest": "`a` 和 `b` 中的 128 位通道。",
        "translate": ""
    },
    {
        "source": "Unpacks and interleave 8-bit integers from the low half of each",
        "suggest": "从每个低位拆包并交织 8 位整数",
        "translate": ""
    },
    {
        "source": "128-bit lane of `a` and `b`.",
        "suggest": "`a` 和 `b` 的 128 位通道",
        "translate": ""
    },
    {
        "source": "Unpacks and interleave 16-bit integers from the high half of each",
        "suggest": "从每个高位的一半拆包并交织 16 位整数",
        "translate": ""
    },
    {
        "source": "Unpacks and interleave 16-bit integers from the low half of each",
        "suggest": "从每个低位拆包并交织 16 位整数",
        "translate": ""
    },
    {
        "source": "Unpacks and interleave 32-bit integers from the high half of each",
        "suggest": "从每个高位的一半拆包并交织 32 位整数",
        "translate": ""
    },
    {
        "source": "Unpacks and interleave 32-bit integers from the low half of each",
        "suggest": "从每个低位拆包并交织 32 位整数",
        "translate": ""
    },
    {
        "source": "Unpacks and interleave 64-bit integers from the high half of each",
        "suggest": "从每个高位的一半拆包并交织 64 位整数",
        "translate": ""
    },
    {
        "source": "Unpacks and interleave 64-bit integers from the low half of each",
        "suggest": "从每个字节的下半部分拆包并交织 64 位整数",
        "translate": ""
    },
    {
        "source": "Computes the bitwise XOR of 256 bits (representing integer data) in `a` and `b`",
        "suggest": "计算 `a` 和 `b` 中 256 位 (表示整数数据) 的按位 XOR",
        "translate": ""
    },
    {
        "source": "Extracts an 8-bit integer from `a`, selected with `imm8`.",
        "suggest": "从 `a` 中提取一个 8 位整数，并用 `imm8` 选择。",
        "translate": ""
    },
    {
        "source": "Returns a 32-bit integer containing the zero-extended integer data.",
        "suggest": "返回包含零扩展整数数据的 32 位整数。",
        "translate": ""
    },
    {
        "source": "Extracts a 16-bit integer from `a`, selected with `imm8`.",
        "suggest": "从 `a` 提取 16 位整数，并用 `imm8` 选择。",
        "translate": ""
    },
    {
        "source": "Extracts a 32-bit integer from `a`, selected with `imm8`.",
        "suggest": "从 `a` 提取 32 位整数，并用 `imm8` 选择。",
        "translate": ""
    },
    {
        "source": "Returns the first element of the input vector of `[4 x double]`.",
        "suggest": "返回 `[4 x double]` 的输入 vector 的第一个元素。",
        "translate": ""
    },
    {
        "source": "Returns the first element of the input vector of `[8 x i32]`.",
        "suggest": "返回 `[8 x i32]` 的输入 vector 的第一个元素。",
        "translate": ""
    },
    {
        "source": "A multiplier of 4 is word-addressing",
        "suggest": "4 的乘数是字寻址",
        "translate": ""
    },
    {
        "source": "A multiplier of 4 is word-addressing for f32s",
        "suggest": "乘数 4 是 f32s 的字寻址",
        "translate": ""
    },
    {
        "source": "A multiplier of 8 is word-addressing for i64s",
        "suggest": "8 的乘数是 i64 的字寻址",
        "translate": ""
    },
    {
        "source": "A multiplier of 8 is word-addressing for f64s",
        "suggest": "乘数 8 是 f64 的字寻址",
        "translate": ""
    },
    {
        "source": "Bit-oriented Algorithms (BITALG)",
        "suggest": "面向比特的算法 (BITALG)",
        "translate": ""
    },
    {
        "source": "The intrinsics here correspond to those in the `immintrin.h` C header.",
        "suggest": "这里的内联函数对应于 `immintrin.h` C 头文件中的内联函数。",
        "translate": ""
    },
    {
        "source": "For each packed 16-bit integer maps the value to the number of logical 1 bits.",
        "suggest": "对于每个包装的 16 位整数 maps，该值等于逻辑 1 位的数量。",
        "translate": ""
    },
    {
        "source": "Uses the writemask in k - elements are zeroed in the result if the corresponding mask bit is not set.",
        "suggest": "使用 k 中的写掩码 - 如果未设置相应的掩码位，则结果中的元素为零。",
        "translate": ""
    },
    {
        "source": "Otherwise the computation result is written into the result.",
        "suggest": "否则，将计算结果写入结果中。",
        "translate": ""
    },
    {
        "source": "Uses the writemask in k - elements are copied from src if the corresponding mask bit is not set.",
        "suggest": "使用 k 中的写掩码 - 如果未设置相应的掩码位，则从 src 复制元素。",
        "translate": ""
    },
    {
        "source": "For each packed 8-bit integer maps the value to the number of logical 1 bits.",
        "suggest": "对于每个包装的 8 位整数 maps，该值等于逻辑 1 位的数量。",
        "translate": ""
    },
    {
        "source": "Considers the input `b` as packed 64-bit integers and `c` as packed 8-bit integers.",
        "suggest": "将输入 `b` 视为包装的 64 位整数，并将 `c` 视为包装的 8 位整数。",
        "translate": ""
    },
    {
        "source": "Then groups 8 8-bit values from `c`as indices into the the bits of the corresponding 64-bit integer.",
        "suggest": "然后将来自 `c` 的 8 个 8 位值作为索引分组到相应的 64 位整数的位中。",
        "translate": ""
    },
    {
        "source": "It then selects these bits and packs them into the output.",
        "suggest": "然后，选择这些位并将其包装到输出中。",
        "translate": ""
    },
    {
        "source": "Some of the constants in the tests below are just bit patterns.",
        "suggest": "以下测试中的某些常量只是位模式。",
        "translate": ""
    },
    {
        "source": "Compute the absolute value of packed signed 16-bit integers in a, and store the unsigned results in dst.",
        "suggest": "计算 a 中包装的带符号的 16 位整数的绝对值，并将无符号的结果存储在 dst 中。",
        "translate": ""
    },
    {
        "source": "is a properly initialized i16x32",
        "suggest": "是正确初始化的 i16x32",
        "translate": ""
    },
    {
        "source": "Compute the absolute value of packed signed 16-bit integers in a, and store the unsigned results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).",
        "suggest": "计算 a 中包装的带符号的 16 位整数的绝对值，并使用写掩码 k 将无符号的结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。",
        "translate": ""
    },
    {
        "source": "Compute the absolute value of packed signed 16-bit integers in a, and store the unsigned results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).",
        "suggest": "计算 a 中包装的带符号的 16 位整数的绝对值，并使用零掩码 k (将未设置相应掩码位的元素清零) 将无符号结果存储在 dst 中。",
        "translate": ""
    },
    {
        "source": "Compute the absolute value of packed signed 8-bit integers in a, and store the unsigned results in dst.",
        "suggest": "计算 a 中包装的带符号的 8 位整数的绝对值，并将无符号的结果存储在 dst 中。",
        "translate": ""
    },
    {
        "source": "is a properly initialized i8x64",
        "suggest": "是正确初始化的 i8x64",
        "translate": ""
    },
    {
        "source": "Compute the absolute value of packed signed 8-bit integers in a, and store the unsigned results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).",
        "suggest": "计算 a 中包装的带符号的 8 位整数的绝对值，并使用写掩码 k 将无符号的结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。",
        "translate": ""
    },
    {
        "source": "Compute the absolute value of packed signed 8-bit integers in a, and store the unsigned results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).",
        "suggest": "计算 a 中包装的带符号的 8 位整数的绝对值，并使用零掩码 k 将无符号结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。",
        "translate": ""
    },
    {
        "source": "Compute the absolute value of packed signed 8-bit integers in a, and store the unsigned results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set)",
        "suggest": "计算 a 中包装的带符号的 8 位整数的绝对值，并使用写掩码 k 将无符号的结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)",
        "translate": ""
    },
    {
        "source": "Add packed 16-bit integers in a and b, and store the results in dst.",
        "suggest": "将包装的 16 位整数添加到 a 和 b 中，并将结果存储在 dst 中。",
        "translate": ""
    },
    {
        "source": "Add packed 16-bit integers in a and b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).",
        "suggest": "在 a 和 b 中添加包装的 16 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。",
        "translate": ""
    },
    {
        "source": "Add packed 16-bit integers in a and b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).",
        "suggest": "将包装的 16 位整数添加到 a 和 b 中，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。",
        "translate": ""
    },
    {
        "source": "Add packed 8-bit integers in a and b, and store the results in dst.",
        "suggest": "将包装的 8 位整数添加到 a 和 b 中，并将结果存储在 dst 中。",
        "translate": ""
    },
    {
        "source": "Add packed 8-bit integers in a and b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).",
        "suggest": "在 a 和 b 中添加包装的 8 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。",
        "translate": ""
    },
    {
        "source": "Add packed 8-bit integers in a and b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).",
        "suggest": "在 a 和 b 中添加包装的 8 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。",
        "translate": ""
    },
    {
        "source": "Add packed unsigned 16-bit integers in a and b using saturation, and store the results in dst.",
        "suggest": "使用饱和度在 a 和 b 中添加包装的无符号 16 位整数，并将结果存储在 dst 中。",
        "translate": ""
    },
    {
        "source": "Add packed unsigned 16-bit integers in a and b using saturation, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).",
        "suggest": "使用饱和度在 a 和 b 中添加包装的无符号 16 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。",
        "translate": ""
    },
    {
        "source": "Add packed unsigned 16-bit integers in a and b using saturation, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).",
        "suggest": "使用饱和度在 a 和 b 中添加包装的无符号 16 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素清零)。",
        "translate": ""
    },
    {
        "source": "Add packed unsigned 8-bit integers in a and b using saturation, and store the results in dst.",
        "suggest": "使用饱和度在 a 和 b 中添加包装的无符号 8 位整数，并将结果存储在 dst 中。",
        "translate": ""
    },
    {
        "source": "Add packed unsigned 8-bit integers in a and b using saturation, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).",
        "suggest": "使用饱和度在 a 和 b 中添加包装的无符号 8 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。",
        "translate": ""
    },
    {
        "source": "Add packed unsigned 8-bit integers in a and b using saturation, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).",
        "suggest": "使用饱和度在 a 和 b 中添加包装的无符号 8 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时元素清零)。",
        "translate": ""
    },
    {
        "source": "Add packed signed 16-bit integers in a and b using saturation, and store the results in dst.",
        "suggest": "使用饱和度在 a 和 b 中添加包装的带符号的 16 位整数，并将结果存储在 dst 中。",
        "translate": ""
    },
    {
        "source": "Add packed signed 16-bit integers in a and b using saturation, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).",
        "suggest": "使用饱和度在 a 和 b 中添加包装的带符号的 16 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。",
        "translate": ""
    },
    {
        "source": "Add packed signed 16-bit integers in a and b using saturation, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).",
        "suggest": "使用饱和度在 a 和 b 中添加包装的带符号的 16 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时元素清零)。",
        "translate": ""
    },
    {
        "source": "Add packed signed 8-bit integers in a and b using saturation, and store the results in dst.",
        "suggest": "使用饱和度在 a 和 b 中添加包装的带符号的 8 位整数，并将结果存储在 dst 中。",
        "translate": ""
    },
    {
        "source": "Add packed signed 8-bit integers in a and b using saturation, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).",
        "suggest": "使用饱和度在 a 和 b 中添加包装的带符号的 8 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。",
        "translate": ""
    },
    {
        "source": "Add packed signed 8-bit integers in a and b using saturation, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).",
        "suggest": "使用饱和度在 a 和 b 中添加包装的带符号的 8 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素清零)。",
        "translate": ""
    },
    {
        "source": "Subtract packed 16-bit integers in b from packed 16-bit integers in a, and store the results in dst.",
        "suggest": "从 a 中的包装的 16 位整数中减去 b 中的包装的 16 位整数，并将结果存储在 dst 中。",
        "translate": ""
    },
    {
        "source": "Subtract packed 16-bit integers in b from packed 16-bit integers in a, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).",
        "suggest": "从 a 中的包装的 16 位整数中减去 b 中的包装的 16 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。",
        "translate": ""
    },
    {
        "source": "Subtract packed 16-bit integers in b from packed 16-bit integers in a, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).",
        "suggest": "从 a 中的包装的 16 位整数中减去 b 中的包装的 16 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素清零)。",
        "translate": ""
    },
    {
        "source": "Subtract packed 8-bit integers in b from packed 8-bit integers in a, and store the results in dst.",
        "suggest": "从 a 中的包装 8 位整数中减去 b 中的包装 8 位整数，并将结果存储在 dst 中。",
        "translate": ""
    },
    {
        "source": "Subtract packed 8-bit integers in b from packed 8-bit integers in a, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).",
        "suggest": "从 a 中的包装 8 位整数中减去 b 中的包装 8 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。",
        "translate": ""
    },
    {
        "source": "Subtract packed 8-bit integers in b from packed 8-bit integers in a, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).",
        "suggest": "从 a 中的包装 8 位整数中减去 b 中的包装 8 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素清零)。",
        "translate": ""
    },
    {
        "source": "Subtract packed unsigned 16-bit integers in b from packed unsigned 16-bit integers in a using saturation, and store the results in dst.",
        "suggest": "使用饱和度将 b 中的包装无符号 16 位整数减去 b 中的包装无符号 16 位整数，并将结果存储在 dst 中。",
        "translate": ""
    },
    {
        "source": "Subtract packed unsigned 16-bit integers in b from packed unsigned 16-bit integers in a using saturation, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).",
        "suggest": "使用 a 饱和度从 b 中的包装无符号 16 位整数减去 b 中的包装无符号 16 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时从 src 复制元素)。",
        "translate": ""
    },
    {
        "source": "Subtract packed unsigned 16-bit integers in b from packed unsigned 16-bit integers in a using saturation, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).",
        "suggest": "使用 a 饱和度将 b 中的包装无符号 16 位整数减去 b 中的包装无符号 16 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时元素清零)。",
        "translate": ""
    },
    {
        "source": "Subtract packed unsigned 8-bit integers in b from packed unsigned 8-bit integers in a using saturation, and store the results in dst.",
        "suggest": "使用 a 饱和度将 b 中的包装无符号 8 位整数减去 b 中的包装无符号 8 位整数，并将结果存储在 dst 中。",
        "translate": ""
    },
    {
        "source": "Subtract packed unsigned 8-bit integers in b from packed unsigned 8-bit integers in a using saturation, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).",
        "suggest": "使用 a 饱和度将 b 中的包装无符号 8 位整数减去 b 中的包装无符号 8 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时从 src 复制元素)。",
        "translate": ""
    },
    {
        "source": "Subtract packed unsigned 8-bit integers in b from packed unsigned 8-bit integers in a using saturation, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).",
        "suggest": "使用 a 饱和度从 b 中的包装无符号 8 位整数减去 b 中的包装无符号 8 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时元素清零)。",
        "translate": ""
    },
    {
        "source": "Subtract packed signed 16-bit integers in b from packed 16-bit integers in a using saturation, and store the results in dst.",
        "suggest": "使用饱和度从 a 中的包装的 16 位整数减去 b 中的包装的有符号 16 位整数，并将结果存储在 dst 中。",
        "translate": ""
    },
    {
        "source": "Subtract packed signed 16-bit integers in b from packed 16-bit integers in a using saturation, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).",
        "suggest": "使用饱和度将 b 中的包装 16 位整数减去 b 中的包装有符号 16 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时从 src 复制元素)。",
        "translate": ""
    },
    {
        "source": "Subtract packed signed 16-bit integers in b from packed 16-bit integers in a using saturation, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).",
        "suggest": "使用饱和度将 b 中的包装 16 位整数减去 b 中的包装有符号 16 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时元素清零)。",
        "translate": ""
    },
    {
        "source": "Subtract packed signed 8-bit integers in b from packed 8-bit integers in a using saturation, and store the results in dst.",
        "suggest": "使用饱和度从包装的 8 位整数中减去 b 中的包装有符号 8 位整数，并将结果存储在 dst 中。",
        "translate": ""
    },
    {
        "source": "Subtract packed signed 8-bit integers in b from packed 8-bit integers in a using saturation, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).",
        "suggest": "使用饱和度将 b 中的包装 8 位整数减去 b 中的包装 8 位有符号整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。",
        "translate": ""
    },
    {
        "source": "Subtract packed signed 8-bit integers in b from packed 8-bit integers in a using saturation, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).",
        "suggest": "使用饱和度从包装的 8 位整数中减去 b 中的包装有符号的 8 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素清零)。",
        "translate": ""
    },
    {
        "source": "Multiply the packed unsigned 16-bit integers in a and b, producing intermediate 32-bit integers, and store the high 16 bits of the intermediate integers in dst.",
        "suggest": "将包装的无符号 16 位整数与 a 和 b 相乘，生成中间的 32 位整数，并将中间整数的高 16 位存储在 dst 中。",
        "translate": ""
    },
    {
        "source": "Multiply the packed unsigned 16-bit integers in a and b, producing intermediate 32-bit integers, and store the high 16 bits of the intermediate integers in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).",
        "suggest": "将 a 和 b 中包装的无符号 16 位整数相乘，生成 32 位中间整数，并使用写掩码 k 将中间整数的高 16 位存储在 dst 中 (当未设置相应的掩码位时从 src 复制元素)。",
        "translate": ""
    },
    {
        "source": "Multiply the packed unsigned 16-bit integers in a and b, producing intermediate 32-bit integers, and store the high 16 bits of the intermediate integers in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).",
        "suggest": "将 a 和 b 中包装的无符号 16 位整数相乘，生成中间的 32 位整数，并使用零掩码 k 将中间整数的高 16 位存储在 dst 中 (当未设置相应的掩码位时元素清零)。",
        "translate": ""
    },
    {
        "source": "Multiply the packed signed 16-bit integers in a and b, producing intermediate 32-bit integers, and store the high 16 bits of the intermediate integers in dst.",
        "suggest": "将包装的带符号的 16 位整数与 a 和 b 相乘，生成中间的 32 位整数，并将中间整数的高 16 位存储在 dst 中。",
        "translate": ""
    },
    {
        "source": "Multiply the packed signed 16-bit integers in a and b, producing intermediate 32-bit integers, and store the high 16 bits of the intermediate integers in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).",
        "suggest": "将 a 和 b 中包装的带符号的 16 位整数相乘，生成 32 位中间整数，并使用写掩码 k 将中间整数的高 16 位存储在 dst 中 (当未设置相应的掩码位时从 src 复制元素)。",
        "translate": ""
    },
    {
        "source": "Multiply the packed signed 16-bit integers in a and b, producing intermediate 32-bit integers, and store the high 16 bits of the intermediate integers in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).",
        "suggest": "将 a 和 b 中包装的带符号的 16 位整数相乘，生成中间的 32 位整数，并使用零掩码 k 将中间整数的高 16 位存储在 dst 中 (当未设置相应的掩码位时元素清零)。",
        "translate": ""
    },
    {
        "source": "Multiply packed signed 16-bit integers in a and b, producing intermediate signed 32-bit integers.",
        "suggest": "在 a 和 b 中乘以包装的带符号的 16 位整数，产生中间的带符号的 32 位整数。",
        "translate": ""
    },
    {
        "source": "Truncate each intermediate integer to the 18 most significant bits, round by adding 1, and store bits \\[16:1\\] to dst.",
        "suggest": "将每个中间整数截断为 18 个最高有效位，加 1 舍入，然后将 \\[16: 1\\] 位存储到 dst。",
        "translate": ""
    },
    {
        "source": "Multiply the packed 16-bit integers in a and b, producing intermediate 32-bit integers, and store the low 16 bits of the intermediate integers in dst.",
        "suggest": "将 a 和 b 中的包装的 16 位整数相乘，生成中间的 32 位整数，并将中间整数的低 16 位存储在 dst 中。",
        "translate": ""
    }
]
